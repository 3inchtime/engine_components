# 核心组件详解

> 深入理解 @thatopen/components 的核心架构和组件系统

本章将全面介绍 @thatopen/components 的核心组件系统，从基础的组件管理到复杂的 3D 世界构建，帮助您深入理解整个架构的设计理念和使用方法。

## 📋 本章内容

- [组件系统架构](#1-组件系统架构) - 理解组件管理的核心机制
- [世界系统管理](#2-世界系统-worlds) - 掌握多世界管理和配置
- [场景系统详解](#3-场景系统-simplescene) - 学习 3D 场景的构建和管理
- [相机系统控制](#4-相机系统-simplecamera) - 掌握相机控制和视角管理
- [渲染系统优化](#5-渲染系统-simplerenderer) - 了解渲染管线和性能优化
- [内存管理策略](#6-内存管理和性能优化) - 学习资源管理和性能调优
- [自定义组件开发](#7-自定义组件开发) - 创建自己的组件

## 🎯 学习目标

通过本章学习，您将能够：

✅ 理解组件系统的设计模式和生命周期管理  
✅ 熟练创建和配置 3D 世界、场景、相机和渲染器  
✅ 掌握组件间的通信和事件处理机制  
✅ 实现高效的内存管理和性能优化  
✅ 开发自定义组件来扩展功能

## 1. 组件系统架构

### 1.1 Components 类 - 组件管理器

`Components` 类是整个 @thatopen/components 库的核心入口点，采用**依赖注入容器**的设计模式，负责管理所有组件的生命周期、依赖关系和通信机制。

#### 🏗️ 设计理念

- **单一职责**: 专注于组件的注册、创建和生命周期管理
- **依赖注入**: 自动解析组件间的依赖关系
- **类型安全**: 完整的 TypeScript 类型支持
- **内存安全**: 自动的资源清理和内存泄漏防护

#### 🔧 核心特性

```typescript
interface ComponentsFeatures {
  // 版本管理
  version: string;                    // 当前版本 2.4.11
  
  // 组件注册表
  list: Map<string, Component>;       // 已注册的组件实例
  
  // 生命周期管理
  enabled: boolean;                   // 组件系统启用状态
  onInit: Event<Components>;          // 初始化事件
  onDisposed: Event<string>;          // 销毁事件
  
  // 更新循环
  onBeforeUpdate: Event<Components>;  // 更新前事件
  onAfterUpdate: Event<Components>;   // 更新后事件
}
```

#### 📝 基础使用

```typescript
import * as OBC from "@thatopen/components";

// 1. 创建组件管理器实例
const components = new OBC.Components();

// 2. 获取或创建组件实例（自动依赖注入）
const worlds = components.get(OBC.Worlds);
const fragmentsManager = components.get(OBC.FragmentsManager);
const ifcLoader = components.get(OBC.IfcLoader);

// 3. 手动添加组件实例
const customComponent = new MyCustomComponent(components);
components.add("my-custom-component", customComponent);

// 4. 初始化组件系统
components.init();

// 5. 启动更新循环（如果需要）
const animate = () => {
  components.update(); // 触发所有可更新组件的更新
  requestAnimationFrame(animate);
};
animate();
```

#### 🔄 生命周期管理

```typescript
// 监听系统初始化
components.onInit.add((components) => {
  console.log('组件系统已初始化');
  console.log(`已注册组件数量: ${components.list.size}`);
});

// 监听组件销毁
components.onDisposed.add((componentId) => {
  console.log(`组件已销毁: ${componentId}`);
});

// 监听更新循环
components.onBeforeUpdate.add(() => {
  // 更新前的准备工作
});

components.onAfterUpdate.add(() => {
  // 更新后的清理工作
});

// 销毁整个组件系统
window.addEventListener('beforeunload', () => {
  components.dispose(); // 清理所有资源
});
```

#### 🎯 高级用法

```typescript
// 条件性组件获取
const getComponentSafely = <T extends OBC.Component>(
  ComponentClass: new (components: OBC.Components) => T
): T | null => {
  try {
    return components.get(ComponentClass);
  } catch (error) {
    console.warn(`组件获取失败: ${ComponentClass.name}`, error);
    return null;
  }
};

// 组件状态检查
const checkComponentHealth = () => {
  const healthReport = {
    totalComponents: components.list.size,
    enabledComponents: 0,
    disabledComponents: 0,
    updateableComponents: 0
  };
  
  for (const [id, component] of components.list) {
    if (component.enabled) {
      healthReport.enabledComponents++;
    } else {
      healthReport.disabledComponents++;
    }
    
    if ('update' in component) {
      healthReport.updateableComponents++;
    }
  }
  
  return healthReport;
};

// 批量组件操作
const batchComponentOperation = (operation: 'enable' | 'disable') => {
  for (const [id, component] of components.list) {
    if ('enabled' in component) {
      component.enabled = operation === 'enable';
    }
  }
};
```

### 1.2 组件接口设计

@thatopen/components 采用基于接口的组件设计，确保所有组件都遵循统一的规范和生命周期管理。

#### 🔌 核心接口体系

```typescript
// 基础组件接口
interface Component {
  enabled: boolean;           // 组件启用状态
  components: Components;     // 组件管理器引用
}

// 可更新组件接口
interface Updateable extends Component {
  onBeforeUpdate: Event<Component>;  // 更新前事件
  onAfterUpdate: Event<Component>;   // 更新后事件
  update(delta?: number): void;      // 更新方法
}

// 可销毁组件接口
interface Disposable extends Component {
  onDisposed: Event<string>;         // 销毁事件
  dispose(): void;                   // 销毁方法
}

// 可配置组件接口
interface Configurable<T = any> extends Component {
  config: T;                         // 配置对象
  setup(config?: Partial<T>): Promise<void> | void; // 设置方法
}

// 可创建组件接口
interface Createable extends Component {
  create(...args: any[]): any;       // 创建方法
}

// 可隐藏组件接口
interface Hideable extends Component {
  visible: boolean;                  // 可见性状态
  setVisibility(visible: boolean): void; // 设置可见性
}
```

#### 🏗️ 接口组合模式

实际组件通常实现多个接口的组合：

```typescript
// 示例：完整功能的测量工具组件
class LengthMeasurement implements 
  Component, 
  Updateable, 
  Disposable, 
  Createable, 
  Hideable {
  
  // Component 接口实现
  enabled: boolean = true;
  components: Components;
  
  // Updateable 接口实现
  onBeforeUpdate = new Event<Component>();
  onAfterUpdate = new Event<Component>();
  
  update(delta?: number): void {
    if (!this.enabled) return;
    
    this.onBeforeUpdate.trigger(this);
    // 执行更新逻辑
    this.onAfterUpdate.trigger(this);
  }
  
  // Disposable 接口实现
  onDisposed = new Event<string>();
  
  dispose(): void {
    // 清理资源
    this.onDisposed.trigger("LengthMeasurement");
  }
  
  // Createable 接口实现
  create(): MeasurementElement {
    // 创建测量元素
    return new MeasurementElement();
  }
  
  // Hideable 接口实现
  visible: boolean = true;
  
  setVisibility(visible: boolean): void {
    this.visible = visible;
    // 更新可见性
  }
  
  constructor(components: Components) {
    this.components = components;
  }
}
```

#### 🎯 接口使用最佳实践

```typescript
// 1. 类型安全的组件检查
function isUpdateable(component: Component): component is Updateable {
  return 'update' in component && typeof component.update === 'function';
}

function isDisposable(component: Component): component is Disposable {
  return 'dispose' in component && typeof component.dispose === 'function';
}

// 2. 通用的组件操作函数
function updateAllComponents(components: Components, delta: number): void {
  for (const [id, component] of components.list) {
    if (component.enabled && isUpdateable(component)) {
      component.update(delta);
    }
  }
}

function disposeAllComponents(components: Components): void {
  for (const [id, component] of components.list) {
    if (isDisposable(component)) {
      component.dispose();
    }
  }
}

// 3. 组件状态管理
class ComponentStateManager {
  private components: Components;
  
  constructor(components: Components) {
    this.components = components;
  }
  
  // 批量启用/禁用组件
  setComponentsEnabled(enabled: boolean, filter?: (component: Component) => boolean): void {
    for (const [id, component] of this.components.list) {
      if (!filter || filter(component)) {
        component.enabled = enabled;
      }
    }
  }
  
  // 获取特定类型的组件
  getComponentsByType<T extends Component>(predicate: (component: Component) => component is T): T[] {
    const result: T[] = [];
    for (const [id, component] of this.components.list) {
      if (predicate(component)) {
        result.push(component);
      }
    }
    return result;
  }
  
  // 组件性能监控
  monitorPerformance(): ComponentPerformanceReport {
    const report: ComponentPerformanceReport = {
      totalComponents: this.components.list.size,
      activeComponents: 0,
      updateableComponents: 0,
      memoryUsage: 0
    };
    
    for (const [id, component] of this.components.list) {
      if (component.enabled) {
        report.activeComponents++;
      }
      if (isUpdateable(component)) {
        report.updateableComponents++;
      }
    }
    
    return report;
  }
}

interface ComponentPerformanceReport {
  totalComponents: number;
  activeComponents: number;
  updateableComponents: number;
  memoryUsage: number;
}
```

## 2. 世界系统 (Worlds)

### 2.1 Worlds 管理器概述

`Worlds` 类是 @thatopen/components 的核心管理器，负责创建和管理多个独立的 3D 世界实例。每个世界都包含完整的场景、相机和渲染器组合，支持复杂的多视口应用。

#### 🌍 核心特性

- **多世界管理**：支持同时运行多个独立的 3D 世界
- **组件解耦**：场景、相机、渲染器可独立配置
- **类型安全**：完整的 TypeScript 类型支持
- **生命周期管理**：统一的初始化和销毁流程
- **事件驱动**：丰富的世界状态事件

#### 🏗️ 基础使用

```typescript
import * as OBC from "@thatopen/components";

// 获取世界管理器
const components = new OBC.Components();
const worlds = components.get(OBC.Worlds);

// 创建新世界（指定组件类型）
const world = worlds.create<
  OBC.SimpleScene,
  OBC.SimpleCamera, 
  OBC.SimpleRenderer
>();

// 配置世界组件
world.scene = new OBC.SimpleScene(components);
world.renderer = new OBC.SimpleRenderer(components, container);
world.camera = new OBC.SimpleCamera(components);

// 初始化世界
await world.init();

// 启动渲染循环
world.renderer.onBeforeUpdate.add(() => {
  // 渲染前处理
});

world.renderer.onAfterUpdate.add(() => {
  // 渲染后处理
});
```

#### 🎯 高级世界配置

```typescript
// 1. 创建多个世界实例
class MultiWorldManager {
  private components: OBC.Components;
  private worlds: Map<string, OBC.World> = new Map();
  
  constructor() {
    this.components = new OBC.Components();
  }
  
  // 创建主视口世界
  async createMainWorld(container: HTMLElement): Promise<OBC.World> {
    const worlds = this.components.get(OBC.Worlds);
    const world = worlds.create<
      OBC.SimpleScene,
      OBC.OrthoPerspectiveCamera,
      OBC.PostproductionRenderer
    >();
    
    // 配置高级场景
    world.scene = new OBC.SimpleScene(this.components);
    world.scene.setup();
    
    // 配置正交透视相机
    world.camera = new OBC.OrthoPerspectiveCamera(this.components);
    world.camera.controls.setLookAt(10, 10, 10, 0, 0, 0);
    
    // 配置后处理渲染器
    world.renderer = new OBC.PostproductionRenderer(this.components, container);
    world.renderer.postproduction.enabled = true;
    
    await world.init();
    
    this.worlds.set('main', world);
    return world;
  }
  
  // 创建小地图世界
  async createMinimapWorld(container: HTMLElement): Promise<OBC.World> {
    const worlds = this.components.get(OBC.Worlds);
    const world = worlds.create<
      OBC.SimpleScene,
      OBC.OrthoPerspectiveCamera,
      OBC.SimpleRenderer
    >();
    
    // 共享主世界的场景
    const mainWorld = this.worlds.get('main');
    if (mainWorld) {
      world.scene = mainWorld.scene;
    }
    
    // 配置俯视相机
    world.camera = new OBC.OrthoPerspectiveCamera(this.components);
    world.camera.projection.current = "Orthographic";
    world.camera.controls.setLookAt(0, 50, 0, 0, 0, 0);
    
    // 配置简单渲染器
    world.renderer = new OBC.SimpleRenderer(this.components, container);
    
    await world.init();
    
    this.worlds.set('minimap', world);
    return world;
  }
  
  // 同步世界状态
  syncWorlds(): void {
    const mainWorld = this.worlds.get('main');
    const minimapWorld = this.worlds.get('minimap');
    
    if (mainWorld && minimapWorld) {
      // 同步相机位置到小地图
      const mainPosition = mainWorld.camera.controls.getPosition();
      minimapWorld.camera.controls.setLookAt(
        mainPosition.x, 50, mainPosition.z,
        mainPosition.x, 0, mainPosition.z
      );
    }
  }
  
  // 销毁所有世界
  dispose(): void {
    for (const [id, world] of this.worlds) {
      world.dispose();
    }
    this.worlds.clear();
  }
}
```

#### 🔄 世界生命周期管理

```typescript
class WorldLifecycleManager {
  private world: OBC.World;
  private isInitialized: boolean = false;
  
  constructor(world: OBC.World) {
    this.world = world;
    this.setupEventListeners();
  }
  
  private setupEventListeners(): void {
    // 监听世界初始化
    this.world.onInitialized.add(() => {
      console.log('世界初始化完成');
      this.isInitialized = true;
      this.onWorldReady();
    });
    
    // 监听世界销毁
    this.world.onDisposed.add(() => {
      console.log('世界已销毁');
      this.isInitialized = false;
      this.onWorldDestroyed();
    });
    
    // 监听渲染器更新
    if (this.world.renderer) {
      this.world.renderer.onBeforeUpdate.add((delta) => {
        this.onBeforeRender(delta);
      });
      
      this.world.renderer.onAfterUpdate.add((delta) => {
        this.onAfterRender(delta);
      });
    }
  }
  
  private onWorldReady(): void {
    // 世界准备就绪后的初始化逻辑
    this.setupLighting();
    this.setupGrid();
    this.setupControls();
  }
  
  private onWorldDestroyed(): void {
    // 清理资源
    this.cleanup();
  }
  
  private onBeforeRender(delta?: number): void {
    // 渲染前更新逻辑
    if (this.isInitialized) {
      this.updateAnimations(delta);
      this.updateUI();
    }
  }
  
  private onAfterRender(delta?: number): void {
    // 渲染后处理逻辑
    this.updatePerformanceMetrics(delta);
  }
  
  private setupLighting(): void {
    // 设置光照
    const scene = this.world.scene.three;
    
    // 环境光
    const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
    scene.add(ambientLight);
    
    // 方向光
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(10, 10, 5);
    directionalLight.castShadow = true;
    scene.add(directionalLight);
  }
  
  private setupGrid(): void {
    // 设置网格
    const grids = this.world.scene.three.getObjectByName('grids');
    if (!grids) {
      const gridHelper = new THREE.GridHelper(100, 100);
      gridHelper.name = 'grids';
      this.world.scene.three.add(gridHelper);
    }
  }
  
  private setupControls(): void {
    // 配置相机控制
    if (this.world.camera.controls) {
      this.world.camera.controls.enableDamping = true;
      this.world.camera.controls.dampingFactor = 0.05;
      this.world.camera.controls.enableZoom = true;
      this.world.camera.controls.enableRotate = true;
      this.world.camera.controls.enablePan = true;
    }
  }
  
  private updateAnimations(delta?: number): void {
    // 更新动画
    // 实现自定义动画逻辑
  }
  
  private updateUI(): void {
    // 更新UI状态
    // 实现UI更新逻辑
  }
  
  private updatePerformanceMetrics(delta?: number): void {
    // 更新性能指标
    // 实现性能监控逻辑
  }
  
  private cleanup(): void {
    // 清理资源
    // 实现资源清理逻辑
  }
}
```

### 2.2 World 实例详解

每个 World 实例是一个完整的 3D 环境容器，包含场景、相机和渲染器三个核心组件。

#### 🏛️ World 接口定义

```typescript
interface World<
  TScene extends BaseScene = BaseScene,
  TCamera extends BaseCamera = BaseCamera, 
  TRenderer extends BaseRenderer = BaseRenderer
> extends Component, Disposable {
  // 核心组件
  scene?: TScene;
  camera?: TCamera;
  renderer?: TRenderer;
  
  // 生命周期方法
  init(): Promise<void>;
  dispose(): void;
  
  // 事件
  onInitialized: Event<World>;
  onDisposed: Event<World>;
  
  // 状态属性
  isInitialized: boolean;
  uuid: string;
}
```

#### 🔄 世界初始化流程

```typescript
// 完整的世界初始化示例
class WorldInitializer {
  private components: OBC.Components;
  
  constructor() {
    this.components = new OBC.Components();
  }
  
  async createCompleteWorld(container: HTMLElement): Promise<OBC.World> {
    const worlds = this.components.get(OBC.Worlds);
    
    // 1. 创建世界实例
    const world = worlds.create<
      OBC.SimpleScene,
      OBC.OrthoPerspectiveCamera,
      OBC.PostproductionRenderer
    >();
    
    // 2. 配置场景组件
    world.scene = new OBC.SimpleScene(this.components);
    await this.setupScene(world.scene);
    
    // 3. 配置相机组件
    world.camera = new OBC.OrthoPerspectiveCamera(this.components);
    this.setupCamera(world.camera);
    
    // 4. 配置渲染器组件
    world.renderer = new OBC.PostproductionRenderer(this.components, container);
    await this.setupRenderer(world.renderer);
    
    // 5. 初始化世界
    await world.init();
    
    // 6. 启动组件系统
    this.components.init();
    
    return world;
  }
  
  private async setupScene(scene: OBC.SimpleScene): Promise<void> {
    // 场景基础设置
    scene.setup();
    
    // 添加环境光
    const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
    scene.three.add(ambientLight);
    
    // 添加方向光
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(10, 10, 5);
    directionalLight.castShadow = true;
    scene.three.add(directionalLight);
    
    // 添加网格
    const gridHelper = new THREE.GridHelper(100, 100, 0x888888, 0x444444);
    scene.three.add(gridHelper);
  }
  
  private setupCamera(camera: OBC.OrthoPerspectiveCamera): void {
    // 设置相机位置
    camera.controls.setLookAt(10, 10, 10, 0, 0, 0);
    
    // 配置控制器
    camera.controls.enableDamping = true;
    camera.controls.dampingFactor = 0.05;
    
    // 设置投影模式
    camera.projection.current = "Perspective";
    
    // 配置透视相机参数
    if (camera.three instanceof THREE.PerspectiveCamera) {
      camera.three.fov = 75;
      camera.three.near = 0.1;
      camera.three.far = 1000;
    }
  }
  
  private async setupRenderer(renderer: OBC.PostproductionRenderer): Promise<void> {
    // 基础渲染设置
    renderer.three.shadowMap.enabled = true;
    renderer.three.shadowMap.type = THREE.PCFSoftShadowMap;
    
    // 后处理效果
    renderer.postproduction.enabled = true;
    
    // 添加自定义后处理效果
    const composer = renderer.postproduction.composer;
    
    // 抗锯齿
    const fxaaPass = new THREE.ShaderPass(THREE.FXAAShader);
    composer.addPass(fxaaPass);
    
    // 辉光效果
    const bloomPass = new THREE.UnrealBloomPass(
      new THREE.Vector2(window.innerWidth, window.innerHeight),
      1.5, 0.4, 0.85
    );
    composer.addPass(bloomPass);
  }
}
```

#### 🎮 世界状态管理

```typescript
class WorldStateManager {
  private world: OBC.World;
  private state: WorldState;
  
  constructor(world: OBC.World) {
    this.world = world;
    this.state = {
      isActive: false,
      isPaused: false,
      renderMode: 'normal',
      performance: {
        fps: 0,
        frameTime: 0,
        memoryUsage: 0
      }
    };
    
    this.setupStateMonitoring();
  }
  
  private setupStateMonitoring(): void {
    // 监听世界初始化
    this.world.onInitialized.add(() => {
      this.state.isActive = true;
      this.startPerformanceMonitoring();
    });
    
    // 监听世界销毁
    this.world.onDisposed.add(() => {
      this.state.isActive = false;
      this.stopPerformanceMonitoring();
    });
  }
  
  // 暂停/恢复世界
  setPaused(paused: boolean): void {
    this.state.isPaused = paused;
    
    if (this.world.renderer) {
      if (paused) {
        this.world.renderer.enabled = false;
      } else {
        this.world.renderer.enabled = true;
      }
    }
  }
  
  // 设置渲染模式
  setRenderMode(mode: 'normal' | 'wireframe' | 'points'): void {
    this.state.renderMode = mode;
    
    if (this.world.scene) {
      this.world.scene.three.traverse((object) => {
        if (object instanceof THREE.Mesh) {
          switch (mode) {
            case 'wireframe':
              object.material.wireframe = true;
              break;
            case 'points':
              // 转换为点云显示
              break;
            default:
              object.material.wireframe = false;
              break;
          }
        }
      });
    }
  }
  
  // 性能监控
  private startPerformanceMonitoring(): void {
    const monitor = () => {
      if (!this.state.isActive) return;
      
      // 计算FPS
      this.state.performance.fps = this.calculateFPS();
      
      // 计算帧时间
      this.state.performance.frameTime = this.calculateFrameTime();
      
      // 计算内存使用
      this.state.performance.memoryUsage = this.calculateMemoryUsage();
      
      requestAnimationFrame(monitor);
    };
    
    monitor();
  }
  
  private stopPerformanceMonitoring(): void {
    // 停止性能监控
  }
  
  private calculateFPS(): number {
    // FPS计算逻辑
    return 60; // 示例值
  }
  
  private calculateFrameTime(): number {
    // 帧时间计算逻辑
    return 16.67; // 示例值
  }
  
  private calculateMemoryUsage(): number {
    // 内存使用计算逻辑
    return 0; // 示例值
  }
  
  // 获取世界状态
  getState(): WorldState {
    return { ...this.state };
  }
}

interface WorldState {
  isActive: boolean;
  isPaused: boolean;
  renderMode: 'normal' | 'wireframe' | 'points';
  performance: {
    fps: number;
    frameTime: number;
    memoryUsage: number;
  };
}
```

#### 生命周期事件

```typescript
// 监听更新事件
world.onBeforeUpdate.add(() => {
  // 更新前的逻辑
});

world.onAfterUpdate.add(() => {
  // 更新后的逻辑
});

// 监听销毁事件
world.onDisposed.add(() => {
  // 清理资源
});
```

## 3. 场景系统 (Scenes)

### 3.1 场景系统概述

场景系统是 3D 世界的核心容器，负责管理所有 3D 对象、光照、材质和空间关系。@thatopen/components 提供了多种场景实现以满足不同的应用需求。

#### 🎭 场景类型

- **SimpleScene**: 基础场景实现，适用于大多数应用
- **AdvancedScene**: 高级场景，支持复杂的渲染特性
- **CustomScene**: 自定义场景，可扩展特定功能

### 3.2 SimpleScene 详解

`SimpleScene` 是最常用的场景实现，提供了完整的基础 3D 场景功能和智能的默认配置。

#### 🔧 默认配置

```typescript
const defaultConfig: SimpleSceneConfig = {
  backgroundColor: new THREE.Color(0x202932),
  directionalLight: {
    color: new THREE.Color("white"),
    intensity: 1.5,
    position: new THREE.Vector3(5, 10, 3),
    castShadow: true
  },
  ambientLight: {
    color: new THREE.Color("white"),
    intensity: 0.3
  },
  fog: {
    enabled: false,
    color: new THREE.Color(0x202932),
    near: 50,
    far: 200
  }
};
```

#### 🏗️ 基础使用

```typescript
import * as OBC from "@thatopen/components";
import * as THREE from "three";

// 创建场景实例
const components = new OBC.Components();
const scene = new OBC.SimpleScene(components);

// 使用默认配置初始化
scene.setup();

// 自定义配置初始化
scene.setup({
  backgroundColor: new THREE.Color(0x87CEEB),
  directionalLight: {
    color: new THREE.Color("#ffffff"),
    intensity: 2.0,
    position: new THREE.Vector3(10, 15, 5),
    castShadow: true
  },
  ambientLight: {
    color: new THREE.Color("#404040"),
    intensity: 0.4
  },
  fog: {
    enabled: true,
    color: new THREE.Color(0x87CEEB),
    near: 100,
    far: 500
  }
});

// 监听设置完成事件
scene.onSetup.add(() => {
  console.log('场景设置完成');
  // 添加自定义对象
  addSceneObjects();
});

function addSceneObjects(): void {
  // 添加基础几何体
  const geometry = new THREE.BoxGeometry(1, 1, 1);
  const material = new THREE.MeshStandardMaterial({ color: 0x00ff00 });
  const cube = new THREE.Mesh(geometry, material);
  cube.castShadow = true;
  cube.receiveShadow = true;
  scene.three.add(cube);
  
  // 添加地面
  const groundGeometry = new THREE.PlaneGeometry(20, 20);
  const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x808080 });
  const ground = new THREE.Mesh(groundGeometry, groundMaterial);
  ground.rotation.x = -Math.PI / 2;
  ground.receiveShadow = true;
  scene.three.add(ground);
}
```

#### 💡 高级灯光管理

```typescript
class AdvancedLightingManager {
  private scene: OBC.SimpleScene;
  
  constructor(scene: OBC.SimpleScene) {
    this.scene = scene;
  }
  
  // 设置专业照明方案
  setupProfessionalLighting(): void {
    // 清除默认灯光
    this.scene.deleteAllLights();
    
    // 主光源 (Key Light)
    const keyLight = new THREE.DirectionalLight(0xffffff, 1.2);
    keyLight.position.set(10, 10, 5);
    keyLight.castShadow = true;
    keyLight.shadow.mapSize.width = 2048;
    keyLight.shadow.mapSize.height = 2048;
    keyLight.shadow.camera.near = 0.5;
    keyLight.shadow.camera.far = 50;
    this.scene.three.add(keyLight);
    
    // 补光 (Fill Light)
    const fillLight = new THREE.DirectionalLight(0x87CEEB, 0.4);
    fillLight.position.set(-5, 5, 2);
    this.scene.three.add(fillLight);
    
    // 背景光 (Back Light)
    const backLight = new THREE.DirectionalLight(0xffffff, 0.3);
    backLight.position.set(0, 5, -10);
    this.scene.three.add(backLight);
    
    // 环境光
    const ambientLight = new THREE.AmbientLight(0x404040, 0.2);
    this.scene.three.add(ambientLight);
    
    // 局部点光源
    const pointLight = new THREE.PointLight(0xffffff, 0.8, 20);
    pointLight.position.set(5, 3, 5);
    pointLight.castShadow = true;
    this.scene.three.add(pointLight);
  }
  
  // 设置室内照明
  setupIndoorLighting(): void {
    this.scene.deleteAllLights();
    
    // 天花板灯光
    const ceilingLights = [
      { position: new THREE.Vector3(-5, 8, -5), intensity: 0.6 },
      { position: new THREE.Vector3(5, 8, -5), intensity: 0.6 },
      { position: new THREE.Vector3(-5, 8, 5), intensity: 0.6 },
      { position: new THREE.Vector3(5, 8, 5), intensity: 0.6 }
    ];
    
    ceilingLights.forEach((lightConfig, index) => {
      const light = new THREE.PointLight(0xffffff, lightConfig.intensity, 15);
      light.position.copy(lightConfig.position);
      light.castShadow = true;
      light.name = `ceiling-light-${index}`;
      this.scene.three.add(light);
    });
    
    // 窗户光
    const windowLight = new THREE.DirectionalLight(0x87CEEB, 0.8);
    windowLight.position.set(15, 5, 0);
    windowLight.castShadow = true;
    this.scene.three.add(windowLight);
    
    // 环境光
    const ambientLight = new THREE.AmbientLight(0x404040, 0.3);
    this.scene.three.add(ambientLight);
  }
  
  // 动态调整光照
  adjustLightingByTime(hour: number): void {
    const lights = this.scene.three.children.filter(child => child instanceof THREE.Light);
    
    // 根据时间调整光照强度和颜色
    const timeOfDay = this.getTimeOfDay(hour);
    
    lights.forEach(light => {
      if (light instanceof THREE.DirectionalLight) {
        switch (timeOfDay) {
          case 'dawn':
            light.color.setHex(0xFFB366); // 橙色
            light.intensity = 0.6;
            break;
          case 'day':
            light.color.setHex(0xFFFFFF); // 白色
            light.intensity = 1.0;
            break;
          case 'dusk':
            light.color.setHex(0xFF6B35); // 红橙色
            light.intensity = 0.4;
            break;
          case 'night':
            light.color.setHex(0x4169E1); // 蓝色
            light.intensity = 0.2;
            break;
        }
      }
    });
  }
  
  private getTimeOfDay(hour: number): 'dawn' | 'day' | 'dusk' | 'night' {
    if (hour >= 5 && hour < 8) return 'dawn';
    if (hour >= 8 && hour < 18) return 'day';
    if (hour >= 18 && hour < 21) return 'dusk';
    return 'night';
  }
}
```

#### 🎨 场景配置管理

```typescript
class SceneConfigManager {
  private scene: OBC.SimpleScene;
  private originalConfig: any;
  
  constructor(scene: OBC.SimpleScene) {
    this.scene = scene;
    this.originalConfig = { ...scene.config };
  }
  
  // 动态修改背景
  setBackground(type: 'color' | 'gradient' | 'skybox', options: any): void {
    switch (type) {
      case 'color':
        this.scene.three.background = new THREE.Color(options.color);
        break;
        
      case 'gradient':
        const canvas = document.createElement('canvas');
        canvas.width = 512;
        canvas.height = 512;
        const context = canvas.getContext('2d')!;
        const gradient = context.createLinearGradient(0, 0, 0, 512);
        gradient.addColorStop(0, options.topColor);
        gradient.addColorStop(1, options.bottomColor);
        context.fillStyle = gradient;
        context.fillRect(0, 0, 512, 512);
        
        const texture = new THREE.CanvasTexture(canvas);
        this.scene.three.background = texture;
        break;
        
      case 'skybox':
        const loader = new THREE.CubeTextureLoader();
        const skyboxTexture = loader.load(options.urls);
        this.scene.three.background = skyboxTexture;
        break;
    }
  }
  
  // 设置雾效
  setFog(enabled: boolean, options?: { color?: string; near?: number; far?: number }): void {
    if (enabled && options) {
      this.scene.three.fog = new THREE.Fog(
        new THREE.Color(options.color || 0x202932),
        options.near || 50,
        options.far || 200
      );
    } else {
      this.scene.three.fog = null;
    }
  }
  
  // 保存配置
  saveConfig(name: string): void {
    const config = {
      backgroundColor: this.scene.config.backgroundColor.getHex(),
      directionalLight: {
        color: this.scene.config.directionalLight.color.getHex(),
        intensity: this.scene.config.directionalLight.intensity,
        position: this.scene.config.directionalLight.position.toArray()
      },
      ambientLight: {
        color: this.scene.config.ambientLight.color.getHex(),
        intensity: this.scene.config.ambientLight.intensity
      }
    };
    
    localStorage.setItem(`scene-config-${name}`, JSON.stringify(config));
  }
  
  // 加载配置
  loadConfig(name: string): boolean {
    const configStr = localStorage.getItem(`scene-config-${name}`);
    if (!configStr) return false;
    
    try {
      const config = JSON.parse(configStr);
      
      this.scene.config.backgroundColor.setHex(config.backgroundColor);
      this.scene.config.directionalLight.color.setHex(config.directionalLight.color);
      this.scene.config.directionalLight.intensity = config.directionalLight.intensity;
      this.scene.config.directionalLight.position.fromArray(config.directionalLight.position);
      this.scene.config.ambientLight.color.setHex(config.ambientLight.color);
      this.scene.config.ambientLight.intensity = config.ambientLight.intensity;
      
      // 重新应用配置
      this.scene.setup(this.scene.config);
      
      return true;
    } catch (error) {
      console.error('加载场景配置失败:', error);
      return false;
    }
  }
  
  // 重置为默认配置
  resetToDefault(): void {
    this.scene.setup(this.originalConfig);
  }
}

interface SimpleSceneConfig {
  backgroundColor: THREE.Color;
  directionalLight: {
    color: THREE.Color;
    intensity: number;
    position: THREE.Vector3;
    castShadow?: boolean;
  };
  ambientLight: {
    color: THREE.Color;
    intensity: number;
  };
  fog?: {
    enabled: boolean;
    color: THREE.Color;
    near: number;
    far: number;
  };
}
```

## 4. 相机系统 (Cameras)

### 4.1 相机系统概述

相机系统负责定义 3D 世界的观察视角和投影方式。@thatopen/components 提供了多种相机实现，支持不同的投影模式和交互方式。

#### 📷 相机类型

- **SimpleCamera**: 基础透视相机，适用于一般 3D 场景
- **OrthoPerspectiveCamera**: 支持正交和透视投影切换的相机
- **FirstPersonCamera**: 第一人称视角相机
- **CustomCamera**: 自定义相机实现

### 4.2 SimpleCamera 详解

`SimpleCamera` 提供基础的透视相机功能，集成了轨道控制器，适用于大多数 3D 应用场景。

#### 🏗️ 基础使用

```typescript
import * as OBC from "@thatopen/components";
import * as THREE from "three";

// 创建相机实例
const components = new OBC.Components();
const camera = new OBC.SimpleCamera(components);

// 设置相机位置和目标
camera.controls.setLookAt(10, 10, 10, 0, 0, 0);

// 获取相机控制器
const controls = camera.controls;

// 配置相机参数
camera.three.fov = 75;        // 视野角度
camera.three.near = 0.1;      // 近裁剪面
camera.three.far = 1000;      // 远裁剪面
camera.three.updateProjectionMatrix();

// 配置控制器
controls.enableDamping = true;      // 启用阻尼
controls.dampingFactor = 0.05;      // 阻尼系数
controls.enableZoom = true;         // 启用缩放
controls.enableRotate = true;       // 启用旋转
controls.enablePan = true;          // 启用平移

// 设置缩放限制
controls.minDistance = 1;
controls.maxDistance = 100;

// 设置旋转限制
controls.minPolarAngle = 0;
controls.maxPolarAngle = Math.PI;
```

### 4.3 OrthoPerspectiveCamera 详解

`OrthoPerspectiveCamera` 支持在正交投影和透视投影之间动态切换，适用于建筑设计和工程应用。

#### 🔄 投影模式切换

```typescript
class CameraProjectionManager {
  private camera: OBC.OrthoPerspectiveCamera;
  
  constructor(components: OBC.Components) {
    this.camera = new OBC.OrthoPerspectiveCamera(components);
    this.setupCamera();
  }
  
  private setupCamera(): void {
    // 设置初始位置
    this.camera.controls.setLookAt(15, 15, 15, 0, 0, 0);
    
    // 配置透视相机参数
    if (this.camera.three instanceof THREE.PerspectiveCamera) {
      this.camera.three.fov = 60;
      this.camera.three.near = 0.1;
      this.camera.three.far = 1000;
    }
    
    // 配置正交相机参数
    this.camera.projection.onChanged.add(() => {
      this.onProjectionChanged();
    });
  }
  
  // 切换到透视投影
  switchToPerspective(): void {
    this.camera.projection.current = "Perspective";
  }
  
  // 切换到正交投影
  switchToOrthographic(): void {
    this.camera.projection.current = "Orthographic";
  }
  
  // 投影模式改变时的回调
  private onProjectionChanged(): void {
    const currentMode = this.camera.projection.current;
    console.log(`相机投影模式切换到: ${currentMode}`);
    
    if (currentMode === "Orthographic") {
      // 正交模式下的特殊设置
      this.setupOrthographicView();
    } else {
      // 透视模式下的特殊设置
      this.setupPerspectiveView();
    }
  }
  
  private setupOrthographicView(): void {
    // 正交视图的特殊配置
    this.camera.controls.enableRotate = false;
    this.camera.controls.enableZoom = true;
    this.camera.controls.enablePan = true;
  }
  
  private setupPerspectiveView(): void {
    // 透视视图的特殊配置
    this.camera.controls.enableRotate = true;
    this.camera.controls.enableZoom = true;
    this.camera.controls.enablePan = true;
  }
  
  // 设置预定义视角
  setPresetView(view: 'front' | 'back' | 'left' | 'right' | 'top' | 'bottom' | 'isometric'): void {
    const distance = 20;
    
    switch (view) {
      case 'front':
        this.camera.controls.setLookAt(0, 0, distance, 0, 0, 0);
        break;
      case 'back':
        this.camera.controls.setLookAt(0, 0, -distance, 0, 0, 0);
        break;
      case 'left':
        this.camera.controls.setLookAt(-distance, 0, 0, 0, 0, 0);
        break;
      case 'right':
        this.camera.controls.setLookAt(distance, 0, 0, 0, 0, 0);
        break;
      case 'top':
        this.camera.controls.setLookAt(0, distance, 0, 0, 0, 0);
        break;
      case 'bottom':
        this.camera.controls.setLookAt(0, -distance, 0, 0, 0, 0);
        break;
      case 'isometric':
        this.camera.controls.setLookAt(distance, distance, distance, 0, 0, 0);
        break;
    }
  }
  
  // 获取相机状态
  getCameraState(): CameraState {
    const position = this.camera.controls.getPosition();
    const target = this.camera.controls.getTarget();
    
    return {
      position: position.toArray(),
      target: target.toArray(),
      projection: this.camera.projection.current,
      zoom: this.camera.controls.getDistance()
    };
  }
  
  // 恢复相机状态
  setCameraState(state: CameraState): void {
    this.camera.projection.current = state.projection;
    this.camera.controls.setLookAt(
      state.position[0], state.position[1], state.position[2],
      state.target[0], state.target[1], state.target[2]
    );
  }
}

interface CameraState {
  position: [number, number, number];
  target: [number, number, number];
  projection: "Perspective" | "Orthographic";
  zoom: number;
}
```

#### 🎮 高级相机控制

```typescript
class AdvancedCameraController {
  private camera: OBC.OrthoPerspectiveCamera;
  private animationId: number | null = null;
  
  constructor(camera: OBC.OrthoPerspectiveCamera) {
    this.camera = camera;
  }
  
  // 平滑动画到目标位置
  animateToPosition(
    targetPosition: THREE.Vector3,
    targetLookAt: THREE.Vector3,
    duration: number = 1000
  ): Promise<void> {
    return new Promise((resolve) => {
      const startPosition = this.camera.controls.getPosition().clone();
      const startLookAt = this.camera.controls.getTarget().clone();
      const startTime = Date.now();
      
      const animate = () => {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);
        
        // 使用缓动函数
        const easeProgress = this.easeInOutCubic(progress);
        
        // 插值计算当前位置
        const currentPosition = startPosition.clone().lerp(targetPosition, easeProgress);
        const currentLookAt = startLookAt.clone().lerp(targetLookAt, easeProgress);
        
        // 更新相机位置
        this.camera.controls.setLookAt(
          currentPosition.x, currentPosition.y, currentPosition.z,
          currentLookAt.x, currentLookAt.y, currentLookAt.z
        );
        
        if (progress < 1) {
          this.animationId = requestAnimationFrame(animate);
        } else {
          this.animationId = null;
          resolve();
        }
      };
      
      animate();
    });
  }
  
  // 停止动画
  stopAnimation(): void {
    if (this.animationId) {
      cancelAnimationFrame(this.animationId);
      this.animationId = null;
    }
  }
  
  // 缓动函数
  private easeInOutCubic(t: number): number {
    return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
  }
  
  // 聚焦到对象
  focusOnObject(object: THREE.Object3D, offset: number = 5): Promise<void> {
    const box = new THREE.Box3().setFromObject(object);
    const center = box.getCenter(new THREE.Vector3());
    const size = box.getSize(new THREE.Vector3());
    
    // 计算合适的相机距离
    const maxDim = Math.max(size.x, size.y, size.z);
    const distance = maxDim * 2 + offset;
    
    // 计算相机位置（保持当前角度）
    const currentPosition = this.camera.controls.getPosition();
    const currentTarget = this.camera.controls.getTarget();
    const direction = currentPosition.clone().sub(currentTarget).normalize();
    const newPosition = center.clone().add(direction.multiplyScalar(distance));
    
    return this.animateToPosition(newPosition, center);
  }
  
  // 环绕对象
  orbitAroundObject(
    center: THREE.Vector3,
    radius: number,
    speed: number = 0.01
  ): void {
    let angle = 0;
    
    const orbit = () => {
      if (this.animationId === null) return;
      
      angle += speed;
      const x = center.x + radius * Math.cos(angle);
      const z = center.z + radius * Math.sin(angle);
      const y = center.y + radius * 0.3; // 稍微抬高视角
      
      this.camera.controls.setLookAt(x, y, z, center.x, center.y, center.z);
      
      this.animationId = requestAnimationFrame(orbit);
    };
    
    this.animationId = requestAnimationFrame(orbit);
  }
  
  // 第一人称漫游
  enableFirstPersonMode(): void {
    const controls = this.camera.controls;
    
    // 禁用默认控制
    controls.enabled = false;
    
    // 实现第一人称控制逻辑
    this.setupFirstPersonControls();
  }
  
  private setupFirstPersonControls(): void {
    const moveSpeed = 0.1;
    const lookSpeed = 0.002;
    
    const keys = {
      forward: false,
      backward: false,
      left: false,
      right: false
    };
    
    // 键盘事件
    document.addEventListener('keydown', (event) => {
      switch (event.code) {
        case 'KeyW': keys.forward = true; break;
        case 'KeyS': keys.backward = true; break;
        case 'KeyA': keys.left = true; break;
        case 'KeyD': keys.right = true; break;
      }
    });
    
    document.addEventListener('keyup', (event) => {
      switch (event.code) {
        case 'KeyW': keys.forward = false; break;
        case 'KeyS': keys.backward = false; break;
        case 'KeyA': keys.left = false; break;
        case 'KeyD': keys.right = false; break;
      }
    });
    
    // 鼠标事件
    let isMouseDown = false;
    let mouseX = 0;
    let mouseY = 0;
    
    document.addEventListener('mousedown', () => {
      isMouseDown = true;
    });
    
    document.addEventListener('mouseup', () => {
      isMouseDown = false;
    });
    
    document.addEventListener('mousemove', (event) => {
      if (!isMouseDown) return;
      
      const deltaX = event.clientX - mouseX;
      const deltaY = event.clientY - mouseY;
      
      // 实现鼠标看向逻辑
      this.updateFirstPersonLook(deltaX * lookSpeed, deltaY * lookSpeed);
      
      mouseX = event.clientX;
      mouseY = event.clientY;
    });
    
    // 移动更新循环
    const updateMovement = () => {
      this.updateFirstPersonMovement(keys, moveSpeed);
      requestAnimationFrame(updateMovement);
    };
    
    updateMovement();
  }
  
  private updateFirstPersonLook(deltaX: number, deltaY: number): void {
    // 实现第一人称视角旋转逻辑
    // 这里需要根据具体需求实现
  }
  
  private updateFirstPersonMovement(keys: any, speed: number): void {
    // 实现第一人称移动逻辑
    // 这里需要根据具体需求实现
  }
}
```

### 4.2 OrthoPerspectiveCamera 类

支持正交和透视投影切换的高级相机：

```typescript
// 创建正交透视相机
const camera = new OrthoPerspectiveCamera(components);

// 切换投影模式
camera.setProjection("Orthographic");
camera.setProjection("Perspective");

// 监听投影变化
camera.onProjectionChanged.add((projection) => {
  console.log(`投影模式切换为: ${projection}`);
});
```

## 5. 渲染系统 (Renderers)

### 5.1 渲染系统概述

渲染系统负责将 3D 场景转换为 2D 图像输出到屏幕。@thatopen/components 提供了高性能的 WebGL 渲染器，支持现代渲染技术和后处理效果。

#### 🎨 渲染器特性

- **高性能 WebGL 渲染**: 基于 Three.js 的优化渲染管道
- **阴影系统**: 支持多种阴影映射技术
- **后处理效果**: 内置多种视觉效果
- **自适应渲染**: 根据设备性能自动调整渲染质量
- **多视口支持**: 支持分屏和多窗口渲染

### 5.2 SimpleRenderer 详解

`SimpleRenderer` 提供完整的 WebGL 渲染功能，集成了阴影、后处理和性能优化。

#### 🏗️ 基础设置

```typescript
import * as OBC from "@thatopen/components";
import * as THREE from "three";

// 创建渲染器实例
const components = new OBC.Components();
const container = document.getElementById('container')!;
const renderer = new OBC.SimpleRenderer(components, container);

// 基础配置
renderer.three.setPixelRatio(window.devicePixelRatio);
renderer.three.setClearColor(0xf0f0f0, 1.0);
renderer.three.setSize(container.clientWidth, container.clientHeight);

// 启用阴影
renderer.three.shadowMap.enabled = true;
renderer.three.shadowMap.type = THREE.PCFSoftShadowMap;
renderer.three.shadowMap.autoUpdate = true;

// 设置色调映射
renderer.three.toneMapping = THREE.ACESFilmicToneMapping;
renderer.three.toneMappingExposure = 1.0;

// 启用物理正确的光照
renderer.three.physicallyCorrectLights = true;

// 自动调整大小
window.addEventListener('resize', () => {
  renderer.resize();
});
```

#### 🌟 高级渲染配置

```typescript
class AdvancedRenderingManager {
  private renderer: OBC.SimpleRenderer;
  private performanceMonitor: PerformanceMonitor;
  
  constructor(components: OBC.Components, container: HTMLElement) {
    this.renderer = new OBC.SimpleRenderer(components, container);
    this.performanceMonitor = new PerformanceMonitor();
    this.setupAdvancedRendering();
  }
  
  private setupAdvancedRendering(): void {
    // 配置渲染器
    this.configureRenderer();
    
    // 配置阴影
    this.configureShadows();
    
    // 性能监控
    this.setupPerformanceMonitoring();
  }
  
  private configureRenderer(): void {
    const renderer = this.renderer.three;
    
    // 高质量渲染设置
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.outputEncoding = THREE.sRGBEncoding;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.2;
    
    // 抗锯齿
    renderer.antialias = true;
    
    // 启用物理正确的光照
    renderer.physicallyCorrectLights = true;
    
    // 设置清除颜色
    renderer.setClearColor(0x263238, 1.0);
    
    // 启用深度测试和写入
    renderer.sortObjects = true;
    renderer.autoClear = true;
    renderer.autoClearColor = true;
    renderer.autoClearDepth = true;
    renderer.autoClearStencil = true;
  }
  
  private configureShadows(): void {
    const renderer = this.renderer.three;
    
    // 启用阴影
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.shadowMap.autoUpdate = true;
    
    // 设置阴影级联
    this.setupCascadedShadows();
  }
  
  private setupCascadedShadows(): void {
    // 为不同距离的对象设置不同质量的阴影
    const shadowConfigs = [
      { distance: 50, mapSize: 2048, bias: -0.0001 },
      { distance: 100, mapSize: 1024, bias: -0.0005 },
      { distance: 200, mapSize: 512, bias: -0.001 }
    ];
    
    // 这里可以根据对象距离相机的远近来动态调整阴影质量
    // 具体实现需要在渲染循环中进行
  }
  
  private setupPerformanceMonitoring(): void {
    this.performanceMonitor.onFPSChange.add((fps) => {
      this.adjustRenderQuality(fps);
    });
    
    this.performanceMonitor.start();
  }
  
  private adjustRenderQuality(fps: number): void {
    const renderer = this.renderer.three;
    
    if (fps < 30) {
      // 降低渲染质量
      renderer.setPixelRatio(Math.min(window.devicePixelRatio * 0.5, 1));
      renderer.shadowMap.enabled = false;
    } else if (fps > 50) {
      // 提高渲染质量
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.shadowMap.enabled = true;
    }
  }
  
  // 设置渲染模式
  setRenderMode(mode: 'realistic' | 'wireframe' | 'normals' | 'depth'): void {
    switch (mode) {
      case 'realistic':
        this.setRealisticMode();
        break;
      case 'wireframe':
        this.setWireframeMode();
        break;
      case 'normals':
        this.setNormalsMode();
        break;
      case 'depth':
        this.setDepthMode();
        break;
    }
  }
  
  private setRealisticMode(): void {
    // 恢复正常材质
    this.traverseAndSetMaterial((material: THREE.Material) => {
      material.wireframe = false;
      if (material instanceof THREE.MeshStandardMaterial) {
        material.needsUpdate = true;
      }
    });
  }
  
  private setWireframeMode(): void {
    // 设置线框模式
    this.traverseAndSetMaterial((material: THREE.Material) => {
      material.wireframe = true;
    });
  }
  
  private setNormalsMode(): void {
    // 显示法线
    const normalMaterial = new THREE.MeshNormalMaterial();
    this.traverseAndSetMaterial(() => normalMaterial);
  }
  
  private setDepthMode(): void {
    // 显示深度
    const depthMaterial = new THREE.MeshDepthMaterial();
    this.traverseAndSetMaterial(() => depthMaterial);
  }
  
  private traverseAndSetMaterial(
    callback: (material: THREE.Material) => THREE.Material | void
  ): void {
    // 遍历场景中的所有对象并应用材质变更
    // 这里需要访问场景对象，具体实现取决于应用架构
  }
  
  // 截图功能
  captureScreenshot(width?: number, height?: number): string {
    const renderer = this.renderer.three;
    const originalSize = renderer.getSize(new THREE.Vector2());
    
    if (width && height) {
      renderer.setSize(width, height);
    }
    
    const dataURL = renderer.domElement.toDataURL('image/png');
    
    // 恢复原始尺寸
    if (width && height) {
      renderer.setSize(originalSize.x, originalSize.y);
    }
    
    return dataURL;
  }
  
  // 获取渲染统计信息
  getRenderStats(): RenderStats {
    const renderer = this.renderer.three;
    const info = renderer.info;
    
    return {
      triangles: info.render.triangles,
      points: info.render.points,
      lines: info.render.lines,
      calls: info.render.calls,
      geometries: info.memory.geometries,
      textures: info.memory.textures,
      programs: info.programs?.length || 0
    };
  }
  
  // 销毁渲染器
  dispose(): void {
    this.renderer.dispose();
    this.performanceMonitor.stop();
  }
}

interface RenderStats {
  triangles: number;
  points: number;
  lines: number;
  calls: number;
  geometries: number;
  textures: number;
  programs: number;
}

class PerformanceMonitor {
  private frameCount = 0;
  private lastTime = performance.now();
  private fps = 60;
  private animationId: number | null = null;
  
  public onFPSChange = new Set<(fps: number) => void>();
  
  start(): void {
    const monitor = () => {
      this.frameCount++;
      const currentTime = performance.now();
      
      if (currentTime - this.lastTime >= 1000) {
        this.fps = Math.round((this.frameCount * 1000) / (currentTime - this.lastTime));
        this.frameCount = 0;
        this.lastTime = currentTime;
        
        // 通知 FPS 变化
        this.onFPSChange.forEach(callback => callback(this.fps));
      }
      
      this.animationId = requestAnimationFrame(monitor);
    };
    
    monitor();
  }
  
  stop(): void {
    if (this.animationId) {
      cancelAnimationFrame(this.animationId);
      this.animationId = null;
    }
  }
  
  getCurrentFPS(): number {
    return this.fps;
  }
}
```

### 5.3 PostproductionRenderer 详解

`PostproductionRenderer` 提供了丰富的后处理效果，可以显著提升渲染质量。

#### 🎭 后处理效果配置

```typescript
class PostProcessingManager {
  private renderer: OBC.PostproductionRenderer;
  
  constructor(components: OBC.Components, container: HTMLElement) {
    this.renderer = new OBC.PostproductionRenderer(components, container);
    this.setupEffects();
  }
  
  private setupEffects(): void {
    // 启用后处理
    this.renderer.postproduction.enabled = true;
    
    // 配置内置效果
    this.configureBuiltInEffects();
    
    // 添加自定义效果
    this.addCustomEffects();
  }
  
  private configureBuiltInEffects(): void {
    const postproduction = this.renderer.postproduction;
    
    // 配置自定义效果
    if (postproduction.customEffects) {
      // 排除某些网格不参与后处理
      postproduction.customEffects.excludedMeshes.add('background');
      postproduction.customEffects.excludedMeshes.add('skybox');
    }
  }
  
  private addCustomEffects(): void {
    const composer = this.renderer.postproduction.composer;
    
    // 添加 FXAA 抗锯齿
    const fxaaPass = this.createFXAAPass();
    composer.addPass(fxaaPass);
    
    // 添加辉光效果
    const bloomPass = this.createBloomPass();
    composer.addPass(bloomPass);
    
    // 添加色彩分级
    const colorGradingPass = this.createColorGradingPass();
    composer.addPass(colorGradingPass);
  }
  
  private createFXAAPass(): THREE.ShaderPass {
    const fxaaPass = new THREE.ShaderPass(THREE.FXAAShader);
    fxaaPass.material.uniforms['resolution'].value.x = 1 / window.innerWidth;
    fxaaPass.material.uniforms['resolution'].value.y = 1 / window.innerHeight;
    return fxaaPass;
  }
  
  private createBloomPass(): THREE.UnrealBloomPass {
    const bloomPass = new THREE.UnrealBloomPass(
      new THREE.Vector2(window.innerWidth, window.innerHeight),
      1.5,  // strength
      0.4,  // radius
      0.85  // threshold
    );
    
    return bloomPass;
  }
  
  private createColorGradingPass(): THREE.ShaderPass {
    const colorGradingShader = {
      uniforms: {
        'tDiffuse': { value: null },
        'brightness': { value: 0.0 },
        'contrast': { value: 1.0 },
        'saturation': { value: 1.0 }
      },
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform float brightness;
        uniform float contrast;
        uniform float saturation;
        varying vec2 vUv;
        
        void main() {
          vec4 color = texture2D(tDiffuse, vUv);
          
          // 亮度调整
          color.rgb += brightness;
          
          // 对比度调整
          color.rgb = (color.rgb - 0.5) * contrast + 0.5;
          
          // 饱和度调整
          float gray = dot(color.rgb, vec3(0.299, 0.587, 0.114));
          color.rgb = mix(vec3(gray), color.rgb, saturation);
          
          gl_FragColor = color;
        }
      `
    };
    
    return new THREE.ShaderPass(colorGradingShader);
  }
  
  // 动态调整效果强度
  adjustEffectIntensity(effectName: string, intensity: number): void {
    const composer = this.renderer.postproduction.composer;
    
    composer.passes.forEach(pass => {
      if (pass.name === effectName) {
        if ('strength' in pass) {
          (pass as any).strength = intensity;
        }
      }
    });
  }
  
  // 切换效果开关
  toggleEffect(effectName: string, enabled: boolean): void {
    const composer = this.renderer.postproduction.composer;
    
    composer.passes.forEach(pass => {
      if (pass.name === effectName) {
        pass.enabled = enabled;
      }
    });
  }
  
  // 预设效果配置
  applyPreset(preset: 'realistic' | 'cinematic' | 'cartoon' | 'noir'): void {
    switch (preset) {
      case 'realistic':
        this.applyRealisticPreset();
        break;
      case 'cinematic':
        this.applyCinematicPreset();
        break;
      case 'cartoon':
        this.applyCartoonPreset();
        break;
      case 'noir':
        this.applyNoirPreset();
        break;
    }
  }
  
  private applyRealisticPreset(): void {
    // 现实主义风格设置
    this.adjustEffectIntensity('bloom', 0.3);
    this.adjustColorGrading(0.0, 1.0, 1.0); // 亮度, 对比度, 饱和度
  }
  
  private applyCinematicPreset(): void {
    // 电影风格设置
    this.adjustEffectIntensity('bloom', 0.8);
    this.adjustColorGrading(-0.1, 1.2, 0.9);
  }
  
  private applyCartoonPreset(): void {
    // 卡通风格设置
    this.adjustEffectIntensity('bloom', 1.2);
    this.adjustColorGrading(0.1, 1.3, 1.2);
  }
  
  private applyNoirPreset(): void {
    // 黑白风格设置
    this.adjustEffectIntensity('bloom', 0.5);
    this.adjustColorGrading(-0.2, 1.5, 0.0);
  }
  
  private adjustColorGrading(brightness: number, contrast: number, saturation: number): void {
    const composer = this.renderer.postproduction.composer;
    
    composer.passes.forEach(pass => {
      if (pass.name === 'colorGrading') {
        const material = (pass as THREE.ShaderPass).material;
        material.uniforms['brightness'].value = brightness;
        material.uniforms['contrast'].value = contrast;
        material.uniforms['saturation'].value = saturation;
      }
    });
  }
}
```

## 6. 完整示例

以下是一个完整的世界创建和配置示例：

```typescript
import * as THREE from "three";
import * as OBC from "@thatopen/components";

// 创建组件系统
const components = new OBC.Components();

// 获取世界管理器
const worlds = components.get(OBC.Worlds);

// 创建世界
const world = worlds.create<
  OBC.SimpleScene,
  OBC.OrthoPerspectiveCamera,
  OBC.SimpleRenderer
>();

// 配置场景
world.scene = new OBC.SimpleScene(components);
world.scene.setup({
  backgroundColor: new THREE.Color(0x87CEEB),
  directionalLight: {
    intensity: 2.0,
    position: new THREE.Vector3(10, 15, 5)
  }
});

// 配置相机
world.camera = new OBC.OrthoPerspectiveCamera(components);
world.camera.controls.setLookAt(15, 15, 15, 0, 0, 0);

// 配置渲染器
const container = document.getElementById('container')!;
world.renderer = new OBC.SimpleRenderer(components, container);
world.renderer.three.shadowMap.enabled = true;

// 初始化系统
components.init();

// 添加几何体
const geometry = new THREE.BoxGeometry(2, 2, 2);
const material = new THREE.MeshLambertMaterial({ color: 0x00ff00 });
const cube = new THREE.Mesh(geometry, material);
cube.castShadow = true;
world.scene.three.add(cube);
world.meshes.add(cube);

// 监听世界事件
world.onBeforeUpdate.add(() => {
  // 每帧更新前的逻辑
  cube.rotation.x += 0.01;
  cube.rotation.y += 0.01;
});

// 清理资源
window.addEventListener('beforeunload', () => {
  components.dispose();
});
```

## 7. 内存管理 (Memory Management)

### 7.1 内存管理概述

在 3D 应用中，内存管理至关重要。@thatopen/components 提供了完善的内存管理机制，确保应用的稳定性和性能。

#### 🧠 内存管理特性

- **自动资源清理**: 组件销毁时自动释放相关资源
- **生命周期管理**: 完整的组件生命周期跟踪
- **内存泄漏检测**: 内置内存泄漏检测和预警
- **资源池化**: 重用常用对象以减少垃圾回收压力
- **智能缓存**: 自动管理纹理、几何体等资源的缓存

### 7.2 组件生命周期管理

所有组件都实现了 `Disposable` 接口，确保资源的正确释放。

```typescript
import * as OBC from "@thatopen/components";

class ComponentLifecycleManager {
  private components: OBC.Components;
  private activeComponents = new Set<OBC.Component>();
  
  constructor() {
    this.components = new OBC.Components();
    this.setupLifecycleMonitoring();
  }
  
  private setupLifecycleMonitoring(): void {
    // 监听组件初始化
    this.components.onInitialized.add((component) => {
      console.log(`组件已初始化: ${component.constructor.name}`);
      this.activeComponents.add(component);
      
      // 为组件添加销毁监听
      if ('onDisposed' in component) {
        (component as any).onDisposed.add(() => {
          console.log(`组件已销毁: ${component.constructor.name}`);
          this.activeComponents.delete(component);
        });
      }
    });
  }
  
  // 安全销毁单个组件
  disposeComponent(component: OBC.Component): void {
    try {
      if ('dispose' in component && typeof component.dispose === 'function') {
        component.dispose();
      }
    } catch (error) {
      console.error(`销毁组件时发生错误: ${component.constructor.name}`, error);
    }
  }
  
  // 销毁所有组件
  disposeAll(): void {
    try {
      this.components.dispose();
    } catch (error) {
      console.error('销毁所有组件时发生错误:', error);
    }
  }
}
```

### 7.3 内存泄漏预防

```typescript
class MemoryLeakPreventionExample implements OBC.Disposable {
  private _disposed = false;
  private eventListeners: Array<() => void> = [];
  private threeJSObjects: THREE.Object3D[] = [];
  private textures: THREE.Texture[] = [];
  private geometries: THREE.BufferGeometry[] = [];
  private materials: THREE.Material[] = [];
  private animationFrameId: number | null = null;
  
  readonly onDisposed = new OBC.Event<void>();
  
  constructor() {
    this.setupComponent();
  }
  
  private setupComponent(): void {
    // 添加事件监听器时记录清理函数
    const handleResize = () => this.handleResize();
    window.addEventListener('resize', handleResize);
    this.eventListeners.push(() => {
      window.removeEventListener('resize', handleResize);
    });
  }
  
  // 正确的资源清理
  dispose(): void {
    if (this._disposed) return;
    
    try {
      // 停止动画循环
      if (this.animationFrameId !== null) {
        cancelAnimationFrame(this.animationFrameId);
        this.animationFrameId = null;
      }
      
      // 清理事件监听器
      this.eventListeners.forEach(cleanup => cleanup());
      this.eventListeners.length = 0;
      
      // 清理 Three.js 资源
      this.cleanupThreeJSResources();
      
      // 触发销毁事件
      this.onDisposed.trigger();
      this.onDisposed.reset();
      
      this._disposed = true;
      
    } catch (error) {
      console.error('销毁组件时发生错误:', error);
    }
  }
  
  private cleanupThreeJSResources(): void {
    // 清理几何体
    this.geometries.forEach(geometry => geometry.dispose());
    this.geometries.length = 0;
    
    // 清理材质
    this.materials.forEach(material => material.dispose());
    this.materials.length = 0;
    
    // 清理纹理
    this.textures.forEach(texture => texture.dispose());
    this.textures.length = 0;
    
    // 从场景中移除对象
    this.threeJSObjects.forEach(object => {
      if (object.parent) {
        object.parent.remove(object);
      }
    });
    this.threeJSObjects.length = 0;
  }
  
  private handleResize(): void {
    // 处理窗口大小变化
  }
  
  get disposed(): boolean {
    return this._disposed;
  }
}
```

## 8. 自定义组件开发 (Custom Component Development)

### 8.1 自定义组件概述

@thatopen/components 提供了灵活的组件系统，允许开发者创建自定义组件来扩展功能。

#### 🔧 组件开发特性

- **接口驱动**: 基于标准接口的组件设计
- **生命周期管理**: 完整的组件生命周期支持
- **事件系统**: 内置事件系统用于组件通信
- **配置管理**: 灵活的配置系统
- **类型安全**: 完整的 TypeScript 类型支持

### 8.2 基础组件开发

#### 🏗️ 创建简单组件

```typescript
import * as OBC from "@thatopen/components";
import * as THREE from "three";

// 定义组件配置接口
interface CustomComponentConfig {
  color: THREE.Color;
  size: number;
  position: THREE.Vector3;
  autoRotate: boolean;
  rotationSpeed: number;
}

// 创建自定义组件
class CustomComponent 
  extends OBC.Component 
  implements OBC.Updateable, OBC.Disposable, OBC.Configurable<CustomComponentConfig> 
{
  static readonly uuid = "custom-component-uuid" as const;
  
  // 组件是否启用
  enabled = true;
  
  // 配置对象
  config: Required<CustomComponentConfig> = {
    color: new THREE.Color(0x00ff00),
    size: 1,
    position: new THREE.Vector3(0, 0, 0),
    autoRotate: true,
    rotationSpeed: 0.01
  };
  
  // 事件定义
  readonly onConfigChanged = new OBC.Event<Partial<CustomComponentConfig>>();
  readonly onDisposed = new OBC.Event<void>();
  readonly onObjectCreated = new OBC.Event<THREE.Mesh>();
  
  // 私有属性
  private _mesh: THREE.Mesh | null = null;
  private _disposed = false;
  
  constructor(components: OBC.Components) {
    super(components);
    this.createMesh();
  }
  
  // 创建 3D 对象
  private createMesh(): void {
    const geometry = new THREE.BoxGeometry(
      this.config.size,
      this.config.size,
      this.config.size
    );
    
    const material = new THREE.MeshStandardMaterial({
      color: this.config.color
    });
    
    this._mesh = new THREE.Mesh(geometry, material);
    this._mesh.position.copy(this.config.position);
    this._mesh.castShadow = true;
    this._mesh.receiveShadow = true;
    
    // 触发对象创建事件
    this.onObjectCreated.trigger(this._mesh);
  }
  
  // 更新方法（实现 Updateable 接口）
  update(): void {
    if (!this.enabled || !this._mesh || this._disposed) return;
    
    if (this.config.autoRotate) {
      this._mesh.rotation.x += this.config.rotationSpeed;
      this._mesh.rotation.y += this.config.rotationSpeed;
    }
  }
  
  // 配置更新方法（实现 Configurable 接口）
  setup(config?: Partial<CustomComponentConfig>): void {
    if (!config) return;
    
    const oldConfig = { ...this.config };
    
    // 更新配置
    Object.assign(this.config, config);
    
    // 应用配置变更
    this.applyConfigChanges(oldConfig, config);
    
    // 触发配置变更事件
    this.onConfigChanged.trigger(config);
  }
  
  private applyConfigChanges(
    oldConfig: CustomComponentConfig,
    newConfig: Partial<CustomComponentConfig>
  ): void {
    if (!this._mesh) return;
    
    // 更新颜色
    if (newConfig.color && !newConfig.color.equals(oldConfig.color)) {
      (this._mesh.material as THREE.MeshStandardMaterial).color.copy(newConfig.color);
    }
    
    // 更新大小
    if (newConfig.size && newConfig.size !== oldConfig.size) {
      this._mesh.scale.setScalar(newConfig.size / oldConfig.size);
    }
    
    // 更新位置
    if (newConfig.position && !newConfig.position.equals(oldConfig.position)) {
      this._mesh.position.copy(newConfig.position);
    }
  }
  
  // 获取创建的网格
  get mesh(): THREE.Mesh | null {
    return this._mesh;
  }
  
  // 设置可见性
  setVisible(visible: boolean): void {
    if (this._mesh) {
      this._mesh.visible = visible;
    }
  }
  
  // 销毁方法（实现 Disposable 接口）
  dispose(): void {
    if (this._disposed) return;
    
    try {
      // 清理 3D 对象
      if (this._mesh) {
        // 清理几何体和材质
        this._mesh.geometry.dispose();
        (this._mesh.material as THREE.Material).dispose();
        
        // 从父对象中移除
        if (this._mesh.parent) {
          this._mesh.parent.remove(this._mesh);
        }
        
        this._mesh = null;
      }
      
      // 清理事件
      this.onConfigChanged.reset();
      this.onDisposed.trigger();
      this.onDisposed.reset();
      this.onObjectCreated.reset();
      
      this._disposed = true;
      
    } catch (error) {
      console.error('销毁自定义组件时发生错误:', error);
    }
  }
  
  get disposed(): boolean {
    return this._disposed;
  }
}
```

### 8.3 高级组件开发

#### 🚀 复杂组件示例

```typescript
// 粒子系统组件
class ParticleSystemComponent 
  extends OBC.Component 
  implements OBC.Updateable, OBC.Disposable, OBC.Configurable<ParticleConfig> 
{
  static readonly uuid = "particle-system-uuid" as const;
  
  enabled = true;
  
  config: Required<ParticleConfig> = {
    particleCount: 1000,
    particleSize: 0.1,
    emissionRate: 10,
    lifetime: 5.0,
    gravity: new THREE.Vector3(0, -9.8, 0),
    initialVelocity: new THREE.Vector3(0, 5, 0),
    velocityVariation: new THREE.Vector3(2, 2, 2),
    color: new THREE.Color(0xffffff),
    colorVariation: 0.2
  };
  
  readonly onParticleEmitted = new OBC.Event<Particle>();
  readonly onParticleDestroyed = new OBC.Event<Particle>();
  readonly onDisposed = new OBC.Event<void>();
  
  private particles: Particle[] = [];
  private particlePool: Particle[] = [];
  private emissionTimer = 0;
  private particleGeometry: THREE.BufferGeometry;
  private particleMaterial: THREE.PointsMaterial;
  private particleSystem: THREE.Points;
  private _disposed = false;
  
  constructor(components: OBC.Components) {
    super(components);
    this.initializeParticleSystem();
  }
  
  private initializeParticleSystem(): void {
    // 创建粒子几何体
    this.particleGeometry = new THREE.BufferGeometry();
    
    // 创建粒子材质
    this.particleMaterial = new THREE.PointsMaterial({
      size: this.config.particleSize,
      color: this.config.color,
      transparent: true,
      alphaTest: 0.1
    });
    
    // 创建粒子系统
    this.particleSystem = new THREE.Points(this.particleGeometry, this.particleMaterial);
    
    // 初始化粒子池
    this.initializeParticlePool();
  }
  
  private initializeParticlePool(): void {
    for (let i = 0; i < this.config.particleCount; i++) {
      this.particlePool.push(this.createParticle());
    }
  }
  
  private createParticle(): Particle {
    return {
      position: new THREE.Vector3(),
      velocity: new THREE.Vector3(),
      life: 0,
      maxLife: this.config.lifetime,
      size: this.config.particleSize,
      color: this.config.color.clone(),
      active: false
    };
  }
  
  update(deltaTime: number): void {
    if (!this.enabled || this._disposed) return;
    
    // 发射新粒子
    this.emitParticles(deltaTime);
    
    // 更新现有粒子
    this.updateParticles(deltaTime);
    
    // 更新粒子系统几何体
    this.updateParticleGeometry();
  }
  
  private emitParticles(deltaTime: number): void {
    this.emissionTimer += deltaTime;
    const emissionInterval = 1.0 / this.config.emissionRate;
    
    while (this.emissionTimer >= emissionInterval && this.particlePool.length > 0) {
      const particle = this.particlePool.pop()!;
      this.initializeParticle(particle);
      this.particles.push(particle);
      
      this.onParticleEmitted.trigger(particle);
      this.emissionTimer -= emissionInterval;
    }
  }
  
  private initializeParticle(particle: Particle): void {
    particle.position.set(0, 0, 0);
    particle.velocity.copy(this.config.initialVelocity);
    
    // 添加速度变化
    particle.velocity.add(
      new THREE.Vector3(
        (Math.random() - 0.5) * this.config.velocityVariation.x,
        (Math.random() - 0.5) * this.config.velocityVariation.y,
        (Math.random() - 0.5) * this.config.velocityVariation.z
      )
    );
    
    particle.life = 0;
    particle.maxLife = this.config.lifetime * (0.8 + Math.random() * 0.4);
    particle.active = true;
    
    // 颜色变化
    particle.color.copy(this.config.color);
    const colorVar = this.config.colorVariation;
    particle.color.offsetHSL(
      (Math.random() - 0.5) * colorVar,
      (Math.random() - 0.5) * colorVar,
      (Math.random() - 0.5) * colorVar
    );
  }
  
  private updateParticles(deltaTime: number): void {
    for (let i = this.particles.length - 1; i >= 0; i--) {
      const particle = this.particles[i];
      
      // 更新生命周期
      particle.life += deltaTime;
      
      if (particle.life >= particle.maxLife) {
        // 粒子死亡，回收到池中
        particle.active = false;
        this.particles.splice(i, 1);
        this.particlePool.push(particle);
        this.onParticleDestroyed.trigger(particle);
        continue;
      }
      
      // 更新物理
      particle.velocity.add(
        this.config.gravity.clone().multiplyScalar(deltaTime)
      );
      particle.position.add(
        particle.velocity.clone().multiplyScalar(deltaTime)
      );
      
      // 更新透明度（基于生命周期）
      const lifeRatio = particle.life / particle.maxLife;
      const alpha = 1.0 - lifeRatio;
      particle.color.setScalar(alpha);
    }
  }
  
  private updateParticleGeometry(): void {
    const positions = new Float32Array(this.particles.length * 3);
    const colors = new Float32Array(this.particles.length * 3);
    
    for (let i = 0; i < this.particles.length; i++) {
      const particle = this.particles[i];
      const i3 = i * 3;
      
      positions[i3] = particle.position.x;
      positions[i3 + 1] = particle.position.y;
      positions[i3 + 2] = particle.position.z;
      
      colors[i3] = particle.color.r;
      colors[i3 + 1] = particle.color.g;
      colors[i3 + 2] = particle.color.b;
    }
    
    this.particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    this.particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    this.particleGeometry.attributes.position.needsUpdate = true;
    this.particleGeometry.attributes.color.needsUpdate = true;
  }
  
  setup(config?: Partial<ParticleConfig>): void {
    if (!config) return;
    
    Object.assign(this.config, config);
    
    // 应用配置变更
    if (config.particleSize !== undefined) {
      this.particleMaterial.size = config.particleSize;
    }
    
    if (config.color !== undefined) {
      this.particleMaterial.color.copy(config.color);
    }
  }
  
  get system(): THREE.Points {
    return this.particleSystem;
  }
  
  dispose(): void {
    if (this._disposed) return;
    
    try {
      // 清理粒子
      this.particles.length = 0;
      this.particlePool.length = 0;
      
      // 清理 Three.js 资源
      this.particleGeometry.dispose();
      this.particleMaterial.dispose();
      
      // 清理事件
      this.onParticleEmitted.reset();
      this.onParticleDestroyed.reset();
      this.onDisposed.trigger();
      this.onDisposed.reset();
      
      this._disposed = true;
      
    } catch (error) {
      console.error('销毁粒子系统时发生错误:', error);
    }
  }
  
  get disposed(): boolean {
    return this._disposed;
  }
}

interface ParticleConfig {
  particleCount: number;
  particleSize: number;
  emissionRate: number;
  lifetime: number;
  gravity: THREE.Vector3;
  initialVelocity: THREE.Vector3;
  velocityVariation: THREE.Vector3;
  color: THREE.Color;
  colorVariation: number;
}

interface Particle {
  position: THREE.Vector3;
  velocity: THREE.Vector3;
  life: number;
  maxLife: number;
  size: number;
  color: THREE.Color;
  active: boolean;
}
```

### 8.4 组件注册和使用

```typescript
// 注册自定义组件
const components = new OBC.Components();

// 添加自定义组件
const customComponent = new CustomComponent(components);
components.add(CustomComponent.uuid, customComponent);

// 添加粒子系统组件
const particleSystem = new ParticleSystemComponent(components);
components.add(ParticleSystemComponent.uuid, particleSystem);

// 获取和使用组件
const myComponent = components.get(CustomComponent);
myComponent.setup({
  color: new THREE.Color(0xff0000),
  size: 2,
  autoRotate: true
});

// 将组件对象添加到场景
const world = components.get(OBC.Worlds).create();
if (myComponent.mesh) {
  world.scene.three.add(myComponent.mesh);
}

if (particleSystem.system) {
  world.scene.three.add(particleSystem.system);
}

// 启动更新循环
components.init();
```

## 9. 最佳实践

### 9.1 内存管理最佳实践

```typescript
// 始终在应用结束时清理资源
components.dispose();

// 删除不需要的世界
worlds.delete(world);

// 清理几何体和材质
geometry.dispose();
material.dispose();

// 使用对象池减少垃圾回收
class ObjectPool<T> {
  private pool: T[] = [];
  private createFn: () => T;
  private resetFn: (obj: T) => void;
  
  constructor(createFn: () => T, resetFn: (obj: T) => void, initialSize = 10) {
    this.createFn = createFn;
    this.resetFn = resetFn;
    
    // 预填充池
    for (let i = 0; i < initialSize; i++) {
      this.pool.push(this.createFn());
    }
  }
  
  get(): T {
    return this.pool.pop() || this.createFn();
  }
  
  release(obj: T): void {
    this.resetFn(obj);
    this.pool.push(obj);
  }
}

// 使用示例
const vectorPool = new ObjectPool(
  () => new THREE.Vector3(),
  (v) => v.set(0, 0, 0),
  50
);
```

### 9.2 性能优化最佳实践

#### 🚀 渲染性能优化

```typescript
class PerformanceOptimizer {
  private components: OBC.Components;
  private frameCounter = 0;
  private lastFPSCheck = 0;
  private currentFPS = 0;
  
  constructor(components: OBC.Components) {
    this.components = components;
    this.setupPerformanceMonitoring();
  }
  
  private setupPerformanceMonitoring(): void {
    // 监控 FPS
    const updateLoop = () => {
      this.frameCounter++;
      const now = performance.now();
      
      if (now - this.lastFPSCheck >= 1000) {
        this.currentFPS = this.frameCounter;
        this.frameCounter = 0;
        this.lastFPSCheck = now;
        
        // 根据 FPS 调整渲染质量
        this.adjustRenderQuality();
      }
      
      requestAnimationFrame(updateLoop);
    };
    updateLoop();
  }
  
  private adjustRenderQuality(): void {
    const renderer = this.components.get(OBC.SimpleRenderer);
    
    if (this.currentFPS < 30) {
      // 降低渲染质量
      renderer.three.setPixelRatio(Math.min(window.devicePixelRatio * 0.5, 1));
      renderer.three.shadowMap.enabled = false;
    } else if (this.currentFPS > 50) {
      // 提高渲染质量
      renderer.three.setPixelRatio(window.devicePixelRatio);
      renderer.three.shadowMap.enabled = true;
    }
  }
  
  // 批量更新优化
  batchUpdate(objects: THREE.Object3D[], updateFn: (obj: THREE.Object3D) => void): void {
    // 暂停渲染
    const renderer = this.components.get(OBC.SimpleRenderer);
    const autoRender = renderer.three.autoClear;
    renderer.three.autoClear = false;
    
    try {
      // 批量更新
      objects.forEach(updateFn);
    } finally {
      // 恢复渲染
      renderer.three.autoClear = autoRender;
      renderer.three.render(
        this.components.get(OBC.Worlds).list.values().next().value.scene.three,
        this.components.get(OBC.Worlds).list.values().next().value.camera.three
      );
    }
  }
  
  // LOD (Level of Detail) 管理
  setupLOD(object: THREE.Object3D, distances: number[], geometries: THREE.BufferGeometry[]): THREE.LOD {
    const lod = new THREE.LOD();
    
    geometries.forEach((geometry, index) => {
      const material = new THREE.MeshStandardMaterial({ color: 0x00ff00 });
      const mesh = new THREE.Mesh(geometry, material);
      lod.addLevel(mesh, distances[index] || 0);
    });
    
    return lod;
  }
}
```

#### 🎯 组件更新优化

```typescript
class OptimizedComponent extends OBC.Component implements OBC.Updateable {
  enabled = true;
  private updateInterval = 16; // 60 FPS
  private lastUpdate = 0;
  private isDirty = false;
  
  // 条件更新 - 只在需要时更新
  update(): void {
    if (!this.enabled || !this.isDirty) return;
    
    const now = performance.now();
    if (now - this.lastUpdate < this.updateInterval) return;
    
    this.performUpdate();
    this.isDirty = false;
    this.lastUpdate = now;
  }
  
  private performUpdate(): void {
    // 实际更新逻辑
  }
  
  // 标记为需要更新
  markDirty(): void {
    this.isDirty = true;
  }
  
  // 设置更新频率
  setUpdateRate(fps: number): void {
    this.updateInterval = 1000 / fps;
  }
}
```

### 9.3 错误处理最佳实践

```typescript
class ErrorHandlingExample {
  private components: OBC.Components;
  private errorLog: Array<{ timestamp: number; error: Error; context: string }> = [];
  
  constructor() {
    this.components = new OBC.Components();
    this.setupGlobalErrorHandling();
  }
  
  private setupGlobalErrorHandling(): void {
    // 全局错误处理
    window.addEventListener('error', (event) => {
      this.logError(event.error, 'Global Error');
    });
    
    // Promise 错误处理
    window.addEventListener('unhandledrejection', (event) => {
      this.logError(new Error(event.reason), 'Unhandled Promise Rejection');
    });
  }
  
  private logError(error: Error, context: string): void {
    const errorEntry = {
      timestamp: Date.now(),
      error,
      context
    };
    
    this.errorLog.push(errorEntry);
    console.error(`[${context}]`, error);
    
    // 限制错误日志大小
    if (this.errorLog.length > 100) {
      this.errorLog.shift();
    }
  }
  
  // 安全的组件操作
  safeComponentOperation<T>(
    operation: () => T,
    fallback: T,
    context: string
  ): T {
    try {
      return operation();
    } catch (error) {
      this.logError(error as Error, context);
      return fallback;
    }
  }
  
  // 异步操作错误处理
  async safeAsyncOperation<T>(
    operation: () => Promise<T>,
    fallback: T,
    context: string
  ): Promise<T> {
    try {
      return await operation();
    } catch (error) {
      this.logError(error as Error, context);
      return fallback;
    }
  }
  
  // 组件初始化错误处理
  initializeComponentSafely<T extends OBC.Component>(
    ComponentClass: new (components: OBC.Components) => T
  ): T | null {
    return this.safeComponentOperation(
      () => {
        const component = new ComponentClass(this.components);
        this.components.add(ComponentClass.uuid, component);
        return component;
      },
      null,
      `Initialize ${ComponentClass.name}`
    );
  }
}
```

### 9.4 组件设计模式

#### 🏗️ 工厂模式

```typescript
interface ComponentFactory {
  create<T extends OBC.Component>(type: string, config?: any): T | null;
}

class StandardComponentFactory implements ComponentFactory {
  private components: OBC.Components;
  private registry = new Map<string, new (components: OBC.Components) => OBC.Component>();
  
  constructor(components: OBC.Components) {
    this.components = components;
    this.registerStandardComponents();
  }
  
  private registerStandardComponents(): void {
    this.registry.set('simple-scene', OBC.SimpleScene);
    this.registry.set('simple-camera', OBC.SimpleCamera);
    this.registry.set('simple-renderer', OBC.SimpleRenderer);
    // 注册更多组件...
  }
  
  register<T extends OBC.Component>(
    type: string,
    ComponentClass: new (components: OBC.Components) => T
  ): void {
    this.registry.set(type, ComponentClass);
  }
  
  create<T extends OBC.Component>(type: string, config?: any): T | null {
    const ComponentClass = this.registry.get(type);
    if (!ComponentClass) {
      console.warn(`未知的组件类型: ${type}`);
      return null;
    }
    
    try {
      const component = new ComponentClass(this.components) as T;
      
      if (config && 'setup' in component) {
        (component as any).setup(config);
      }
      
      return component;
    } catch (error) {
      console.error(`创建组件失败: ${type}`, error);
      return null;
    }
  }
}
```

#### 🔄 观察者模式

```typescript
class ComponentEventManager {
  private eventBus = new Map<string, Set<Function>>();
  
  // 订阅事件
  subscribe(eventName: string, callback: Function): () => void {
    if (!this.eventBus.has(eventName)) {
      this.eventBus.set(eventName, new Set());
    }
    
    this.eventBus.get(eventName)!.add(callback);
    
    // 返回取消订阅函数
    return () => {
      this.eventBus.get(eventName)?.delete(callback);
    };
  }
  
  // 发布事件
  publish(eventName: string, data?: any): void {
    const callbacks = this.eventBus.get(eventName);
    if (callbacks) {
      callbacks.forEach(callback => {
        try {
          callback(data);
        } catch (error) {
          console.error(`事件回调执行失败: ${eventName}`, error);
        }
      });
    }
  }
  
  // 清理所有事件
  clear(): void {
    this.eventBus.clear();
  }
}
```

### 9.5 调试和开发工具

```typescript
class DevelopmentTools {
  private components: OBC.Components;
  private debugPanel: HTMLElement | null = null;
  
  constructor(components: OBC.Components) {
    this.components = components;
    this.createDebugPanel();
  }
  
  private createDebugPanel(): void {
    if (process.env.NODE_ENV !== 'development') return;
    
    this.debugPanel = document.createElement('div');
    this.debugPanel.style.cssText = `
      position: fixed;
      top: 10px;
      right: 10px;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 10px;
      border-radius: 5px;
      font-family: monospace;
      font-size: 12px;
      z-index: 10000;
      max-width: 300px;
    `;
    
    document.body.appendChild(this.debugPanel);
    this.updateDebugInfo();
  }
  
  private updateDebugInfo(): void {
    if (!this.debugPanel) return;
    
    const updateLoop = () => {
      const info = this.gatherDebugInfo();
      this.debugPanel!.innerHTML = `
        <div><strong>组件调试信息</strong></div>
        <div>活跃组件: ${info.activeComponents}</div>
        <div>内存使用: ${info.memoryUsage}MB</div>
        <div>FPS: ${info.fps}</div>
        <div>渲染调用: ${info.renderCalls}</div>
        <div>三角形数: ${info.triangles}</div>
      `;
      
      requestAnimationFrame(updateLoop);
    };
    updateLoop();
  }
  
  private gatherDebugInfo() {
    const renderer = this.components.get(OBC.SimpleRenderer);
    const info = renderer.three.info;
    
    return {
      activeComponents: this.components.list.size,
      memoryUsage: (performance as any).memory ? 
        Math.round((performance as any).memory.usedJSHeapSize / 1048576) : 'N/A',
      fps: Math.round(1000 / 16), // 简化的 FPS 计算
      renderCalls: info.render.calls,
      triangles: info.render.triangles
    };
  }
  
  // 组件检查器
  inspectComponent(component: OBC.Component): void {
    console.group(`组件检查: ${component.constructor.name}`);
    console.log('UUID:', (component.constructor as any).uuid);
    console.log('启用状态:', 'enabled' in component ? (component as any).enabled : 'N/A');
    console.log('配置:', 'config' in component ? (component as any).config : 'N/A');
    console.log('已销毁:', 'disposed' in component ? (component as any).disposed : 'N/A');
    console.groupEnd();
  }
}
```

### 7.2 性能优化

```typescript
// 禁用不需要的组件
component.enabled = false;

// 使用对象池重用几何体
const geometryPool = new Map<string, THREE.BufferGeometry>();

// 批量处理网格更新
world.onBeforeUpdate.add(() => {
  // 批量更新逻辑
});
```

### 7.3 错误处理

```typescript
try {
  const world = worlds.create();
  // 配置世界...
} catch (error) {
  console.error('世界创建失败:', error);
}

// 监听组件错误
components.onDisposed.add(() => {
  console.log('组件系统已安全销毁');
});
```

## 10. 总结

### 10.1 核心组件系统回顾

通过本章的学习，我们深入了解了 @thatopen/components 的核心组件系统：

#### 🏗️ 组件架构
- **Components 容器**: 作为依赖注入容器，管理所有组件的生命周期
- **接口驱动设计**: 通过标准接口确保组件的一致性和可扩展性
- **事件系统**: 提供组件间的松耦合通信机制

#### 🌍 核心组件
- **世界系统 (Worlds)**: 管理多个 3D 世界实例
- **场景系统 (SimpleScene)**: 提供场景管理和光照配置
- **相机系统 (SimpleCamera/OrthoPerspectiveCamera)**: 灵活的相机控制
- **渲染系统 (SimpleRenderer/PostproductionRenderer)**: 高性能渲染和后处理

#### 🔧 高级特性
- **内存管理**: 自动资源清理和内存泄漏预防
- **性能优化**: LOD、对象池、批量更新等优化策略
- **错误处理**: 完善的错误处理和调试工具
- **自定义组件**: 灵活的组件扩展机制

### 10.2 开发建议

#### ✅ 最佳实践
1. **始终使用 TypeScript** - 充分利用类型安全特性
2. **正确管理生命周期** - 及时清理资源，避免内存泄漏
3. **合理使用事件系统** - 实现组件间的松耦合通信
4. **性能优化优先** - 在开发早期就考虑性能问题
5. **错误处理完善** - 建立完善的错误处理机制

#### ⚠️ 常见陷阱
1. **忘记调用 dispose()** - 导致内存泄漏
2. **过度使用事件监听** - 影响性能
3. **不当的组件依赖** - 造成循环依赖
4. **忽略错误处理** - 导致应用崩溃

### 10.3 学习路径建议

#### 🎯 初学者路径
1. 掌握基础组件的使用
2. 理解组件生命周期
3. 学习事件系统
4. 实践简单的 3D 场景

#### 🚀 进阶路径
1. 深入理解组件架构
2. 开发自定义组件
3. 性能优化实践
4. 复杂应用架构设计

#### 🏆 专家路径
1. 贡献开源组件
2. 架构设计模式
3. 性能调优专家
4. 技术分享和指导

### 10.4 实践项目建议

#### 🏠 建筑可视化项目
```typescript
// 项目结构示例
class ArchitecturalViewer {
  private components: OBC.Components;
  private world: OBC.World;
  private modelLoader: IFCLoader;
  private measurementTools: MeasurementTools;
  
  async initialize(): Promise<void> {
    // 初始化核心组件
    this.setupComponents();
    
    // 创建世界
    this.createWorld();
    
    // 加载模型
    await this.loadModel();
    
    // 设置工具
    this.setupTools();
  }
}
```

#### 🎮 交互式 3D 应用
```typescript
// 游戏引擎风格的应用
class Interactive3DApp {
  private gameLoop: GameLoop;
  private inputManager: InputManager;
  private sceneManager: SceneManager;
  
  start(): void {
    this.gameLoop.start();
  }
}
```

### 10.5 社区和资源

#### 📚 学习资源
- [官方文档](https://docs.thatopen.com/)
- [GitHub 仓库](https://github.com/ThatOpen/engine_components)
- [示例项目](https://github.com/ThatOpen/engine_components/tree/main/examples)
- [API 参考](https://docs.thatopen.com/api/)

#### 🤝 社区支持
- [Discord 社区](https://discord.gg/thatopen)
- [GitHub Discussions](https://github.com/ThatOpen/engine_components/discussions)
- [Stack Overflow](https://stackoverflow.com/questions/tagged/thatopen)

#### 🔄 持续学习
- 关注项目更新和新特性
- 参与社区讨论和问题解答
- 贡献代码和文档
- 分享使用经验和最佳实践

---

**下一章**: [IFC 文件处理系统](./03-IFC文件处理系统.md) - 学习如何加载、解析和操作 IFC 建筑模型文件，深入了解 BIM 数据处理的核心技术。