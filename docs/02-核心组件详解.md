# æ ¸å¿ƒç»„ä»¶è¯¦è§£

> æ·±å…¥ç†è§£ @thatopen/components çš„æ ¸å¿ƒæ¶æ„å’Œç»„ä»¶ç³»ç»Ÿ

æœ¬ç« å°†å…¨é¢ä»‹ç» @thatopen/components çš„æ ¸å¿ƒç»„ä»¶ç³»ç»Ÿï¼Œä»åŸºç¡€çš„ç»„ä»¶ç®¡ç†åˆ°å¤æ‚çš„ 3D ä¸–ç•Œæ„å»ºï¼Œå¸®åŠ©æ‚¨æ·±å…¥ç†è§£æ•´ä¸ªæ¶æ„çš„è®¾è®¡ç†å¿µå’Œä½¿ç”¨æ–¹æ³•ã€‚

## ğŸ“‹ æœ¬ç« å†…å®¹

- [ç»„ä»¶ç³»ç»Ÿæ¶æ„](#1-ç»„ä»¶ç³»ç»Ÿæ¶æ„) - ç†è§£ç»„ä»¶ç®¡ç†çš„æ ¸å¿ƒæœºåˆ¶
- [ä¸–ç•Œç³»ç»Ÿç®¡ç†](#2-ä¸–ç•Œç³»ç»Ÿ-worlds) - æŒæ¡å¤šä¸–ç•Œç®¡ç†å’Œé…ç½®
- [åœºæ™¯ç³»ç»Ÿè¯¦è§£](#3-åœºæ™¯ç³»ç»Ÿ-simplescene) - å­¦ä¹  3D åœºæ™¯çš„æ„å»ºå’Œç®¡ç†
- [ç›¸æœºç³»ç»Ÿæ§åˆ¶](#4-ç›¸æœºç³»ç»Ÿ-simplecamera) - æŒæ¡ç›¸æœºæ§åˆ¶å’Œè§†è§’ç®¡ç†
- [æ¸²æŸ“ç³»ç»Ÿä¼˜åŒ–](#5-æ¸²æŸ“ç³»ç»Ÿ-simplerenderer) - äº†è§£æ¸²æŸ“ç®¡çº¿å’Œæ€§èƒ½ä¼˜åŒ–
- [å†…å­˜ç®¡ç†ç­–ç•¥](#6-å†…å­˜ç®¡ç†å’Œæ€§èƒ½ä¼˜åŒ–) - å­¦ä¹ èµ„æºç®¡ç†å’Œæ€§èƒ½è°ƒä¼˜
- [è‡ªå®šä¹‰ç»„ä»¶å¼€å‘](#7-è‡ªå®šä¹‰ç»„ä»¶å¼€å‘) - åˆ›å»ºè‡ªå·±çš„ç»„ä»¶

## ğŸ¯ å­¦ä¹ ç›®æ ‡

é€šè¿‡æœ¬ç« å­¦ä¹ ï¼Œæ‚¨å°†èƒ½å¤Ÿï¼š

âœ… ç†è§£ç»„ä»¶ç³»ç»Ÿçš„è®¾è®¡æ¨¡å¼å’Œç”Ÿå‘½å‘¨æœŸç®¡ç†  
âœ… ç†Ÿç»ƒåˆ›å»ºå’Œé…ç½® 3D ä¸–ç•Œã€åœºæ™¯ã€ç›¸æœºå’Œæ¸²æŸ“å™¨  
âœ… æŒæ¡ç»„ä»¶é—´çš„é€šä¿¡å’Œäº‹ä»¶å¤„ç†æœºåˆ¶  
âœ… å®ç°é«˜æ•ˆçš„å†…å­˜ç®¡ç†å’Œæ€§èƒ½ä¼˜åŒ–  
âœ… å¼€å‘è‡ªå®šä¹‰ç»„ä»¶æ¥æ‰©å±•åŠŸèƒ½

## 1. ç»„ä»¶ç³»ç»Ÿæ¶æ„

### 1.1 Components ç±» - ç»„ä»¶ç®¡ç†å™¨

`Components` ç±»æ˜¯æ•´ä¸ª @thatopen/components åº“çš„æ ¸å¿ƒå…¥å£ç‚¹ï¼Œé‡‡ç”¨**ä¾èµ–æ³¨å…¥å®¹å™¨**çš„è®¾è®¡æ¨¡å¼ï¼Œè´Ÿè´£ç®¡ç†æ‰€æœ‰ç»„ä»¶çš„ç”Ÿå‘½å‘¨æœŸã€ä¾èµ–å…³ç³»å’Œé€šä¿¡æœºåˆ¶ã€‚

#### ğŸ—ï¸ è®¾è®¡ç†å¿µ

- **å•ä¸€èŒè´£**: ä¸“æ³¨äºç»„ä»¶çš„æ³¨å†Œã€åˆ›å»ºå’Œç”Ÿå‘½å‘¨æœŸç®¡ç†
- **ä¾èµ–æ³¨å…¥**: è‡ªåŠ¨è§£æç»„ä»¶é—´çš„ä¾èµ–å…³ç³»
- **ç±»å‹å®‰å…¨**: å®Œæ•´çš„ TypeScript ç±»å‹æ”¯æŒ
- **å†…å­˜å®‰å…¨**: è‡ªåŠ¨çš„èµ„æºæ¸…ç†å’Œå†…å­˜æ³„æ¼é˜²æŠ¤

#### ğŸ”§ æ ¸å¿ƒç‰¹æ€§

```typescript
interface ComponentsFeatures {
  // ç‰ˆæœ¬ç®¡ç†
  version: string;                    // å½“å‰ç‰ˆæœ¬ 2.4.11
  
  // ç»„ä»¶æ³¨å†Œè¡¨
  list: Map<string, Component>;       // å·²æ³¨å†Œçš„ç»„ä»¶å®ä¾‹
  
  // ç”Ÿå‘½å‘¨æœŸç®¡ç†
  enabled: boolean;                   // ç»„ä»¶ç³»ç»Ÿå¯ç”¨çŠ¶æ€
  onInit: Event<Components>;          // åˆå§‹åŒ–äº‹ä»¶
  onDisposed: Event<string>;          // é”€æ¯äº‹ä»¶
  
  // æ›´æ–°å¾ªç¯
  onBeforeUpdate: Event<Components>;  // æ›´æ–°å‰äº‹ä»¶
  onAfterUpdate: Event<Components>;   // æ›´æ–°åäº‹ä»¶
}
```

#### ğŸ“ åŸºç¡€ä½¿ç”¨

```typescript
import * as OBC from "@thatopen/components";

// 1. åˆ›å»ºç»„ä»¶ç®¡ç†å™¨å®ä¾‹
const components = new OBC.Components();

// 2. è·å–æˆ–åˆ›å»ºç»„ä»¶å®ä¾‹ï¼ˆè‡ªåŠ¨ä¾èµ–æ³¨å…¥ï¼‰
const worlds = components.get(OBC.Worlds);
const fragmentsManager = components.get(OBC.FragmentsManager);
const ifcLoader = components.get(OBC.IfcLoader);

// 3. æ‰‹åŠ¨æ·»åŠ ç»„ä»¶å®ä¾‹
const customComponent = new MyCustomComponent(components);
components.add("my-custom-component", customComponent);

// 4. åˆå§‹åŒ–ç»„ä»¶ç³»ç»Ÿ
components.init();

// 5. å¯åŠ¨æ›´æ–°å¾ªç¯ï¼ˆå¦‚æœéœ€è¦ï¼‰
const animate = () => {
  components.update(); // è§¦å‘æ‰€æœ‰å¯æ›´æ–°ç»„ä»¶çš„æ›´æ–°
  requestAnimationFrame(animate);
};
animate();
```

#### ğŸ”„ ç”Ÿå‘½å‘¨æœŸç®¡ç†

```typescript
// ç›‘å¬ç³»ç»Ÿåˆå§‹åŒ–
components.onInit.add((components) => {
  console.log('ç»„ä»¶ç³»ç»Ÿå·²åˆå§‹åŒ–');
  console.log(`å·²æ³¨å†Œç»„ä»¶æ•°é‡: ${components.list.size}`);
});

// ç›‘å¬ç»„ä»¶é”€æ¯
components.onDisposed.add((componentId) => {
  console.log(`ç»„ä»¶å·²é”€æ¯: ${componentId}`);
});

// ç›‘å¬æ›´æ–°å¾ªç¯
components.onBeforeUpdate.add(() => {
  // æ›´æ–°å‰çš„å‡†å¤‡å·¥ä½œ
});

components.onAfterUpdate.add(() => {
  // æ›´æ–°åçš„æ¸…ç†å·¥ä½œ
});

// é”€æ¯æ•´ä¸ªç»„ä»¶ç³»ç»Ÿ
window.addEventListener('beforeunload', () => {
  components.dispose(); // æ¸…ç†æ‰€æœ‰èµ„æº
});
```

#### ğŸ¯ é«˜çº§ç”¨æ³•

```typescript
// æ¡ä»¶æ€§ç»„ä»¶è·å–
const getComponentSafely = <T extends OBC.Component>(
  ComponentClass: new (components: OBC.Components) => T
): T | null => {
  try {
    return components.get(ComponentClass);
  } catch (error) {
    console.warn(`ç»„ä»¶è·å–å¤±è´¥: ${ComponentClass.name}`, error);
    return null;
  }
};

// ç»„ä»¶çŠ¶æ€æ£€æŸ¥
const checkComponentHealth = () => {
  const healthReport = {
    totalComponents: components.list.size,
    enabledComponents: 0,
    disabledComponents: 0,
    updateableComponents: 0
  };
  
  for (const [id, component] of components.list) {
    if (component.enabled) {
      healthReport.enabledComponents++;
    } else {
      healthReport.disabledComponents++;
    }
    
    if ('update' in component) {
      healthReport.updateableComponents++;
    }
  }
  
  return healthReport;
};

// æ‰¹é‡ç»„ä»¶æ“ä½œ
const batchComponentOperation = (operation: 'enable' | 'disable') => {
  for (const [id, component] of components.list) {
    if ('enabled' in component) {
      component.enabled = operation === 'enable';
    }
  }
};
```

### 1.2 ç»„ä»¶æ¥å£è®¾è®¡

@thatopen/components é‡‡ç”¨åŸºäºæ¥å£çš„ç»„ä»¶è®¾è®¡ï¼Œç¡®ä¿æ‰€æœ‰ç»„ä»¶éƒ½éµå¾ªç»Ÿä¸€çš„è§„èŒƒå’Œç”Ÿå‘½å‘¨æœŸç®¡ç†ã€‚

#### ğŸ”Œ æ ¸å¿ƒæ¥å£ä½“ç³»

```typescript
// åŸºç¡€ç»„ä»¶æ¥å£
interface Component {
  enabled: boolean;           // ç»„ä»¶å¯ç”¨çŠ¶æ€
  components: Components;     // ç»„ä»¶ç®¡ç†å™¨å¼•ç”¨
}

// å¯æ›´æ–°ç»„ä»¶æ¥å£
interface Updateable extends Component {
  onBeforeUpdate: Event<Component>;  // æ›´æ–°å‰äº‹ä»¶
  onAfterUpdate: Event<Component>;   // æ›´æ–°åäº‹ä»¶
  update(delta?: number): void;      // æ›´æ–°æ–¹æ³•
}

// å¯é”€æ¯ç»„ä»¶æ¥å£
interface Disposable extends Component {
  onDisposed: Event<string>;         // é”€æ¯äº‹ä»¶
  dispose(): void;                   // é”€æ¯æ–¹æ³•
}

// å¯é…ç½®ç»„ä»¶æ¥å£
interface Configurable<T = any> extends Component {
  config: T;                         // é…ç½®å¯¹è±¡
  setup(config?: Partial<T>): Promise<void> | void; // è®¾ç½®æ–¹æ³•
}

// å¯åˆ›å»ºç»„ä»¶æ¥å£
interface Createable extends Component {
  create(...args: any[]): any;       // åˆ›å»ºæ–¹æ³•
}

// å¯éšè—ç»„ä»¶æ¥å£
interface Hideable extends Component {
  visible: boolean;                  // å¯è§æ€§çŠ¶æ€
  setVisibility(visible: boolean): void; // è®¾ç½®å¯è§æ€§
}
```

#### ğŸ—ï¸ æ¥å£ç»„åˆæ¨¡å¼

å®é™…ç»„ä»¶é€šå¸¸å®ç°å¤šä¸ªæ¥å£çš„ç»„åˆï¼š

```typescript
// ç¤ºä¾‹ï¼šå®Œæ•´åŠŸèƒ½çš„æµ‹é‡å·¥å…·ç»„ä»¶
class LengthMeasurement implements 
  Component, 
  Updateable, 
  Disposable, 
  Createable, 
  Hideable {
  
  // Component æ¥å£å®ç°
  enabled: boolean = true;
  components: Components;
  
  // Updateable æ¥å£å®ç°
  onBeforeUpdate = new Event<Component>();
  onAfterUpdate = new Event<Component>();
  
  update(delta?: number): void {
    if (!this.enabled) return;
    
    this.onBeforeUpdate.trigger(this);
    // æ‰§è¡Œæ›´æ–°é€»è¾‘
    this.onAfterUpdate.trigger(this);
  }
  
  // Disposable æ¥å£å®ç°
  onDisposed = new Event<string>();
  
  dispose(): void {
    // æ¸…ç†èµ„æº
    this.onDisposed.trigger("LengthMeasurement");
  }
  
  // Createable æ¥å£å®ç°
  create(): MeasurementElement {
    // åˆ›å»ºæµ‹é‡å…ƒç´ 
    return new MeasurementElement();
  }
  
  // Hideable æ¥å£å®ç°
  visible: boolean = true;
  
  setVisibility(visible: boolean): void {
    this.visible = visible;
    // æ›´æ–°å¯è§æ€§
  }
  
  constructor(components: Components) {
    this.components = components;
  }
}
```

#### ğŸ¯ æ¥å£ä½¿ç”¨æœ€ä½³å®è·µ

```typescript
// 1. ç±»å‹å®‰å…¨çš„ç»„ä»¶æ£€æŸ¥
function isUpdateable(component: Component): component is Updateable {
  return 'update' in component && typeof component.update === 'function';
}

function isDisposable(component: Component): component is Disposable {
  return 'dispose' in component && typeof component.dispose === 'function';
}

// 2. é€šç”¨çš„ç»„ä»¶æ“ä½œå‡½æ•°
function updateAllComponents(components: Components, delta: number): void {
  for (const [id, component] of components.list) {
    if (component.enabled && isUpdateable(component)) {
      component.update(delta);
    }
  }
}

function disposeAllComponents(components: Components): void {
  for (const [id, component] of components.list) {
    if (isDisposable(component)) {
      component.dispose();
    }
  }
}

// 3. ç»„ä»¶çŠ¶æ€ç®¡ç†
class ComponentStateManager {
  private components: Components;
  
  constructor(components: Components) {
    this.components = components;
  }
  
  // æ‰¹é‡å¯ç”¨/ç¦ç”¨ç»„ä»¶
  setComponentsEnabled(enabled: boolean, filter?: (component: Component) => boolean): void {
    for (const [id, component] of this.components.list) {
      if (!filter || filter(component)) {
        component.enabled = enabled;
      }
    }
  }
  
  // è·å–ç‰¹å®šç±»å‹çš„ç»„ä»¶
  getComponentsByType<T extends Component>(predicate: (component: Component) => component is T): T[] {
    const result: T[] = [];
    for (const [id, component] of this.components.list) {
      if (predicate(component)) {
        result.push(component);
      }
    }
    return result;
  }
  
  // ç»„ä»¶æ€§èƒ½ç›‘æ§
  monitorPerformance(): ComponentPerformanceReport {
    const report: ComponentPerformanceReport = {
      totalComponents: this.components.list.size,
      activeComponents: 0,
      updateableComponents: 0,
      memoryUsage: 0
    };
    
    for (const [id, component] of this.components.list) {
      if (component.enabled) {
        report.activeComponents++;
      }
      if (isUpdateable(component)) {
        report.updateableComponents++;
      }
    }
    
    return report;
  }
}

interface ComponentPerformanceReport {
  totalComponents: number;
  activeComponents: number;
  updateableComponents: number;
  memoryUsage: number;
}
```

## 2. ä¸–ç•Œç³»ç»Ÿ (Worlds)

### 2.1 Worlds ç®¡ç†å™¨æ¦‚è¿°

`Worlds` ç±»æ˜¯ @thatopen/components çš„æ ¸å¿ƒç®¡ç†å™¨ï¼Œè´Ÿè´£åˆ›å»ºå’Œç®¡ç†å¤šä¸ªç‹¬ç«‹çš„ 3D ä¸–ç•Œå®ä¾‹ã€‚æ¯ä¸ªä¸–ç•Œéƒ½åŒ…å«å®Œæ•´çš„åœºæ™¯ã€ç›¸æœºå’Œæ¸²æŸ“å™¨ç»„åˆï¼Œæ”¯æŒå¤æ‚çš„å¤šè§†å£åº”ç”¨ã€‚

#### ğŸŒ æ ¸å¿ƒç‰¹æ€§

- **å¤šä¸–ç•Œç®¡ç†**ï¼šæ”¯æŒåŒæ—¶è¿è¡Œå¤šä¸ªç‹¬ç«‹çš„ 3D ä¸–ç•Œ
- **ç»„ä»¶è§£è€¦**ï¼šåœºæ™¯ã€ç›¸æœºã€æ¸²æŸ“å™¨å¯ç‹¬ç«‹é…ç½®
- **ç±»å‹å®‰å…¨**ï¼šå®Œæ•´çš„ TypeScript ç±»å‹æ”¯æŒ
- **ç”Ÿå‘½å‘¨æœŸç®¡ç†**ï¼šç»Ÿä¸€çš„åˆå§‹åŒ–å’Œé”€æ¯æµç¨‹
- **äº‹ä»¶é©±åŠ¨**ï¼šä¸°å¯Œçš„ä¸–ç•ŒçŠ¶æ€äº‹ä»¶

#### ğŸ—ï¸ åŸºç¡€ä½¿ç”¨

```typescript
import * as OBC from "@thatopen/components";

// è·å–ä¸–ç•Œç®¡ç†å™¨
const components = new OBC.Components();
const worlds = components.get(OBC.Worlds);

// åˆ›å»ºæ–°ä¸–ç•Œï¼ˆæŒ‡å®šç»„ä»¶ç±»å‹ï¼‰
const world = worlds.create<
  OBC.SimpleScene,
  OBC.SimpleCamera, 
  OBC.SimpleRenderer
>();

// é…ç½®ä¸–ç•Œç»„ä»¶
world.scene = new OBC.SimpleScene(components);
world.renderer = new OBC.SimpleRenderer(components, container);
world.camera = new OBC.SimpleCamera(components);

// åˆå§‹åŒ–ä¸–ç•Œ
await world.init();

// å¯åŠ¨æ¸²æŸ“å¾ªç¯
world.renderer.onBeforeUpdate.add(() => {
  // æ¸²æŸ“å‰å¤„ç†
});

world.renderer.onAfterUpdate.add(() => {
  // æ¸²æŸ“åå¤„ç†
});
```

#### ğŸ¯ é«˜çº§ä¸–ç•Œé…ç½®

```typescript
// 1. åˆ›å»ºå¤šä¸ªä¸–ç•Œå®ä¾‹
class MultiWorldManager {
  private components: OBC.Components;
  private worlds: Map<string, OBC.World> = new Map();
  
  constructor() {
    this.components = new OBC.Components();
  }
  
  // åˆ›å»ºä¸»è§†å£ä¸–ç•Œ
  async createMainWorld(container: HTMLElement): Promise<OBC.World> {
    const worlds = this.components.get(OBC.Worlds);
    const world = worlds.create<
      OBC.SimpleScene,
      OBC.OrthoPerspectiveCamera,
      OBC.PostproductionRenderer
    >();
    
    // é…ç½®é«˜çº§åœºæ™¯
    world.scene = new OBC.SimpleScene(this.components);
    world.scene.setup();
    
    // é…ç½®æ­£äº¤é€è§†ç›¸æœº
    world.camera = new OBC.OrthoPerspectiveCamera(this.components);
    world.camera.controls.setLookAt(10, 10, 10, 0, 0, 0);
    
    // é…ç½®åå¤„ç†æ¸²æŸ“å™¨
    world.renderer = new OBC.PostproductionRenderer(this.components, container);
    world.renderer.postproduction.enabled = true;
    
    await world.init();
    
    this.worlds.set('main', world);
    return world;
  }
  
  // åˆ›å»ºå°åœ°å›¾ä¸–ç•Œ
  async createMinimapWorld(container: HTMLElement): Promise<OBC.World> {
    const worlds = this.components.get(OBC.Worlds);
    const world = worlds.create<
      OBC.SimpleScene,
      OBC.OrthoPerspectiveCamera,
      OBC.SimpleRenderer
    >();
    
    // å…±äº«ä¸»ä¸–ç•Œçš„åœºæ™¯
    const mainWorld = this.worlds.get('main');
    if (mainWorld) {
      world.scene = mainWorld.scene;
    }
    
    // é…ç½®ä¿¯è§†ç›¸æœº
    world.camera = new OBC.OrthoPerspectiveCamera(this.components);
    world.camera.projection.current = "Orthographic";
    world.camera.controls.setLookAt(0, 50, 0, 0, 0, 0);
    
    // é…ç½®ç®€å•æ¸²æŸ“å™¨
    world.renderer = new OBC.SimpleRenderer(this.components, container);
    
    await world.init();
    
    this.worlds.set('minimap', world);
    return world;
  }
  
  // åŒæ­¥ä¸–ç•ŒçŠ¶æ€
  syncWorlds(): void {
    const mainWorld = this.worlds.get('main');
    const minimapWorld = this.worlds.get('minimap');
    
    if (mainWorld && minimapWorld) {
      // åŒæ­¥ç›¸æœºä½ç½®åˆ°å°åœ°å›¾
      const mainPosition = mainWorld.camera.controls.getPosition();
      minimapWorld.camera.controls.setLookAt(
        mainPosition.x, 50, mainPosition.z,
        mainPosition.x, 0, mainPosition.z
      );
    }
  }
  
  // é”€æ¯æ‰€æœ‰ä¸–ç•Œ
  dispose(): void {
    for (const [id, world] of this.worlds) {
      world.dispose();
    }
    this.worlds.clear();
  }
}
```

#### ğŸ”„ ä¸–ç•Œç”Ÿå‘½å‘¨æœŸç®¡ç†

```typescript
class WorldLifecycleManager {
  private world: OBC.World;
  private isInitialized: boolean = false;
  
  constructor(world: OBC.World) {
    this.world = world;
    this.setupEventListeners();
  }
  
  private setupEventListeners(): void {
    // ç›‘å¬ä¸–ç•Œåˆå§‹åŒ–
    this.world.onInitialized.add(() => {
      console.log('ä¸–ç•Œåˆå§‹åŒ–å®Œæˆ');
      this.isInitialized = true;
      this.onWorldReady();
    });
    
    // ç›‘å¬ä¸–ç•Œé”€æ¯
    this.world.onDisposed.add(() => {
      console.log('ä¸–ç•Œå·²é”€æ¯');
      this.isInitialized = false;
      this.onWorldDestroyed();
    });
    
    // ç›‘å¬æ¸²æŸ“å™¨æ›´æ–°
    if (this.world.renderer) {
      this.world.renderer.onBeforeUpdate.add((delta) => {
        this.onBeforeRender(delta);
      });
      
      this.world.renderer.onAfterUpdate.add((delta) => {
        this.onAfterRender(delta);
      });
    }
  }
  
  private onWorldReady(): void {
    // ä¸–ç•Œå‡†å¤‡å°±ç»ªåçš„åˆå§‹åŒ–é€»è¾‘
    this.setupLighting();
    this.setupGrid();
    this.setupControls();
  }
  
  private onWorldDestroyed(): void {
    // æ¸…ç†èµ„æº
    this.cleanup();
  }
  
  private onBeforeRender(delta?: number): void {
    // æ¸²æŸ“å‰æ›´æ–°é€»è¾‘
    if (this.isInitialized) {
      this.updateAnimations(delta);
      this.updateUI();
    }
  }
  
  private onAfterRender(delta?: number): void {
    // æ¸²æŸ“åå¤„ç†é€»è¾‘
    this.updatePerformanceMetrics(delta);
  }
  
  private setupLighting(): void {
    // è®¾ç½®å…‰ç…§
    const scene = this.world.scene.three;
    
    // ç¯å¢ƒå…‰
    const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
    scene.add(ambientLight);
    
    // æ–¹å‘å…‰
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(10, 10, 5);
    directionalLight.castShadow = true;
    scene.add(directionalLight);
  }
  
  private setupGrid(): void {
    // è®¾ç½®ç½‘æ ¼
    const grids = this.world.scene.three.getObjectByName('grids');
    if (!grids) {
      const gridHelper = new THREE.GridHelper(100, 100);
      gridHelper.name = 'grids';
      this.world.scene.three.add(gridHelper);
    }
  }
  
  private setupControls(): void {
    // é…ç½®ç›¸æœºæ§åˆ¶
    if (this.world.camera.controls) {
      this.world.camera.controls.enableDamping = true;
      this.world.camera.controls.dampingFactor = 0.05;
      this.world.camera.controls.enableZoom = true;
      this.world.camera.controls.enableRotate = true;
      this.world.camera.controls.enablePan = true;
    }
  }
  
  private updateAnimations(delta?: number): void {
    // æ›´æ–°åŠ¨ç”»
    // å®ç°è‡ªå®šä¹‰åŠ¨ç”»é€»è¾‘
  }
  
  private updateUI(): void {
    // æ›´æ–°UIçŠ¶æ€
    // å®ç°UIæ›´æ–°é€»è¾‘
  }
  
  private updatePerformanceMetrics(delta?: number): void {
    // æ›´æ–°æ€§èƒ½æŒ‡æ ‡
    // å®ç°æ€§èƒ½ç›‘æ§é€»è¾‘
  }
  
  private cleanup(): void {
    // æ¸…ç†èµ„æº
    // å®ç°èµ„æºæ¸…ç†é€»è¾‘
  }
}
```

### 2.2 World å®ä¾‹è¯¦è§£

æ¯ä¸ª World å®ä¾‹æ˜¯ä¸€ä¸ªå®Œæ•´çš„ 3D ç¯å¢ƒå®¹å™¨ï¼ŒåŒ…å«åœºæ™¯ã€ç›¸æœºå’Œæ¸²æŸ“å™¨ä¸‰ä¸ªæ ¸å¿ƒç»„ä»¶ã€‚

#### ğŸ›ï¸ World æ¥å£å®šä¹‰

```typescript
interface World<
  TScene extends BaseScene = BaseScene,
  TCamera extends BaseCamera = BaseCamera, 
  TRenderer extends BaseRenderer = BaseRenderer
> extends Component, Disposable {
  // æ ¸å¿ƒç»„ä»¶
  scene?: TScene;
  camera?: TCamera;
  renderer?: TRenderer;
  
  // ç”Ÿå‘½å‘¨æœŸæ–¹æ³•
  init(): Promise<void>;
  dispose(): void;
  
  // äº‹ä»¶
  onInitialized: Event<World>;
  onDisposed: Event<World>;
  
  // çŠ¶æ€å±æ€§
  isInitialized: boolean;
  uuid: string;
}
```

#### ğŸ”„ ä¸–ç•Œåˆå§‹åŒ–æµç¨‹

```typescript
// å®Œæ•´çš„ä¸–ç•Œåˆå§‹åŒ–ç¤ºä¾‹
class WorldInitializer {
  private components: OBC.Components;
  
  constructor() {
    this.components = new OBC.Components();
  }
  
  async createCompleteWorld(container: HTMLElement): Promise<OBC.World> {
    const worlds = this.components.get(OBC.Worlds);
    
    // 1. åˆ›å»ºä¸–ç•Œå®ä¾‹
    const world = worlds.create<
      OBC.SimpleScene,
      OBC.OrthoPerspectiveCamera,
      OBC.PostproductionRenderer
    >();
    
    // 2. é…ç½®åœºæ™¯ç»„ä»¶
    world.scene = new OBC.SimpleScene(this.components);
    await this.setupScene(world.scene);
    
    // 3. é…ç½®ç›¸æœºç»„ä»¶
    world.camera = new OBC.OrthoPerspectiveCamera(this.components);
    this.setupCamera(world.camera);
    
    // 4. é…ç½®æ¸²æŸ“å™¨ç»„ä»¶
    world.renderer = new OBC.PostproductionRenderer(this.components, container);
    await this.setupRenderer(world.renderer);
    
    // 5. åˆå§‹åŒ–ä¸–ç•Œ
    await world.init();
    
    // 6. å¯åŠ¨ç»„ä»¶ç³»ç»Ÿ
    this.components.init();
    
    return world;
  }
  
  private async setupScene(scene: OBC.SimpleScene): Promise<void> {
    // åœºæ™¯åŸºç¡€è®¾ç½®
    scene.setup();
    
    // æ·»åŠ ç¯å¢ƒå…‰
    const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
    scene.three.add(ambientLight);
    
    // æ·»åŠ æ–¹å‘å…‰
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(10, 10, 5);
    directionalLight.castShadow = true;
    scene.three.add(directionalLight);
    
    // æ·»åŠ ç½‘æ ¼
    const gridHelper = new THREE.GridHelper(100, 100, 0x888888, 0x444444);
    scene.three.add(gridHelper);
  }
  
  private setupCamera(camera: OBC.OrthoPerspectiveCamera): void {
    // è®¾ç½®ç›¸æœºä½ç½®
    camera.controls.setLookAt(10, 10, 10, 0, 0, 0);
    
    // é…ç½®æ§åˆ¶å™¨
    camera.controls.enableDamping = true;
    camera.controls.dampingFactor = 0.05;
    
    // è®¾ç½®æŠ•å½±æ¨¡å¼
    camera.projection.current = "Perspective";
    
    // é…ç½®é€è§†ç›¸æœºå‚æ•°
    if (camera.three instanceof THREE.PerspectiveCamera) {
      camera.three.fov = 75;
      camera.three.near = 0.1;
      camera.three.far = 1000;
    }
  }
  
  private async setupRenderer(renderer: OBC.PostproductionRenderer): Promise<void> {
    // åŸºç¡€æ¸²æŸ“è®¾ç½®
    renderer.three.shadowMap.enabled = true;
    renderer.three.shadowMap.type = THREE.PCFSoftShadowMap;
    
    // åå¤„ç†æ•ˆæœ
    renderer.postproduction.enabled = true;
    
    // æ·»åŠ è‡ªå®šä¹‰åå¤„ç†æ•ˆæœ
    const composer = renderer.postproduction.composer;
    
    // æŠ—é”¯é½¿
    const fxaaPass = new THREE.ShaderPass(THREE.FXAAShader);
    composer.addPass(fxaaPass);
    
    // è¾‰å…‰æ•ˆæœ
    const bloomPass = new THREE.UnrealBloomPass(
      new THREE.Vector2(window.innerWidth, window.innerHeight),
      1.5, 0.4, 0.85
    );
    composer.addPass(bloomPass);
  }
}
```

#### ğŸ® ä¸–ç•ŒçŠ¶æ€ç®¡ç†

```typescript
class WorldStateManager {
  private world: OBC.World;
  private state: WorldState;
  
  constructor(world: OBC.World) {
    this.world = world;
    this.state = {
      isActive: false,
      isPaused: false,
      renderMode: 'normal',
      performance: {
        fps: 0,
        frameTime: 0,
        memoryUsage: 0
      }
    };
    
    this.setupStateMonitoring();
  }
  
  private setupStateMonitoring(): void {
    // ç›‘å¬ä¸–ç•Œåˆå§‹åŒ–
    this.world.onInitialized.add(() => {
      this.state.isActive = true;
      this.startPerformanceMonitoring();
    });
    
    // ç›‘å¬ä¸–ç•Œé”€æ¯
    this.world.onDisposed.add(() => {
      this.state.isActive = false;
      this.stopPerformanceMonitoring();
    });
  }
  
  // æš‚åœ/æ¢å¤ä¸–ç•Œ
  setPaused(paused: boolean): void {
    this.state.isPaused = paused;
    
    if (this.world.renderer) {
      if (paused) {
        this.world.renderer.enabled = false;
      } else {
        this.world.renderer.enabled = true;
      }
    }
  }
  
  // è®¾ç½®æ¸²æŸ“æ¨¡å¼
  setRenderMode(mode: 'normal' | 'wireframe' | 'points'): void {
    this.state.renderMode = mode;
    
    if (this.world.scene) {
      this.world.scene.three.traverse((object) => {
        if (object instanceof THREE.Mesh) {
          switch (mode) {
            case 'wireframe':
              object.material.wireframe = true;
              break;
            case 'points':
              // è½¬æ¢ä¸ºç‚¹äº‘æ˜¾ç¤º
              break;
            default:
              object.material.wireframe = false;
              break;
          }
        }
      });
    }
  }
  
  // æ€§èƒ½ç›‘æ§
  private startPerformanceMonitoring(): void {
    const monitor = () => {
      if (!this.state.isActive) return;
      
      // è®¡ç®—FPS
      this.state.performance.fps = this.calculateFPS();
      
      // è®¡ç®—å¸§æ—¶é—´
      this.state.performance.frameTime = this.calculateFrameTime();
      
      // è®¡ç®—å†…å­˜ä½¿ç”¨
      this.state.performance.memoryUsage = this.calculateMemoryUsage();
      
      requestAnimationFrame(monitor);
    };
    
    monitor();
  }
  
  private stopPerformanceMonitoring(): void {
    // åœæ­¢æ€§èƒ½ç›‘æ§
  }
  
  private calculateFPS(): number {
    // FPSè®¡ç®—é€»è¾‘
    return 60; // ç¤ºä¾‹å€¼
  }
  
  private calculateFrameTime(): number {
    // å¸§æ—¶é—´è®¡ç®—é€»è¾‘
    return 16.67; // ç¤ºä¾‹å€¼
  }
  
  private calculateMemoryUsage(): number {
    // å†…å­˜ä½¿ç”¨è®¡ç®—é€»è¾‘
    return 0; // ç¤ºä¾‹å€¼
  }
  
  // è·å–ä¸–ç•ŒçŠ¶æ€
  getState(): WorldState {
    return { ...this.state };
  }
}

interface WorldState {
  isActive: boolean;
  isPaused: boolean;
  renderMode: 'normal' | 'wireframe' | 'points';
  performance: {
    fps: number;
    frameTime: number;
    memoryUsage: number;
  };
}
```

#### ç”Ÿå‘½å‘¨æœŸäº‹ä»¶

```typescript
// ç›‘å¬æ›´æ–°äº‹ä»¶
world.onBeforeUpdate.add(() => {
  // æ›´æ–°å‰çš„é€»è¾‘
});

world.onAfterUpdate.add(() => {
  // æ›´æ–°åçš„é€»è¾‘
});

// ç›‘å¬é”€æ¯äº‹ä»¶
world.onDisposed.add(() => {
  // æ¸…ç†èµ„æº
});
```

## 3. åœºæ™¯ç³»ç»Ÿ (Scenes)

### 3.1 åœºæ™¯ç³»ç»Ÿæ¦‚è¿°

åœºæ™¯ç³»ç»Ÿæ˜¯ 3D ä¸–ç•Œçš„æ ¸å¿ƒå®¹å™¨ï¼Œè´Ÿè´£ç®¡ç†æ‰€æœ‰ 3D å¯¹è±¡ã€å…‰ç…§ã€æè´¨å’Œç©ºé—´å…³ç³»ã€‚@thatopen/components æä¾›äº†å¤šç§åœºæ™¯å®ç°ä»¥æ»¡è¶³ä¸åŒçš„åº”ç”¨éœ€æ±‚ã€‚

#### ğŸ­ åœºæ™¯ç±»å‹

- **SimpleScene**: åŸºç¡€åœºæ™¯å®ç°ï¼Œé€‚ç”¨äºå¤§å¤šæ•°åº”ç”¨
- **AdvancedScene**: é«˜çº§åœºæ™¯ï¼Œæ”¯æŒå¤æ‚çš„æ¸²æŸ“ç‰¹æ€§
- **CustomScene**: è‡ªå®šä¹‰åœºæ™¯ï¼Œå¯æ‰©å±•ç‰¹å®šåŠŸèƒ½

### 3.2 SimpleScene è¯¦è§£

`SimpleScene` æ˜¯æœ€å¸¸ç”¨çš„åœºæ™¯å®ç°ï¼Œæä¾›äº†å®Œæ•´çš„åŸºç¡€ 3D åœºæ™¯åŠŸèƒ½å’Œæ™ºèƒ½çš„é»˜è®¤é…ç½®ã€‚

#### ğŸ”§ é»˜è®¤é…ç½®

```typescript
const defaultConfig: SimpleSceneConfig = {
  backgroundColor: new THREE.Color(0x202932),
  directionalLight: {
    color: new THREE.Color("white"),
    intensity: 1.5,
    position: new THREE.Vector3(5, 10, 3),
    castShadow: true
  },
  ambientLight: {
    color: new THREE.Color("white"),
    intensity: 0.3
  },
  fog: {
    enabled: false,
    color: new THREE.Color(0x202932),
    near: 50,
    far: 200
  }
};
```

#### ğŸ—ï¸ åŸºç¡€ä½¿ç”¨

```typescript
import * as OBC from "@thatopen/components";
import * as THREE from "three";

// åˆ›å»ºåœºæ™¯å®ä¾‹
const components = new OBC.Components();
const scene = new OBC.SimpleScene(components);

// ä½¿ç”¨é»˜è®¤é…ç½®åˆå§‹åŒ–
scene.setup();

// è‡ªå®šä¹‰é…ç½®åˆå§‹åŒ–
scene.setup({
  backgroundColor: new THREE.Color(0x87CEEB),
  directionalLight: {
    color: new THREE.Color("#ffffff"),
    intensity: 2.0,
    position: new THREE.Vector3(10, 15, 5),
    castShadow: true
  },
  ambientLight: {
    color: new THREE.Color("#404040"),
    intensity: 0.4
  },
  fog: {
    enabled: true,
    color: new THREE.Color(0x87CEEB),
    near: 100,
    far: 500
  }
});

// ç›‘å¬è®¾ç½®å®Œæˆäº‹ä»¶
scene.onSetup.add(() => {
  console.log('åœºæ™¯è®¾ç½®å®Œæˆ');
  // æ·»åŠ è‡ªå®šä¹‰å¯¹è±¡
  addSceneObjects();
});

function addSceneObjects(): void {
  // æ·»åŠ åŸºç¡€å‡ ä½•ä½“
  const geometry = new THREE.BoxGeometry(1, 1, 1);
  const material = new THREE.MeshStandardMaterial({ color: 0x00ff00 });
  const cube = new THREE.Mesh(geometry, material);
  cube.castShadow = true;
  cube.receiveShadow = true;
  scene.three.add(cube);
  
  // æ·»åŠ åœ°é¢
  const groundGeometry = new THREE.PlaneGeometry(20, 20);
  const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x808080 });
  const ground = new THREE.Mesh(groundGeometry, groundMaterial);
  ground.rotation.x = -Math.PI / 2;
  ground.receiveShadow = true;
  scene.three.add(ground);
}
```

#### ğŸ’¡ é«˜çº§ç¯å…‰ç®¡ç†

```typescript
class AdvancedLightingManager {
  private scene: OBC.SimpleScene;
  
  constructor(scene: OBC.SimpleScene) {
    this.scene = scene;
  }
  
  // è®¾ç½®ä¸“ä¸šç…§æ˜æ–¹æ¡ˆ
  setupProfessionalLighting(): void {
    // æ¸…é™¤é»˜è®¤ç¯å…‰
    this.scene.deleteAllLights();
    
    // ä¸»å…‰æº (Key Light)
    const keyLight = new THREE.DirectionalLight(0xffffff, 1.2);
    keyLight.position.set(10, 10, 5);
    keyLight.castShadow = true;
    keyLight.shadow.mapSize.width = 2048;
    keyLight.shadow.mapSize.height = 2048;
    keyLight.shadow.camera.near = 0.5;
    keyLight.shadow.camera.far = 50;
    this.scene.three.add(keyLight);
    
    // è¡¥å…‰ (Fill Light)
    const fillLight = new THREE.DirectionalLight(0x87CEEB, 0.4);
    fillLight.position.set(-5, 5, 2);
    this.scene.three.add(fillLight);
    
    // èƒŒæ™¯å…‰ (Back Light)
    const backLight = new THREE.DirectionalLight(0xffffff, 0.3);
    backLight.position.set(0, 5, -10);
    this.scene.three.add(backLight);
    
    // ç¯å¢ƒå…‰
    const ambientLight = new THREE.AmbientLight(0x404040, 0.2);
    this.scene.three.add(ambientLight);
    
    // å±€éƒ¨ç‚¹å…‰æº
    const pointLight = new THREE.PointLight(0xffffff, 0.8, 20);
    pointLight.position.set(5, 3, 5);
    pointLight.castShadow = true;
    this.scene.three.add(pointLight);
  }
  
  // è®¾ç½®å®¤å†…ç…§æ˜
  setupIndoorLighting(): void {
    this.scene.deleteAllLights();
    
    // å¤©èŠ±æ¿ç¯å…‰
    const ceilingLights = [
      { position: new THREE.Vector3(-5, 8, -5), intensity: 0.6 },
      { position: new THREE.Vector3(5, 8, -5), intensity: 0.6 },
      { position: new THREE.Vector3(-5, 8, 5), intensity: 0.6 },
      { position: new THREE.Vector3(5, 8, 5), intensity: 0.6 }
    ];
    
    ceilingLights.forEach((lightConfig, index) => {
      const light = new THREE.PointLight(0xffffff, lightConfig.intensity, 15);
      light.position.copy(lightConfig.position);
      light.castShadow = true;
      light.name = `ceiling-light-${index}`;
      this.scene.three.add(light);
    });
    
    // çª—æˆ·å…‰
    const windowLight = new THREE.DirectionalLight(0x87CEEB, 0.8);
    windowLight.position.set(15, 5, 0);
    windowLight.castShadow = true;
    this.scene.three.add(windowLight);
    
    // ç¯å¢ƒå…‰
    const ambientLight = new THREE.AmbientLight(0x404040, 0.3);
    this.scene.three.add(ambientLight);
  }
  
  // åŠ¨æ€è°ƒæ•´å…‰ç…§
  adjustLightingByTime(hour: number): void {
    const lights = this.scene.three.children.filter(child => child instanceof THREE.Light);
    
    // æ ¹æ®æ—¶é—´è°ƒæ•´å…‰ç…§å¼ºåº¦å’Œé¢œè‰²
    const timeOfDay = this.getTimeOfDay(hour);
    
    lights.forEach(light => {
      if (light instanceof THREE.DirectionalLight) {
        switch (timeOfDay) {
          case 'dawn':
            light.color.setHex(0xFFB366); // æ©™è‰²
            light.intensity = 0.6;
            break;
          case 'day':
            light.color.setHex(0xFFFFFF); // ç™½è‰²
            light.intensity = 1.0;
            break;
          case 'dusk':
            light.color.setHex(0xFF6B35); // çº¢æ©™è‰²
            light.intensity = 0.4;
            break;
          case 'night':
            light.color.setHex(0x4169E1); // è“è‰²
            light.intensity = 0.2;
            break;
        }
      }
    });
  }
  
  private getTimeOfDay(hour: number): 'dawn' | 'day' | 'dusk' | 'night' {
    if (hour >= 5 && hour < 8) return 'dawn';
    if (hour >= 8 && hour < 18) return 'day';
    if (hour >= 18 && hour < 21) return 'dusk';
    return 'night';
  }
}
```

#### ğŸ¨ åœºæ™¯é…ç½®ç®¡ç†

```typescript
class SceneConfigManager {
  private scene: OBC.SimpleScene;
  private originalConfig: any;
  
  constructor(scene: OBC.SimpleScene) {
    this.scene = scene;
    this.originalConfig = { ...scene.config };
  }
  
  // åŠ¨æ€ä¿®æ”¹èƒŒæ™¯
  setBackground(type: 'color' | 'gradient' | 'skybox', options: any): void {
    switch (type) {
      case 'color':
        this.scene.three.background = new THREE.Color(options.color);
        break;
        
      case 'gradient':
        const canvas = document.createElement('canvas');
        canvas.width = 512;
        canvas.height = 512;
        const context = canvas.getContext('2d')!;
        const gradient = context.createLinearGradient(0, 0, 0, 512);
        gradient.addColorStop(0, options.topColor);
        gradient.addColorStop(1, options.bottomColor);
        context.fillStyle = gradient;
        context.fillRect(0, 0, 512, 512);
        
        const texture = new THREE.CanvasTexture(canvas);
        this.scene.three.background = texture;
        break;
        
      case 'skybox':
        const loader = new THREE.CubeTextureLoader();
        const skyboxTexture = loader.load(options.urls);
        this.scene.three.background = skyboxTexture;
        break;
    }
  }
  
  // è®¾ç½®é›¾æ•ˆ
  setFog(enabled: boolean, options?: { color?: string; near?: number; far?: number }): void {
    if (enabled && options) {
      this.scene.three.fog = new THREE.Fog(
        new THREE.Color(options.color || 0x202932),
        options.near || 50,
        options.far || 200
      );
    } else {
      this.scene.three.fog = null;
    }
  }
  
  // ä¿å­˜é…ç½®
  saveConfig(name: string): void {
    const config = {
      backgroundColor: this.scene.config.backgroundColor.getHex(),
      directionalLight: {
        color: this.scene.config.directionalLight.color.getHex(),
        intensity: this.scene.config.directionalLight.intensity,
        position: this.scene.config.directionalLight.position.toArray()
      },
      ambientLight: {
        color: this.scene.config.ambientLight.color.getHex(),
        intensity: this.scene.config.ambientLight.intensity
      }
    };
    
    localStorage.setItem(`scene-config-${name}`, JSON.stringify(config));
  }
  
  // åŠ è½½é…ç½®
  loadConfig(name: string): boolean {
    const configStr = localStorage.getItem(`scene-config-${name}`);
    if (!configStr) return false;
    
    try {
      const config = JSON.parse(configStr);
      
      this.scene.config.backgroundColor.setHex(config.backgroundColor);
      this.scene.config.directionalLight.color.setHex(config.directionalLight.color);
      this.scene.config.directionalLight.intensity = config.directionalLight.intensity;
      this.scene.config.directionalLight.position.fromArray(config.directionalLight.position);
      this.scene.config.ambientLight.color.setHex(config.ambientLight.color);
      this.scene.config.ambientLight.intensity = config.ambientLight.intensity;
      
      // é‡æ–°åº”ç”¨é…ç½®
      this.scene.setup(this.scene.config);
      
      return true;
    } catch (error) {
      console.error('åŠ è½½åœºæ™¯é…ç½®å¤±è´¥:', error);
      return false;
    }
  }
  
  // é‡ç½®ä¸ºé»˜è®¤é…ç½®
  resetToDefault(): void {
    this.scene.setup(this.originalConfig);
  }
}

interface SimpleSceneConfig {
  backgroundColor: THREE.Color;
  directionalLight: {
    color: THREE.Color;
    intensity: number;
    position: THREE.Vector3;
    castShadow?: boolean;
  };
  ambientLight: {
    color: THREE.Color;
    intensity: number;
  };
  fog?: {
    enabled: boolean;
    color: THREE.Color;
    near: number;
    far: number;
  };
}
```

## 4. ç›¸æœºç³»ç»Ÿ (Cameras)

### 4.1 ç›¸æœºç³»ç»Ÿæ¦‚è¿°

ç›¸æœºç³»ç»Ÿè´Ÿè´£å®šä¹‰ 3D ä¸–ç•Œçš„è§‚å¯Ÿè§†è§’å’ŒæŠ•å½±æ–¹å¼ã€‚@thatopen/components æä¾›äº†å¤šç§ç›¸æœºå®ç°ï¼Œæ”¯æŒä¸åŒçš„æŠ•å½±æ¨¡å¼å’Œäº¤äº’æ–¹å¼ã€‚

#### ğŸ“· ç›¸æœºç±»å‹

- **SimpleCamera**: åŸºç¡€é€è§†ç›¸æœºï¼Œé€‚ç”¨äºä¸€èˆ¬ 3D åœºæ™¯
- **OrthoPerspectiveCamera**: æ”¯æŒæ­£äº¤å’Œé€è§†æŠ•å½±åˆ‡æ¢çš„ç›¸æœº
- **FirstPersonCamera**: ç¬¬ä¸€äººç§°è§†è§’ç›¸æœº
- **CustomCamera**: è‡ªå®šä¹‰ç›¸æœºå®ç°

### 4.2 SimpleCamera è¯¦è§£

`SimpleCamera` æä¾›åŸºç¡€çš„é€è§†ç›¸æœºåŠŸèƒ½ï¼Œé›†æˆäº†è½¨é“æ§åˆ¶å™¨ï¼Œé€‚ç”¨äºå¤§å¤šæ•° 3D åº”ç”¨åœºæ™¯ã€‚

#### ğŸ—ï¸ åŸºç¡€ä½¿ç”¨

```typescript
import * as OBC from "@thatopen/components";
import * as THREE from "three";

// åˆ›å»ºç›¸æœºå®ä¾‹
const components = new OBC.Components();
const camera = new OBC.SimpleCamera(components);

// è®¾ç½®ç›¸æœºä½ç½®å’Œç›®æ ‡
camera.controls.setLookAt(10, 10, 10, 0, 0, 0);

// è·å–ç›¸æœºæ§åˆ¶å™¨
const controls = camera.controls;

// é…ç½®ç›¸æœºå‚æ•°
camera.three.fov = 75;        // è§†é‡è§’åº¦
camera.three.near = 0.1;      // è¿‘è£å‰ªé¢
camera.three.far = 1000;      // è¿œè£å‰ªé¢
camera.three.updateProjectionMatrix();

// é…ç½®æ§åˆ¶å™¨
controls.enableDamping = true;      // å¯ç”¨é˜»å°¼
controls.dampingFactor = 0.05;      // é˜»å°¼ç³»æ•°
controls.enableZoom = true;         // å¯ç”¨ç¼©æ”¾
controls.enableRotate = true;       // å¯ç”¨æ—‹è½¬
controls.enablePan = true;          // å¯ç”¨å¹³ç§»

// è®¾ç½®ç¼©æ”¾é™åˆ¶
controls.minDistance = 1;
controls.maxDistance = 100;

// è®¾ç½®æ—‹è½¬é™åˆ¶
controls.minPolarAngle = 0;
controls.maxPolarAngle = Math.PI;
```

### 4.3 OrthoPerspectiveCamera è¯¦è§£

`OrthoPerspectiveCamera` æ”¯æŒåœ¨æ­£äº¤æŠ•å½±å’Œé€è§†æŠ•å½±ä¹‹é—´åŠ¨æ€åˆ‡æ¢ï¼Œé€‚ç”¨äºå»ºç­‘è®¾è®¡å’Œå·¥ç¨‹åº”ç”¨ã€‚

#### ğŸ”„ æŠ•å½±æ¨¡å¼åˆ‡æ¢

```typescript
class CameraProjectionManager {
  private camera: OBC.OrthoPerspectiveCamera;
  
  constructor(components: OBC.Components) {
    this.camera = new OBC.OrthoPerspectiveCamera(components);
    this.setupCamera();
  }
  
  private setupCamera(): void {
    // è®¾ç½®åˆå§‹ä½ç½®
    this.camera.controls.setLookAt(15, 15, 15, 0, 0, 0);
    
    // é…ç½®é€è§†ç›¸æœºå‚æ•°
    if (this.camera.three instanceof THREE.PerspectiveCamera) {
      this.camera.three.fov = 60;
      this.camera.three.near = 0.1;
      this.camera.three.far = 1000;
    }
    
    // é…ç½®æ­£äº¤ç›¸æœºå‚æ•°
    this.camera.projection.onChanged.add(() => {
      this.onProjectionChanged();
    });
  }
  
  // åˆ‡æ¢åˆ°é€è§†æŠ•å½±
  switchToPerspective(): void {
    this.camera.projection.current = "Perspective";
  }
  
  // åˆ‡æ¢åˆ°æ­£äº¤æŠ•å½±
  switchToOrthographic(): void {
    this.camera.projection.current = "Orthographic";
  }
  
  // æŠ•å½±æ¨¡å¼æ”¹å˜æ—¶çš„å›è°ƒ
  private onProjectionChanged(): void {
    const currentMode = this.camera.projection.current;
    console.log(`ç›¸æœºæŠ•å½±æ¨¡å¼åˆ‡æ¢åˆ°: ${currentMode}`);
    
    if (currentMode === "Orthographic") {
      // æ­£äº¤æ¨¡å¼ä¸‹çš„ç‰¹æ®Šè®¾ç½®
      this.setupOrthographicView();
    } else {
      // é€è§†æ¨¡å¼ä¸‹çš„ç‰¹æ®Šè®¾ç½®
      this.setupPerspectiveView();
    }
  }
  
  private setupOrthographicView(): void {
    // æ­£äº¤è§†å›¾çš„ç‰¹æ®Šé…ç½®
    this.camera.controls.enableRotate = false;
    this.camera.controls.enableZoom = true;
    this.camera.controls.enablePan = true;
  }
  
  private setupPerspectiveView(): void {
    // é€è§†è§†å›¾çš„ç‰¹æ®Šé…ç½®
    this.camera.controls.enableRotate = true;
    this.camera.controls.enableZoom = true;
    this.camera.controls.enablePan = true;
  }
  
  // è®¾ç½®é¢„å®šä¹‰è§†è§’
  setPresetView(view: 'front' | 'back' | 'left' | 'right' | 'top' | 'bottom' | 'isometric'): void {
    const distance = 20;
    
    switch (view) {
      case 'front':
        this.camera.controls.setLookAt(0, 0, distance, 0, 0, 0);
        break;
      case 'back':
        this.camera.controls.setLookAt(0, 0, -distance, 0, 0, 0);
        break;
      case 'left':
        this.camera.controls.setLookAt(-distance, 0, 0, 0, 0, 0);
        break;
      case 'right':
        this.camera.controls.setLookAt(distance, 0, 0, 0, 0, 0);
        break;
      case 'top':
        this.camera.controls.setLookAt(0, distance, 0, 0, 0, 0);
        break;
      case 'bottom':
        this.camera.controls.setLookAt(0, -distance, 0, 0, 0, 0);
        break;
      case 'isometric':
        this.camera.controls.setLookAt(distance, distance, distance, 0, 0, 0);
        break;
    }
  }
  
  // è·å–ç›¸æœºçŠ¶æ€
  getCameraState(): CameraState {
    const position = this.camera.controls.getPosition();
    const target = this.camera.controls.getTarget();
    
    return {
      position: position.toArray(),
      target: target.toArray(),
      projection: this.camera.projection.current,
      zoom: this.camera.controls.getDistance()
    };
  }
  
  // æ¢å¤ç›¸æœºçŠ¶æ€
  setCameraState(state: CameraState): void {
    this.camera.projection.current = state.projection;
    this.camera.controls.setLookAt(
      state.position[0], state.position[1], state.position[2],
      state.target[0], state.target[1], state.target[2]
    );
  }
}

interface CameraState {
  position: [number, number, number];
  target: [number, number, number];
  projection: "Perspective" | "Orthographic";
  zoom: number;
}
```

#### ğŸ® é«˜çº§ç›¸æœºæ§åˆ¶

```typescript
class AdvancedCameraController {
  private camera: OBC.OrthoPerspectiveCamera;
  private animationId: number | null = null;
  
  constructor(camera: OBC.OrthoPerspectiveCamera) {
    this.camera = camera;
  }
  
  // å¹³æ»‘åŠ¨ç”»åˆ°ç›®æ ‡ä½ç½®
  animateToPosition(
    targetPosition: THREE.Vector3,
    targetLookAt: THREE.Vector3,
    duration: number = 1000
  ): Promise<void> {
    return new Promise((resolve) => {
      const startPosition = this.camera.controls.getPosition().clone();
      const startLookAt = this.camera.controls.getTarget().clone();
      const startTime = Date.now();
      
      const animate = () => {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);
        
        // ä½¿ç”¨ç¼“åŠ¨å‡½æ•°
        const easeProgress = this.easeInOutCubic(progress);
        
        // æ’å€¼è®¡ç®—å½“å‰ä½ç½®
        const currentPosition = startPosition.clone().lerp(targetPosition, easeProgress);
        const currentLookAt = startLookAt.clone().lerp(targetLookAt, easeProgress);
        
        // æ›´æ–°ç›¸æœºä½ç½®
        this.camera.controls.setLookAt(
          currentPosition.x, currentPosition.y, currentPosition.z,
          currentLookAt.x, currentLookAt.y, currentLookAt.z
        );
        
        if (progress < 1) {
          this.animationId = requestAnimationFrame(animate);
        } else {
          this.animationId = null;
          resolve();
        }
      };
      
      animate();
    });
  }
  
  // åœæ­¢åŠ¨ç”»
  stopAnimation(): void {
    if (this.animationId) {
      cancelAnimationFrame(this.animationId);
      this.animationId = null;
    }
  }
  
  // ç¼“åŠ¨å‡½æ•°
  private easeInOutCubic(t: number): number {
    return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
  }
  
  // èšç„¦åˆ°å¯¹è±¡
  focusOnObject(object: THREE.Object3D, offset: number = 5): Promise<void> {
    const box = new THREE.Box3().setFromObject(object);
    const center = box.getCenter(new THREE.Vector3());
    const size = box.getSize(new THREE.Vector3());
    
    // è®¡ç®—åˆé€‚çš„ç›¸æœºè·ç¦»
    const maxDim = Math.max(size.x, size.y, size.z);
    const distance = maxDim * 2 + offset;
    
    // è®¡ç®—ç›¸æœºä½ç½®ï¼ˆä¿æŒå½“å‰è§’åº¦ï¼‰
    const currentPosition = this.camera.controls.getPosition();
    const currentTarget = this.camera.controls.getTarget();
    const direction = currentPosition.clone().sub(currentTarget).normalize();
    const newPosition = center.clone().add(direction.multiplyScalar(distance));
    
    return this.animateToPosition(newPosition, center);
  }
  
  // ç¯ç»•å¯¹è±¡
  orbitAroundObject(
    center: THREE.Vector3,
    radius: number,
    speed: number = 0.01
  ): void {
    let angle = 0;
    
    const orbit = () => {
      if (this.animationId === null) return;
      
      angle += speed;
      const x = center.x + radius * Math.cos(angle);
      const z = center.z + radius * Math.sin(angle);
      const y = center.y + radius * 0.3; // ç¨å¾®æŠ¬é«˜è§†è§’
      
      this.camera.controls.setLookAt(x, y, z, center.x, center.y, center.z);
      
      this.animationId = requestAnimationFrame(orbit);
    };
    
    this.animationId = requestAnimationFrame(orbit);
  }
  
  // ç¬¬ä¸€äººç§°æ¼«æ¸¸
  enableFirstPersonMode(): void {
    const controls = this.camera.controls;
    
    // ç¦ç”¨é»˜è®¤æ§åˆ¶
    controls.enabled = false;
    
    // å®ç°ç¬¬ä¸€äººç§°æ§åˆ¶é€»è¾‘
    this.setupFirstPersonControls();
  }
  
  private setupFirstPersonControls(): void {
    const moveSpeed = 0.1;
    const lookSpeed = 0.002;
    
    const keys = {
      forward: false,
      backward: false,
      left: false,
      right: false
    };
    
    // é”®ç›˜äº‹ä»¶
    document.addEventListener('keydown', (event) => {
      switch (event.code) {
        case 'KeyW': keys.forward = true; break;
        case 'KeyS': keys.backward = true; break;
        case 'KeyA': keys.left = true; break;
        case 'KeyD': keys.right = true; break;
      }
    });
    
    document.addEventListener('keyup', (event) => {
      switch (event.code) {
        case 'KeyW': keys.forward = false; break;
        case 'KeyS': keys.backward = false; break;
        case 'KeyA': keys.left = false; break;
        case 'KeyD': keys.right = false; break;
      }
    });
    
    // é¼ æ ‡äº‹ä»¶
    let isMouseDown = false;
    let mouseX = 0;
    let mouseY = 0;
    
    document.addEventListener('mousedown', () => {
      isMouseDown = true;
    });
    
    document.addEventListener('mouseup', () => {
      isMouseDown = false;
    });
    
    document.addEventListener('mousemove', (event) => {
      if (!isMouseDown) return;
      
      const deltaX = event.clientX - mouseX;
      const deltaY = event.clientY - mouseY;
      
      // å®ç°é¼ æ ‡çœ‹å‘é€»è¾‘
      this.updateFirstPersonLook(deltaX * lookSpeed, deltaY * lookSpeed);
      
      mouseX = event.clientX;
      mouseY = event.clientY;
    });
    
    // ç§»åŠ¨æ›´æ–°å¾ªç¯
    const updateMovement = () => {
      this.updateFirstPersonMovement(keys, moveSpeed);
      requestAnimationFrame(updateMovement);
    };
    
    updateMovement();
  }
  
  private updateFirstPersonLook(deltaX: number, deltaY: number): void {
    // å®ç°ç¬¬ä¸€äººç§°è§†è§’æ—‹è½¬é€»è¾‘
    // è¿™é‡Œéœ€è¦æ ¹æ®å…·ä½“éœ€æ±‚å®ç°
  }
  
  private updateFirstPersonMovement(keys: any, speed: number): void {
    // å®ç°ç¬¬ä¸€äººç§°ç§»åŠ¨é€»è¾‘
    // è¿™é‡Œéœ€è¦æ ¹æ®å…·ä½“éœ€æ±‚å®ç°
  }
}
```

### 4.2 OrthoPerspectiveCamera ç±»

æ”¯æŒæ­£äº¤å’Œé€è§†æŠ•å½±åˆ‡æ¢çš„é«˜çº§ç›¸æœºï¼š

```typescript
// åˆ›å»ºæ­£äº¤é€è§†ç›¸æœº
const camera = new OrthoPerspectiveCamera(components);

// åˆ‡æ¢æŠ•å½±æ¨¡å¼
camera.setProjection("Orthographic");
camera.setProjection("Perspective");

// ç›‘å¬æŠ•å½±å˜åŒ–
camera.onProjectionChanged.add((projection) => {
  console.log(`æŠ•å½±æ¨¡å¼åˆ‡æ¢ä¸º: ${projection}`);
});
```

## 5. æ¸²æŸ“ç³»ç»Ÿ (Renderers)

### 5.1 æ¸²æŸ“ç³»ç»Ÿæ¦‚è¿°

æ¸²æŸ“ç³»ç»Ÿè´Ÿè´£å°† 3D åœºæ™¯è½¬æ¢ä¸º 2D å›¾åƒè¾“å‡ºåˆ°å±å¹•ã€‚@thatopen/components æä¾›äº†é«˜æ€§èƒ½çš„ WebGL æ¸²æŸ“å™¨ï¼Œæ”¯æŒç°ä»£æ¸²æŸ“æŠ€æœ¯å’Œåå¤„ç†æ•ˆæœã€‚

#### ğŸ¨ æ¸²æŸ“å™¨ç‰¹æ€§

- **é«˜æ€§èƒ½ WebGL æ¸²æŸ“**: åŸºäº Three.js çš„ä¼˜åŒ–æ¸²æŸ“ç®¡é“
- **é˜´å½±ç³»ç»Ÿ**: æ”¯æŒå¤šç§é˜´å½±æ˜ å°„æŠ€æœ¯
- **åå¤„ç†æ•ˆæœ**: å†…ç½®å¤šç§è§†è§‰æ•ˆæœ
- **è‡ªé€‚åº”æ¸²æŸ“**: æ ¹æ®è®¾å¤‡æ€§èƒ½è‡ªåŠ¨è°ƒæ•´æ¸²æŸ“è´¨é‡
- **å¤šè§†å£æ”¯æŒ**: æ”¯æŒåˆ†å±å’Œå¤šçª—å£æ¸²æŸ“

### 5.2 SimpleRenderer è¯¦è§£

`SimpleRenderer` æä¾›å®Œæ•´çš„ WebGL æ¸²æŸ“åŠŸèƒ½ï¼Œé›†æˆäº†é˜´å½±ã€åå¤„ç†å’Œæ€§èƒ½ä¼˜åŒ–ã€‚

#### ğŸ—ï¸ åŸºç¡€è®¾ç½®

```typescript
import * as OBC from "@thatopen/components";
import * as THREE from "three";

// åˆ›å»ºæ¸²æŸ“å™¨å®ä¾‹
const components = new OBC.Components();
const container = document.getElementById('container')!;
const renderer = new OBC.SimpleRenderer(components, container);

// åŸºç¡€é…ç½®
renderer.three.setPixelRatio(window.devicePixelRatio);
renderer.three.setClearColor(0xf0f0f0, 1.0);
renderer.three.setSize(container.clientWidth, container.clientHeight);

// å¯ç”¨é˜´å½±
renderer.three.shadowMap.enabled = true;
renderer.three.shadowMap.type = THREE.PCFSoftShadowMap;
renderer.three.shadowMap.autoUpdate = true;

// è®¾ç½®è‰²è°ƒæ˜ å°„
renderer.three.toneMapping = THREE.ACESFilmicToneMapping;
renderer.three.toneMappingExposure = 1.0;

// å¯ç”¨ç‰©ç†æ­£ç¡®çš„å…‰ç…§
renderer.three.physicallyCorrectLights = true;

// è‡ªåŠ¨è°ƒæ•´å¤§å°
window.addEventListener('resize', () => {
  renderer.resize();
});
```

#### ğŸŒŸ é«˜çº§æ¸²æŸ“é…ç½®

```typescript
class AdvancedRenderingManager {
  private renderer: OBC.SimpleRenderer;
  private performanceMonitor: PerformanceMonitor;
  
  constructor(components: OBC.Components, container: HTMLElement) {
    this.renderer = new OBC.SimpleRenderer(components, container);
    this.performanceMonitor = new PerformanceMonitor();
    this.setupAdvancedRendering();
  }
  
  private setupAdvancedRendering(): void {
    // é…ç½®æ¸²æŸ“å™¨
    this.configureRenderer();
    
    // é…ç½®é˜´å½±
    this.configureShadows();
    
    // æ€§èƒ½ç›‘æ§
    this.setupPerformanceMonitoring();
  }
  
  private configureRenderer(): void {
    const renderer = this.renderer.three;
    
    // é«˜è´¨é‡æ¸²æŸ“è®¾ç½®
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.outputEncoding = THREE.sRGBEncoding;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.2;
    
    // æŠ—é”¯é½¿
    renderer.antialias = true;
    
    // å¯ç”¨ç‰©ç†æ­£ç¡®çš„å…‰ç…§
    renderer.physicallyCorrectLights = true;
    
    // è®¾ç½®æ¸…é™¤é¢œè‰²
    renderer.setClearColor(0x263238, 1.0);
    
    // å¯ç”¨æ·±åº¦æµ‹è¯•å’Œå†™å…¥
    renderer.sortObjects = true;
    renderer.autoClear = true;
    renderer.autoClearColor = true;
    renderer.autoClearDepth = true;
    renderer.autoClearStencil = true;
  }
  
  private configureShadows(): void {
    const renderer = this.renderer.three;
    
    // å¯ç”¨é˜´å½±
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.shadowMap.autoUpdate = true;
    
    // è®¾ç½®é˜´å½±çº§è”
    this.setupCascadedShadows();
  }
  
  private setupCascadedShadows(): void {
    // ä¸ºä¸åŒè·ç¦»çš„å¯¹è±¡è®¾ç½®ä¸åŒè´¨é‡çš„é˜´å½±
    const shadowConfigs = [
      { distance: 50, mapSize: 2048, bias: -0.0001 },
      { distance: 100, mapSize: 1024, bias: -0.0005 },
      { distance: 200, mapSize: 512, bias: -0.001 }
    ];
    
    // è¿™é‡Œå¯ä»¥æ ¹æ®å¯¹è±¡è·ç¦»ç›¸æœºçš„è¿œè¿‘æ¥åŠ¨æ€è°ƒæ•´é˜´å½±è´¨é‡
    // å…·ä½“å®ç°éœ€è¦åœ¨æ¸²æŸ“å¾ªç¯ä¸­è¿›è¡Œ
  }
  
  private setupPerformanceMonitoring(): void {
    this.performanceMonitor.onFPSChange.add((fps) => {
      this.adjustRenderQuality(fps);
    });
    
    this.performanceMonitor.start();
  }
  
  private adjustRenderQuality(fps: number): void {
    const renderer = this.renderer.three;
    
    if (fps < 30) {
      // é™ä½æ¸²æŸ“è´¨é‡
      renderer.setPixelRatio(Math.min(window.devicePixelRatio * 0.5, 1));
      renderer.shadowMap.enabled = false;
    } else if (fps > 50) {
      // æé«˜æ¸²æŸ“è´¨é‡
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.shadowMap.enabled = true;
    }
  }
  
  // è®¾ç½®æ¸²æŸ“æ¨¡å¼
  setRenderMode(mode: 'realistic' | 'wireframe' | 'normals' | 'depth'): void {
    switch (mode) {
      case 'realistic':
        this.setRealisticMode();
        break;
      case 'wireframe':
        this.setWireframeMode();
        break;
      case 'normals':
        this.setNormalsMode();
        break;
      case 'depth':
        this.setDepthMode();
        break;
    }
  }
  
  private setRealisticMode(): void {
    // æ¢å¤æ­£å¸¸æè´¨
    this.traverseAndSetMaterial((material: THREE.Material) => {
      material.wireframe = false;
      if (material instanceof THREE.MeshStandardMaterial) {
        material.needsUpdate = true;
      }
    });
  }
  
  private setWireframeMode(): void {
    // è®¾ç½®çº¿æ¡†æ¨¡å¼
    this.traverseAndSetMaterial((material: THREE.Material) => {
      material.wireframe = true;
    });
  }
  
  private setNormalsMode(): void {
    // æ˜¾ç¤ºæ³•çº¿
    const normalMaterial = new THREE.MeshNormalMaterial();
    this.traverseAndSetMaterial(() => normalMaterial);
  }
  
  private setDepthMode(): void {
    // æ˜¾ç¤ºæ·±åº¦
    const depthMaterial = new THREE.MeshDepthMaterial();
    this.traverseAndSetMaterial(() => depthMaterial);
  }
  
  private traverseAndSetMaterial(
    callback: (material: THREE.Material) => THREE.Material | void
  ): void {
    // éå†åœºæ™¯ä¸­çš„æ‰€æœ‰å¯¹è±¡å¹¶åº”ç”¨æè´¨å˜æ›´
    // è¿™é‡Œéœ€è¦è®¿é—®åœºæ™¯å¯¹è±¡ï¼Œå…·ä½“å®ç°å–å†³äºåº”ç”¨æ¶æ„
  }
  
  // æˆªå›¾åŠŸèƒ½
  captureScreenshot(width?: number, height?: number): string {
    const renderer = this.renderer.three;
    const originalSize = renderer.getSize(new THREE.Vector2());
    
    if (width && height) {
      renderer.setSize(width, height);
    }
    
    const dataURL = renderer.domElement.toDataURL('image/png');
    
    // æ¢å¤åŸå§‹å°ºå¯¸
    if (width && height) {
      renderer.setSize(originalSize.x, originalSize.y);
    }
    
    return dataURL;
  }
  
  // è·å–æ¸²æŸ“ç»Ÿè®¡ä¿¡æ¯
  getRenderStats(): RenderStats {
    const renderer = this.renderer.three;
    const info = renderer.info;
    
    return {
      triangles: info.render.triangles,
      points: info.render.points,
      lines: info.render.lines,
      calls: info.render.calls,
      geometries: info.memory.geometries,
      textures: info.memory.textures,
      programs: info.programs?.length || 0
    };
  }
  
  // é”€æ¯æ¸²æŸ“å™¨
  dispose(): void {
    this.renderer.dispose();
    this.performanceMonitor.stop();
  }
}

interface RenderStats {
  triangles: number;
  points: number;
  lines: number;
  calls: number;
  geometries: number;
  textures: number;
  programs: number;
}

class PerformanceMonitor {
  private frameCount = 0;
  private lastTime = performance.now();
  private fps = 60;
  private animationId: number | null = null;
  
  public onFPSChange = new Set<(fps: number) => void>();
  
  start(): void {
    const monitor = () => {
      this.frameCount++;
      const currentTime = performance.now();
      
      if (currentTime - this.lastTime >= 1000) {
        this.fps = Math.round((this.frameCount * 1000) / (currentTime - this.lastTime));
        this.frameCount = 0;
        this.lastTime = currentTime;
        
        // é€šçŸ¥ FPS å˜åŒ–
        this.onFPSChange.forEach(callback => callback(this.fps));
      }
      
      this.animationId = requestAnimationFrame(monitor);
    };
    
    monitor();
  }
  
  stop(): void {
    if (this.animationId) {
      cancelAnimationFrame(this.animationId);
      this.animationId = null;
    }
  }
  
  getCurrentFPS(): number {
    return this.fps;
  }
}
```

### 5.3 PostproductionRenderer è¯¦è§£

`PostproductionRenderer` æä¾›äº†ä¸°å¯Œçš„åå¤„ç†æ•ˆæœï¼Œå¯ä»¥æ˜¾è‘—æå‡æ¸²æŸ“è´¨é‡ã€‚

#### ğŸ­ åå¤„ç†æ•ˆæœé…ç½®

```typescript
class PostProcessingManager {
  private renderer: OBC.PostproductionRenderer;
  
  constructor(components: OBC.Components, container: HTMLElement) {
    this.renderer = new OBC.PostproductionRenderer(components, container);
    this.setupEffects();
  }
  
  private setupEffects(): void {
    // å¯ç”¨åå¤„ç†
    this.renderer.postproduction.enabled = true;
    
    // é…ç½®å†…ç½®æ•ˆæœ
    this.configureBuiltInEffects();
    
    // æ·»åŠ è‡ªå®šä¹‰æ•ˆæœ
    this.addCustomEffects();
  }
  
  private configureBuiltInEffects(): void {
    const postproduction = this.renderer.postproduction;
    
    // é…ç½®è‡ªå®šä¹‰æ•ˆæœ
    if (postproduction.customEffects) {
      // æ’é™¤æŸäº›ç½‘æ ¼ä¸å‚ä¸åå¤„ç†
      postproduction.customEffects.excludedMeshes.add('background');
      postproduction.customEffects.excludedMeshes.add('skybox');
    }
  }
  
  private addCustomEffects(): void {
    const composer = this.renderer.postproduction.composer;
    
    // æ·»åŠ  FXAA æŠ—é”¯é½¿
    const fxaaPass = this.createFXAAPass();
    composer.addPass(fxaaPass);
    
    // æ·»åŠ è¾‰å…‰æ•ˆæœ
    const bloomPass = this.createBloomPass();
    composer.addPass(bloomPass);
    
    // æ·»åŠ è‰²å½©åˆ†çº§
    const colorGradingPass = this.createColorGradingPass();
    composer.addPass(colorGradingPass);
  }
  
  private createFXAAPass(): THREE.ShaderPass {
    const fxaaPass = new THREE.ShaderPass(THREE.FXAAShader);
    fxaaPass.material.uniforms['resolution'].value.x = 1 / window.innerWidth;
    fxaaPass.material.uniforms['resolution'].value.y = 1 / window.innerHeight;
    return fxaaPass;
  }
  
  private createBloomPass(): THREE.UnrealBloomPass {
    const bloomPass = new THREE.UnrealBloomPass(
      new THREE.Vector2(window.innerWidth, window.innerHeight),
      1.5,  // strength
      0.4,  // radius
      0.85  // threshold
    );
    
    return bloomPass;
  }
  
  private createColorGradingPass(): THREE.ShaderPass {
    const colorGradingShader = {
      uniforms: {
        'tDiffuse': { value: null },
        'brightness': { value: 0.0 },
        'contrast': { value: 1.0 },
        'saturation': { value: 1.0 }
      },
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform float brightness;
        uniform float contrast;
        uniform float saturation;
        varying vec2 vUv;
        
        void main() {
          vec4 color = texture2D(tDiffuse, vUv);
          
          // äº®åº¦è°ƒæ•´
          color.rgb += brightness;
          
          // å¯¹æ¯”åº¦è°ƒæ•´
          color.rgb = (color.rgb - 0.5) * contrast + 0.5;
          
          // é¥±å’Œåº¦è°ƒæ•´
          float gray = dot(color.rgb, vec3(0.299, 0.587, 0.114));
          color.rgb = mix(vec3(gray), color.rgb, saturation);
          
          gl_FragColor = color;
        }
      `
    };
    
    return new THREE.ShaderPass(colorGradingShader);
  }
  
  // åŠ¨æ€è°ƒæ•´æ•ˆæœå¼ºåº¦
  adjustEffectIntensity(effectName: string, intensity: number): void {
    const composer = this.renderer.postproduction.composer;
    
    composer.passes.forEach(pass => {
      if (pass.name === effectName) {
        if ('strength' in pass) {
          (pass as any).strength = intensity;
        }
      }
    });
  }
  
  // åˆ‡æ¢æ•ˆæœå¼€å…³
  toggleEffect(effectName: string, enabled: boolean): void {
    const composer = this.renderer.postproduction.composer;
    
    composer.passes.forEach(pass => {
      if (pass.name === effectName) {
        pass.enabled = enabled;
      }
    });
  }
  
  // é¢„è®¾æ•ˆæœé…ç½®
  applyPreset(preset: 'realistic' | 'cinematic' | 'cartoon' | 'noir'): void {
    switch (preset) {
      case 'realistic':
        this.applyRealisticPreset();
        break;
      case 'cinematic':
        this.applyCinematicPreset();
        break;
      case 'cartoon':
        this.applyCartoonPreset();
        break;
      case 'noir':
        this.applyNoirPreset();
        break;
    }
  }
  
  private applyRealisticPreset(): void {
    // ç°å®ä¸»ä¹‰é£æ ¼è®¾ç½®
    this.adjustEffectIntensity('bloom', 0.3);
    this.adjustColorGrading(0.0, 1.0, 1.0); // äº®åº¦, å¯¹æ¯”åº¦, é¥±å’Œåº¦
  }
  
  private applyCinematicPreset(): void {
    // ç”µå½±é£æ ¼è®¾ç½®
    this.adjustEffectIntensity('bloom', 0.8);
    this.adjustColorGrading(-0.1, 1.2, 0.9);
  }
  
  private applyCartoonPreset(): void {
    // å¡é€šé£æ ¼è®¾ç½®
    this.adjustEffectIntensity('bloom', 1.2);
    this.adjustColorGrading(0.1, 1.3, 1.2);
  }
  
  private applyNoirPreset(): void {
    // é»‘ç™½é£æ ¼è®¾ç½®
    this.adjustEffectIntensity('bloom', 0.5);
    this.adjustColorGrading(-0.2, 1.5, 0.0);
  }
  
  private adjustColorGrading(brightness: number, contrast: number, saturation: number): void {
    const composer = this.renderer.postproduction.composer;
    
    composer.passes.forEach(pass => {
      if (pass.name === 'colorGrading') {
        const material = (pass as THREE.ShaderPass).material;
        material.uniforms['brightness'].value = brightness;
        material.uniforms['contrast'].value = contrast;
        material.uniforms['saturation'].value = saturation;
      }
    });
  }
}
```

## 6. å®Œæ•´ç¤ºä¾‹

ä»¥ä¸‹æ˜¯ä¸€ä¸ªå®Œæ•´çš„ä¸–ç•Œåˆ›å»ºå’Œé…ç½®ç¤ºä¾‹ï¼š

```typescript
import * as THREE from "three";
import * as OBC from "@thatopen/components";

// åˆ›å»ºç»„ä»¶ç³»ç»Ÿ
const components = new OBC.Components();

// è·å–ä¸–ç•Œç®¡ç†å™¨
const worlds = components.get(OBC.Worlds);

// åˆ›å»ºä¸–ç•Œ
const world = worlds.create<
  OBC.SimpleScene,
  OBC.OrthoPerspectiveCamera,
  OBC.SimpleRenderer
>();

// é…ç½®åœºæ™¯
world.scene = new OBC.SimpleScene(components);
world.scene.setup({
  backgroundColor: new THREE.Color(0x87CEEB),
  directionalLight: {
    intensity: 2.0,
    position: new THREE.Vector3(10, 15, 5)
  }
});

// é…ç½®ç›¸æœº
world.camera = new OBC.OrthoPerspectiveCamera(components);
world.camera.controls.setLookAt(15, 15, 15, 0, 0, 0);

// é…ç½®æ¸²æŸ“å™¨
const container = document.getElementById('container')!;
world.renderer = new OBC.SimpleRenderer(components, container);
world.renderer.three.shadowMap.enabled = true;

// åˆå§‹åŒ–ç³»ç»Ÿ
components.init();

// æ·»åŠ å‡ ä½•ä½“
const geometry = new THREE.BoxGeometry(2, 2, 2);
const material = new THREE.MeshLambertMaterial({ color: 0x00ff00 });
const cube = new THREE.Mesh(geometry, material);
cube.castShadow = true;
world.scene.three.add(cube);
world.meshes.add(cube);

// ç›‘å¬ä¸–ç•Œäº‹ä»¶
world.onBeforeUpdate.add(() => {
  // æ¯å¸§æ›´æ–°å‰çš„é€»è¾‘
  cube.rotation.x += 0.01;
  cube.rotation.y += 0.01;
});

// æ¸…ç†èµ„æº
window.addEventListener('beforeunload', () => {
  components.dispose();
});
```

## 7. å†…å­˜ç®¡ç† (Memory Management)

### 7.1 å†…å­˜ç®¡ç†æ¦‚è¿°

åœ¨ 3D åº”ç”¨ä¸­ï¼Œå†…å­˜ç®¡ç†è‡³å…³é‡è¦ã€‚@thatopen/components æä¾›äº†å®Œå–„çš„å†…å­˜ç®¡ç†æœºåˆ¶ï¼Œç¡®ä¿åº”ç”¨çš„ç¨³å®šæ€§å’Œæ€§èƒ½ã€‚

#### ğŸ§  å†…å­˜ç®¡ç†ç‰¹æ€§

- **è‡ªåŠ¨èµ„æºæ¸…ç†**: ç»„ä»¶é”€æ¯æ—¶è‡ªåŠ¨é‡Šæ”¾ç›¸å…³èµ„æº
- **ç”Ÿå‘½å‘¨æœŸç®¡ç†**: å®Œæ•´çš„ç»„ä»¶ç”Ÿå‘½å‘¨æœŸè·Ÿè¸ª
- **å†…å­˜æ³„æ¼æ£€æµ‹**: å†…ç½®å†…å­˜æ³„æ¼æ£€æµ‹å’Œé¢„è­¦
- **èµ„æºæ± åŒ–**: é‡ç”¨å¸¸ç”¨å¯¹è±¡ä»¥å‡å°‘åƒåœ¾å›æ”¶å‹åŠ›
- **æ™ºèƒ½ç¼“å­˜**: è‡ªåŠ¨ç®¡ç†çº¹ç†ã€å‡ ä½•ä½“ç­‰èµ„æºçš„ç¼“å­˜

### 7.2 ç»„ä»¶ç”Ÿå‘½å‘¨æœŸç®¡ç†

æ‰€æœ‰ç»„ä»¶éƒ½å®ç°äº† `Disposable` æ¥å£ï¼Œç¡®ä¿èµ„æºçš„æ­£ç¡®é‡Šæ”¾ã€‚

```typescript
import * as OBC from "@thatopen/components";

class ComponentLifecycleManager {
  private components: OBC.Components;
  private activeComponents = new Set<OBC.Component>();
  
  constructor() {
    this.components = new OBC.Components();
    this.setupLifecycleMonitoring();
  }
  
  private setupLifecycleMonitoring(): void {
    // ç›‘å¬ç»„ä»¶åˆå§‹åŒ–
    this.components.onInitialized.add((component) => {
      console.log(`ç»„ä»¶å·²åˆå§‹åŒ–: ${component.constructor.name}`);
      this.activeComponents.add(component);
      
      // ä¸ºç»„ä»¶æ·»åŠ é”€æ¯ç›‘å¬
      if ('onDisposed' in component) {
        (component as any).onDisposed.add(() => {
          console.log(`ç»„ä»¶å·²é”€æ¯: ${component.constructor.name}`);
          this.activeComponents.delete(component);
        });
      }
    });
  }
  
  // å®‰å…¨é”€æ¯å•ä¸ªç»„ä»¶
  disposeComponent(component: OBC.Component): void {
    try {
      if ('dispose' in component && typeof component.dispose === 'function') {
        component.dispose();
      }
    } catch (error) {
      console.error(`é”€æ¯ç»„ä»¶æ—¶å‘ç”Ÿé”™è¯¯: ${component.constructor.name}`, error);
    }
  }
  
  // é”€æ¯æ‰€æœ‰ç»„ä»¶
  disposeAll(): void {
    try {
      this.components.dispose();
    } catch (error) {
      console.error('é”€æ¯æ‰€æœ‰ç»„ä»¶æ—¶å‘ç”Ÿé”™è¯¯:', error);
    }
  }
}
```

### 7.3 å†…å­˜æ³„æ¼é¢„é˜²

```typescript
class MemoryLeakPreventionExample implements OBC.Disposable {
  private _disposed = false;
  private eventListeners: Array<() => void> = [];
  private threeJSObjects: THREE.Object3D[] = [];
  private textures: THREE.Texture[] = [];
  private geometries: THREE.BufferGeometry[] = [];
  private materials: THREE.Material[] = [];
  private animationFrameId: number | null = null;
  
  readonly onDisposed = new OBC.Event<void>();
  
  constructor() {
    this.setupComponent();
  }
  
  private setupComponent(): void {
    // æ·»åŠ äº‹ä»¶ç›‘å¬å™¨æ—¶è®°å½•æ¸…ç†å‡½æ•°
    const handleResize = () => this.handleResize();
    window.addEventListener('resize', handleResize);
    this.eventListeners.push(() => {
      window.removeEventListener('resize', handleResize);
    });
  }
  
  // æ­£ç¡®çš„èµ„æºæ¸…ç†
  dispose(): void {
    if (this._disposed) return;
    
    try {
      // åœæ­¢åŠ¨ç”»å¾ªç¯
      if (this.animationFrameId !== null) {
        cancelAnimationFrame(this.animationFrameId);
        this.animationFrameId = null;
      }
      
      // æ¸…ç†äº‹ä»¶ç›‘å¬å™¨
      this.eventListeners.forEach(cleanup => cleanup());
      this.eventListeners.length = 0;
      
      // æ¸…ç† Three.js èµ„æº
      this.cleanupThreeJSResources();
      
      // è§¦å‘é”€æ¯äº‹ä»¶
      this.onDisposed.trigger();
      this.onDisposed.reset();
      
      this._disposed = true;
      
    } catch (error) {
      console.error('é”€æ¯ç»„ä»¶æ—¶å‘ç”Ÿé”™è¯¯:', error);
    }
  }
  
  private cleanupThreeJSResources(): void {
    // æ¸…ç†å‡ ä½•ä½“
    this.geometries.forEach(geometry => geometry.dispose());
    this.geometries.length = 0;
    
    // æ¸…ç†æè´¨
    this.materials.forEach(material => material.dispose());
    this.materials.length = 0;
    
    // æ¸…ç†çº¹ç†
    this.textures.forEach(texture => texture.dispose());
    this.textures.length = 0;
    
    // ä»åœºæ™¯ä¸­ç§»é™¤å¯¹è±¡
    this.threeJSObjects.forEach(object => {
      if (object.parent) {
        object.parent.remove(object);
      }
    });
    this.threeJSObjects.length = 0;
  }
  
  private handleResize(): void {
    // å¤„ç†çª—å£å¤§å°å˜åŒ–
  }
  
  get disposed(): boolean {
    return this._disposed;
  }
}
```

## 8. è‡ªå®šä¹‰ç»„ä»¶å¼€å‘ (Custom Component Development)

### 8.1 è‡ªå®šä¹‰ç»„ä»¶æ¦‚è¿°

@thatopen/components æä¾›äº†çµæ´»çš„ç»„ä»¶ç³»ç»Ÿï¼Œå…è®¸å¼€å‘è€…åˆ›å»ºè‡ªå®šä¹‰ç»„ä»¶æ¥æ‰©å±•åŠŸèƒ½ã€‚

#### ğŸ”§ ç»„ä»¶å¼€å‘ç‰¹æ€§

- **æ¥å£é©±åŠ¨**: åŸºäºæ ‡å‡†æ¥å£çš„ç»„ä»¶è®¾è®¡
- **ç”Ÿå‘½å‘¨æœŸç®¡ç†**: å®Œæ•´çš„ç»„ä»¶ç”Ÿå‘½å‘¨æœŸæ”¯æŒ
- **äº‹ä»¶ç³»ç»Ÿ**: å†…ç½®äº‹ä»¶ç³»ç»Ÿç”¨äºç»„ä»¶é€šä¿¡
- **é…ç½®ç®¡ç†**: çµæ´»çš„é…ç½®ç³»ç»Ÿ
- **ç±»å‹å®‰å…¨**: å®Œæ•´çš„ TypeScript ç±»å‹æ”¯æŒ

### 8.2 åŸºç¡€ç»„ä»¶å¼€å‘

#### ğŸ—ï¸ åˆ›å»ºç®€å•ç»„ä»¶

```typescript
import * as OBC from "@thatopen/components";
import * as THREE from "three";

// å®šä¹‰ç»„ä»¶é…ç½®æ¥å£
interface CustomComponentConfig {
  color: THREE.Color;
  size: number;
  position: THREE.Vector3;
  autoRotate: boolean;
  rotationSpeed: number;
}

// åˆ›å»ºè‡ªå®šä¹‰ç»„ä»¶
class CustomComponent 
  extends OBC.Component 
  implements OBC.Updateable, OBC.Disposable, OBC.Configurable<CustomComponentConfig> 
{
  static readonly uuid = "custom-component-uuid" as const;
  
  // ç»„ä»¶æ˜¯å¦å¯ç”¨
  enabled = true;
  
  // é…ç½®å¯¹è±¡
  config: Required<CustomComponentConfig> = {
    color: new THREE.Color(0x00ff00),
    size: 1,
    position: new THREE.Vector3(0, 0, 0),
    autoRotate: true,
    rotationSpeed: 0.01
  };
  
  // äº‹ä»¶å®šä¹‰
  readonly onConfigChanged = new OBC.Event<Partial<CustomComponentConfig>>();
  readonly onDisposed = new OBC.Event<void>();
  readonly onObjectCreated = new OBC.Event<THREE.Mesh>();
  
  // ç§æœ‰å±æ€§
  private _mesh: THREE.Mesh | null = null;
  private _disposed = false;
  
  constructor(components: OBC.Components) {
    super(components);
    this.createMesh();
  }
  
  // åˆ›å»º 3D å¯¹è±¡
  private createMesh(): void {
    const geometry = new THREE.BoxGeometry(
      this.config.size,
      this.config.size,
      this.config.size
    );
    
    const material = new THREE.MeshStandardMaterial({
      color: this.config.color
    });
    
    this._mesh = new THREE.Mesh(geometry, material);
    this._mesh.position.copy(this.config.position);
    this._mesh.castShadow = true;
    this._mesh.receiveShadow = true;
    
    // è§¦å‘å¯¹è±¡åˆ›å»ºäº‹ä»¶
    this.onObjectCreated.trigger(this._mesh);
  }
  
  // æ›´æ–°æ–¹æ³•ï¼ˆå®ç° Updateable æ¥å£ï¼‰
  update(): void {
    if (!this.enabled || !this._mesh || this._disposed) return;
    
    if (this.config.autoRotate) {
      this._mesh.rotation.x += this.config.rotationSpeed;
      this._mesh.rotation.y += this.config.rotationSpeed;
    }
  }
  
  // é…ç½®æ›´æ–°æ–¹æ³•ï¼ˆå®ç° Configurable æ¥å£ï¼‰
  setup(config?: Partial<CustomComponentConfig>): void {
    if (!config) return;
    
    const oldConfig = { ...this.config };
    
    // æ›´æ–°é…ç½®
    Object.assign(this.config, config);
    
    // åº”ç”¨é…ç½®å˜æ›´
    this.applyConfigChanges(oldConfig, config);
    
    // è§¦å‘é…ç½®å˜æ›´äº‹ä»¶
    this.onConfigChanged.trigger(config);
  }
  
  private applyConfigChanges(
    oldConfig: CustomComponentConfig,
    newConfig: Partial<CustomComponentConfig>
  ): void {
    if (!this._mesh) return;
    
    // æ›´æ–°é¢œè‰²
    if (newConfig.color && !newConfig.color.equals(oldConfig.color)) {
      (this._mesh.material as THREE.MeshStandardMaterial).color.copy(newConfig.color);
    }
    
    // æ›´æ–°å¤§å°
    if (newConfig.size && newConfig.size !== oldConfig.size) {
      this._mesh.scale.setScalar(newConfig.size / oldConfig.size);
    }
    
    // æ›´æ–°ä½ç½®
    if (newConfig.position && !newConfig.position.equals(oldConfig.position)) {
      this._mesh.position.copy(newConfig.position);
    }
  }
  
  // è·å–åˆ›å»ºçš„ç½‘æ ¼
  get mesh(): THREE.Mesh | null {
    return this._mesh;
  }
  
  // è®¾ç½®å¯è§æ€§
  setVisible(visible: boolean): void {
    if (this._mesh) {
      this._mesh.visible = visible;
    }
  }
  
  // é”€æ¯æ–¹æ³•ï¼ˆå®ç° Disposable æ¥å£ï¼‰
  dispose(): void {
    if (this._disposed) return;
    
    try {
      // æ¸…ç† 3D å¯¹è±¡
      if (this._mesh) {
        // æ¸…ç†å‡ ä½•ä½“å’Œæè´¨
        this._mesh.geometry.dispose();
        (this._mesh.material as THREE.Material).dispose();
        
        // ä»çˆ¶å¯¹è±¡ä¸­ç§»é™¤
        if (this._mesh.parent) {
          this._mesh.parent.remove(this._mesh);
        }
        
        this._mesh = null;
      }
      
      // æ¸…ç†äº‹ä»¶
      this.onConfigChanged.reset();
      this.onDisposed.trigger();
      this.onDisposed.reset();
      this.onObjectCreated.reset();
      
      this._disposed = true;
      
    } catch (error) {
      console.error('é”€æ¯è‡ªå®šä¹‰ç»„ä»¶æ—¶å‘ç”Ÿé”™è¯¯:', error);
    }
  }
  
  get disposed(): boolean {
    return this._disposed;
  }
}
```

### 8.3 é«˜çº§ç»„ä»¶å¼€å‘

#### ğŸš€ å¤æ‚ç»„ä»¶ç¤ºä¾‹

```typescript
// ç²’å­ç³»ç»Ÿç»„ä»¶
class ParticleSystemComponent 
  extends OBC.Component 
  implements OBC.Updateable, OBC.Disposable, OBC.Configurable<ParticleConfig> 
{
  static readonly uuid = "particle-system-uuid" as const;
  
  enabled = true;
  
  config: Required<ParticleConfig> = {
    particleCount: 1000,
    particleSize: 0.1,
    emissionRate: 10,
    lifetime: 5.0,
    gravity: new THREE.Vector3(0, -9.8, 0),
    initialVelocity: new THREE.Vector3(0, 5, 0),
    velocityVariation: new THREE.Vector3(2, 2, 2),
    color: new THREE.Color(0xffffff),
    colorVariation: 0.2
  };
  
  readonly onParticleEmitted = new OBC.Event<Particle>();
  readonly onParticleDestroyed = new OBC.Event<Particle>();
  readonly onDisposed = new OBC.Event<void>();
  
  private particles: Particle[] = [];
  private particlePool: Particle[] = [];
  private emissionTimer = 0;
  private particleGeometry: THREE.BufferGeometry;
  private particleMaterial: THREE.PointsMaterial;
  private particleSystem: THREE.Points;
  private _disposed = false;
  
  constructor(components: OBC.Components) {
    super(components);
    this.initializeParticleSystem();
  }
  
  private initializeParticleSystem(): void {
    // åˆ›å»ºç²’å­å‡ ä½•ä½“
    this.particleGeometry = new THREE.BufferGeometry();
    
    // åˆ›å»ºç²’å­æè´¨
    this.particleMaterial = new THREE.PointsMaterial({
      size: this.config.particleSize,
      color: this.config.color,
      transparent: true,
      alphaTest: 0.1
    });
    
    // åˆ›å»ºç²’å­ç³»ç»Ÿ
    this.particleSystem = new THREE.Points(this.particleGeometry, this.particleMaterial);
    
    // åˆå§‹åŒ–ç²’å­æ± 
    this.initializeParticlePool();
  }
  
  private initializeParticlePool(): void {
    for (let i = 0; i < this.config.particleCount; i++) {
      this.particlePool.push(this.createParticle());
    }
  }
  
  private createParticle(): Particle {
    return {
      position: new THREE.Vector3(),
      velocity: new THREE.Vector3(),
      life: 0,
      maxLife: this.config.lifetime,
      size: this.config.particleSize,
      color: this.config.color.clone(),
      active: false
    };
  }
  
  update(deltaTime: number): void {
    if (!this.enabled || this._disposed) return;
    
    // å‘å°„æ–°ç²’å­
    this.emitParticles(deltaTime);
    
    // æ›´æ–°ç°æœ‰ç²’å­
    this.updateParticles(deltaTime);
    
    // æ›´æ–°ç²’å­ç³»ç»Ÿå‡ ä½•ä½“
    this.updateParticleGeometry();
  }
  
  private emitParticles(deltaTime: number): void {
    this.emissionTimer += deltaTime;
    const emissionInterval = 1.0 / this.config.emissionRate;
    
    while (this.emissionTimer >= emissionInterval && this.particlePool.length > 0) {
      const particle = this.particlePool.pop()!;
      this.initializeParticle(particle);
      this.particles.push(particle);
      
      this.onParticleEmitted.trigger(particle);
      this.emissionTimer -= emissionInterval;
    }
  }
  
  private initializeParticle(particle: Particle): void {
    particle.position.set(0, 0, 0);
    particle.velocity.copy(this.config.initialVelocity);
    
    // æ·»åŠ é€Ÿåº¦å˜åŒ–
    particle.velocity.add(
      new THREE.Vector3(
        (Math.random() - 0.5) * this.config.velocityVariation.x,
        (Math.random() - 0.5) * this.config.velocityVariation.y,
        (Math.random() - 0.5) * this.config.velocityVariation.z
      )
    );
    
    particle.life = 0;
    particle.maxLife = this.config.lifetime * (0.8 + Math.random() * 0.4);
    particle.active = true;
    
    // é¢œè‰²å˜åŒ–
    particle.color.copy(this.config.color);
    const colorVar = this.config.colorVariation;
    particle.color.offsetHSL(
      (Math.random() - 0.5) * colorVar,
      (Math.random() - 0.5) * colorVar,
      (Math.random() - 0.5) * colorVar
    );
  }
  
  private updateParticles(deltaTime: number): void {
    for (let i = this.particles.length - 1; i >= 0; i--) {
      const particle = this.particles[i];
      
      // æ›´æ–°ç”Ÿå‘½å‘¨æœŸ
      particle.life += deltaTime;
      
      if (particle.life >= particle.maxLife) {
        // ç²’å­æ­»äº¡ï¼Œå›æ”¶åˆ°æ± ä¸­
        particle.active = false;
        this.particles.splice(i, 1);
        this.particlePool.push(particle);
        this.onParticleDestroyed.trigger(particle);
        continue;
      }
      
      // æ›´æ–°ç‰©ç†
      particle.velocity.add(
        this.config.gravity.clone().multiplyScalar(deltaTime)
      );
      particle.position.add(
        particle.velocity.clone().multiplyScalar(deltaTime)
      );
      
      // æ›´æ–°é€æ˜åº¦ï¼ˆåŸºäºç”Ÿå‘½å‘¨æœŸï¼‰
      const lifeRatio = particle.life / particle.maxLife;
      const alpha = 1.0 - lifeRatio;
      particle.color.setScalar(alpha);
    }
  }
  
  private updateParticleGeometry(): void {
    const positions = new Float32Array(this.particles.length * 3);
    const colors = new Float32Array(this.particles.length * 3);
    
    for (let i = 0; i < this.particles.length; i++) {
      const particle = this.particles[i];
      const i3 = i * 3;
      
      positions[i3] = particle.position.x;
      positions[i3 + 1] = particle.position.y;
      positions[i3 + 2] = particle.position.z;
      
      colors[i3] = particle.color.r;
      colors[i3 + 1] = particle.color.g;
      colors[i3 + 2] = particle.color.b;
    }
    
    this.particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    this.particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    this.particleGeometry.attributes.position.needsUpdate = true;
    this.particleGeometry.attributes.color.needsUpdate = true;
  }
  
  setup(config?: Partial<ParticleConfig>): void {
    if (!config) return;
    
    Object.assign(this.config, config);
    
    // åº”ç”¨é…ç½®å˜æ›´
    if (config.particleSize !== undefined) {
      this.particleMaterial.size = config.particleSize;
    }
    
    if (config.color !== undefined) {
      this.particleMaterial.color.copy(config.color);
    }
  }
  
  get system(): THREE.Points {
    return this.particleSystem;
  }
  
  dispose(): void {
    if (this._disposed) return;
    
    try {
      // æ¸…ç†ç²’å­
      this.particles.length = 0;
      this.particlePool.length = 0;
      
      // æ¸…ç† Three.js èµ„æº
      this.particleGeometry.dispose();
      this.particleMaterial.dispose();
      
      // æ¸…ç†äº‹ä»¶
      this.onParticleEmitted.reset();
      this.onParticleDestroyed.reset();
      this.onDisposed.trigger();
      this.onDisposed.reset();
      
      this._disposed = true;
      
    } catch (error) {
      console.error('é”€æ¯ç²’å­ç³»ç»Ÿæ—¶å‘ç”Ÿé”™è¯¯:', error);
    }
  }
  
  get disposed(): boolean {
    return this._disposed;
  }
}

interface ParticleConfig {
  particleCount: number;
  particleSize: number;
  emissionRate: number;
  lifetime: number;
  gravity: THREE.Vector3;
  initialVelocity: THREE.Vector3;
  velocityVariation: THREE.Vector3;
  color: THREE.Color;
  colorVariation: number;
}

interface Particle {
  position: THREE.Vector3;
  velocity: THREE.Vector3;
  life: number;
  maxLife: number;
  size: number;
  color: THREE.Color;
  active: boolean;
}
```

### 8.4 ç»„ä»¶æ³¨å†Œå’Œä½¿ç”¨

```typescript
// æ³¨å†Œè‡ªå®šä¹‰ç»„ä»¶
const components = new OBC.Components();

// æ·»åŠ è‡ªå®šä¹‰ç»„ä»¶
const customComponent = new CustomComponent(components);
components.add(CustomComponent.uuid, customComponent);

// æ·»åŠ ç²’å­ç³»ç»Ÿç»„ä»¶
const particleSystem = new ParticleSystemComponent(components);
components.add(ParticleSystemComponent.uuid, particleSystem);

// è·å–å’Œä½¿ç”¨ç»„ä»¶
const myComponent = components.get(CustomComponent);
myComponent.setup({
  color: new THREE.Color(0xff0000),
  size: 2,
  autoRotate: true
});

// å°†ç»„ä»¶å¯¹è±¡æ·»åŠ åˆ°åœºæ™¯
const world = components.get(OBC.Worlds).create();
if (myComponent.mesh) {
  world.scene.three.add(myComponent.mesh);
}

if (particleSystem.system) {
  world.scene.three.add(particleSystem.system);
}

// å¯åŠ¨æ›´æ–°å¾ªç¯
components.init();
```

## 9. æœ€ä½³å®è·µ

### 9.1 å†…å­˜ç®¡ç†æœ€ä½³å®è·µ

```typescript
// å§‹ç»ˆåœ¨åº”ç”¨ç»“æŸæ—¶æ¸…ç†èµ„æº
components.dispose();

// åˆ é™¤ä¸éœ€è¦çš„ä¸–ç•Œ
worlds.delete(world);

// æ¸…ç†å‡ ä½•ä½“å’Œæè´¨
geometry.dispose();
material.dispose();

// ä½¿ç”¨å¯¹è±¡æ± å‡å°‘åƒåœ¾å›æ”¶
class ObjectPool<T> {
  private pool: T[] = [];
  private createFn: () => T;
  private resetFn: (obj: T) => void;
  
  constructor(createFn: () => T, resetFn: (obj: T) => void, initialSize = 10) {
    this.createFn = createFn;
    this.resetFn = resetFn;
    
    // é¢„å¡«å……æ± 
    for (let i = 0; i < initialSize; i++) {
      this.pool.push(this.createFn());
    }
  }
  
  get(): T {
    return this.pool.pop() || this.createFn();
  }
  
  release(obj: T): void {
    this.resetFn(obj);
    this.pool.push(obj);
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const vectorPool = new ObjectPool(
  () => new THREE.Vector3(),
  (v) => v.set(0, 0, 0),
  50
);
```

### 9.2 æ€§èƒ½ä¼˜åŒ–æœ€ä½³å®è·µ

#### ğŸš€ æ¸²æŸ“æ€§èƒ½ä¼˜åŒ–

```typescript
class PerformanceOptimizer {
  private components: OBC.Components;
  private frameCounter = 0;
  private lastFPSCheck = 0;
  private currentFPS = 0;
  
  constructor(components: OBC.Components) {
    this.components = components;
    this.setupPerformanceMonitoring();
  }
  
  private setupPerformanceMonitoring(): void {
    // ç›‘æ§ FPS
    const updateLoop = () => {
      this.frameCounter++;
      const now = performance.now();
      
      if (now - this.lastFPSCheck >= 1000) {
        this.currentFPS = this.frameCounter;
        this.frameCounter = 0;
        this.lastFPSCheck = now;
        
        // æ ¹æ® FPS è°ƒæ•´æ¸²æŸ“è´¨é‡
        this.adjustRenderQuality();
      }
      
      requestAnimationFrame(updateLoop);
    };
    updateLoop();
  }
  
  private adjustRenderQuality(): void {
    const renderer = this.components.get(OBC.SimpleRenderer);
    
    if (this.currentFPS < 30) {
      // é™ä½æ¸²æŸ“è´¨é‡
      renderer.three.setPixelRatio(Math.min(window.devicePixelRatio * 0.5, 1));
      renderer.three.shadowMap.enabled = false;
    } else if (this.currentFPS > 50) {
      // æé«˜æ¸²æŸ“è´¨é‡
      renderer.three.setPixelRatio(window.devicePixelRatio);
      renderer.three.shadowMap.enabled = true;
    }
  }
  
  // æ‰¹é‡æ›´æ–°ä¼˜åŒ–
  batchUpdate(objects: THREE.Object3D[], updateFn: (obj: THREE.Object3D) => void): void {
    // æš‚åœæ¸²æŸ“
    const renderer = this.components.get(OBC.SimpleRenderer);
    const autoRender = renderer.three.autoClear;
    renderer.three.autoClear = false;
    
    try {
      // æ‰¹é‡æ›´æ–°
      objects.forEach(updateFn);
    } finally {
      // æ¢å¤æ¸²æŸ“
      renderer.three.autoClear = autoRender;
      renderer.three.render(
        this.components.get(OBC.Worlds).list.values().next().value.scene.three,
        this.components.get(OBC.Worlds).list.values().next().value.camera.three
      );
    }
  }
  
  // LOD (Level of Detail) ç®¡ç†
  setupLOD(object: THREE.Object3D, distances: number[], geometries: THREE.BufferGeometry[]): THREE.LOD {
    const lod = new THREE.LOD();
    
    geometries.forEach((geometry, index) => {
      const material = new THREE.MeshStandardMaterial({ color: 0x00ff00 });
      const mesh = new THREE.Mesh(geometry, material);
      lod.addLevel(mesh, distances[index] || 0);
    });
    
    return lod;
  }
}
```

#### ğŸ¯ ç»„ä»¶æ›´æ–°ä¼˜åŒ–

```typescript
class OptimizedComponent extends OBC.Component implements OBC.Updateable {
  enabled = true;
  private updateInterval = 16; // 60 FPS
  private lastUpdate = 0;
  private isDirty = false;
  
  // æ¡ä»¶æ›´æ–° - åªåœ¨éœ€è¦æ—¶æ›´æ–°
  update(): void {
    if (!this.enabled || !this.isDirty) return;
    
    const now = performance.now();
    if (now - this.lastUpdate < this.updateInterval) return;
    
    this.performUpdate();
    this.isDirty = false;
    this.lastUpdate = now;
  }
  
  private performUpdate(): void {
    // å®é™…æ›´æ–°é€»è¾‘
  }
  
  // æ ‡è®°ä¸ºéœ€è¦æ›´æ–°
  markDirty(): void {
    this.isDirty = true;
  }
  
  // è®¾ç½®æ›´æ–°é¢‘ç‡
  setUpdateRate(fps: number): void {
    this.updateInterval = 1000 / fps;
  }
}
```

### 9.3 é”™è¯¯å¤„ç†æœ€ä½³å®è·µ

```typescript
class ErrorHandlingExample {
  private components: OBC.Components;
  private errorLog: Array<{ timestamp: number; error: Error; context: string }> = [];
  
  constructor() {
    this.components = new OBC.Components();
    this.setupGlobalErrorHandling();
  }
  
  private setupGlobalErrorHandling(): void {
    // å…¨å±€é”™è¯¯å¤„ç†
    window.addEventListener('error', (event) => {
      this.logError(event.error, 'Global Error');
    });
    
    // Promise é”™è¯¯å¤„ç†
    window.addEventListener('unhandledrejection', (event) => {
      this.logError(new Error(event.reason), 'Unhandled Promise Rejection');
    });
  }
  
  private logError(error: Error, context: string): void {
    const errorEntry = {
      timestamp: Date.now(),
      error,
      context
    };
    
    this.errorLog.push(errorEntry);
    console.error(`[${context}]`, error);
    
    // é™åˆ¶é”™è¯¯æ—¥å¿—å¤§å°
    if (this.errorLog.length > 100) {
      this.errorLog.shift();
    }
  }
  
  // å®‰å…¨çš„ç»„ä»¶æ“ä½œ
  safeComponentOperation<T>(
    operation: () => T,
    fallback: T,
    context: string
  ): T {
    try {
      return operation();
    } catch (error) {
      this.logError(error as Error, context);
      return fallback;
    }
  }
  
  // å¼‚æ­¥æ“ä½œé”™è¯¯å¤„ç†
  async safeAsyncOperation<T>(
    operation: () => Promise<T>,
    fallback: T,
    context: string
  ): Promise<T> {
    try {
      return await operation();
    } catch (error) {
      this.logError(error as Error, context);
      return fallback;
    }
  }
  
  // ç»„ä»¶åˆå§‹åŒ–é”™è¯¯å¤„ç†
  initializeComponentSafely<T extends OBC.Component>(
    ComponentClass: new (components: OBC.Components) => T
  ): T | null {
    return this.safeComponentOperation(
      () => {
        const component = new ComponentClass(this.components);
        this.components.add(ComponentClass.uuid, component);
        return component;
      },
      null,
      `Initialize ${ComponentClass.name}`
    );
  }
}
```

### 9.4 ç»„ä»¶è®¾è®¡æ¨¡å¼

#### ğŸ—ï¸ å·¥å‚æ¨¡å¼

```typescript
interface ComponentFactory {
  create<T extends OBC.Component>(type: string, config?: any): T | null;
}

class StandardComponentFactory implements ComponentFactory {
  private components: OBC.Components;
  private registry = new Map<string, new (components: OBC.Components) => OBC.Component>();
  
  constructor(components: OBC.Components) {
    this.components = components;
    this.registerStandardComponents();
  }
  
  private registerStandardComponents(): void {
    this.registry.set('simple-scene', OBC.SimpleScene);
    this.registry.set('simple-camera', OBC.SimpleCamera);
    this.registry.set('simple-renderer', OBC.SimpleRenderer);
    // æ³¨å†Œæ›´å¤šç»„ä»¶...
  }
  
  register<T extends OBC.Component>(
    type: string,
    ComponentClass: new (components: OBC.Components) => T
  ): void {
    this.registry.set(type, ComponentClass);
  }
  
  create<T extends OBC.Component>(type: string, config?: any): T | null {
    const ComponentClass = this.registry.get(type);
    if (!ComponentClass) {
      console.warn(`æœªçŸ¥çš„ç»„ä»¶ç±»å‹: ${type}`);
      return null;
    }
    
    try {
      const component = new ComponentClass(this.components) as T;
      
      if (config && 'setup' in component) {
        (component as any).setup(config);
      }
      
      return component;
    } catch (error) {
      console.error(`åˆ›å»ºç»„ä»¶å¤±è´¥: ${type}`, error);
      return null;
    }
  }
}
```

#### ğŸ”„ è§‚å¯Ÿè€…æ¨¡å¼

```typescript
class ComponentEventManager {
  private eventBus = new Map<string, Set<Function>>();
  
  // è®¢é˜…äº‹ä»¶
  subscribe(eventName: string, callback: Function): () => void {
    if (!this.eventBus.has(eventName)) {
      this.eventBus.set(eventName, new Set());
    }
    
    this.eventBus.get(eventName)!.add(callback);
    
    // è¿”å›å–æ¶ˆè®¢é˜…å‡½æ•°
    return () => {
      this.eventBus.get(eventName)?.delete(callback);
    };
  }
  
  // å‘å¸ƒäº‹ä»¶
  publish(eventName: string, data?: any): void {
    const callbacks = this.eventBus.get(eventName);
    if (callbacks) {
      callbacks.forEach(callback => {
        try {
          callback(data);
        } catch (error) {
          console.error(`äº‹ä»¶å›è°ƒæ‰§è¡Œå¤±è´¥: ${eventName}`, error);
        }
      });
    }
  }
  
  // æ¸…ç†æ‰€æœ‰äº‹ä»¶
  clear(): void {
    this.eventBus.clear();
  }
}
```

### 9.5 è°ƒè¯•å’Œå¼€å‘å·¥å…·

```typescript
class DevelopmentTools {
  private components: OBC.Components;
  private debugPanel: HTMLElement | null = null;
  
  constructor(components: OBC.Components) {
    this.components = components;
    this.createDebugPanel();
  }
  
  private createDebugPanel(): void {
    if (process.env.NODE_ENV !== 'development') return;
    
    this.debugPanel = document.createElement('div');
    this.debugPanel.style.cssText = `
      position: fixed;
      top: 10px;
      right: 10px;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 10px;
      border-radius: 5px;
      font-family: monospace;
      font-size: 12px;
      z-index: 10000;
      max-width: 300px;
    `;
    
    document.body.appendChild(this.debugPanel);
    this.updateDebugInfo();
  }
  
  private updateDebugInfo(): void {
    if (!this.debugPanel) return;
    
    const updateLoop = () => {
      const info = this.gatherDebugInfo();
      this.debugPanel!.innerHTML = `
        <div><strong>ç»„ä»¶è°ƒè¯•ä¿¡æ¯</strong></div>
        <div>æ´»è·ƒç»„ä»¶: ${info.activeComponents}</div>
        <div>å†…å­˜ä½¿ç”¨: ${info.memoryUsage}MB</div>
        <div>FPS: ${info.fps}</div>
        <div>æ¸²æŸ“è°ƒç”¨: ${info.renderCalls}</div>
        <div>ä¸‰è§’å½¢æ•°: ${info.triangles}</div>
      `;
      
      requestAnimationFrame(updateLoop);
    };
    updateLoop();
  }
  
  private gatherDebugInfo() {
    const renderer = this.components.get(OBC.SimpleRenderer);
    const info = renderer.three.info;
    
    return {
      activeComponents: this.components.list.size,
      memoryUsage: (performance as any).memory ? 
        Math.round((performance as any).memory.usedJSHeapSize / 1048576) : 'N/A',
      fps: Math.round(1000 / 16), // ç®€åŒ–çš„ FPS è®¡ç®—
      renderCalls: info.render.calls,
      triangles: info.render.triangles
    };
  }
  
  // ç»„ä»¶æ£€æŸ¥å™¨
  inspectComponent(component: OBC.Component): void {
    console.group(`ç»„ä»¶æ£€æŸ¥: ${component.constructor.name}`);
    console.log('UUID:', (component.constructor as any).uuid);
    console.log('å¯ç”¨çŠ¶æ€:', 'enabled' in component ? (component as any).enabled : 'N/A');
    console.log('é…ç½®:', 'config' in component ? (component as any).config : 'N/A');
    console.log('å·²é”€æ¯:', 'disposed' in component ? (component as any).disposed : 'N/A');
    console.groupEnd();
  }
}
```

### 7.2 æ€§èƒ½ä¼˜åŒ–

```typescript
// ç¦ç”¨ä¸éœ€è¦çš„ç»„ä»¶
component.enabled = false;

// ä½¿ç”¨å¯¹è±¡æ± é‡ç”¨å‡ ä½•ä½“
const geometryPool = new Map<string, THREE.BufferGeometry>();

// æ‰¹é‡å¤„ç†ç½‘æ ¼æ›´æ–°
world.onBeforeUpdate.add(() => {
  // æ‰¹é‡æ›´æ–°é€»è¾‘
});
```

### 7.3 é”™è¯¯å¤„ç†

```typescript
try {
  const world = worlds.create();
  // é…ç½®ä¸–ç•Œ...
} catch (error) {
  console.error('ä¸–ç•Œåˆ›å»ºå¤±è´¥:', error);
}

// ç›‘å¬ç»„ä»¶é”™è¯¯
components.onDisposed.add(() => {
  console.log('ç»„ä»¶ç³»ç»Ÿå·²å®‰å…¨é”€æ¯');
});
```

## 10. æ€»ç»“

### 10.1 æ ¸å¿ƒç»„ä»¶ç³»ç»Ÿå›é¡¾

é€šè¿‡æœ¬ç« çš„å­¦ä¹ ï¼Œæˆ‘ä»¬æ·±å…¥äº†è§£äº† @thatopen/components çš„æ ¸å¿ƒç»„ä»¶ç³»ç»Ÿï¼š

#### ğŸ—ï¸ ç»„ä»¶æ¶æ„
- **Components å®¹å™¨**: ä½œä¸ºä¾èµ–æ³¨å…¥å®¹å™¨ï¼Œç®¡ç†æ‰€æœ‰ç»„ä»¶çš„ç”Ÿå‘½å‘¨æœŸ
- **æ¥å£é©±åŠ¨è®¾è®¡**: é€šè¿‡æ ‡å‡†æ¥å£ç¡®ä¿ç»„ä»¶çš„ä¸€è‡´æ€§å’Œå¯æ‰©å±•æ€§
- **äº‹ä»¶ç³»ç»Ÿ**: æä¾›ç»„ä»¶é—´çš„æ¾è€¦åˆé€šä¿¡æœºåˆ¶

#### ğŸŒ æ ¸å¿ƒç»„ä»¶
- **ä¸–ç•Œç³»ç»Ÿ (Worlds)**: ç®¡ç†å¤šä¸ª 3D ä¸–ç•Œå®ä¾‹
- **åœºæ™¯ç³»ç»Ÿ (SimpleScene)**: æä¾›åœºæ™¯ç®¡ç†å’Œå…‰ç…§é…ç½®
- **ç›¸æœºç³»ç»Ÿ (SimpleCamera/OrthoPerspectiveCamera)**: çµæ´»çš„ç›¸æœºæ§åˆ¶
- **æ¸²æŸ“ç³»ç»Ÿ (SimpleRenderer/PostproductionRenderer)**: é«˜æ€§èƒ½æ¸²æŸ“å’Œåå¤„ç†

#### ğŸ”§ é«˜çº§ç‰¹æ€§
- **å†…å­˜ç®¡ç†**: è‡ªåŠ¨èµ„æºæ¸…ç†å’Œå†…å­˜æ³„æ¼é¢„é˜²
- **æ€§èƒ½ä¼˜åŒ–**: LODã€å¯¹è±¡æ± ã€æ‰¹é‡æ›´æ–°ç­‰ä¼˜åŒ–ç­–ç•¥
- **é”™è¯¯å¤„ç†**: å®Œå–„çš„é”™è¯¯å¤„ç†å’Œè°ƒè¯•å·¥å…·
- **è‡ªå®šä¹‰ç»„ä»¶**: çµæ´»çš„ç»„ä»¶æ‰©å±•æœºåˆ¶

### 10.2 å¼€å‘å»ºè®®

#### âœ… æœ€ä½³å®è·µ
1. **å§‹ç»ˆä½¿ç”¨ TypeScript** - å……åˆ†åˆ©ç”¨ç±»å‹å®‰å…¨ç‰¹æ€§
2. **æ­£ç¡®ç®¡ç†ç”Ÿå‘½å‘¨æœŸ** - åŠæ—¶æ¸…ç†èµ„æºï¼Œé¿å…å†…å­˜æ³„æ¼
3. **åˆç†ä½¿ç”¨äº‹ä»¶ç³»ç»Ÿ** - å®ç°ç»„ä»¶é—´çš„æ¾è€¦åˆé€šä¿¡
4. **æ€§èƒ½ä¼˜åŒ–ä¼˜å…ˆ** - åœ¨å¼€å‘æ—©æœŸå°±è€ƒè™‘æ€§èƒ½é—®é¢˜
5. **é”™è¯¯å¤„ç†å®Œå–„** - å»ºç«‹å®Œå–„çš„é”™è¯¯å¤„ç†æœºåˆ¶

#### âš ï¸ å¸¸è§é™·é˜±
1. **å¿˜è®°è°ƒç”¨ dispose()** - å¯¼è‡´å†…å­˜æ³„æ¼
2. **è¿‡åº¦ä½¿ç”¨äº‹ä»¶ç›‘å¬** - å½±å“æ€§èƒ½
3. **ä¸å½“çš„ç»„ä»¶ä¾èµ–** - é€ æˆå¾ªç¯ä¾èµ–
4. **å¿½ç•¥é”™è¯¯å¤„ç†** - å¯¼è‡´åº”ç”¨å´©æºƒ

### 10.3 å­¦ä¹ è·¯å¾„å»ºè®®

#### ğŸ¯ åˆå­¦è€…è·¯å¾„
1. æŒæ¡åŸºç¡€ç»„ä»¶çš„ä½¿ç”¨
2. ç†è§£ç»„ä»¶ç”Ÿå‘½å‘¨æœŸ
3. å­¦ä¹ äº‹ä»¶ç³»ç»Ÿ
4. å®è·µç®€å•çš„ 3D åœºæ™¯

#### ğŸš€ è¿›é˜¶è·¯å¾„
1. æ·±å…¥ç†è§£ç»„ä»¶æ¶æ„
2. å¼€å‘è‡ªå®šä¹‰ç»„ä»¶
3. æ€§èƒ½ä¼˜åŒ–å®è·µ
4. å¤æ‚åº”ç”¨æ¶æ„è®¾è®¡

#### ğŸ† ä¸“å®¶è·¯å¾„
1. è´¡çŒ®å¼€æºç»„ä»¶
2. æ¶æ„è®¾è®¡æ¨¡å¼
3. æ€§èƒ½è°ƒä¼˜ä¸“å®¶
4. æŠ€æœ¯åˆ†äº«å’ŒæŒ‡å¯¼

### 10.4 å®è·µé¡¹ç›®å»ºè®®

#### ğŸ  å»ºç­‘å¯è§†åŒ–é¡¹ç›®
```typescript
// é¡¹ç›®ç»“æ„ç¤ºä¾‹
class ArchitecturalViewer {
  private components: OBC.Components;
  private world: OBC.World;
  private modelLoader: IFCLoader;
  private measurementTools: MeasurementTools;
  
  async initialize(): Promise<void> {
    // åˆå§‹åŒ–æ ¸å¿ƒç»„ä»¶
    this.setupComponents();
    
    // åˆ›å»ºä¸–ç•Œ
    this.createWorld();
    
    // åŠ è½½æ¨¡å‹
    await this.loadModel();
    
    // è®¾ç½®å·¥å…·
    this.setupTools();
  }
}
```

#### ğŸ® äº¤äº’å¼ 3D åº”ç”¨
```typescript
// æ¸¸æˆå¼•æ“é£æ ¼çš„åº”ç”¨
class Interactive3DApp {
  private gameLoop: GameLoop;
  private inputManager: InputManager;
  private sceneManager: SceneManager;
  
  start(): void {
    this.gameLoop.start();
  }
}
```

### 10.5 ç¤¾åŒºå’Œèµ„æº

#### ğŸ“š å­¦ä¹ èµ„æº
- [å®˜æ–¹æ–‡æ¡£](https://docs.thatopen.com/)
- [GitHub ä»“åº“](https://github.com/ThatOpen/engine_components)
- [ç¤ºä¾‹é¡¹ç›®](https://github.com/ThatOpen/engine_components/tree/main/examples)
- [API å‚è€ƒ](https://docs.thatopen.com/api/)

#### ğŸ¤ ç¤¾åŒºæ”¯æŒ
- [Discord ç¤¾åŒº](https://discord.gg/thatopen)
- [GitHub Discussions](https://github.com/ThatOpen/engine_components/discussions)
- [Stack Overflow](https://stackoverflow.com/questions/tagged/thatopen)

#### ğŸ”„ æŒç»­å­¦ä¹ 
- å…³æ³¨é¡¹ç›®æ›´æ–°å’Œæ–°ç‰¹æ€§
- å‚ä¸ç¤¾åŒºè®¨è®ºå’Œé—®é¢˜è§£ç­”
- è´¡çŒ®ä»£ç å’Œæ–‡æ¡£
- åˆ†äº«ä½¿ç”¨ç»éªŒå’Œæœ€ä½³å®è·µ

---

**ä¸‹ä¸€ç« **: [IFC æ–‡ä»¶å¤„ç†ç³»ç»Ÿ](./03-IFCæ–‡ä»¶å¤„ç†ç³»ç»Ÿ.md) - å­¦ä¹ å¦‚ä½•åŠ è½½ã€è§£æå’Œæ“ä½œ IFC å»ºç­‘æ¨¡å‹æ–‡ä»¶ï¼Œæ·±å…¥äº†è§£ BIM æ•°æ®å¤„ç†çš„æ ¸å¿ƒæŠ€æœ¯ã€‚