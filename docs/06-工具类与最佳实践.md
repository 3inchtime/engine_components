# å·¥å…·ç±»ä¸æœ€ä½³å®è·µ

## æ¦‚è¿°

@thatopen/components æä¾›äº†ä¸°å¯Œçš„å·¥å…·ç±»å’Œå®ç”¨åŠŸèƒ½ï¼Œè¿™äº›å·¥å…·ç±»ä¸º BIM åº”ç”¨å¼€å‘æä¾›äº†åŸºç¡€æ”¯æŒã€‚æœ¬æ–‡æ¡£ä»‹ç»æ ¸å¿ƒå·¥å…·ç±»çš„ä½¿ç”¨æ–¹æ³•ï¼Œå¹¶æä¾›å¼€å‘ BIM åº”ç”¨çš„æœ€ä½³å®è·µæŒ‡å—ã€‚

## æ ¸å¿ƒå·¥å…·ç±»

### å‡ ä½•å·¥å…· (Geometry Utils)

å‡ ä½•å·¥å…·æä¾›äº†åŸºç¡€çš„å‡ ä½•è®¡ç®—åŠŸèƒ½ã€‚

#### ç‚¹ä¸å¹³é¢å…³ç³»åˆ¤æ–­

```typescript
import { isPointAbovePlane } from "@thatopen/components";

// åˆ¤æ–­ç‚¹æ˜¯å¦åœ¨å¹³é¢ä¸Šæ–¹
const point = [10, 5, 0];           // æµ‹è¯•ç‚¹
const planePoint = [0, 0, 0];       // å¹³é¢ä¸Šçš„ç‚¹
const planeNormal = [0, 1, 0];      // å¹³é¢æ³•å‘é‡

const isAbove = isPointAbovePlane(point, planePoint, planeNormal);
console.log(`ç‚¹æ˜¯å¦åœ¨å¹³é¢ä¸Šæ–¹: ${isAbove}`);

// å®é™…åº”ç”¨ï¼šæ¥¼å±‚åˆ†å‰²
function separateElementsByFloor(
  elements: THREE.Vector3[],
  floorElevation: number
) {
  const floorPlane = [0, floorElevation, 0];
  const upNormal = [0, 1, 0];
  
  const above: THREE.Vector3[] = [];
  const below: THREE.Vector3[] = [];
  
  for (const element of elements) {
    const point = [element.x, element.y, element.z];
    if (isPointAbovePlane(point, floorPlane, upNormal)) {
      above.push(element);
    } else {
      below.push(element);
    }
  }
  
  return { above, below };
}
```

### é¡¶ç‚¹æ‹¾å–å™¨ (Vertex Picker)

é¡¶ç‚¹æ‹¾å–å™¨æä¾›ç²¾ç¡®çš„ 3D é¡¶ç‚¹é€‰æ‹©åŠŸèƒ½ã€‚

#### åŸºç¡€é¡¶ç‚¹æ‹¾å–å™¨

```typescript
import * as OBC from "@thatopen/components";

// åˆ›å»ºé¡¶ç‚¹æ‹¾å–å™¨
const vertexPicker = new OBC.VertexPicker(components, {
  snapDistance: 0.5,     // æ•æ‰è·ç¦»
  previewElement: null   // é¢„è§ˆå…ƒç´ 
});

// é…ç½®å·¥ä½œå¹³é¢
const workingPlane = new THREE.Plane(
  new THREE.Vector3(0, 1, 0), // æ³•å‘é‡
  0 // è·ç¦»åŸç‚¹çš„è·ç¦»
);
vertexPicker.workingPlane = workingPlane;

// å¯ç”¨é¡¶ç‚¹æ‹¾å–
vertexPicker.enabled = true;

// è·å–é¡¶ç‚¹
const pickedVertex = vertexPicker.get(world);
if (pickedVertex) {
  console.log("æ‹¾å–çš„é¡¶ç‚¹:", pickedVertex);
}
```

#### å›¾å½¢åŒ–é¡¶ç‚¹æ‹¾å–å™¨

```typescript
import { GraphicVertexPicker } from "@thatopen/components-front";

// åˆ›å»ºå›¾å½¢åŒ–é¡¶ç‚¹æ‹¾å–å™¨
const graphicPicker = new GraphicVertexPicker(components, {
  snapDistance: 0.25
});

// è®¾ç½®æ ‡è®°æ ·å¼
graphicPicker.className = "custom-vertex-marker";

// å¯ç”¨æ‹¾å–å™¨
graphicPicker.enabled = true;

// è·å–é¡¶ç‚¹ï¼ˆä¼šæ˜¾ç¤ºå¯è§†åŒ–æ ‡è®°ï¼‰
const vertex = graphicPicker.get(world);
if (vertex) {
  console.log("å›¾å½¢åŒ–æ‹¾å–çš„é¡¶ç‚¹:", vertex);
  
  // æ ‡è®°ä¼šè‡ªåŠ¨æ˜¾ç¤ºåœ¨æ‹¾å–ä½ç½®
  if (graphicPicker.marker) {
    graphicPicker.marker.visible = true;
  }
}
```

### æè´¨å·¥å…· (Materials)

æè´¨å·¥å…·æä¾›æè´¨ç®¡ç†å’Œåˆ›å»ºåŠŸèƒ½ã€‚

```typescript
// åˆ›å»ºæ ‡å‡†æè´¨
function createStandardMaterial(color: number, opacity: number = 1) {
  return new THREE.MeshStandardMaterial({
    color,
    opacity,
    transparent: opacity < 1,
    side: THREE.DoubleSide
  });
}

// åˆ›å»ºçº¿æ¡†æè´¨
function createWireframeMaterial(color: number) {
  return new THREE.MeshBasicMaterial({
    color,
    wireframe: true,
    transparent: true,
    opacity: 0.3
  });
}

// æè´¨ç®¡ç†å™¨
class MaterialManager {
  private materials = new Map<string, THREE.Material>();
  
  create(name: string, config: any): THREE.Material {
    let material: THREE.Material;
    
    switch (config.type) {
      case 'standard':
        material = createStandardMaterial(config.color, config.opacity);
        break;
      case 'wireframe':
        material = createWireframeMaterial(config.color);
        break;
      default:
        material = new THREE.MeshBasicMaterial({ color: config.color });
    }
    
    this.materials.set(name, material);
    return material;
  }
  
  get(name: string): THREE.Material | undefined {
    return this.materials.get(name);
  }
  
  dispose() {
    for (const material of this.materials.values()) {
      material.dispose();
    }
    this.materials.clear();
  }
}
```

### UUID å·¥å…·

```typescript
import { generateUUID } from "@thatopen/components";

// ç”Ÿæˆå”¯ä¸€æ ‡è¯†ç¬¦
const elementId = generateUUID();
console.log("ç”Ÿæˆçš„ UUID:", elementId);

// åœ¨ç»„ä»¶ä¸­ä½¿ç”¨
class CustomComponent extends OBC.Component {
  static readonly uuid = generateUUID();
  
  constructor(components: OBC.Components) {
    super(components);
    this.components.add(CustomComponent.uuid, this);
  }
}
```

### æˆªé¢ç”Ÿæˆå™¨ (Section Generator)

æˆªé¢ç”Ÿæˆå™¨ç”¨äºåˆ›å»ºå»ºç­‘æˆªé¢å’Œå‰–é¢ã€‚

```typescript
// åˆ›å»ºæ°´å¹³æˆªé¢
function createHorizontalSection(
  elevation: number,
  boundingBox: THREE.Box3
): THREE.Plane {
  const normal = new THREE.Vector3(0, 1, 0);
  const point = new THREE.Vector3(0, elevation, 0);
  return new THREE.Plane(normal, -normal.dot(point));
}

// åˆ›å»ºå‚ç›´æˆªé¢
function createVerticalSection(
  direction: THREE.Vector3,
  position: THREE.Vector3
): THREE.Plane {
  const normal = direction.normalize();
  return new THREE.Plane(normal, -normal.dot(position));
}

// æˆªé¢ç®¡ç†å™¨
class SectionManager {
  private sections: THREE.Plane[] = [];
  
  addHorizontalSection(elevation: number) {
    const section = createHorizontalSection(elevation, this.getBoundingBox());
    this.sections.push(section);
    return section;
  }
  
  addVerticalSection(direction: THREE.Vector3, position: THREE.Vector3) {
    const section = createVerticalSection(direction, position);
    this.sections.push(section);
    return section;
  }
  
  private getBoundingBox(): THREE.Box3 {
    // è·å–åœºæ™¯è¾¹ç•Œæ¡†
    const box = new THREE.Box3();
    // å®ç°è·å–åœºæ™¯è¾¹ç•Œæ¡†çš„é€»è¾‘
    return box;
  }
}
```

### è¾¹ç•Œæ¡†å·¥å…· (BBox)

```typescript
// è®¡ç®— Fragment è¾¹ç•Œæ¡†
function getFragmentBoundingBox(fragment: FRAGS.Fragment): THREE.Box3 {
  const box = new THREE.Box3();
  box.setFromObject(fragment.mesh);
  return box;
}

// è®¡ç®—å¤šä¸ªå¯¹è±¡çš„è”åˆè¾¹ç•Œæ¡†
function getUnionBoundingBox(objects: THREE.Object3D[]): THREE.Box3 {
  const box = new THREE.Box3();
  
  for (const object of objects) {
    const objectBox = new THREE.Box3();
    objectBox.setFromObject(object);
    box.union(objectBox);
  }
  
  return box;
}

// è¾¹ç•Œæ¡†å·¥å…·ç±»
class BoundingBoxUtils {
  static getCenter(box: THREE.Box3): THREE.Vector3 {
    return box.getCenter(new THREE.Vector3());
  }
  
  static getSize(box: THREE.Box3): THREE.Vector3 {
    return box.getSize(new THREE.Vector3());
  }
  
  static expandBox(box: THREE.Box3, margin: number): THREE.Box3 {
    const expandedBox = box.clone();
    const expansion = new THREE.Vector3(margin, margin, margin);
    expandedBox.expandByVector(expansion);
    return expandedBox;
  }
  
  static intersects(box1: THREE.Box3, box2: THREE.Box3): boolean {
    return box1.intersectsBox(box2);
  }
}
```

## æœ€ä½³å®è·µæŒ‡å—

### 1. ç»„ä»¶æ¶æ„è®¾è®¡

#### ç»„ä»¶ç»§æ‰¿ç»“æ„

```typescript
// åŸºç¡€ç»„ä»¶æ¥å£
interface BaseComponentConfig {
  enabled?: boolean;
  visible?: boolean;
}

// æŠ½è±¡åŸºç¡€ç»„ä»¶
abstract class BaseCustomComponent extends OBC.Component {
  protected config: BaseComponentConfig;
  
  constructor(
    components: OBC.Components,
    config: BaseComponentConfig = {}
  ) {
    super(components);
    this.config = {
      enabled: true,
      visible: true,
      ...config
    };
  }
  
  get enabled(): boolean {
    return this.config.enabled ?? true;
  }
  
  set enabled(value: boolean) {
    this.config.enabled = value;
    this.onEnabledChanged(value);
  }
  
  protected abstract onEnabledChanged(enabled: boolean): void;
}

// å…·ä½“ç»„ä»¶å®ç°
class CustomMeasurementTool extends BaseCustomComponent {
  static readonly uuid = "custom-measurement-tool";
  
  protected onEnabledChanged(enabled: boolean): void {
    // å®ç°å¯ç”¨/ç¦ç”¨é€»è¾‘
    this.setupEvents(enabled);
  }
  
  private setupEvents(enabled: boolean) {
    // äº‹ä»¶è®¾ç½®é€»è¾‘
  }
}
```

#### ç»„ä»¶æ³¨å†Œå’Œç®¡ç†

```typescript
// ç»„ä»¶æ³¨å†Œç®¡ç†å™¨
class ComponentRegistry {
  private static instance: ComponentRegistry;
  private components = new Map<string, typeof OBC.Component>();
  
  static getInstance(): ComponentRegistry {
    if (!ComponentRegistry.instance) {
      ComponentRegistry.instance = new ComponentRegistry();
    }
    return ComponentRegistry.instance;
  }
  
  register<T extends OBC.Component>(
    uuid: string,
    componentClass: new (components: OBC.Components) => T
  ) {
    this.components.set(uuid, componentClass as any);
  }
  
  create<T extends OBC.Component>(
    uuid: string,
    components: OBC.Components
  ): T | null {
    const ComponentClass = this.components.get(uuid);
    if (ComponentClass) {
      return new ComponentClass(components) as T;
    }
    return null;
  }
  
  getRegistered(): string[] {
    return Array.from(this.components.keys());
  }
}

// ä½¿ç”¨ç»„ä»¶æ³¨å†Œå™¨
const registry = ComponentRegistry.getInstance();
registry.register(CustomMeasurementTool.uuid, CustomMeasurementTool);

// åˆ›å»ºç»„ä»¶å®ä¾‹
const tool = registry.create<CustomMeasurementTool>(
  CustomMeasurementTool.uuid,
  components
);
```

### 2. å†…å­˜ç®¡ç†æœ€ä½³å®è·µ

#### èµ„æºç”Ÿå‘½å‘¨æœŸç®¡ç†

```typescript
// èµ„æºç®¡ç†å™¨
class ResourceManager {
  private resources: OBC.Disposable[] = [];
  private textures: THREE.Texture[] = [];
  private geometries: THREE.BufferGeometry[] = [];
  private materials: THREE.Material[] = [];
  
  // æ³¨å†Œå¯é‡Šæ”¾èµ„æº
  registerDisposable(resource: OBC.Disposable) {
    this.resources.push(resource);
  }
  
  // æ³¨å†Œ Three.js èµ„æº
  registerTexture(texture: THREE.Texture) {
    this.textures.push(texture);
  }
  
  registerGeometry(geometry: THREE.BufferGeometry) {
    this.geometries.push(geometry);
  }
  
  registerMaterial(material: THREE.Material) {
    this.materials.push(material);
  }
  
  // æ¸…ç†æ‰€æœ‰èµ„æº
  dispose() {
    // æ¸…ç†ç»„ä»¶èµ„æº
    for (const resource of this.resources) {
      try {
        resource.dispose();
      } catch (error) {
        console.warn("èµ„æºæ¸…ç†å¤±è´¥:", error);
      }
    }
    
    // æ¸…ç† Three.js èµ„æº
    for (const texture of this.textures) {
      texture.dispose();
    }
    
    for (const geometry of this.geometries) {
      geometry.dispose();
    }
    
    for (const material of this.materials) {
      material.dispose();
    }
    
    // æ¸…ç©ºæ•°ç»„
    this.resources.length = 0;
    this.textures.length = 0;
    this.geometries.length = 0;
    this.materials.length = 0;
  }
}

// åœ¨ç»„ä»¶ä¸­ä½¿ç”¨èµ„æºç®¡ç†å™¨
class ManagedComponent extends OBC.Component implements OBC.Disposable {
  readonly onDisposed = new OBC.Event();
  private resourceManager = new ResourceManager();
  
  constructor(components: OBC.Components) {
    super(components);
    
    // æ³¨å†Œè‡ªèº«åˆ°èµ„æºç®¡ç†å™¨
    this.resourceManager.registerDisposable(this);
  }
  
  createMaterial(): THREE.Material {
    const material = new THREE.MeshStandardMaterial();
    this.resourceManager.registerMaterial(material);
    return material;
  }
  
  dispose() {
    this.resourceManager.dispose();
    this.onDisposed.trigger();
    this.onDisposed.reset();
  }
}
```

#### å†…å­˜æ³„æ¼æ£€æµ‹

```typescript
// å†…å­˜ç›‘æ§å™¨
class MemoryMonitor {
  private static instance: MemoryMonitor;
  private intervalId: number | null = null;
  private thresholds = {
    warning: 100 * 1024 * 1024,  // 100MB
    critical: 500 * 1024 * 1024  // 500MB
  };
  
  static getInstance(): MemoryMonitor {
    if (!MemoryMonitor.instance) {
      MemoryMonitor.instance = new MemoryMonitor();
    }
    return MemoryMonitor.instance;
  }
  
  startMonitoring(interval: number = 5000) {
    this.intervalId = setInterval(() => {
      this.checkMemoryUsage();
    }, interval);
  }
  
  stopMonitoring() {
    if (this.intervalId) {
      clearInterval(this.intervalId);
      this.intervalId = null;
    }
  }
  
  private checkMemoryUsage() {
    if ('memory' in performance) {
      const memory = (performance as any).memory;
      const used = memory.usedJSHeapSize;
      
      if (used > this.thresholds.critical) {
        console.error(`å†…å­˜ä½¿ç”¨è¿‡é«˜: ${(used / 1024 / 1024).toFixed(2)}MB`);
        this.triggerGarbageCollection();
      } else if (used > this.thresholds.warning) {
        console.warn(`å†…å­˜ä½¿ç”¨è­¦å‘Š: ${(used / 1024 / 1024).toFixed(2)}MB`);
      }
    }
  }
  
  private triggerGarbageCollection() {
    // è§¦å‘åƒåœ¾å›æ”¶ï¼ˆä»…åœ¨å¼€å‘ç¯å¢ƒï¼‰
    if ('gc' in window) {
      (window as any).gc();
    }
  }
}

// å¯åŠ¨å†…å­˜ç›‘æ§
const memoryMonitor = MemoryMonitor.getInstance();
memoryMonitor.startMonitoring();
```

### 3. æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

#### æ¸²æŸ“æ€§èƒ½ä¼˜åŒ–

```typescript
// æ€§èƒ½ç›‘æ§å™¨
class PerformanceMonitor {
  private frameCount = 0;
  private lastTime = performance.now();
  private fps = 0;
  
  update() {
    this.frameCount++;
    const currentTime = performance.now();
    
    if (currentTime - this.lastTime >= 1000) {
      this.fps = this.frameCount;
      this.frameCount = 0;
      this.lastTime = currentTime;
      
      // æ€§èƒ½è­¦å‘Š
      if (this.fps < 30) {
        console.warn(`FPS è¿‡ä½: ${this.fps}`);
        this.suggestOptimizations();
      }
    }
  }
  
  private suggestOptimizations() {
    console.log("æ€§èƒ½ä¼˜åŒ–å»ºè®®:");
    console.log("- å‡å°‘æ¸²æŸ“çš„å‡ ä½•ä½“æ•°é‡");
    console.log("- ä½¿ç”¨ LOD (Level of Detail)");
    console.log("- å¯ç”¨è§†é”¥ä½“å‰”é™¤");
    console.log("- å‡å°‘æè´¨å¤æ‚åº¦");
  }
  
  getFPS(): number {
    return this.fps;
  }
}

// LOD ç®¡ç†å™¨
class LODManager {
  private lodObjects = new Map<string, THREE.LOD>();
  
  createLOD(
    id: string,
    highDetail: THREE.Object3D,
    mediumDetail: THREE.Object3D,
    lowDetail: THREE.Object3D
  ): THREE.LOD {
    const lod = new THREE.LOD();
    
    lod.addLevel(highDetail, 0);    // 0-50 è·ç¦»
    lod.addLevel(mediumDetail, 50); // 50-200 è·ç¦»
    lod.addLevel(lowDetail, 200);   // 200+ è·ç¦»
    
    this.lodObjects.set(id, lod);
    return lod;
  }
  
  updateLOD(camera: THREE.Camera) {
    for (const lod of this.lodObjects.values()) {
      lod.update(camera);
    }
  }
  
  dispose() {
    for (const lod of this.lodObjects.values()) {
      lod.clear();
    }
    this.lodObjects.clear();
  }
}
```

#### å¼‚æ­¥åŠ è½½ä¼˜åŒ–

```typescript
// å¼‚æ­¥åŠ è½½ç®¡ç†å™¨
class AsyncLoadManager {
  private loadQueue: Array<() => Promise<any>> = [];
  private maxConcurrent = 3;
  private currentLoading = 0;
  
  async addToQueue<T>(loadFunction: () => Promise<T>): Promise<T> {
    return new Promise((resolve, reject) => {
      this.loadQueue.push(async () => {
        try {
          const result = await loadFunction();
          resolve(result);
        } catch (error) {
          reject(error);
        }
      });
      
      this.processQueue();
    });
  }
  
  private async processQueue() {
    if (this.currentLoading >= this.maxConcurrent || this.loadQueue.length === 0) {
      return;
    }
    
    const loadFunction = this.loadQueue.shift();
    if (!loadFunction) return;
    
    this.currentLoading++;
    
    try {
      await loadFunction();
    } finally {
      this.currentLoading--;
      this.processQueue(); // å¤„ç†ä¸‹ä¸€ä¸ª
    }
  }
}

// ä½¿ç”¨å¼‚æ­¥åŠ è½½ç®¡ç†å™¨
const loadManager = new AsyncLoadManager();

// æ‰¹é‡åŠ è½½ IFC æ–‡ä»¶
async function loadMultipleIFCFiles(files: File[]) {
  const ifcLoader = components.get(OBC.IfcLoader);
  const results = [];
  
  for (const file of files) {
    const result = await loadManager.addToQueue(async () => {
      console.log(`å¼€å§‹åŠ è½½: ${file.name}`);
      const model = await ifcLoader.load(file);
      console.log(`å®ŒæˆåŠ è½½: ${file.name}`);
      return model;
    });
    
    results.push(result);
  }
  
  return results;
}
```

### 4. é”™è¯¯å¤„ç†å’Œè°ƒè¯•

#### é”™è¯¯å¤„ç†ç­–ç•¥

```typescript
// é”™è¯¯ç±»å‹å®šä¹‰
enum ErrorType {
  COMPONENT_INIT = "COMPONENT_INIT",
  FILE_LOAD = "FILE_LOAD",
  RENDER = "RENDER",
  MEMORY = "MEMORY",
  NETWORK = "NETWORK"
}

class BIMError extends Error {
  constructor(
    public type: ErrorType,
    message: string,
    public context?: any
  ) {
    super(message);
    this.name = "BIMError";
  }
}

// é”™è¯¯å¤„ç†å™¨
class ErrorHandler {
  private static instance: ErrorHandler;
  private errorCallbacks = new Map<ErrorType, Array<(error: BIMError) => void>>();
  
  static getInstance(): ErrorHandler {
    if (!ErrorHandler.instance) {
      ErrorHandler.instance = new ErrorHandler();
    }
    return ErrorHandler.instance;
  }
  
  onError(type: ErrorType, callback: (error: BIMError) => void) {
    if (!this.errorCallbacks.has(type)) {
      this.errorCallbacks.set(type, []);
    }
    this.errorCallbacks.get(type)!.push(callback);
  }
  
  handleError(error: BIMError) {
    console.error(`[${error.type}] ${error.message}`, error.context);
    
    const callbacks = this.errorCallbacks.get(error.type);
    if (callbacks) {
      for (const callback of callbacks) {
        try {
          callback(error);
        } catch (callbackError) {
          console.error("é”™è¯¯å›è°ƒæ‰§è¡Œå¤±è´¥:", callbackError);
        }
      }
    }
  }
}

// ä½¿ç”¨é”™è¯¯å¤„ç†å™¨
const errorHandler = ErrorHandler.getInstance();

// æ³¨å†Œé”™è¯¯å¤„ç†å›è°ƒ
errorHandler.onError(ErrorType.FILE_LOAD, (error) => {
  // æ˜¾ç¤ºç”¨æˆ·å‹å¥½çš„é”™è¯¯æ¶ˆæ¯
  showUserMessage(`æ–‡ä»¶åŠ è½½å¤±è´¥: ${error.message}`);
});

errorHandler.onError(ErrorType.MEMORY, (error) => {
  // è§¦å‘å†…å­˜æ¸…ç†
  triggerMemoryCleanup();
});

// å®‰å…¨çš„ç»„ä»¶åˆå§‹åŒ–
async function safeInitializeComponent<T extends OBC.Component>(
  ComponentClass: new (components: OBC.Components) => T,
  components: OBC.Components
): Promise<T | null> {
  try {
    const component = new ComponentClass(components);
    
    // å¦‚æœç»„ä»¶æœ‰å¼‚æ­¥åˆå§‹åŒ–æ–¹æ³•
    if ('init' in component && typeof component.init === 'function') {
      await (component as any).init();
    }
    
    return component;
  } catch (error) {
    const bimError = new BIMError(
      ErrorType.COMPONENT_INIT,
      `ç»„ä»¶åˆå§‹åŒ–å¤±è´¥: ${ComponentClass.name}`,
      { error, ComponentClass }
    );
    
    errorHandler.handleError(bimError);
    return null;
  }
}
```

#### è°ƒè¯•å·¥å…·

```typescript
// è°ƒè¯•å·¥å…·ç±»
class DebugTools {
  private static instance: DebugTools;
  private debugPanel: HTMLElement | null = null;
  
  static getInstance(): DebugTools {
    if (!DebugTools.instance) {
      DebugTools.instance = new DebugTools();
    }
    return DebugTools.instance;
  }
  
  createDebugPanel() {
    if (this.debugPanel) return;
    
    this.debugPanel = document.createElement('div');
    this.debugPanel.style.cssText = `
      position: fixed;
      top: 10px;
      right: 10px;
      width: 300px;
      background: rgba(0,0,0,0.8);
      color: white;
      padding: 10px;
      font-family: monospace;
      font-size: 12px;
      z-index: 10000;
      border-radius: 5px;
    `;
    
    document.body.appendChild(this.debugPanel);
  }
  
  updateDebugInfo(info: Record<string, any>) {
    if (!this.debugPanel) return;
    
    const html = Object.entries(info)
      .map(([key, value]) => `<div>${key}: ${value}</div>`)
      .join('');
    
    this.debugPanel.innerHTML = html;
  }
  
  logComponentState(component: OBC.Component) {
    console.group(`ç»„ä»¶çŠ¶æ€: ${component.constructor.name}`);
    console.log('UUID:', (component.constructor as any).uuid);
    console.log('Enabled:', component.enabled);
    console.log('Component:', component);
    console.groupEnd();
  }
  
  logFragmentInfo(fragment: FRAGS.Fragment) {
    console.group(`Fragment ä¿¡æ¯: ${fragment.id}`);
    console.log('Items count:', fragment.items.size);
    console.log('Capacity:', fragment.capacity);
    console.log('Mesh:', fragment.mesh);
    console.log('Materials:', fragment.mesh.material);
    console.groupEnd();
  }
}

// åœ¨å¼€å‘ç¯å¢ƒä¸­å¯ç”¨è°ƒè¯•
if (process.env.NODE_ENV === 'development') {
  const debugTools = DebugTools.getInstance();
  debugTools.createDebugPanel();
  
  // å®šæœŸæ›´æ–°è°ƒè¯•ä¿¡æ¯
  setInterval(() => {
    const info = {
      'FPS': performanceMonitor.getFPS(),
      'Memory': `${(performance as any).memory?.usedJSHeapSize / 1024 / 1024 || 0}MB`,
      'Components': components.list.size,
      'Fragments': fragmentsManager.list.size
    };
    
    debugTools.updateDebugInfo(info);
  }, 1000);
}
```

### 5. é…ç½®ç®¡ç†

```typescript
// é…ç½®ç®¡ç†å™¨
class ConfigManager {
  private static instance: ConfigManager;
  private config: Record<string, any> = {};
  
  static getInstance(): ConfigManager {
    if (!ConfigManager.instance) {
      ConfigManager.instance = new ConfigManager();
    }
    return ConfigManager.instance;
  }
  
  set(key: string, value: any) {
    this.config[key] = value;
    this.saveToStorage();
  }
  
  get<T>(key: string, defaultValue?: T): T {
    return this.config[key] ?? defaultValue;
  }
  
  loadFromStorage() {
    try {
      const stored = localStorage.getItem('bim-app-config');
      if (stored) {
        this.config = JSON.parse(stored);
      }
    } catch (error) {
      console.warn('é…ç½®åŠ è½½å¤±è´¥:', error);
    }
  }
  
  private saveToStorage() {
    try {
      localStorage.setItem('bim-app-config', JSON.stringify(this.config));
    } catch (error) {
      console.warn('é…ç½®ä¿å­˜å¤±è´¥:', error);
    }
  }
  
  reset() {
    this.config = {};
    localStorage.removeItem('bim-app-config');
  }
}

// ä½¿ç”¨é…ç½®ç®¡ç†å™¨
const config = ConfigManager.getInstance();
config.loadFromStorage();

// è®¾ç½®é»˜è®¤é…ç½®
config.set('renderer.antialias', true);
config.set('camera.fov', 75);
config.set('highlighter.selectionColor', '#BCF124');

// åœ¨ç»„ä»¶ä¸­ä½¿ç”¨é…ç½®
class ConfigurableComponent extends OBC.Component {
  constructor(components: OBC.Components) {
    super(components);
    
    // ä»é…ç½®åŠ è½½è®¾ç½®
    this.loadConfiguration();
  }
  
  private loadConfiguration() {
    const config = ConfigManager.getInstance();
    
    // åº”ç”¨é…ç½®
    this.enabled = config.get('components.enabled', true);
    // å…¶ä»–é…ç½®...
  }
}
```

## æ€»ç»“

é€šè¿‡åˆç†ä½¿ç”¨å·¥å…·ç±»å’Œéµå¾ªæœ€ä½³å®è·µï¼Œå¯ä»¥æ„å»ºé«˜è´¨é‡ã€é«˜æ€§èƒ½çš„ BIM åº”ç”¨ï¼š

1. **å·¥å…·ç±»ä½¿ç”¨**ï¼šå……åˆ†åˆ©ç”¨æä¾›çš„å‡ ä½•ã€æè´¨ã€é¡¶ç‚¹æ‹¾å–ç­‰å·¥å…·ç±»
2. **æ¶æ„è®¾è®¡**ï¼šé‡‡ç”¨æ¸…æ™°çš„ç»„ä»¶æ¶æ„å’Œç»§æ‰¿ç»“æ„
3. **å†…å­˜ç®¡ç†**ï¼šå®æ–½ä¸¥æ ¼çš„èµ„æºç”Ÿå‘½å‘¨æœŸç®¡ç†
4. **æ€§èƒ½ä¼˜åŒ–**ï¼šä½¿ç”¨ LODã€å¼‚æ­¥åŠ è½½ç­‰ä¼˜åŒ–ç­–ç•¥
5. **é”™è¯¯å¤„ç†**ï¼šå»ºç«‹å®Œå–„çš„é”™è¯¯å¤„ç†å’Œè°ƒè¯•æœºåˆ¶
6. **é…ç½®ç®¡ç†**ï¼šå®ç°çµæ´»çš„é…ç½®ç³»ç»Ÿ

è¿™äº›å®è·µå°†å¸®åŠ©å¼€å‘è€…æ„å»ºç¨³å®šã€é«˜æ•ˆçš„ BIM åº”ç”¨ç¨‹åºã€‚

## é«˜çº§å¼€å‘æ¨¡å¼

### 1. æ’ä»¶åŒ–æ¶æ„

```typescript
// æ’ä»¶æ¥å£å®šä¹‰
interface Plugin {
  name: string;
  version: string;
  dependencies?: string[];
  install(components: OBC.Components): Promise<void>;
  uninstall(): Promise<void>;
}

// æ’ä»¶ç®¡ç†å™¨
class PluginManager {
  private plugins = new Map<string, Plugin>();
  private loadedPlugins = new Set<string>();

  async loadPlugin(plugin: Plugin): Promise<void> {
    // æ£€æŸ¥ä¾èµ–
    if (plugin.dependencies) {
      for (const dep of plugin.dependencies) {
        if (!this.loadedPlugins.has(dep)) {
          throw new Error(`Missing dependency: ${dep}`);
        }
      }
    }

    // å®‰è£…æ’ä»¶
    await plugin.install(this.components);
    this.plugins.set(plugin.name, plugin);
    this.loadedPlugins.add(plugin.name);

    console.log(`Plugin loaded: ${plugin.name} v${plugin.version}`);
  }

  async unloadPlugin(name: string): Promise<void> {
    const plugin = this.plugins.get(name);
    if (plugin) {
      await plugin.uninstall();
      this.plugins.delete(name);
      this.loadedPlugins.delete(name);
    }
  }
}

// ç¤ºä¾‹æ’ä»¶
class MeasurementPlugin implements Plugin {
  name = "measurement-tools";
  version = "1.0.0";

  async install(components: OBC.Components): Promise<void> {
    // æ³¨å†Œæµ‹é‡å·¥å…·
    const lengthTool = new LengthMeasurement(components);
    components.add("length-measurement", lengthTool);
  }

  async uninstall(): Promise<void> {
    // æ¸…ç†èµ„æº
  }
}
```

### 2. çŠ¶æ€ç®¡ç†æ¨¡å¼

```typescript
// åº”ç”¨çŠ¶æ€ç®¡ç†
interface AppState {
  currentTool: string;
  selectedElements: Set<string>;
  viewMode: 'perspective' | 'orthographic';
  showGrid: boolean;
  measurements: any[];
}

class StateManager {
  private state: AppState = {
    currentTool: 'select',
    selectedElements: new Set(),
    viewMode: 'perspective',
    showGrid: true,
    measurements: []
  };

  private listeners = new Map<keyof AppState, Set<(value: any) => void>>();

  get<K extends keyof AppState>(key: K): AppState[K] {
    return this.state[key];
  }

  set<K extends keyof AppState>(key: K, value: AppState[K]): void {
    const oldValue = this.state[key];
    this.state[key] = value;

    // é€šçŸ¥ç›‘å¬å™¨
    const keyListeners = this.listeners.get(key);
    if (keyListeners) {
      keyListeners.forEach(listener => listener(value));
    }

    console.log(`State changed: ${key}`, { oldValue, newValue: value });
  }

  subscribe<K extends keyof AppState>(
    key: K,
    listener: (value: AppState[K]) => void
  ): () => void {
    if (!this.listeners.has(key)) {
      this.listeners.set(key, new Set());
    }

    this.listeners.get(key)!.add(listener);

    // è¿”å›å–æ¶ˆè®¢é˜…å‡½æ•°
    return () => {
      this.listeners.get(key)?.delete(listener);
    };
  }
}
```

### 3. é…ç½®ç®¡ç†ç³»ç»Ÿ

```typescript
// é…ç½®ç®¡ç†
interface AppConfig {
  rendering: {
    antialias: boolean;
    shadows: boolean;
    postprocessing: boolean;
  };
  measurement: {
    precision: number;
    snapDistance: number;
    showLabels: boolean;
  };
  ui: {
    theme: 'light' | 'dark';
    language: string;
    showTooltips: boolean;
  };
}

class ConfigManager {
  private config: AppConfig;
  private readonly storageKey = 'bim-app-config';

  constructor() {
    this.config = this.loadConfig();
  }

  private getDefaultConfig(): AppConfig {
    return {
      rendering: {
        antialias: true,
        shadows: true,
        postprocessing: false
      },
      measurement: {
        precision: 2,
        snapDistance: 0.25,
        showLabels: true
      },
      ui: {
        theme: 'light',
        language: 'zh-CN',
        showTooltips: true
      }
    };
  }

  private loadConfig(): AppConfig {
    try {
      const stored = localStorage.getItem(this.storageKey);
      if (stored) {
        const parsed = JSON.parse(stored);
        return { ...this.getDefaultConfig(), ...parsed };
      }
    } catch (error) {
      console.warn('Failed to load config:', error);
    }

    return this.getDefaultConfig();
  }

  saveConfig(): void {
    try {
      localStorage.setItem(this.storageKey, JSON.stringify(this.config));
    } catch (error) {
      console.error('Failed to save config:', error);
    }
  }

  get<K extends keyof AppConfig>(section: K): AppConfig[K] {
    return this.config[section];
  }

  set<K extends keyof AppConfig>(section: K, value: Partial<AppConfig[K]>): void {
    this.config[section] = { ...this.config[section], ...value };
    this.saveConfig();
  }

  reset(): void {
    this.config = this.getDefaultConfig();
    this.saveConfig();
  }
}
```

## è°ƒè¯•å’Œè¯Šæ–­å·¥å…·

### 1. æ€§èƒ½ç›‘æ§

```typescript
// æ€§èƒ½ç›‘æ§å™¨
class PerformanceMonitor {
  private metrics = new Map<string, number[]>();
  private isMonitoring = false;

  start(): void {
    this.isMonitoring = true;
    this.monitorFrameRate();
    this.monitorMemoryUsage();
  }

  stop(): void {
    this.isMonitoring = false;
  }

  private monitorFrameRate(): void {
    let lastTime = performance.now();
    let frameCount = 0;

    const measure = () => {
      if (!this.isMonitoring) return;

      frameCount++;
      const currentTime = performance.now();

      if (currentTime - lastTime >= 1000) {
        const fps = frameCount;
        this.recordMetric('fps', fps);

        frameCount = 0;
        lastTime = currentTime;
      }

      requestAnimationFrame(measure);
    };

    requestAnimationFrame(measure);
  }

  private monitorMemoryUsage(): void {
    const monitor = () => {
      if (!this.isMonitoring) return;

      if ('memory' in performance) {
        const memory = (performance as any).memory;
        this.recordMetric('memory', memory.usedJSHeapSize / 1024 / 1024);
      }

      setTimeout(monitor, 1000);
    };

    monitor();
  }

  private recordMetric(name: string, value: number): void {
    if (!this.metrics.has(name)) {
      this.metrics.set(name, []);
    }

    const values = this.metrics.get(name)!;
    values.push(value);

    // ä¿æŒæœ€è¿‘100ä¸ªå€¼
    if (values.length > 100) {
      values.shift();
    }
  }

  getMetrics(): Record<string, { current: number; average: number; max: number }> {
    const result: any = {};

    for (const [name, values] of this.metrics) {
      if (values.length > 0) {
        const current = values[values.length - 1];
        const average = values.reduce((a, b) => a + b, 0) / values.length;
        const max = Math.max(...values);

        result[name] = { current, average, max };
      }
    }

    return result;
  }
}
```

### 2. é”™è¯¯å¤„ç†å’Œæ—¥å¿—ç³»ç»Ÿ

```typescript
// æ—¥å¿—çº§åˆ«
enum LogLevel {
  DEBUG = 0,
  INFO = 1,
  WARN = 2,
  ERROR = 3
}

// æ—¥å¿—ç®¡ç†å™¨
class Logger {
  private static instance: Logger;
  private level: LogLevel = LogLevel.INFO;
  private logs: Array<{ level: LogLevel; message: string; timestamp: Date; data?: any }> = [];

  static getInstance(): Logger {
    if (!Logger.instance) {
      Logger.instance = new Logger();
    }
    return Logger.instance;
  }

  setLevel(level: LogLevel): void {
    this.level = level;
  }

  debug(message: string, data?: any): void {
    this.log(LogLevel.DEBUG, message, data);
  }

  info(message: string, data?: any): void {
    this.log(LogLevel.INFO, message, data);
  }

  warn(message: string, data?: any): void {
    this.log(LogLevel.WARN, message, data);
  }

  error(message: string, data?: any): void {
    this.log(LogLevel.ERROR, message, data);
  }

  private log(level: LogLevel, message: string, data?: any): void {
    if (level < this.level) return;

    const logEntry = {
      level,
      message,
      timestamp: new Date(),
      data
    };

    this.logs.push(logEntry);

    // æ§åˆ¶å°è¾“å‡º
    const levelName = LogLevel[level];
    const timestamp = logEntry.timestamp.toISOString();

    switch (level) {
      case LogLevel.DEBUG:
        console.debug(`[${timestamp}] DEBUG: ${message}`, data);
        break;
      case LogLevel.INFO:
        console.info(`[${timestamp}] INFO: ${message}`, data);
        break;
      case LogLevel.WARN:
        console.warn(`[${timestamp}] WARN: ${message}`, data);
        break;
      case LogLevel.ERROR:
        console.error(`[${timestamp}] ERROR: ${message}`, data);
        break;
    }

    // ä¿æŒæœ€è¿‘1000æ¡æ—¥å¿—
    if (this.logs.length > 1000) {
      this.logs.shift();
    }
  }

  getLogs(level?: LogLevel): typeof this.logs {
    if (level !== undefined) {
      return this.logs.filter(log => log.level >= level);
    }
    return [...this.logs];
  }

  exportLogs(): string {
    return JSON.stringify(this.logs, null, 2);
  }

  clear(): void {
    this.logs.length = 0;
  }
}

// å…¨å±€é”™è¯¯å¤„ç†
class ErrorHandler {
  private logger = Logger.getInstance();

  constructor() {
    this.setupGlobalHandlers();
  }

  private setupGlobalHandlers(): void {
    // æ•è·æœªå¤„ç†çš„ Promise æ‹’ç»
    window.addEventListener('unhandledrejection', (event) => {
      this.logger.error('Unhandled Promise Rejection', {
        reason: event.reason,
        stack: event.reason?.stack
      });
    });

    // æ•è·å…¨å±€é”™è¯¯
    window.addEventListener('error', (event) => {
      this.logger.error('Global Error', {
        message: event.message,
        filename: event.filename,
        lineno: event.lineno,
        colno: event.colno,
        error: event.error
      });
    });
  }

  handleComponentError(componentName: string, error: Error): void {
    this.logger.error(`Component Error: ${componentName}`, {
      message: error.message,
      stack: error.stack,
      name: error.name
    });
  }
}
```

## é¡¹ç›®ç»“æ„å»ºè®®

```
src/
â”œâ”€â”€ core/                   # æ ¸å¿ƒåŠŸèƒ½
â”‚   â”œâ”€â”€ components/         # ç»„ä»¶å®šä¹‰
â”‚   â”œâ”€â”€ services/          # æœåŠ¡å±‚
â”‚   â””â”€â”€ utils/             # å·¥å…·å‡½æ•°
â”œâ”€â”€ features/              # åŠŸèƒ½æ¨¡å—
â”‚   â”œâ”€â”€ measurement/       # æµ‹é‡åŠŸèƒ½
â”‚   â”œâ”€â”€ navigation/        # å¯¼èˆªåŠŸèƒ½
â”‚   â””â”€â”€ collaboration/     # åä½œåŠŸèƒ½
â”œâ”€â”€ ui/                    # ç”¨æˆ·ç•Œé¢
â”‚   â”œâ”€â”€ components/        # UI ç»„ä»¶
â”‚   â”œâ”€â”€ layouts/          # å¸ƒå±€
â”‚   â””â”€â”€ styles/           # æ ·å¼
â”œâ”€â”€ config/               # é…ç½®æ–‡ä»¶
â”œâ”€â”€ types/                # ç±»å‹å®šä¹‰
â””â”€â”€ tests/                # æµ‹è¯•æ–‡ä»¶
```

## æ€»ç»“

é€šè¿‡æœ¬ç« çš„å­¦ä¹ ï¼Œæ‚¨å·²ç»æŒæ¡äº†ï¼š

1. **æ ¸å¿ƒå·¥å…·ç±»çš„ä½¿ç”¨æ–¹æ³•**
2. **ç»„ä»¶æ¶æ„è®¾è®¡åŸåˆ™**
3. **å†…å­˜ç®¡ç†æœ€ä½³å®è·µ**
4. **æ€§èƒ½ä¼˜åŒ–ç­–ç•¥**
5. **é”™è¯¯å¤„ç†å’Œè°ƒè¯•æŠ€å·§**
6. **é…ç½®ç®¡ç†ç³»ç»Ÿ**
7. **é«˜çº§å¼€å‘æ¨¡å¼**

è¿™äº›çŸ¥è¯†å°†å¸®åŠ©æ‚¨æ„å»ºä¸“ä¸šã€ç¨³å®šã€é«˜æ€§èƒ½çš„ BIM åº”ç”¨ç¨‹åºã€‚

---

> ğŸ¯ **å»ºè®®**: åœ¨å®é™…é¡¹ç›®ä¸­ï¼Œæ ¹æ®å…·ä½“éœ€æ±‚é€‰æ‹©åˆé€‚çš„å·¥å…·å’Œæ¨¡å¼ã€‚å§‹ç»ˆå…³æ³¨ä»£ç è´¨é‡ã€æ€§èƒ½å’Œç”¨æˆ·ä½“éªŒã€‚