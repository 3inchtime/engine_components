# å‰ç«¯ç»„ä»¶ç³»ç»Ÿ

## æ¦‚è¿°

@thatopen/components-front æä¾›äº†ä¸€å¥—ä¸“ä¸ºæµè§ˆå™¨ç¯å¢ƒè®¾è®¡çš„å‰ç«¯ç»„ä»¶ç³»ç»Ÿï¼ŒåŒ…æ‹¬é«˜äº®å™¨ã€æ ‡è®°å™¨ã€è£å‰ªè¾¹ç¼˜ã€å¹³é¢å›¾å¯¼èˆªç­‰é«˜çº§åŠŸèƒ½ã€‚è¿™äº›ç»„ä»¶ä¸“æ³¨äºç”¨æˆ·äº¤äº’å’Œå¯è§†åŒ–æ•ˆæœï¼Œä¸º BIM åº”ç”¨æä¾›ä¸°å¯Œçš„å‰ç«¯ä½“éªŒã€‚

## æ ¸å¿ƒç‰¹æ€§

- **äº¤äº’å¼é«˜äº®**ï¼šæ™ºèƒ½çš„å‡ ä½•ä½“é«˜äº®å’Œé€‰æ‹©ç³»ç»Ÿ
- **æ ‡è®°ç®¡ç†**ï¼š3D åœºæ™¯ä¸­çš„æ ‡è®°å’Œæ ‡ç­¾ç³»ç»Ÿ
- **è£å‰ªå¯è§†åŒ–**ï¼šè£å‰ªå¹³é¢çš„è¾¹ç¼˜å’Œå¡«å……æ•ˆæœ
- **å¹³é¢å›¾å¯¼èˆª**ï¼š2D å¹³é¢å›¾æµè§ˆå’Œå¯¼èˆª
- **åå¤„ç†æ¸²æŸ“**ï¼šé«˜çº§æ¸²æŸ“æ•ˆæœå’Œåå¤„ç†
- **äº‹ä»¶é©±åŠ¨**ï¼šå®Œæ•´çš„ç”¨æˆ·äº¤äº’äº‹ä»¶ç³»ç»Ÿ

## é«˜äº®å™¨ç³»ç»Ÿ (Highlighter)

### åŠŸèƒ½ç‰¹æ€§

é«˜äº®å™¨æ˜¯å‰ç«¯ç»„ä»¶ä¸­æœ€é‡è¦çš„äº¤äº’å·¥å…·ä¹‹ä¸€ï¼Œæä¾›æ™ºèƒ½çš„å‡ ä½•ä½“é€‰æ‹©å’Œé«˜äº®åŠŸèƒ½ã€‚

- **å¤šç§é«˜äº®æ¨¡å¼**ï¼šé€‰æ‹©é«˜äº®ã€æ‚¬åœé«˜äº®
- **å¤šé€‰æ”¯æŒ**ï¼šæ”¯æŒ Ctrl/Shift é”®å¤šé€‰
- **äº‹ä»¶ç³»ç»Ÿ**ï¼šå®Œæ•´çš„é«˜äº®äº‹ä»¶å›è°ƒ
- **è‡ªå®šä¹‰æ ·å¼**ï¼šå¯é…ç½®çš„é«˜äº®é¢œè‰²å’Œæ•ˆæœ
- **æ€§èƒ½ä¼˜åŒ–**ï¼šé«˜æ•ˆçš„ Fragment é«˜äº®ç®—æ³•

### åŸºç¡€ä½¿ç”¨

```typescript
import { Highlighter } from "@thatopen/components-front";
import * as OBC from "@thatopen/components";

// åˆ›å»ºé«˜äº®å™¨
const highlighter = new Highlighter(components);

// é…ç½®é«˜äº®å™¨
highlighter.config.selectName = "select";
highlighter.config.hoverName = "hover";
highlighter.config.selectEnabled = true;
highlighter.config.hoverEnabled = true;
highlighter.config.selectionColor = new THREE.Color("#BCF124");
highlighter.config.hoverColor = new THREE.Color("#6528D7");
highlighter.config.world = world;

// è®¾ç½®å¤šé€‰æ¨¡å¼
highlighter.multiple = "ctrlKey"; // æˆ– "shiftKey" æˆ– "none"

// å¯ç”¨ç¼©æ”¾åˆ°é€‰æ‹©
highlighter.zoomToSelection = true;
highlighter.zoomFactor = 1.5;

// è®¾ç½®é«˜äº®å™¨
await highlighter.setup();
```

### é«˜äº®é…ç½®æ¥å£

```typescript
interface HighlighterConfig {
  selectName: string;              // é€‰æ‹©äº‹ä»¶åç§°
  selectEnabled: boolean;          // å¯ç”¨é€‰æ‹©åŠŸèƒ½
  hoverName: string;              // æ‚¬åœäº‹ä»¶åç§°
  hoverEnabled: boolean;          // å¯ç”¨æ‚¬åœåŠŸèƒ½
  selectionColor: THREE.Color;    // é€‰æ‹©é¢œè‰²
  hoverColor: THREE.Color;        // æ‚¬åœé¢œè‰²
  autoHighlightOnClick: boolean;  // ç‚¹å‡»è‡ªåŠ¨é«˜äº®
  world: OBC.World;              // 3D ä¸–ç•Œå¼•ç”¨
}
```

### äº‹ä»¶å¤„ç†

```typescript
// ç›‘å¬é«˜äº®äº‹ä»¶
highlighter.events.select.onHighlight.add((fragmentIdMap) => {
  console.log("é€‰æ‹©é«˜äº®:", fragmentIdMap);
  
  // éå†é€‰ä¸­çš„ fragments
  for (const fragmentID in fragmentIdMap) {
    const fragment = fragmentIdMap[fragmentID];
    console.log(`Fragment ${fragmentID}:`, fragment);
  }
});

// ç›‘å¬æ‚¬åœäº‹ä»¶
highlighter.events.hover.onHighlight.add((fragmentIdMap) => {
  console.log("æ‚¬åœé«˜äº®:", fragmentIdMap);
});

// ç›‘å¬æ¸…é™¤äº‹ä»¶
highlighter.events.select.onClear.add(() => {
  console.log("æ¸…é™¤é€‰æ‹©");
});

// ç›‘å¬é«˜äº®å‰äº‹ä»¶
highlighter.events.select.onBeforeHighlight.add((lastSelection) => {
  console.log("é«˜äº®å‰çš„ä¸Šæ¬¡é€‰æ‹©:", lastSelection);
});
```

### é«˜çº§åŠŸèƒ½

```typescript
// æ‰‹åŠ¨é«˜äº®æŒ‡å®š fragments
const fragmentIdMap = {
  "fragment-1": new Set([1, 2, 3]), // fragment ID å’Œ item IDs
  "fragment-2": new Set([4, 5, 6])
};

// é«˜äº®æŒ‡å®š fragments
highlighter.highlightByID("select", fragmentIdMap);

// æ¸…é™¤æŒ‡å®šé«˜äº®
highlighter.clear("select");

// æ¸…é™¤æ‰€æœ‰é«˜äº®
highlighter.clear();

// è·å–å½“å‰é€‰æ‹©
const currentSelection = highlighter.selection.select;
console.log("å½“å‰é€‰æ‹©:", currentSelection);

// ç¼©æ”¾åˆ°é€‰æ‹©
if (Object.keys(currentSelection).length > 0) {
  await highlighter.zoomToSelection();
}
```

### è‡ªå®šä¹‰é«˜äº®æ ·å¼

```typescript
// åˆ›å»ºè‡ªå®šä¹‰é«˜äº®å™¨
class CustomHighlighter extends Highlighter {
  constructor(components: OBC.Components) {
    super(components);
    
    // è‡ªå®šä¹‰é…ç½®
    this.config.selectionColor = new THREE.Color("#ff6b6b");
    this.config.hoverColor = new THREE.Color("#4ecdc4");
  }
  
  // è‡ªå®šä¹‰é«˜äº®é€»è¾‘
  protected async highlightFragment(
    name: string,
    fragmentIdMap: FRAGS.FragmentIdMap,
    highlightMaterial?: THREE.Material
  ) {
    // æ·»åŠ è‡ªå®šä¹‰é«˜äº®æ•ˆæœ
    await super.highlightFragment(name, fragmentIdMap, highlightMaterial);
    
    // æ·»åŠ é¢å¤–çš„è§†è§‰æ•ˆæœ
    this.addCustomEffect(fragmentIdMap);
  }
  
  private addCustomEffect(fragmentIdMap: FRAGS.FragmentIdMap) {
    // å®ç°è‡ªå®šä¹‰æ•ˆæœï¼Œå¦‚è¾¹æ¡†ã€é˜´å½±ç­‰
  }
}
```

## æ ‡è®°å™¨ç³»ç»Ÿ (Marker)

### åŠŸèƒ½ç‰¹æ€§

æ ‡è®°å™¨æä¾›äº†åœ¨ 3D åœºæ™¯ä¸­åˆ›å»ºå’Œç®¡ç†æ ‡è®°çš„å®Œæ•´è§£å†³æ–¹æ¡ˆã€‚

- **å¤šç±»å‹æ ‡è®°**ï¼šæ”¯æŒä¸åŒç±»å‹çš„æ ‡è®°
- **è‡ªåŠ¨èšç±»**ï¼šæ™ºèƒ½çš„æ ‡è®°èšç±»ç®—æ³•
- **é™æ€æ ‡è®°**ï¼šä¸å‚ä¸èšç±»çš„å›ºå®šæ ‡è®°
- **åˆ†ç»„ç®¡ç†**ï¼šæŒ‰ä¸–ç•Œåˆ†ç»„ç®¡ç†æ ‡è®°
- **å¯è§†åŒ–æ§åˆ¶**ï¼šçµæ´»çš„æ˜¾ç¤ºå’Œéšè—æ§åˆ¶

### åŸºç¡€ä½¿ç”¨

```typescript
import { Marker, Mark } from "@thatopen/components-front";

// åˆ›å»ºæ ‡è®°å™¨
const marker = new Marker(components);

// é…ç½®èšç±»
marker.threshold = 50;      // èšç±»è·ç¦»é˜ˆå€¼
marker.autoCluster = true;  // å¯ç”¨è‡ªåŠ¨èšç±»

// åˆ›å»ºæ ‡è®°
const position = new THREE.Vector3(10, 5, 0);
const markElement = new Mark(components, world);
markElement.three.position.copy(position);

// æ·»åŠ æ ‡è®°åˆ°ç®¡ç†å™¨
const markerId = "marker-001";
marker.add(world, markerId, markElement, {
  type: "info",      // æ ‡è®°ç±»å‹
  static: false      // æ˜¯å¦ä¸ºé™æ€æ ‡è®°
});
```

### æ ‡è®°æ¥å£å®šä¹‰

```typescript
interface IMarker {
  key: string;           // å”¯ä¸€æ ‡è¯†ç¬¦
  label: Mark;          // æ ‡è®°å…ƒç´ 
  type?: string;        // æ ‡è®°ç±»å‹
  merged: boolean;      // æ˜¯å¦å·²åˆå¹¶
  static: boolean;      // æ˜¯å¦ä¸ºé™æ€æ ‡è®°
}

interface IGroupedMarkers {
  key: string;          // ç»„æ ‡è¯†ç¬¦
  markerKeys: string[]; // ç»„å†…æ ‡è®°é”®åˆ—è¡¨
  label: Mark;         // ç»„æ ‡ç­¾
}
```

### æ ‡è®°ç®¡ç†

```typescript
// è·å–ä¸–ç•Œä¸­çš„æ‰€æœ‰æ ‡è®°
const worldMarkers = marker.list.get(world.uuid);
if (worldMarkers) {
  for (const [key, markerData] of worldMarkers) {
    console.log(`æ ‡è®° ${key}:`, markerData);
  }
}

// åˆ é™¤æ ‡è®°
marker.delete(world, markerId);

// æ¸…é™¤ä¸–ç•Œä¸­çš„æ‰€æœ‰æ ‡è®°
marker.clear(world);

// è®¾ç½®æ ‡è®°å¯è§æ€§
marker.visible = false;

// æ‰‹åŠ¨è§¦å‘èšç±»
marker.cluster(world);
```

### è‡ªå®šä¹‰æ ‡è®°æ ·å¼

```typescript
// åˆ›å»ºè‡ªå®šä¹‰æ ‡è®°
class CustomMark extends Mark {
  constructor(
    components: OBC.Components,
    world: OBC.World,
    type: string = "default"
  ) {
    super(components, world);
    
    // æ ¹æ®ç±»å‹è®¾ç½®ä¸åŒæ ·å¼
    this.setupStyle(type);
  }
  
  private setupStyle(type: string) {
    switch (type) {
      case "warning":
        this.three.material.color.setHex(0xff9800);
        break;
      case "error":
        this.three.material.color.setHex(0xf44336);
        break;
      case "info":
        this.three.material.color.setHex(0x2196f3);
        break;
      default:
        this.three.material.color.setHex(0x4caf50);
    }
  }
}

// ä½¿ç”¨è‡ªå®šä¹‰æ ‡è®°
const customMark = new CustomMark(components, world, "warning");
marker.add(world, "custom-001", customMark);
```

### æ ‡è®°èšç±»ç®—æ³•

```typescript
// è‡ªå®šä¹‰èšç±»é€»è¾‘
class AdvancedMarker extends Marker {
  // é‡å†™èšç±»æ–¹æ³•
  cluster(world: OBC.World) {
    const worldMarkers = this.list.get(world.uuid);
    if (!worldMarkers) return;
    
    // è·å–ç›¸æœºä½ç½®ç”¨äºè·ç¦»è®¡ç®—
    const camera = world.camera.three;
    const cameraPosition = camera.position;
    
    // å®ç°è‡ªå®šä¹‰èšç±»ç®—æ³•
    const clusters = this.performClustering(worldMarkers, cameraPosition);
    
    // æ›´æ–°èšç±»æ˜¾ç¤º
    this.updateClusterDisplay(clusters);
  }
  
  private performClustering(
    markers: Map<string, IMarker>,
    cameraPosition: THREE.Vector3
  ): IGroupedMarkers[] {
    // å®ç°èšç±»ç®—æ³•
    const clusters: IGroupedMarkers[] = [];
    
    // æŒ‰è·ç¦»å’Œç±»å‹è¿›è¡Œèšç±»
    // ...
    
    return clusters;
  }
}
```

## è£å‰ªè¾¹ç¼˜ç³»ç»Ÿ (ClipEdges)

### åŠŸèƒ½ç‰¹æ€§

è£å‰ªè¾¹ç¼˜ç»„ä»¶ä¸ºè£å‰ªå¹³é¢æä¾›å¯è§†åŒ–çš„è¾¹ç¼˜å’Œå¡«å……æ•ˆæœã€‚

- **è¾¹ç¼˜å¯è§†åŒ–**ï¼šæ˜¾ç¤ºè£å‰ªå¹³é¢çš„è¾¹ç¼˜çº¿
- **å¡«å……æ•ˆæœ**ï¼šä¸ºè£å‰ªåŒºåŸŸæ·»åŠ å¡«å……
- **æ ·å¼é…ç½®**ï¼šå¯è‡ªå®šä¹‰çš„çº¿æ¡å’Œå¡«å……æ ·å¼
- **åŠ¨æ€æ›´æ–°**ï¼šå®æ—¶æ›´æ–°è£å‰ªæ•ˆæœ

### åŸºç¡€ä½¿ç”¨

```typescript
import { ClipEdges } from "@thatopen/components-front";

// åˆ›å»ºè£å‰ªè¾¹ç¼˜ç»„ä»¶
const clipEdges = new ClipEdges(components);

// é…ç½®æ ·å¼
clipEdges.styles.create(
  "default",
  new Set(), // åº”ç”¨çš„ fragment IDs
  world,
  {
    name: "default",
    lineColor: 0xff0000,    // çº¢è‰²è¾¹ç¼˜çº¿
    lineWidth: 2,           // çº¿å®½
    fillColor: 0x0000ff,    // è“è‰²å¡«å……
    fillOpacity: 0.3        // å¡«å……é€æ˜åº¦
  }
);

// å¯ç”¨å¯è§æ€§
clipEdges.visible = true;

// æ›´æ–°è¾¹ç¼˜
await clipEdges.update();
```

### è¾¹ç¼˜æ ·å¼é…ç½®

```typescript
// åˆ›å»ºå¤šç§æ ·å¼
const styles = clipEdges.styles;

// å»ºç­‘æ ·å¼
styles.create("building", buildingFragments, world, {
  name: "building",
  lineColor: 0x2196f3,
  lineWidth: 3,
  fillColor: 0xe3f2fd,
  fillOpacity: 0.2
});

// ç»“æ„æ ·å¼
styles.create("structure", structureFragments, world, {
  name: "structure",
  lineColor: 0xff5722,
  lineWidth: 4,
  fillColor: 0xfbe9e7,
  fillOpacity: 0.25
});

// æœºç”µæ ·å¼
styles.create("mep", mepFragments, world, {
  name: "mep",
  lineColor: 0x4caf50,
  lineWidth: 2,
  fillColor: 0xe8f5e8,
  fillOpacity: 0.15
});
```

### åŠ¨æ€æ›´æ–°

```typescript
// ç›‘å¬è£å‰ªå™¨å˜åŒ–
const clipper = components.get(OBC.Clipper);
clipper.onAfterUpdate.add(async () => {
  // æ ‡è®°éœ€è¦æ›´æ–°å¡«å……
  clipEdges.fillsNeedUpdate = true;
  
  // æ›´æ–°è¾¹ç¼˜
  await clipEdges.update(true); // å¼ºåˆ¶æ›´æ–°å¡«å……
});

// æ‰‹åŠ¨è§¦å‘æ›´æ–°
clipEdges.fillsNeedUpdate = true;
await clipEdges.update();
```

## å¹³é¢å›¾ç³»ç»Ÿ (Plans)

### åŠŸèƒ½ç‰¹æ€§

å¹³é¢å›¾ç»„ä»¶æä¾› 2D å¹³é¢å›¾çš„æµè§ˆå’Œå¯¼èˆªåŠŸèƒ½ã€‚

- **æ¥¼å±‚å¯¼èˆª**ï¼šåœ¨ä¸åŒæ¥¼å±‚é—´åˆ‡æ¢
- **ç›¸æœºæ§åˆ¶**ï¼šè‡ªåŠ¨è°ƒæ•´ç›¸æœºåˆ°å¹³é¢å›¾è§†è§’
- **è£å‰ªå¹³é¢**ï¼šè‡ªåŠ¨åˆ›å»ºæ¥¼å±‚è£å‰ªå¹³é¢
- **ç¼“å­˜æœºåˆ¶**ï¼šç¼“å­˜ç›¸æœºçŠ¶æ€æé«˜æ€§èƒ½

### åŸºç¡€ä½¿ç”¨

```typescript
import { Plans } from "@thatopen/components-front";

// åˆ›å»ºå¹³é¢å›¾ç»„ä»¶
const plans = new Plans(components);
plans.world = world;

// é…ç½®åç§»
plans.offset = 1.5; // è£å‰ªå¹³é¢åç§»è·ç¦»

// ç›‘å¬å¯¼èˆªäº‹ä»¶
plans.onNavigated.add(({ id }) => {
  console.log(`å¯¼èˆªåˆ°å¹³é¢å›¾: ${id}`);
});

plans.onExited.add(() => {
  console.log("é€€å‡ºå¹³é¢å›¾è§†å›¾");
});
```

### å¹³é¢å›¾æ•°æ®æ¥å£

```typescript
interface PlanView extends Section {
  planOffset: number;  // å¹³é¢å›¾åç§»
}

// Section æ¥å£æ¥è‡ª Sections ç»„ä»¶
interface Section {
  id: string;
  name: string;
  normal: THREE.Vector3;
  point: THREE.Vector3;
}
```

### åˆ›å»ºå’Œç®¡ç†å¹³é¢å›¾

```typescript
// ä» IFC æ¨¡å‹åˆ›å»ºå¹³é¢å›¾
const ifcLoader = components.get(OBC.IfcLoader);
const model = await ifcLoader.load(ifcFile);

// è·å–æ¥¼å±‚ä¿¡æ¯
const indexer = components.get(OBC.IfcRelationsIndexer);
const floors = indexer.getEntitiesByType(model, WEBIFC.IFCBUILDINGSTOREY);

// ä¸ºæ¯ä¸ªæ¥¼å±‚åˆ›å»ºå¹³é¢å›¾
for (const floorID of floors) {
  const floor = await model.getProperties(floorID);
  if (!floor) continue;
  
  // è·å–æ¥¼å±‚é«˜åº¦
  const elevation = floor.Elevation?.value || 0;
  
  // åˆ›å»ºå¹³é¢å›¾
  const planView: PlanView = {
    id: floor.GlobalId.value,
    name: floor.Name?.value || `æ¥¼å±‚ ${floorID}`,
    normal: new THREE.Vector3(0, -1, 0), // å‘ä¸‹çš„æ³•å‘é‡
    point: new THREE.Vector3(0, elevation, 0),
    planOffset: 1.5
  };
  
  plans.list.push(planView);
}

console.log(`åˆ›å»ºäº† ${plans.list.length} ä¸ªå¹³é¢å›¾`);
```

### å¹³é¢å›¾å¯¼èˆª

```typescript
// å¯¼èˆªåˆ°æŒ‡å®šå¹³é¢å›¾
const targetPlan = plans.list[0];
if (targetPlan) {
  await plans.goTo(targetPlan.id);
}

// é€€å‡ºå¹³é¢å›¾è§†å›¾
plans.exitPlanView();

// è·å–å½“å‰å¹³é¢å›¾
if (plans.currentPlan) {
  console.log(`å½“å‰å¹³é¢å›¾: ${plans.currentPlan.name}`);
}

// åˆ‡æ¢åˆ°ä¸‹ä¸€ä¸ªå¹³é¢å›¾
const currentIndex = plans.list.findIndex(p => p === plans.currentPlan);
if (currentIndex < plans.list.length - 1) {
  const nextPlan = plans.list[currentIndex + 1];
  await plans.goTo(nextPlan.id);
}
```

### ç›¸æœºçŠ¶æ€ç®¡ç†

```typescript
// å¹³é¢å›¾ç»„ä»¶ä¼šè‡ªåŠ¨ç®¡ç†ç›¸æœºçŠ¶æ€
// è¿›å…¥å¹³é¢å›¾æ—¶ä¿å­˜ 3D ç›¸æœºçŠ¶æ€
// é€€å‡ºæ—¶æ¢å¤åŸå§‹ç›¸æœºçŠ¶æ€

// æ‰‹åŠ¨ä¿å­˜ç›¸æœºçŠ¶æ€
const camera = world.camera.three;
const savedState = {
  position: camera.position.clone(),
  target: camera.target?.clone(),
  zoom: camera.zoom
};

// æ‰‹åŠ¨æ¢å¤ç›¸æœºçŠ¶æ€
camera.position.copy(savedState.position);
if (savedState.target && camera.target) {
  camera.target.copy(savedState.target);
}
camera.zoom = savedState.zoom;
camera.updateProjectionMatrix();
```

## åå¤„ç†æ¸²æŸ“å™¨ (PostproductionRenderer)

### åŠŸèƒ½ç‰¹æ€§

åå¤„ç†æ¸²æŸ“å™¨æä¾›é«˜çº§çš„æ¸²æŸ“æ•ˆæœå’Œåå¤„ç†åŠŸèƒ½ã€‚

- **å¤šç§åå¤„ç†æ•ˆæœ**ï¼šSSAOã€æ™¯æ·±ã€æ³›å…‰ç­‰
- **è‡ªå®šä¹‰é€šé“**ï¼šå¯æ·»åŠ è‡ªå®šä¹‰æ¸²æŸ“é€šé“
- **æ€§èƒ½ä¼˜åŒ–**ï¼šæ™ºèƒ½çš„æ•ˆæœå¼€å…³å’Œè´¨é‡æ§åˆ¶
- **å®æ—¶è°ƒæ•´**ï¼šè¿è¡Œæ—¶è°ƒæ•´æ•ˆæœå‚æ•°

### åŸºç¡€ä½¿ç”¨

```typescript
import { PostproductionRenderer } from "@thatopen/components-front";

// åˆ›å»ºåå¤„ç†æ¸²æŸ“å™¨
const postRenderer = new PostproductionRenderer(components, container);
postRenderer.world = world;

// å¯ç”¨åå¤„ç†æ•ˆæœ
postRenderer.enabled = true;

// é…ç½® SSAOï¼ˆå±å¹•ç©ºé—´ç¯å¢ƒå…‰é®è”½ï¼‰
postRenderer.settings.ao = true;
postRenderer.settings.aoRadius = 0.5;
postRenderer.settings.aoIntensity = 1.0;

// é…ç½®æ™¯æ·±
postRenderer.settings.dof = true;
postRenderer.settings.dofFocus = 10.0;
postRenderer.settings.dofAperture = 0.025;

// é…ç½®æ³›å…‰
postRenderer.settings.bloom = true;
postRenderer.settings.bloomStrength = 0.3;
postRenderer.settings.bloomRadius = 0.8;
```

### è‡ªå®šä¹‰åå¤„ç†é€šé“

```typescript
// æ·»åŠ è‡ªå®šä¹‰é€šé“
class CustomPostProcessor extends PostproductionRenderer {
  constructor(components: OBC.Components, container: HTMLElement) {
    super(components, container);
    
    // æ·»åŠ è‡ªå®šä¹‰é€šé“
    this.addCustomPasses();
  }
  
  private addCustomPasses() {
    // æ·»åŠ è¾¹ç¼˜æ£€æµ‹é€šé“
    const edgePass = new EdgeDetectionPass();
    this.composer.addPass(edgePass);
    
    // æ·»åŠ è‰²è°ƒæ˜ å°„é€šé“
    const toneMappingPass = new ToneMappingPass();
    this.composer.addPass(toneMappingPass);
  }
}
```

## å®Œæ•´å‰ç«¯åº”ç”¨ç¤ºä¾‹

```typescript
import * as OBC from "@thatopen/components";
import * as OBF from "@thatopen/components-front";
import * as THREE from "three";

class AdvancedBIMViewer {
  private components: OBC.Components;
  private world: OBC.World;
  private highlighter: OBF.Highlighter;
  private marker: OBF.Marker;
  private clipEdges: OBF.ClipEdges;
  private plans: OBF.Plans;
  
  constructor(container: HTMLElement) {
    this.initializeComponents(container);
    this.setupFrontendComponents();
    this.setupInteractions();
  }
  
  private initializeComponents(container: HTMLElement) {
    // åˆå§‹åŒ–æ ¸å¿ƒç»„ä»¶
    this.components = new OBC.Components();
    
    // åˆ›å»ºä¸–ç•Œ
    const worlds = this.components.get(OBC.Worlds);
    this.world = worlds.create<OBC.SimpleWorld>();
    
    // ä½¿ç”¨åå¤„ç†æ¸²æŸ“å™¨
    this.world.renderer = new OBF.PostproductionRenderer(
      this.components,
      container
    );
    
    this.world.scene = new OBC.SimpleScene(this.components);
    this.world.camera = new OBC.SimpleCamera(this.components);
    
    // åˆå§‹åŒ–ç»„ä»¶ç³»ç»Ÿ
    this.components.init();
  }
  
  private setupFrontendComponents() {
    // è®¾ç½®é«˜äº®å™¨
    this.highlighter = new OBF.Highlighter(this.components);
    this.highlighter.config.world = this.world;
    this.highlighter.setup();
    
    // è®¾ç½®æ ‡è®°å™¨
    this.marker = new OBF.Marker(this.components);
    
    // è®¾ç½®è£å‰ªè¾¹ç¼˜
    this.clipEdges = new OBF.ClipEdges(this.components);
    
    // è®¾ç½®å¹³é¢å›¾
    this.plans = new OBF.Plans(this.components);
    this.plans.world = this.world;
  }
  
  private setupInteractions() {
    // é«˜äº®äº¤äº’
    this.highlighter.events.select.onHighlight.add((selection) => {
      this.onElementSelected(selection);
    });
    
    // å¹³é¢å›¾å¯¼èˆª
    this.plans.onNavigated.add(({ id }) => {
      this.onPlanNavigated(id);
    });
    
    // é”®ç›˜å¿«æ·é”®
    window.addEventListener('keydown', (event) => {
      this.handleKeyboard(event);
    });
  }
  
  private onElementSelected(selection: FRAGS.FragmentIdMap) {
    console.log("é€‰ä¸­å…ƒç´ :", selection);
    
    // æ·»åŠ æ ‡è®°åˆ°é€‰ä¸­å…ƒç´ 
    for (const fragmentID in selection) {
      const fragment = this.getFragment(fragmentID);
      if (fragment) {
        const center = this.getFragmentCenter(fragment);
        this.addMarker(center, `é€‰ä¸­: ${fragmentID}`);
      }
    }
  }
  
  private onPlanNavigated(planId: string) {
    console.log(`å¯¼èˆªåˆ°å¹³é¢å›¾: ${planId}`);
    
    // æ›´æ–°è£å‰ªè¾¹ç¼˜
    this.clipEdges.update();
  }
  
  private handleKeyboard(event: KeyboardEvent) {
    switch (event.key) {
      case 'Escape':
        // æ¸…é™¤é€‰æ‹©
        this.highlighter.clear();
        break;
      case 'h':
        // åˆ‡æ¢é«˜äº®å™¨
        this.highlighter.enabled = !this.highlighter.enabled;
        break;
      case 'm':
        // åˆ‡æ¢æ ‡è®°å¯è§æ€§
        this.marker.visible = !this.marker.visible;
        break;
      case 'p':
        // é€€å‡ºå¹³é¢å›¾
        this.plans.exitPlanView();
        break;
    }
  }
  
  private getFragment(fragmentID: string): FRAGS.Fragment | null {
    const fragments = this.components.get(OBC.FragmentsManager);
    return fragments.list.get(fragmentID) || null;
  }
  
  private getFragmentCenter(fragment: FRAGS.Fragment): THREE.Vector3 {
    const box = new THREE.Box3();
    box.setFromObject(fragment.mesh);
    return box.getCenter(new THREE.Vector3());
  }
  
  private addMarker(position: THREE.Vector3, text: string) {
    const mark = new OBF.Mark(this.components, this.world);
    mark.three.position.copy(position);
    
    // è®¾ç½®æ ‡è®°æ–‡æœ¬
    mark.labelText = text;
    
    // æ·»åŠ åˆ°æ ‡è®°å™¨
    const markerId = `marker-${Date.now()}`;
    this.marker.add(this.world, markerId, mark);
  }
  
  // å…¬å…± API
  async loadModel(file: File) {
    const ifcLoader = this.components.get(OBC.IfcLoader);
    const model = await ifcLoader.load(file);
    
    // åˆ›å»ºå¹³é¢å›¾
    await this.createPlansFromModel(model);
    
    return model;
  }
  
  private async createPlansFromModel(model: FRAGS.FragmentsGroup) {
    // å®ç°ä»æ¨¡å‹åˆ›å»ºå¹³é¢å›¾çš„é€»è¾‘
    // ...
  }
  
  dispose() {
    this.highlighter.dispose();
    this.marker.dispose();
    this.clipEdges.dispose();
    this.plans.dispose();
    this.components.dispose();
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const container = document.getElementById('viewer-container')!;
const viewer = new AdvancedBIMViewer(container);

// åŠ è½½æ¨¡å‹
const fileInput = document.getElementById('file-input') as HTMLInputElement;
fileInput.addEventListener('change', async (event) => {
  const file = (event.target as HTMLInputElement).files?.[0];
  if (file) {
    await viewer.loadModel(file);
  }
});
```

## æ€§èƒ½ä¼˜åŒ–å»ºè®®

### 1. é«˜äº®å™¨ä¼˜åŒ–

```typescript
// é™åˆ¶é«˜äº®å…ƒç´ æ•°é‡
class OptimizedHighlighter extends Highlighter {
  private maxHighlightItems = 1000;
  
  async highlightByID(name: string, fragmentIdMap: FRAGS.FragmentIdMap) {
    // æ£€æŸ¥é«˜äº®å…ƒç´ æ•°é‡
    const totalItems = Object.values(fragmentIdMap)
      .reduce((sum, items) => sum + items.size, 0);
    
    if (totalItems > this.maxHighlightItems) {
      console.warn(`é«˜äº®å…ƒç´ è¿‡å¤š (${totalItems})ï¼Œå¯èƒ½å½±å“æ€§èƒ½`);
      return;
    }
    
    await super.highlightByID(name, fragmentIdMap);
  }
}
```

### 2. æ ‡è®°å™¨ä¼˜åŒ–

```typescript
// è§†é”¥ä½“å‰”é™¤ä¼˜åŒ–
class OptimizedMarker extends Marker {
  private frustum = new THREE.Frustum();
  
  update(world: OBC.World) {
    // æ›´æ–°è§†é”¥ä½“
    const camera = world.camera.three;
    this.frustum.setFromProjectionMatrix(
      new THREE.Matrix4().multiplyMatrices(
        camera.projectionMatrix,
        camera.matrixWorldInverse
      )
    );
    
    // åªæ›´æ–°å¯è§æ ‡è®°
    const worldMarkers = this.list.get(world.uuid);
    if (worldMarkers) {
      for (const [key, marker] of worldMarkers) {
        const visible = this.frustum.containsPoint(marker.label.three.position);
        marker.label.visible = visible;
      }
    }
  }
}
```

### 3. å†…å­˜ç®¡ç†

```typescript
// èµ„æºæ¸…ç†ç®¡ç†å™¨
class ResourceManager {
  private disposables: OBC.Disposable[] = [];
  
  register(disposable: OBC.Disposable) {
    this.disposables.push(disposable);
  }
  
  dispose() {
    for (const disposable of this.disposables) {
      disposable.dispose();
    }
    this.disposables.length = 0;
  }
}

// ä½¿ç”¨èµ„æºç®¡ç†å™¨
const resourceManager = new ResourceManager();
resourceManager.register(highlighter);
resourceManager.register(marker);
resourceManager.register(clipEdges);

// åº”ç”¨å…³é—­æ—¶æ¸…ç†
window.addEventListener('beforeunload', () => {
  resourceManager.dispose();
});
```

## æœ€ä½³å®è·µ

1. **ç»„ä»¶åè°ƒ**ï¼šç¡®ä¿å‰ç«¯ç»„ä»¶ä¹‹é—´çš„åè°ƒå·¥ä½œ
2. **äº‹ä»¶ç®¡ç†**ï¼šåˆç†ä½¿ç”¨äº‹ä»¶ç³»ç»Ÿï¼Œé¿å…å†…å­˜æ³„æ¼
3. **æ€§èƒ½ç›‘æ§**ï¼šç›‘æ§æ¸²æŸ“æ€§èƒ½ï¼Œé€‚æ—¶è°ƒæ•´æ•ˆæœè´¨é‡
4. **ç”¨æˆ·ä½“éªŒ**ï¼šæä¾›æµç•…çš„äº¤äº’åé¦ˆ
5. **èµ„æºç®¡ç†**ï¼šåŠæ—¶æ¸…ç†ä¸éœ€è¦çš„èµ„æº
6. **é”™è¯¯å¤„ç†**ï¼šä¼˜é›…å¤„ç†ç»„ä»¶åˆå§‹åŒ–å’Œè¿è¡Œæ—¶é”™è¯¯

å‰ç«¯ç»„ä»¶ç³»ç»Ÿä¸º BIM åº”ç”¨æä¾›äº†ä¸°å¯Œçš„äº¤äº’å’Œå¯è§†åŒ–åŠŸèƒ½ï¼Œé€šè¿‡åˆç†çš„æ¶æ„è®¾è®¡å’Œæ€§èƒ½ä¼˜åŒ–ï¼Œå¯ä»¥æ„å»ºå‡ºè‰²çš„ç”¨æˆ·ä½“éªŒã€‚

## å®Œæ•´å‰ç«¯åº”ç”¨ç¤ºä¾‹

### ç»¼åˆ BIM æŸ¥çœ‹å™¨

```typescript
import * as OBC from "@thatopen/components";
import * as OBF from "@thatopen/components-front";
import * as THREE from "three";

class ComprehensiveBIMViewer {
  private components: OBC.Components;
  private world: OBC.World;
  private highlighter: OBF.Highlighter;
  private marker: OBF.Marker;
  private plans: OBF.Plans;
  private clipEdges: OBF.ClipEdges;

  constructor(container: HTMLElement) {
    this.initializeCore(container);
    this.setupFrontendComponents();
    this.setupUI();
  }

  private async initializeCore(container: HTMLElement) {
    // åˆå§‹åŒ–æ ¸å¿ƒç»„ä»¶
    this.components = new OBC.Components();

    const worlds = this.components.get(OBC.Worlds);
    this.world = worlds.create<
      OBC.SimpleScene,
      OBC.OrthoPerspectiveCamera,
      OBF.PostproductionRenderer
    >();

    // é…ç½®åœºæ™¯
    this.world.scene = new OBC.SimpleScene(this.components);
    this.world.scene.setup();

    // é…ç½®é«˜çº§ç›¸æœº
    this.world.camera = new OBF.OrthoPerspectiveCamera(this.components);
    this.world.camera.controls.setLookAt(10, 10, 10, 0, 0, 0);

    // é…ç½®åå¤„ç†æ¸²æŸ“å™¨
    this.world.renderer = new OBF.PostproductionRenderer(this.components, container);
    this.world.renderer.postproduction.enabled = true;

    await this.world.init();
    this.components.init();
  }

  private async setupFrontendComponents() {
    // è®¾ç½®é«˜äº®å™¨
    this.highlighter = new OBF.Highlighter(this.components);
    this.highlighter.config.world = this.world;
    this.highlighter.config.selectEnabled = true;
    this.highlighter.config.hoverEnabled = true;
    await this.highlighter.setup();

    // è®¾ç½®æ ‡è®°å™¨
    this.marker = new OBF.Marker(this.components);
    this.marker.threshold = 50;
    this.marker.autoCluster = true;

    // è®¾ç½®å¹³é¢å›¾å¯¼èˆª
    this.plans = new OBF.Plans(this.components);
    this.plans.world = this.world;

    // è®¾ç½®è£å‰ªè¾¹ç¼˜
    this.clipEdges = new OBF.ClipEdges(this.components);
    this.clipEdges.visible = true;

    this.setupEventHandlers();
  }

  private setupEventHandlers() {
    // é«˜äº®äº‹ä»¶
    this.highlighter.events.select.onHighlight.add((fragmentIdMap) => {
      console.log("é€‰ä¸­å…ƒç´ :", fragmentIdMap);
      this.showElementInfo(fragmentIdMap);
    });

    // å¹³é¢å›¾å¯¼èˆªäº‹ä»¶
    this.plans.onNavigated.add(({ id }) => {
      console.log(`å¯¼èˆªåˆ°å¹³é¢å›¾: ${id}`);
      this.updateUI('plan-view');
    });

    this.plans.onExited.add(() => {
      console.log("é€€å‡ºå¹³é¢å›¾è§†å›¾");
      this.updateUI('3d-view');
    });
  }

  private setupUI() {
    // åˆ›å»ºå·¥å…·æ 
    const toolbar = this.createToolbar();
    document.body.appendChild(toolbar);

    // åˆ›å»ºä¿¡æ¯é¢æ¿
    const infoPanel = this.createInfoPanel();
    document.body.appendChild(infoPanel);
  }

  private createToolbar(): HTMLElement {
    const toolbar = document.createElement('div');
    toolbar.className = 'bim-toolbar';
    toolbar.style.cssText = `
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(255, 255, 255, 0.9);
      padding: 10px;
      border-radius: 5px;
      display: flex;
      gap: 10px;
      z-index: 1000;
    `;

    // æŠ•å½±åˆ‡æ¢æŒ‰é’®
    const projectionBtn = this.createButton('ğŸ”„ æŠ•å½±', () => {
      this.world.camera.projection.toggle();
    });

    // å¹³é¢å›¾æŒ‰é’®
    const planBtn = this.createButton('ğŸ“‹ å¹³é¢å›¾', () => {
      if (this.plans.list.length > 0) {
        this.plans.goTo(this.plans.list[0].id);
      }
    });

    // æ ‡è®°åˆ‡æ¢æŒ‰é’®
    const markerBtn = this.createButton('ğŸ“ æ ‡è®°', () => {
      this.marker.visible = !this.marker.visible;
    });

    // è£å‰ªè¾¹ç¼˜æŒ‰é’®
    const clipBtn = this.createButton('âœ‚ï¸ è£å‰ª', () => {
      this.clipEdges.visible = !this.clipEdges.visible;
    });

    toolbar.append(projectionBtn, planBtn, markerBtn, clipBtn);
    return toolbar;
  }

  private createInfoPanel(): HTMLElement {
    const panel = document.createElement('div');
    panel.id = 'info-panel';
    panel.style.cssText = `
      position: absolute;
      top: 10px;
      right: 10px;
      width: 300px;
      background: rgba(255, 255, 255, 0.9);
      padding: 15px;
      border-radius: 5px;
      z-index: 1000;
      display: none;
    `;

    panel.innerHTML = `
      <h3>å…ƒç´ ä¿¡æ¯</h3>
      <div id="element-details"></div>
    `;

    return panel;
  }

  private createButton(text: string, onClick: () => void): HTMLButtonElement {
    const button = document.createElement('button');
    button.textContent = text;
    button.style.cssText = `
      padding: 8px 12px;
      border: none;
      border-radius: 3px;
      background: #007bff;
      color: white;
      cursor: pointer;
      transition: background 0.2s;
    `;

    button.addEventListener('click', onClick);
    button.addEventListener('mouseenter', () => {
      button.style.background = '#0056b3';
    });
    button.addEventListener('mouseleave', () => {
      button.style.background = '#007bff';
    });

    return button;
  }

  private showElementInfo(fragmentIdMap: any) {
    const panel = document.getElementById('info-panel')!;
    const details = document.getElementById('element-details')!;

    // æ˜¾ç¤ºé€‰ä¸­å…ƒç´ çš„ä¿¡æ¯
    details.innerHTML = `
      <p><strong>é€‰ä¸­å…ƒç´ æ•°é‡:</strong> ${Object.keys(fragmentIdMap).length}</p>
      <p><strong>Fragment IDs:</strong> ${Object.keys(fragmentIdMap).join(', ')}</p>
    `;

    panel.style.display = 'block';
  }

  private updateUI(mode: 'plan-view' | '3d-view') {
    // æ ¹æ®è§†å›¾æ¨¡å¼æ›´æ–°UI
    const toolbar = document.querySelector('.bim-toolbar') as HTMLElement;
    if (mode === 'plan-view') {
      toolbar.style.background = 'rgba(255, 235, 59, 0.9)';
    } else {
      toolbar.style.background = 'rgba(255, 255, 255, 0.9)';
    }
  }

  // å…¬å…±æ–¹æ³•
  async loadIFC(file: File) {
    const ifcLoader = this.components.get(OBC.IfcLoader);
    await ifcLoader.setup({ autoSetWasm: true });

    const buffer = await file.arrayBuffer();
    const model = await ifcLoader.load(buffer);

    this.world.scene.three.add(model);
    this.world.camera.controls.fitToSphere(model, true);

    // ä¸ºæ¨¡å‹åˆ›å»ºå¹³é¢å›¾
    await this.createPlansFromModel(model);

    return model;
  }

  private async createPlansFromModel(model: any) {
    // è¿™é‡Œåº”è¯¥æ ¹æ®å®é™…çš„ IFC æ¨¡å‹ç»“æ„åˆ›å»ºå¹³é¢å›¾
    // ç¤ºä¾‹ä»£ç 
    const samplePlan = {
      id: "ground-floor",
      name: "é¦–å±‚å¹³é¢å›¾",
      normal: new THREE.Vector3(0, -1, 0),
      point: new THREE.Vector3(0, 0, 0),
      planOffset: 1.5
    };

    this.plans.list.push(samplePlan);
  }

  dispose() {
    this.highlighter.dispose();
    this.marker.dispose();
    this.clipEdges.dispose();
    this.components.dispose();
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const container = document.getElementById('container')!;
const viewer = new ComprehensiveBIMViewer(container);

// æ·»åŠ æ–‡ä»¶åŠ è½½åŠŸèƒ½
const fileInput = document.createElement('input');
fileInput.type = 'file';
fileInput.accept = '.ifc';
fileInput.addEventListener('change', async (event) => {
  const file = (event.target as HTMLInputElement).files?.[0];
  if (file) {
    await viewer.loadIFC(file);
  }
});

document.body.appendChild(fileInput);
```

## æ€§èƒ½ä¼˜åŒ–å»ºè®®

### 1. æ¸²æŸ“ä¼˜åŒ–
- ä½¿ç”¨ LOD (Level of Detail) æŠ€æœ¯
- å¯ç”¨è§†é”¥ä½“å‰”é™¤
- åˆç†ä½¿ç”¨åå¤„ç†æ•ˆæœ
- æ§åˆ¶åŒæ—¶æ¸²æŸ“çš„å¯¹è±¡æ•°é‡

### 2. å†…å­˜ç®¡ç†
- åŠæ—¶æ¸…ç†ä¸éœ€è¦çš„ç»„ä»¶
- ä½¿ç”¨å¯¹è±¡æ± é‡ç”¨èµ„æº
- ç›‘æ§å†…å­˜ä½¿ç”¨æƒ…å†µ
- é¿å…å†…å­˜æ³„æ¼

### 3. äº¤äº’ä¼˜åŒ–
- ä½¿ç”¨é˜²æŠ–å’ŒèŠ‚æµæŠ€æœ¯
- ä¼˜åŒ–äº‹ä»¶å¤„ç†é€»è¾‘
- å‡å°‘ä¸å¿…è¦çš„é‡ç»˜
- åˆç†ä½¿ç”¨ç¼“å­˜æœºåˆ¶

---

> ğŸ¯ **æ€»ç»“**: å‰ç«¯ç»„ä»¶ç³»ç»Ÿæä¾›äº†æ„å»ºä¸“ä¸š BIM åº”ç”¨æ‰€éœ€çš„æ‰€æœ‰å·¥å…·ã€‚é€šè¿‡åˆç†ç»„åˆè¿™äº›ç»„ä»¶ï¼Œå¯ä»¥åˆ›å»ºåŠŸèƒ½å¼ºå¤§ã€ç”¨æˆ·ä½“éªŒä¼˜ç§€çš„ BIM åº”ç”¨ç¨‹åºã€‚