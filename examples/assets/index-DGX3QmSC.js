var G=Object.defineProperty;var H=(v,t,e)=>t in v?G(v,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):v[t]=e;var r=(v,t,e)=>(H(v,typeof t!="symbol"?t+"":t,e),e);import{U as P,a as q,c as K,J as Q,m as R}from"./index-DQ59awSV.js";import{M as Y,c as Z,V as L,a as z,P as ee,r as te,e as se,D as ie,s as ne,I as oe,J as re,L as le}from"./web-ifc-api-BC8YMRiS.js";import{e as ae}from"./import-wrapper-prod-LhqN7JJy.js";import{P as W}from"./index-CvD1WrkP.js";class ce{constructor(t,e,s,i){r(this,"mesh",new Y(new Z));r(this,"world");r(this,"styleName");r(this,"_precission",1e4);r(this,"_tempVector",new L);r(this,"_plane");r(this,"_geometry");r(this,"_plane2DCoordinateSystem",new z);r(this,"_planeAxis");this.world=t,this.mesh.material=i,this.mesh.frustumCulled=!1,this._plane=e;const{x:n,y:l,z:o}=e.normal;Math.abs(n)===1?this._planeAxis="x":Math.abs(l)===1?this._planeAxis="y":Math.abs(o)===1&&(this._planeAxis="z"),this._geometry=s,this.mesh.geometry.attributes.position=s.attributes.position;const a=e.normal.clone().multiplyScalar(.01);this.mesh.position.copy(a),this.visible=!0}get visible(){return this.mesh.parent!==null}set visible(t){const e=this.getStyle();t?(this.world.scene.three.add(this.mesh),e&&e.meshes.add(this.mesh)):(this.mesh.removeFromParent(),e&&e.meshes.delete(this.mesh))}set geometry(t){this._geometry=t,this.mesh.geometry.attributes.position=t.attributes.position}dispose(){const t=this.getStyle();t&&t.meshes.delete(this.mesh),this.mesh.geometry.dispose(),this.mesh.removeFromParent(),this.mesh.geometry=null,this.mesh=null,this._plane=null,this._geometry=null}update(t){const e=this._geometry.attributes.position.array;if(!e)return;this.updatePlane2DCoordinateSystem();const s=[];let i=0;for(let n=0;n<t.length;n++){const l=t[n],o=[];for(let g=i;g<l;g+=2)o.push(g*3);const a=this.computeFill(o,e);for(const g of a)s.push(g);i=l}this.mesh.geometry.setIndex(s)}computeFill(t,e){const s=new Map,i={},n=new Map;let l=0;const o=new Map,a=new Map,g=new Set,_=this._precission;for(let x=0;x<t.length;x++){const u=t[x];let S=0,w=0,D=0,y=0;const V=e[u],M=e[u+1],j=e[u+2],$=e[u+3],k=e[u+4],J=e[u+5];if(this._tempVector.set(V,M,j),this._tempVector.applyMatrix4(this._plane2DCoordinateSystem),S=Math.trunc(this._tempVector.x*_)/_,w=Math.trunc(this._tempVector.y*_)/_,this._tempVector.set($,k,J),this._tempVector.applyMatrix4(this._plane2DCoordinateSystem),D=Math.trunc(this._tempVector.x*_)/_,y=Math.trunc(this._tempVector.y*_)/_,S===D&&w===y)continue;const B=`${S}|${w}`,T=`${D}|${y}`;s.has(B)||s.set(B,u/3),s.has(T)||s.set(T,u/3+1);const p=s.get(B),f=s.get(T);i[p]=[S,w],i[f]=[D,y];const A=a.has(p),U=o.has(p),C=a.has(f),F=o.has(f);if(!A&&!U&&!C&&!F)a.set(p,l),o.set(f,l),g.add(l),n.set(l,[p,f]),l++;else if(A&&F){const c=a.get(p),d=o.get(f);if(c!==d){const h=n.get(d),I=n.get(c);if(!h||!I)continue;n.delete(c),g.delete(c),o.set(I[I.length-1],d),o.delete(h[h.length-1]);for(const O of I)h.push(O)}else g.delete(d);a.delete(p),o.delete(f)}else if(U&&C){const c=a.get(f),d=o.get(p);if(c!==d){const h=n.get(d),I=n.get(c);if(!h||!I)continue;n.delete(c),g.delete(c),o.set(I[I.length-1],d),o.delete(h[h.length-1]);for(const O of I)h.push(O)}else g.delete(d);a.delete(f),o.delete(p)}else if(A&&C){const c=a.get(f),d=a.get(p),b=n.get(d),h=n.get(c);if(!b||!h)continue;n.delete(c),g.delete(c),a.delete(b[0]),a.delete(h[0]),o.delete(h[h.length-1]),a.set(h[h.length-1],d),h.reverse(),b.splice(0,0,...h)}else if(U&&F){const c=o.get(f),d=o.get(p),b=n.get(d),h=n.get(c);if(!b||!h)continue;n.delete(c),g.delete(c),o.delete(b[b.length-1]),o.delete(h[h.length-1]),a.delete(h[0]),o.set(h[0],d),h.reverse(),b.push(...h)}else if(A){const c=a.get(p),d=n.get(c);if(!d)continue;d.unshift(f),a.delete(p),a.set(f,c)}else if(U){const c=o.get(p),d=n.get(c);if(!d)continue;d.push(f),o.delete(p),o.set(f,c)}else if(C){const c=a.get(f),d=n.get(c);if(!d)continue;d.unshift(p),a.delete(f),a.set(p,c)}else if(F){const c=o.get(f),d=n.get(c);if(!d)continue;d.push(p),o.delete(f),o.set(p,c)}}const m=[];for(const[x,u]of n){if(g.has(x))continue;const S=[],w=new Map;let D=0;for(const V of u){const M=i[V];S.push(M[0],M[1]),w.set(D++,V)}const y=ae(S);for(const V of y){const M=w.get(V);if(M===void 0)throw new Error("Map error!");m.push(M)}}return m}updatePlane2DCoordinateSystem(){this._plane2DCoordinateSystem=new z;const t=new L(1,0,0),e=new L(0,1,0),s=this._plane.normal,i=new L;this._plane.coplanarPoint(i),this._planeAxis==="x"?t.crossVectors(e,s):this._planeAxis==="y"?e.crossVectors(s,t):this._planeAxis==="z"||(t.crossVectors(e,s).normalize(),e.crossVectors(s,t)),this._plane2DCoordinateSystem.fromArray([t.x,t.y,t.z,0,e.x,e.y,e.z,0,s.x,s.y,s.z,0,i.x,i.y,i.z,1]),this._plane2DCoordinateSystem.invert()}getStyle(){if(!this.world.renderer)return null;const t=this.world.renderer instanceof W;return this.styleName&&t?this.world.renderer.postproduction.customEffects.outlinedMeshes[this.styleName]:null}}class de{constructor(t,e,s){r(this,"onDisposed",new P);r(this,"onAfterUpdate",new P);r(this,"onBeforeUpdate",new P);r(this,"enabled",!0);r(this,"fillNeedsUpdate",!1);r(this,"components");r(this,"world");r(this,"_edges",{});r(this,"_visible",!0);r(this,"_inverseMatrix",new z);r(this,"_localPlane",new ee);r(this,"_tempLine",new te);r(this,"_tempVector",new L);r(this,"_plane");this.components=t,this.world=e,this._plane=s}get visible(){return this._visible}set visible(t){for(const e in this._edges){const s=this._edges[e];t?this.world.scene.three.add(s.mesh):s.mesh.removeFromParent(),s.fill&&(s.fill.visible=t)}}update(){const e=this.components.get(E).styles.list;this.updateDeletedEdges(e);for(const s in e)this.drawEdges(s);this.fillNeedsUpdate=!1}get(){return this._edges}dispose(){const t=Object.keys(this._edges);for(const e of t)this.disposeEdge(e);this.onDisposed.trigger(),this.onDisposed.reset()}newEdgesMesh(t){const i=this.components.get(E).styles.list[t].lineMaterial,n=new Z,l=new Float32Array(3e5),o=new se(l,3,!1);o.setUsage(ie),n.setAttribute("position",o);const a=new ne(n,i);return a.frustumCulled=!1,a}newFillMesh(t,e){const n=this.components.get(E).styles.list[t],l=n.fillMaterial;if(l){const o=new ce(this.world,this._plane,e,l);return this.newFillOutline(t,o,n),o}}newFillOutline(t,e,s){if(!s.outlineMaterial||!this.world.renderer)return;const i=this.world.renderer;if(i instanceof W){const l=i.postproduction.customEffects.outlinedMeshes;l[t]||(l[t]={meshes:new Set,material:s.outlineMaterial}),e.styleName=t}}drawEdges(t){const s=this.components.get(E).styles.list[t];this._edges[t]||this.initializeStyle(t);const i=this._edges[t];let n=0;const l=i.mesh.geometry.attributes.position;l.array.fill(0);const o=[];let a=0;for(const m of s.meshes)if(m.geometry){if(!m.geometry.boundsTree)throw new Error("Bounds tree not found for clipping edges subset.");if(m instanceof oe){if(m.count===0)continue;const x=m;for(let u=0;u<x.count;u++){const S=x instanceof re,w=x,D=s.fragments[w.fragment.id];if(S&&D){const M=w.fragment.getItemID(u);if(M===null||!D.has(M))continue}const y=new Y(m.geometry);y.matrix.copy(m.matrix);const V=new z;x.getMatrixAt(u,V),y.applyMatrix4(V),y.applyMatrix4(m.matrix),y.updateMatrix(),y.updateMatrixWorld(),this._inverseMatrix.copy(y.matrixWorld).invert(),this._localPlane.copy(this._plane).applyMatrix4(this._inverseMatrix),n=this.shapecast(y,l,n),n!==a&&(o.push(n),a=n)}}else this._inverseMatrix.copy(m.matrixWorld).invert(),this._localPlane.copy(this._plane).applyMatrix4(this._inverseMatrix),n=this.shapecast(m,l,n),n!==a&&(o.push(n),a=n)}i.mesh.geometry.setDrawRange(0,n),i.mesh.position.copy(this._plane.normal).multiplyScalar(1e-4),l.needsUpdate=!0;const _=i.mesh.geometry.attributes.position;Number.isNaN(_.array[0])||(i.mesh.parent||this.world.scene.three.add(i.mesh),this.fillNeedsUpdate&&i.fill&&(i.fill.geometry=i.mesh.geometry,i.fill.update(o)))}initializeStyle(t){const e=this.newEdgesMesh(t),s=e.geometry,i=this.newFillMesh(t,s);this._edges[t]={mesh:e,name:t,fill:i}}shapecast(t,e,s){return t.geometry.boundsTree.shapecast({intersectsBounds:i=>this._localPlane.intersectsBox(i),intersectsTriangle:i=>{let n=0;if(this._tempLine.start.copy(i.a),this._tempLine.end.copy(i.b),this._localPlane.intersectLine(this._tempLine,this._tempVector)){const l=this._tempVector.applyMatrix4(t.matrixWorld);e.setXYZ(s,l.x,l.y,l.z),n++,s++}if(this._tempLine.start.copy(i.b),this._tempLine.end.copy(i.c),this._localPlane.intersectLine(this._tempLine,this._tempVector)){const l=this._tempVector.applyMatrix4(t.matrixWorld);e.setXYZ(s,l.x,l.y,l.z),n++,s++}if(this._tempLine.start.copy(i.c),this._tempLine.end.copy(i.a),this._localPlane.intersectLine(this._tempLine,this._tempVector)){const l=this._tempVector.applyMatrix4(t.matrixWorld);e.setXYZ(s,l.x,l.y,l.z),n++,s++}n!==2&&(s-=n)}}),s}updateDeletedEdges(t){const e=Object.keys(this._edges);for(const s of e)t[s]===void 0&&(this.disposeEdge(s),this.disposeOutline(s))}disposeOutline(t){if(!this.world.renderer)return;const e=this.world.renderer;if(e instanceof W){const s=e.postproduction.customEffects.outlinedMeshes;delete s[t]}}disposeEdge(t){const e=this.components.get(q),s=this._edges[t];s.fill&&s.fill.dispose(),e.destroy(s.mesh,!1),delete this._edges[t]}}class X extends K{constructor(e,s,i,n,l,o=5,a=!0){super(e,s,i,n,l,o,a);r(this,"edges");r(this,"edgesMaxUpdateRate",50);r(this,"_visible",!0);r(this,"_edgesVisible",!0);r(this,"updateFill",()=>{this.edges.fillNeedsUpdate=!0,this.edges.update(),this.edges.visible=this._visible});this.edges=new de(e,s,this.three),this.toggleControls(!0),this.edges.visible=!0,this.onDraggingEnded.add(()=>{this.updateFill()}),this.onDraggingStarted.add(()=>this.edges.visible=!1)}get visible(){return this._visible}set visible(e){super.visible=e,this.toggleControls(e)}set enabled(e){this._enabled=e,this.world.renderer&&this.world.renderer.setPlane(e,this.three)}get enabled(){return super.enabled}dispose(){super.dispose(),this.edges.dispose()}}class he{constructor(){r(this,"onDisposed",new P);r(this,"enabled",!0);r(this,"list",{});r(this,"_defaultLineMaterial",new le({color:0,linewidth:.001}));r(this,"onAfterUpdate",new P);r(this,"onBeforeUpdate",new P)}update(t){this.onBeforeUpdate.trigger(this.list),this.onAfterUpdate.trigger(this.list)}create(t,e,s,i,n,l){if(!s.renderer)throw new Error("The given world doesn't have a renderer!");i||(i=this._defaultLineMaterial);for(const g of e)g.geometry.boundsTree||g.geometry.computeBoundsTree();const o=s.renderer;i.clippingPlanes=o.clippingPlanes;const a={name:t,lineMaterial:i,meshes:e,fillMaterial:n,outlineMaterial:l,fragments:{}};return this.list[t]=a,a}dispose(){const t=Object.keys(this.list);for(const e of t)this.deleteStyle(e);this.list={},this.onDisposed.trigger(),this.onDisposed.reset()}deleteStyle(t,e=!0){var i,n;const s=this.list[t];s&&(s.meshes.clear(),e&&(s.lineMaterial.dispose(),(i=s.fillMaterial)==null||i.dispose(),(n=s.outlineMaterial)==null||n.dispose())),delete this.list[t]}}const N=class N extends Q{constructor(e){super(e);r(this,"onDisposed",new P);r(this,"enabled",!0);r(this,"styles");r(this,"fillsNeedUpdate",!1);r(this,"_visible",!0);this.components.list.set(N.uuid,this),this.styles=new he}get visible(){return this._visible}set visible(e){this._visible=e;const s=this.components.get(R);for(const i of s.list)i instanceof X&&(i.edges.visible=e)}dispose(){this.styles.dispose(),this.onDisposed.trigger()}async update(e=!1){if(!this.enabled)return;const s=this.components.get(R);for(const i of s.list)i instanceof X&&(e||this.fillsNeedUpdate?i.updateFill():i.update());this.fillsNeedUpdate=!1}};r(N,"uuid","24dfc306-a3c4-410f-8071-babc4afa5e4d");let E=N;export{E as C,X as E};
