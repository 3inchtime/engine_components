import"./unzipit.module-DQmiVUKU.js";import{c as d,B as g,d as y}from"./serializer-DZyNoHx-.js";class r{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsStreamedGeometry(t,e){return(e||new r).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsStreamedGeometry(t,e){return t.setPosition(t.position()+d),(e||new r).__init(t.readInt32(t.position())+t.position(),t)}geometryId(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.readUint32(this.bb_pos+t):0}position(t){const e=this.bb.__offset(this.bb_pos,6);return e?this.bb.readFloat32(this.bb.__vector(this.bb_pos+e)+t*4):0}positionLength(){const t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}positionArray(){const t=this.bb.__offset(this.bb_pos,6);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}normal(t){const e=this.bb.__offset(this.bb_pos,8);return e?this.bb.readFloat32(this.bb.__vector(this.bb_pos+e)+t*4):0}normalLength(){const t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}normalArray(){const t=this.bb.__offset(this.bb_pos,8);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}index(t){const e=this.bb.__offset(this.bb_pos,10);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+t*4):0}indexLength(){const t=this.bb.__offset(this.bb_pos,10);return t?this.bb.__vector_len(this.bb_pos+t):0}indexArray(){const t=this.bb.__offset(this.bb_pos,10);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}static startStreamedGeometry(t){t.startObject(4)}static addGeometryId(t,e){t.addFieldInt32(0,e,0)}static addPosition(t,e){t.addFieldOffset(1,e,0)}static createPositionVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addFloat32(e[s]);return t.endVector()}static startPositionVector(t,e){t.startVector(4,e,4)}static addNormal(t,e){t.addFieldOffset(2,e,0)}static createNormalVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addFloat32(e[s]);return t.endVector()}static startNormalVector(t,e){t.startVector(4,e,4)}static addIndex(t,e){t.addFieldOffset(3,e,0)}static createIndexVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startIndexVector(t,e){t.startVector(4,e,4)}static endStreamedGeometry(t){return t.endObject()}static createStreamedGeometry(t,e,s,i,o){return r.startStreamedGeometry(t),r.addGeometryId(t,e),r.addPosition(t,s),r.addNormal(t,i),r.addIndex(t,o),r.endStreamedGeometry(t)}}class n{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsStreamedGeometries(t,e){return(e||new n).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsStreamedGeometries(t,e){return t.setPosition(t.position()+d),(e||new n).__init(t.readInt32(t.position())+t.position(),t)}geometries(t,e){const s=this.bb.__offset(this.bb_pos,4);return s?(e||new r).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+t*4),this.bb):null}geometriesLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}static startStreamedGeometries(t){t.startObject(1)}static addGeometries(t,e){t.addFieldOffset(0,e,0)}static createGeometriesVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startGeometriesVector(t,e){t.startVector(4,e,4)}static endStreamedGeometries(t){return t.endObject()}static finishStreamedGeometriesBuffer(t,e){t.finish(e)}static finishSizePrefixedStreamedGeometriesBuffer(t,e){t.finish(e,void 0,!0)}static createStreamedGeometries(t,e){return n.startStreamedGeometries(t),n.addGeometries(t,e),n.endStreamedGeometries(t)}}class x{import(t){const e=new g(t),s=n.getRootAsStreamedGeometries(e),i=new Map,o=s.geometriesLength();for(let a=0;a<o;a++){const c=s.geometries(a);if(!c)continue;const b=c.geometryId();if(b===null)throw new Error("Error finding ID!");const f=c.positionArray(),h=c.normalArray(),_=c.indexArray();!f||!h||!_||i.set(b,{position:f,normal:h,index:_})}return i}export(t){const e=new y(1024),s=[],i=n,o=r;for(const[b,{index:f,position:h,normal:_}]of t){const m=o.createIndexVector(e,f),p=o.createPositionVector(e,h),l=o.createNormalVector(e,_);o.startStreamedGeometry(e),o.addGeometryId(e,b),o.addIndex(e,m),o.addPosition(e,p),o.addNormal(e,l);const u=o.endStreamedGeometry(e);s.push(u)}const a=i.createGeometriesVector(e,s);i.startStreamedGeometries(e),i.addGeometries(e,a);const c=i.endStreamedGeometries(e);return e.finish(c),e.asUint8Array()}}export{x as S};
