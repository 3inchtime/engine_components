var V=Object.defineProperty;var R=(d,l,t)=>l in d?V(d,l,{enumerable:!0,configurable:!0,writable:!0,value:t}):d[l]=t;var u=(d,l,t)=>(R(d,typeof l!="symbol"?l+"":l,t),t);import{D as G,A as $,C as q}from"./web-ifc-api-Glg4rFxW.js";import{S as z}from"./stats.min-GTpOrGrX.js";import{g as J}from"./lil-gui.module.min-Bc0DeA9g.js";import{a as j,E as K,C as Q}from"./index-BjtWM7Op.js";import{S as W,a as X}from"./simple-camera-FtEnIFQL.js";import{I as S,a as Y}from"./properties-utils-CJ1nLVj1.js";import{F as g}from"./index-BHbmf4IB.js";import{C as Z}from"./index-MOFydgmy.js";import"./_commonjsHelpers-Cpj98o6Y.js";import"./async-event-D8tC9awa.js";const D=class D extends j{constructor(t){super(t);u(this,"enabled",!0);u(this,"list",{});u(this,"onDisposed",new K);u(this,"onFragmentsDisposed",t=>{const{groupID:o,fragmentIDs:i}=t;for(const e in this.list){const s=this.list[e],n=Object.keys(s);if(n.includes(o))delete s[o],Object.values(s).length===0&&delete this.list[e];else for(const r of n){const a=s[r];for(const f of i)delete a[f];Object.values(a).length===0&&delete s[r]}}});t.add(D.uuid,this),t.get(g).onFragmentsDisposed.add(this.onFragmentsDisposed)}dispose(){this.list={},this.components.get(g).onFragmentsDisposed.remove(this.onFragmentsDisposed),this.onDisposed.trigger(),this.onDisposed.reset()}remove(t){for(const o in this.list){const i=this.list[o];for(const e in i){const s=i[e];delete s[t]}}}find(t){const o=this.components.get(g);if(!t){const n={};for(const[r,a]of o.list)n[r]=new Set(a.ids);return n}const i=Object.keys(t).length,e={};for(const n in t){const r=t[n];if(!this.list[n]){console.warn(`Classification ${n} does not exist.`);continue}for(const a of r){const f=this.list[n][a];if(f)for(const m in f){e[m]||(e[m]=new Map);for(const p of f[m]){const b=e[m].get(p);b===void 0?e[m].set(p,1):e[m].set(p,b+1)}}}}const s={};for(const n in e){const r=e[n];for(const[a,f]of r){if(f===void 0)throw new Error("Malformed fragments map!");f===i&&(s[n]||(s[n]=new Set),s[n].add(a))}}return s}byModel(t,o){this.list.model||(this.list.model={});const i=this.list.model;i[t]||(i[t]={});const e=i[t];for(const[s,n]of o.data){const r=n[0];for(const a of r){const f=o.keyFragments.get(a);f&&(e[f]||(e[f]=new Set),e[f].add(s))}}}async byPredefinedType(t){var e;this.list.predefinedTypes||(this.list.predefinedTypes={});const o=this.list.predefinedTypes,i=t.getAllPropertiesIDs();for(const s of i){const n=await t.getProperties(s);if(!n)continue;const r=String((e=n.PredefinedType)==null?void 0:e.value).toUpperCase();o[r]||(o[r]={});const a=o[r];for(const[f,m]of t.data){const p=m[0];for(const b of p){const C=t.keyFragments.get(b);if(!C)throw new Error("Fragment ID not found!");a[C]||(a[C]=new Set),a[C].add(n.expressID)}}}}byEntity(t){this.list.entities||(this.list.entities={});for(const[o,i]of t.data){const s=i[1][1],n=Y[s];this.saveItem(t,"entities",n,o)}}byStorey(t){for(const[o,i]of t.data){const n=i[1][0].toString();this.saveItem(t,"storeys",n,o)}}async byIfcRel(t,o,i){S.isRel(o)&&await S.getRelationMap(t,o,async(e,s)=>{const{name:n}=await S.getEntityName(t,e);for(const r of s)this.saveItem(t,i,n??"NO REL NAME",r)})}setColor(t,o,i=!1){const e=this.components.get(g);for(const s in t){const n=e.list.get(s);if(!n)continue;const r=t[s];n.setColor(o,r,i)}}resetColor(t){const o=this.components.get(g);for(const i in t){const e=o.list.get(i);if(!e)continue;const s=t[i];e.resetColor(s)}}saveItem(t,o,i,e){this.list[o]||(this.list[o]={});const s=t.data.get(e);if(s)for(const n of s[0]){const r=t.keyFragments.get(n);if(r){const a=this.list[o];a[i]||(a[i]={}),a[i][r]||(a[i][r]=new Set),a[i][r].add(e)}}}};u(D,"uuid","e25a7f3c-46c4-4a14-9d3d-5115f24ebeb7");let k=D;const I=class I extends j{constructor(t){super(t);u(this,"enabled",!0);this.components.add(I.uuid,this)}set(t,o){const i=this.components.get(g);if(!o){for(const e in i.list){const s=i.list.get(e);s&&(s.setVisibility(t),this.updateCulledVisibility(s))}return}for(const e in o){const s=o[e],n=i.list.get(e);n&&(n.setVisibility(t,s),this.updateCulledVisibility(n))}}isolate(t){this.set(!1),this.set(!0,t)}updateCulledVisibility(t){const o=this.components.get(Z);for(const[i,e]of o.list){const s=e.colorMeshes.get(t.id);s&&(s.count=t.mesh.count)}}};u(I,"uuid","dd9ccf2d-8a21-4821-b7f6-2949add16a29");let v=I;const H=document.getElementById("container"),c=new Q,O=new W(c);O.setup();c.scene=O;const y=new(void 0)(c,H);c.renderer=y;const A=new X(c);c.camera=A;c.raycaster=new(void 0)(c);c.init();y.postproduction.enabled=!0;const L=c.scene.get();A.controls.setLookAt(12,6,8,0,0,-10);const x=new G;x.position.set(5,10,3);x.intensity=.5;L.add(x);const P=new $;P.intensity=.5;L.add(P);const _=new(void 0)(c,new q(6710886)),tt=_.get(),et=y.postproduction.customEffects;et.excludedMeshes.push(tt);const st=new g(c),nt=await fetch("../../../resources/small.frag"),ot=await nt.arrayBuffer(),it=new Uint8Array(ot),T=await st.load(it),rt=await fetch("../../../resources/small.json");T.setLocalProperties(await rt.json());const M=new v(c);await M.loadCached();const h=new k(c);h.byStorey(T);h.byEntity(T);const N=h.get(),E={},at=Object.keys(N.storeys);for(const d of at)E[d]=!0;const F={},ct=Object.keys(N.entities);for(const d of ct)F[d]=!0;const B=new J,dt=B.addFolder("Storeys");for(const d in E)dt.add(E,d).onChange(l=>{const t=h.find({storeys:[d]});M.set(l,t)});const ft=B.addFolder("Classes");for(const d in F)ft.add(F,d).onChange(l=>{const t=h.find({entities:[d]});M.set(l,t)});const U=new(void 0)(c);c.ui.addToolbar(U);const lt=M.uiElement.get("main");U.addChild(lt);const w=new z;w.showPanel(2);document.body.append(w.dom);w.dom.style.left="0px";y.onBeforeUpdate.add(()=>w.begin());y.onAfterUpdate.add(()=>w.end());
