var Q=Object.defineProperty;var q=(b,h,n)=>h in b?Q(b,h,{enumerable:!0,configurable:!0,writable:!0,value:n}):b[h]=n;var p=(b,h,n)=>(q(b,typeof h!="symbol"?h+"":h,n),n);import{V as m,E as J,h as W,c as f,g as y,L as T,Q as tt,p as I,o as et}from"./web-ifc-api-BiYij3qq.js";import{J as Z,U as V,A as nt}from"./index-B3b_h8A8.js";import{C as ot}from"./curve-highlighter-B2XYj340.js";import{M as P}from"./index-Bq1KDtuM.js";import"./import-wrapper-prod-vMwJRSad.js";import{M}from"./mark-B9TqPH3U.js";const st=["Station","Radius","Length","InitialKP","FinalKP","KP","Slope","Height","InitialKPV","FinalKPV"],C=class C extends Z{constructor(n){super(n);p(this,"enabled",!0);p(this,"world",null);p(this,"list",new Map);p(this,"_markerKey",0);p(this,"type","horizontal");p(this,"divisionLength",100);n.add(C.uuid,this)}addKPStation(n,i,t){const e=this.components.get(P),s=document.createElement("div"),o=document.createElement("div");s.appendChild(o),o.innerHTML=i,o.style.color=e.color,o.style.borderBottom="1px dotted white",o.style.width="160px",o.style.textAlign="left";const l=new M(n,s),a=new m;a.x=t.geometry.attributes.position.getX(t.geometry.attributes.position.count-1),a.y=t.geometry.attributes.position.getY(t.geometry.attributes.position.count-1),a.z=t.geometry.attributes.position.getZ(t.geometry.attributes.position.count-1);const r=new m;r.x=t.geometry.attributes.position.getX(t.geometry.attributes.position.count-2),r.y=t.geometry.attributes.position.getY(t.geometry.attributes.position.count-2),r.z=t.geometry.attributes.position.getZ(t.geometry.attributes.position.count-2);const c=new m;c.x=(a.x+r.x)/2,c.y=(a.y+r.y)/2,c.z=(a.z+r.z)/2,l.three.position.copy(c);const d=new m;d.subVectors(a,r).normalize();const u=new tt;u.setFromUnitVectors(new m(0,1,0),d);const g=new J().setFromQuaternion(u).z,w=W.radToDeg(g);o.style.transform=`rotate(${-w-90}deg) translate(-35%, -50%)`;const v=this._markerKey.toString();e.list.set(v,{label:l,key:v,merged:!1,static:!1}),this._markerKey++,this.save(v,"KP")}addVerticalMarker(n,i,t,e,s){const o=this.components.get(P),l=document.createElement("span");l.innerHTML=i,l.style.color=o.color;const a=new M(n,l,s);if(e==="Height"){const c=document.createElement("span");c.innerHTML=i,c.style.color=o.color;const{position:d}=t.geometry.attributes,g=(d.array.length/3-1)*3,w=d.array.slice(g,g+3);a.three.position.set(w[0],w[1]+10,w[2])}else if(e==="InitialKPV"){const{position:c}=t.geometry.attributes,d=c.getX(0),u=c.getY(0),g=c.getZ(0);a.three.position.set(d-20,u,g)}else if(e==="FinalKPV"){const{position:c}=t.geometry.attributes,d=c.getX(t.geometry.attributes.position.count-1),u=c.getY(t.geometry.attributes.position.count-1),g=c.getZ(t.geometry.attributes.position.count-1);a.three.position.set(d+20,u,g)}else if(e==="Slope"){l.style.color="grey";const{position:c}=t.geometry.attributes,d=new m;d.x=c.getX(0),d.y=c.getY(0),d.z=c.getZ(0);const u=new m;u.x=c.getX(c.count-1),u.y=c.getY(c.count-1),u.z=c.getZ(c.count-1);const g=new m;g.addVectors(d,u).multiplyScalar(.5),a.three.position.set(g.x,g.y-10,g.z)}const r=this._markerKey.toString();return o.list.set(r,{label:a,key:r,type:e,merged:!1,static:!1}),this._markerKey++,this.save(r,e),a}addCivilMarker(n,i,t,e){const s=this.components.get(P),o=document.createElement("span");o.innerHTML=i,o.style.color=s.color;const l=new M(n,o);if(e==="InitialKP"){const r=t.geometry.attributes.position.getX(0),c=t.geometry.attributes.position.getY(0),d=t.geometry.attributes.position.getZ(0);l.three.position.set(r+2,c+2,d)}else if(e==="FinalKP"){const r=t.geometry.attributes.position.getX(t.geometry.attributes.position.count-1),c=t.geometry.attributes.position.getY(t.geometry.attributes.position.count-1),d=t.geometry.attributes.position.getZ(t.geometry.attributes.position.count-1);l.three.position.set(r+2,c-2,d)}else if(e==="Length"){const r=new m;r.x=t.geometry.attributes.position.getX(0),r.y=t.geometry.attributes.position.getY(0),r.z=t.geometry.attributes.position.getZ(0);const c=new m;c.x=t.geometry.attributes.position.getX(t.geometry.attributes.position.count-1),c.y=t.geometry.attributes.position.getY(t.geometry.attributes.position.count-1),c.z=t.geometry.attributes.position.getZ(t.geometry.attributes.position.count-1);const d=r.distanceTo(c);l.three.element.innerText=d.toFixed(2);const u=c.clone().add(r).divideScalar(2);l.three.position.copy(u)}const a=this._markerKey.toString();return s.list.set(a,{label:l,key:a,type:e,merged:!1,static:!1}),this._markerKey++,this.save(a,e),l}showKPStations(n){if(!this.world)throw new Error("A world is needed for this component to work!");if(this.type==="horizontal"){const i=this.generateStartAndEndKP(n);for(const[,e]of i)this.addKPStation(this.world,e.value,e.normal);const t=this.generateConstantKP(n);for(const[,e]of t)this.addKPStation(this.world,e.value,e.normal)}}showCurveLength(n,i){if(!this.world)throw new Error("A world is needed for this component to work!");const t=this.components.get(P),e=n.length,s=`${i.toFixed(2)} m`,o=Math.round(e/2),l=n[o],a=t.create(this.world,s,l,!0);this.save(a,"Length")}showLineLength(n,i){if(!this.world)throw new Error("A world is needed for this component to work!");const t=this.components.get(P),e=new m;e.x=n.geometry.getAttribute("position").getX(0),e.y=n.geometry.getAttribute("position").getY(0),e.z=n.geometry.getAttribute("position").getZ(0);const s=new m;s.x=n.geometry.getAttribute("position").getX(1),s.y=n.geometry.getAttribute("position").getY(1),s.z=n.geometry.getAttribute("position").getZ(1);const o=`${i.toFixed(2)} m`,l=new m;l.addVectors(e,s).multiplyScalar(.5);const a=t.create(this.world,o,l,!0);this.save(a,"Length")}showCurveRadius(n,i){if(!this.world)throw new Error("A world is needed for this component to work!");const t=this.components.get(P),e=new m;e.x=n.geometry.getAttribute("position").getX(0),e.y=n.geometry.getAttribute("position").getY(0),e.z=n.geometry.getAttribute("position").getZ(0);const s=new m;s.x=n.geometry.getAttribute("position").getX(1),s.y=n.geometry.getAttribute("position").getY(1),s.z=n.geometry.getAttribute("position").getZ(1);const o=`R = ${i.toFixed(2)} m`,l=new m;l.addVectors(e,s).multiplyScalar(.5);const a=t.create(this.world,o,l,!0);this.save(a,"Radius")}deleteByType(n=st){const i=this.components.get(P);for(const t of n){const e=this.list.get(t);if(e){for(const s of e)i.delete(s);this.list.delete(t)}}}generateStartAndEndKP(n){const{alignment:i}=n.curve,t=new Map;for(const e of i.horizontal){const s=e.getLength();if(t.size>0){const o=e.index-1,a=t.get(o).distance+s,r=e.mesh.geometry.getAttribute("position"),c=r.count-1,d=new m;d.x=r.getX(c),d.y=r.getY(c),d.z=r.getZ(c);const u=this.createNormalLine(e.mesh);t.set(e.index,{value:this.getShortendKPValue(a),distance:a,point:d,normal:u})}else{const o=e.mesh.geometry.getAttribute("position"),l=o.count-1,a=new m;a.x=o.getX(l),a.y=o.getY(l),a.z=o.getZ(l);const r=this.createNormalLine(e.mesh);t.set(e.index,{value:this.getShortendKPValue(s),distance:s,point:a,normal:r})}}return t}createNormalLine(n){const i=n.geometry.attributes.position.count-1,t=i-1,e=new m;e.x=n.geometry.attributes.position.getX(i),e.y=n.geometry.attributes.position.getY(i),e.z=n.geometry.attributes.position.getZ(i);const s=new m;s.x=n.geometry.attributes.position.getX(t),s.y=n.geometry.attributes.position.getY(t),s.z=n.geometry.attributes.position.getZ(t);const l=new m().subVectors(e,s).clone().applyAxisAngle(new m(0,0,1),Math.PI*.5).normalize(),a=new f().setFromPoints([l.clone().setLength(10).add(e),l.clone().setLength(-10).add(e)]);return new y(a)}generateConstantKP(n){const{alignment:i}=n.curve,t=new Map,e=i.getLength("horizontal"),s=Math.floor(e/this.divisionLength);for(let o=0;o<s;o++){const l=o/s,a=i.getPointAt(l,"horizontal"),r=e*l,c=this.getNormal(i,a);t.set(o,{value:this.getShortendKPValue(r),distance:r,point:a,normal:c})}return t}getNormal(n,i){const t=[],e={start:new m,end:new m};for(let r=0;r<n.horizontal.length;r++){const d=n.horizontal[r].mesh.geometry.attributes.position,u=d.count;for(let g=0;g<u;g++){const w=d.getX(g),v=d.getY(g),L=d.getZ(g);t.push(new m(w,v,L))}}for(let r=0;r<t.length-1;r++){const c=t[r],d=t[r+1],u=c.distanceTo(i),g=d.distanceTo(i),w=c.distanceTo(d);Math.abs(u+g-w)<1e-5&&(e.start=c,e.end=d)}const o=new m().subVectors(e.end,e.start).clone().applyAxisAngle(new m(0,0,1),Math.PI*.5).normalize(),l=new f().setFromPoints([o.clone().setLength(10).add(i),o.clone().setLength(-10).add(i)]);return new y(l,new T({color:16711680}))}getShortendKPValue(n){const i=n.toFixed(2),[t,e]=i.toString().split("."),s=e||"00";if(parseInt(t,10)>1e3&&parseInt(t,10)<1e4){const[o,...l]=t;return`${o}+${l.join("")}.${s}`}if(parseInt(t,10)>1e4){const[o,l,...a]=t;return`${o}${l}+${a.join("")}.${s}`}return`0+${t.padStart(3,"0")}.${s}`}save(n,i){this.list.has(i)||this.list.set(i,new Set),this.list.get(i).add(n)}};p(C,"uuid","0af12c32-81ee-4100-a030-e9ae546f6170");let k=C;class it extends Z{constructor(n){super(n);p(this,"enabled",!0);p(this,"highlighter");p(this,"onHighlight",new V);p(this,"onMarkerChange",new V);p(this,"mouseMarkers");p(this,"onMarkerHidden",new V);p(this,"_curves",[]);p(this,"_previousAlignment",null);p(this,"_world",null);p(this,"onMouseMove",n=>{var o,l,a;if(!this._world)throw new Error("No world was given for this navigator!");if(!this._world.renderer)return;const t=this._world.renderer.three.domElement.parentElement,e=this._world.camera.three,s=(o=this.highlighter)==null?void 0:o.castRay(n,e,t,this._curves);if(s){const{object:r}=s;(l=this.highlighter)==null||l.hover(r),this.updateMarker(s,"hover");return}this.mouseMarkers&&(this.mouseMarkers.hover.visible=!1),(a=this.highlighter)==null||a.unHover(),this.onMarkerHidden.trigger({type:"hover"})});p(this,"onClick",n=>{var o,l;if(!this._world)throw new Error("No world was given for this navigator!");if(!this._world.renderer)return;const t=this._world.renderer.three.domElement.parentElement,e=this._world.camera.three,s=(o=this.highlighter)==null?void 0:o.castRay(n,e,t,this._curves);if(s){const a=s,r=a.object;if((l=this.highlighter)==null||l.select(r),this.updateMarker(a,"select"),this._world.camera.hasCameraControls()&&(r.geometry.boundingBox||r.geometry.computeBoundingBox(),r.geometry.boundingBox)){const c=this.getScaledBox(r.geometry.boundingBox,2);this._world.camera.controls.fitToBox(c,!0)}if(this.onHighlight.trigger({mesh:r,point:a.point}),this._previousAlignment!==r.curve.alignment){const c=this.components.get(k);c.deleteByType(),c.showKPStations(r),this._previousAlignment=r.curve.alignment}}});p(this,"onControlsUpdated",()=>{if(!this._world)throw new Error("No world was given for this navigator!");if(!(this._world.camera.three instanceof et)||!this.highlighter)return;const{zoom:n,left:i,right:t,top:e,bottom:s}=this._world.camera.three,o=i-t,l=e-s,r=Math.max(o,l)/n,c=40,{caster:d}=this.highlighter;d.params.Line.threshold=r/c})}get world(){return this._world}set world(n){var t,e,s;if(n===this._world||(this._world&&this.setupEvents(!1),this._world=n,(t=this.highlighter)==null||t.dispose(),(e=this.mouseMarkers)==null||e.hover.dispose(),(s=this.mouseMarkers)==null||s.select.dispose(),!n))return;const i=n.scene.three;this.highlighter=new ot(i,this.view),this.mouseMarkers={select:this.newMouseMarker("#ffffff",n),hover:this.newMouseMarker("#575757",n)},this.setupEvents(!0)}async draw(n,i){if(!n.civilData)throw new Error("The provided model doesn't have civil data!");if(!this._world)throw new Error("No world was given for this navigator!");const{alignments:t}=n.civilData,e=i||t.values(),s=this._world.scene.three,o=new I;o.makeEmpty(),o.min.set(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),o.max.set(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE);for(const a of e){if(!a)throw new Error("Alignment not found!");for(const r of a[this.view])if(s.add(r.mesh),this._curves.push(r.mesh),!o.isEmpty())o.expandByObject(r.mesh);else{r.mesh.geometry.computeBoundingBox();const c=r.mesh.geometry.boundingBox;c instanceof I&&o.copy(c).applyMatrix4(r.mesh.matrixWorld)}}const l=this.getScaledBox(o,1.2);this._world.camera.hasCameraControls()&&await this._world.camera.controls.fitToBox(l,!1)}async dispose(){var n;(n=this.highlighter)==null||n.dispose(),this.clear(),this.onHighlight.reset(),this._curves=[]}clear(){var n,i;(n=this.highlighter)==null||n.unSelect(),(i=this.highlighter)==null||i.unHover();for(const t of this._curves)t.removeFromParent();this._curves=[]}setMarker(n,i,t){if(!this._curves.length)return;const e=n.getCurveAt(i,this.view),s=n.getPointAt(i,this.view),{index:o}=e.curve.getSegmentAt(e.percentage);this.setMouseMarker(s,e.curve.mesh,o,t)}setDefSegments(n){const i=[],t=[],e=(s,o)=>{const l=o[1]-s[1],a=o[0]-s[0];return l/a};for(let s=0;s<n.length;s++){const o=n[s];let l,a,r,c;for(let g=0;g<Object.keys(o).length/3;g++)if(o[g*3]!==void 0&&o[g*3+1]!==void 0){l=o[g*3],a=o[g*3+1];break}for(let g=Object.keys(o).length/3-1;g>=0;g--)if(o[g*3]!==void 0&&o[g*3+1]!==void 0){r=o[g*3],c=o[g*3+1];break}const u=(e([l,a],[r,c])*100).toFixed(2);t.push({slope:u})}for(const s of n)for(let o=0;o<s.length-3;o+=3){const l=s[o],a=s[o+1],r=s[o+2],c=s[o+3],d=s[o+4],u=s[o+5];i.push({start:new m(l,a,r),end:new m(c,d,u)})}return{defSegments:i,slope:t}}hideMarker(n){this.mouseMarkers&&(this.mouseMarkers[n].visible=!1)}setupEvents(n){if(!this._world)throw new Error("No world was given for this navigator!");if(!this._world.renderer)return;const t=this._world.renderer.three.domElement.parentElement;t.removeEventListener("mousemove",this.onMouseMove),t.removeEventListener("click",this.onClick),this._world.camera.hasCameraControls()&&this._world.camera.controls.removeEventListener("update",this.onControlsUpdated),n&&(t.addEventListener("mousemove",this.onMouseMove),t.addEventListener("click",this.onClick),this._world.camera.hasCameraControls()&&this._world.camera.controls.addEventListener("update",this.onControlsUpdated))}newMouseMarker(n,i){if(!this._world)throw new Error("No world was given for this navigator!");const t=i.scene.three,e=document.createElement("div"),s=document.createElement("div");e.appendChild(s),s.style.backgroundColor=n,s.style.width="3rem",s.style.height="3px";const o=new M(this._world,e,t);return o.visible=!1,o}setMouseMarker(n,i,t,e){if(t===void 0||!this.mouseMarkers)return;this.mouseMarkers[e].visible=!0;const s=this.mouseMarkers[e].three;s.position.copy(n);const o=i,{startPoint:l,endPoint:a}=o.curve.getSegment(t),r=Math.atan2(a.y-l.y,a.x-l.x),c=s.element.children[0],d=90-r/Math.PI*180;c.style.transform=`rotate(${d}deg)`}updateMarker(n,i){const{point:t,index:e,object:s}=n,o=s,l=o.curve,a=o.curve.alignment,r=a.getPercentageAt(t,this.view),c=t.clone();this.setMouseMarker(c,o,e,i),r!==null&&this.onMarkerChange.trigger({alignment:a,percentage:r,type:i,curve:l})}getScaledBox(n,i){const t=new I,e=new m,s=new m;return n.getCenter(s),n.getSize(e),e.multiplyScalar(i),t.setFromCenterAndSize(s,e),t}}class rt{constructor(h,n,i){p(this,"components");p(this,"_scene");p(this,"_world");p(this,"offset",10);p(this,"markupLines",[]);p(this,"currentCurveMesh");p(this,"markupMaterial",new T({color:6842472}));this.components=h,this._scene=n,this._world=i}showCurveInfo(h){switch(this.disposeMarkups(),this.currentCurveMesh=h,h.curve.data.TYPE){case"LINE":this.showLineInfo(h,this.offset);break;case"CIRCULARARC":this.showCircularArcInfo(h,this.offset);break;case"CLOTHOID":this.showClothoidInfo(h,this.offset);break;default:console.log("Unknown curve type:",h.curve.data.TYPE);break}}updateOffset(h,n,i){const e=Math.max(h.height,h.width)/(n*150);e!==this.offset&&(this.offset=e,i&&this.currentCurveMesh&&this.showCurveInfo(this.currentCurveMesh))}dispose(){for(const h of this.markupLines)h.removeFromParent();this.disposeMarkups(),this.markupMaterial.dispose()}disposeMarkups(){for(const h of this.markupLines)h.geometry.dispose(),h.removeFromParent();this.markupLines=[]}unSelect(){this.disposeMarkups()}calculateTangent(h,n){const t=n*3,e=Math.max(0,t-3),s=Math.min(h.length-3,t+3),o=new m().fromArray(h,e);return new m().fromArray(h,s).clone().sub(o).normalize()}calculateParallelCurve(h,n,i){const t=[];for(let e=0;e<n;e++){const o=this.calculateTangent(h,e).clone().applyAxisAngle(new m(0,0,1),Math.PI/2);o.normalize();const l=o.clone().multiplyScalar(i),a=e*3,r=new m().fromArray(h,a).add(l);t.push(r)}return t}calculateDimensionLines(h,n){const i=[],t=h.geometry.attributes.position.array,e=n.geometry.attributes.position.array;if(t.length<6&&e.length<6)throw new Error("Line must have at least two vertices");const s=new m(t[0],t[1],t[2]),o=new m(e[0],e[1],e[2]),l=[],a=t.length-3,r=new m(t[a],t[a+1],t[a+2]),c=e.length-3,d=new m(e[c],e[c+1],e[c+2]);return i.push(s,o),l.push(r,d),{startDimensionPoints:i,endDimensionPoints:l}}offsetDimensionLine(h,n){const t=new m().copy(h[h.length-1]).sub(h[0]).normalize().clone().multiplyScalar(n);return h.map(s=>s.clone().add(t))}showLineInfo(h,n){const i=this.components.get(k);i.world=this._world,i.deleteByType(["Length","Radius"]);const t=h.geometry.attributes.position.array,e=this.calculateParallelCurve(t,t.length/3,n),s=new f().setFromPoints(e),o=new y(s,this.markupMaterial);i.showLineLength(o,h.curve.getLength()),this._scene.add(o),this.markupLines.push(o);const{startDimensionPoints:l,endDimensionPoints:a}=this.calculateDimensionLines(h,o),r=this.offsetDimensionLine(l,n*.1),c=this.offsetDimensionLine(a,n*.1),d=new f().setFromPoints(r),u=new f().setFromPoints(c),g=new y(d,this.markupMaterial);this._scene.add(g),this.markupLines.push(g);const w=new y(u,this.markupMaterial);this._scene.add(w),this.markupLines.push(w)}showClothoidInfo(h,n){const i=this.components.get(k);i.world=this._world,i.deleteByType(["Length","Radius"]);const t=h.geometry.attributes.position.array,e=this.calculateParallelCurve(t,t.length/3,n),s=new f().setFromPoints(e);i.showCurveLength(e,h.curve.getLength());const o=new y(s,this.markupMaterial);this._scene.add(o),this.markupLines.push(o);const{startDimensionPoints:l,endDimensionPoints:a}=this.calculateDimensionLines(h,o),r=this.offsetDimensionLine(l,n*.1),c=this.offsetDimensionLine(a,n*.1),d=new f().setFromPoints(r),u=new f().setFromPoints(c),g=new y(d,this.markupMaterial);this._scene.add(g),this.markupLines.push(g);const w=new y(u,this.markupMaterial);this._scene.add(w),this.markupLines.push(w)}showCircularArcInfo(h,n){const i=this.components.get(k);i.world=this._world,i.deleteByType(["Length","Radius"]);const t=h.curve.data.RADIUS,e=h.geometry.attributes.position.array,s=h.geometry.attributes.position.count,o=[],l=new m(e[0],e[1],e[2]),a=(s-1)*3,r=new m(e[a],e[a+1],e[a+2]),c=s/2*3,d=new m(e[c],e[c+1],e[c+2]),u=r.clone().sub(l).normalize(),g=new m(-u.y,u.x,0);g.multiplyScalar(t);const w=d.clone().add(g);o.push(d),o.push(w);const v=new f().setFromPoints(o),L=new y(v,this.markupMaterial);i.showCurveRadius(L,Math.abs(t)),this._scene.add(L),this.markupLines.push(L);const _=[];for(let x=0;x<s;x++){const F=this.calculateTangent(e,x),j=h.curve.data.RADIUS,E=new m(F.y,-F.x,0);E.normalize(),j<0&&E.negate();const z=E.clone().multiplyScalar(n),D=x*3,O=new m(e[D]+z.x,e[D+1]+z.y,e[D+2]+z.z);_.push(O)}const B=new f().setFromPoints(_);i.showCurveLength(_,h.curve.getLength());const S=new y(B,this.markupMaterial);this._scene.add(S),this.markupLines.push(S);const{startDimensionPoints:H,endDimensionPoints:N}=this.calculateDimensionLines(h,S),U=this.offsetDimensionLine(H,n*.1),R=this.offsetDimensionLine(N,n*.1),$=new f().setFromPoints(U),G=new f().setFromPoints(R),X=new y($,this.markupMaterial);this._scene.add(X),this.markupLines.push(X);const K=new y(G,this.markupMaterial);this._scene.add(K),this.markupLines.push(K)}}const A=class A extends it{constructor(n){super(n);p(this,"view","horizontal");p(this,"planHighlighter");this.components.add(A.uuid,this),this.onHighlight.add(({mesh:i})=>{!this.highlighter||!this.planHighlighter||(this.planHighlighter.showCurveInfo(i),this.fitCameraToAlignment(i))})}set world(n){var i;super.world=n,n&&((i=this.planHighlighter)==null||i.dispose(),this.planHighlighter=new rt(this.components,n.scene.three,n))}async fitCameraToAlignment(n){const i=this.components.get(nt),t=n.curve.alignment;for(const c of t.horizontal)i.addMesh(c.mesh);const e=i.get(),s=new m,{min:o,max:l}=e,a=1.2,r=new m((l.x-o.x)*a,(l.y-o.y)*a,(l.z-o.z)*a);e.getCenter(s),e.setFromCenterAndSize(s,r),i.reset(),this.world&&this.world.camera.hasCameraControls()&&await this.world.camera.controls.fitToBox(e,!0)}};p(A,"uuid","3096dea0-5bc2-41c7-abce-9089b6c9431b");let Y=A;export{Y as C,it as a,k as b};
