var I=Object.defineProperty;var x=(s,t,e)=>t in s?I(s,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):s[t]=e;var i=(s,t,e)=>(x(s,typeof t!="symbol"?t+"":t,e),e);import{k as B,w as R,W as T,h as E,I as S,a as L,a6 as m,C as F,y as V,f as W,_ as k,M as G}from"./unzipit.module-aSGGZIxN.js";import{S as H}from"./stats.min-GTpOrGrX.js";import{E as w,D as U,c as N,C as O,W as $,S as z,a as X,b as K}from"./index-CB6lCoIW.js";import{G as j}from"./index-Bm-te9Ra.js";import"./_commonjsHelpers-Cpj98o6Y.js";class A{static isTransparent(t){return t.transparent&&t.opacity<1}}function Y(s,t,e,r){return new Promise((n,o)=>{function a(){const d=s.clientWaitSync(t,e,0);if(d===s.WAIT_FAILED){o();return}if(d===s.TIMEOUT_EXPIRED){setTimeout(a,r);return}n()}a()})}async function q(s,t,e,r,n,o,a){const d=s.fenceSync(s.SYNC_GPU_COMMANDS_COMPLETE,0);s.flush(),await Y(s,d,0,10),s.deleteSync(d),s.bindBuffer(t,e),s.getBufferSubData(t,r,n,o,a),s.bindBuffer(t,null)}async function J(s,t,e,r,n,o,a,d){const l=s.createBuffer();return s.bindBuffer(s.PIXEL_PACK_BUFFER,l),s.bufferData(s.PIXEL_PACK_BUFFER,d.byteLength,s.STREAM_READ),s.readPixels(t,e,r,n,o,a,0),s.bindBuffer(s.PIXEL_PACK_BUFFER,null),await q(s,s.PIXEL_PACK_BUFFER,l,0,d),s.deleteBuffer(l),d}class Q{constructor(t,e,r){i(this,"onDisposed",new w);i(this,"onViewUpdated",new w);i(this,"enabled",!0);i(this,"needsUpdate",!1);i(this,"renderDebugFrame",!1);i(this,"components");i(this,"world");i(this,"renderer");i(this,"autoUpdate",!0);i(this,"updateInterval",1e3);i(this,"worker");i(this,"scene",new B);i(this,"_width",512);i(this,"_height",512);i(this,"_availableColor",1);i(this,"renderTarget");i(this,"bufferSize");i(this,"_buffer");i(this,"updateVisibility",async t=>{if(!this.enabled||!this.needsUpdate&&!t)return;const e=this.world.camera.three;e.updateMatrix(),this.renderer.setSize(this._width,this._height),this.renderer.setRenderTarget(this.renderTarget),this.renderer.render(this.scene,e);const r=this.renderer.getContext();await J(r,0,0,this._width,this._height,r.RGBA,r.UNSIGNED_BYTE,this._buffer),this.renderer.setRenderTarget(null),this.renderDebugFrame&&this.renderer.render(this.scene,e),this.worker.postMessage({buffer:this._buffer}),this.needsUpdate=!1});if(!e.renderer)throw new Error("The given world must have a renderer!");this.components=t,this.applySettings(r),this.world=e,this.renderer=new R,this.renderTarget=new T(this._width,this._height),this.bufferSize=this._width*this._height*4,this._buffer=new Uint8Array(this.bufferSize),this.renderer.clippingPlanes=e.renderer.clippingPlanes;const n=`
      addEventListener("message", (event) => {
        const { buffer } = event.data;
        const colors = new Map();
        for (let i = 0; i < buffer.length; i += 4) {
          const r = buffer[i];
          const g = buffer[i + 1];
          const b = buffer[i + 2];
          const code = "" + r + "-" + g + "-" + b;
          if(colors.has(code)) {
            colors.set(code, colors.get(code) + 1);
          } else {
            colors.set(code, 1);
          }
        }
        postMessage({ colors });
      });
    `,o=new Blob([n],{type:"application/javascript"});this.worker=new Worker(URL.createObjectURL(o))}dispose(){this.enabled=!1;for(const t of this.scene.children)t.removeFromParent();this.onViewUpdated.reset(),this.worker.terminate(),this.renderer.dispose(),this.renderTarget.dispose(),this._buffer=null,this.onDisposed.reset()}getAvailableColor(){let t=BigInt(this._availableColor.toString());const e=[];do e.unshift(Number(t%256n)),t/=256n;while(t);for(;e.length!==3;)e.unshift(0);const[r,n,o]=e,a=`${r}-${n}-${o}`;return{r,g:n,b:o,code:a}}increaseColor(){if(this._availableColor===256*256*256){console.warn("Color can't be increased over 256 x 256 x 256!");return}this._availableColor++}decreaseColor(){if(this._availableColor===1){console.warn("Color can't be decreased under 0!");return}this._availableColor--}applySettings(t){t&&(t.updateInterval!==void 0&&(this.updateInterval=t.updateInterval),t.height!==void 0&&(this._height=t.height),t.width!==void 0&&(this._width=t.width),t.autoUpdate!==void 0&&(this.autoUpdate=t.autoUpdate))}}class Z extends Q{constructor(e,r,n){super(e,r,n);i(this,"threshold",100);i(this,"onViewUpdated",new w);i(this,"colorMeshes",new Map);i(this,"isProcessing",!1);i(this,"_colorCodeMeshMap",new Map);i(this,"_meshIDColorCodeMap",new Map);i(this,"_currentVisibleMeshes",new Set);i(this,"_recentlyHiddenMeshes",new Set);i(this,"_transparentMat",new E({transparent:!0,opacity:0}));i(this,"handleWorkerMessage",async e=>{if(this.isProcessing)return;const r=e.data.colors;this._recentlyHiddenMeshes=new Set(this._currentVisibleMeshes),this._currentVisibleMeshes.clear();for(const[n,o]of r){if(o<this.threshold)continue;const a=this._colorCodeMeshMap.get(n);a&&(this._currentVisibleMeshes.add(a),this._recentlyHiddenMeshes.delete(a))}this.onViewUpdated.trigger({seen:this._currentVisibleMeshes,unseen:this._recentlyHiddenMeshes})});this.worker.addEventListener("message",this.handleWorkerMessage),this.autoUpdate&&window.setInterval(async()=>{this.isProcessing||await this.updateVisibility()},this.updateInterval),this.onViewUpdated.add(({seen:o,unseen:a})=>{for(const d of o)d.visible=!0;for(const d of a)d.visible=!1})}dispose(){super.dispose(),this._currentVisibleMeshes.clear(),this._recentlyHiddenMeshes.clear(),this._meshIDColorCodeMap.clear(),this._transparentMat.dispose(),this._colorCodeMeshMap.clear();const e=this.components.get(U);for(const r in this.colorMeshes){const n=this.colorMeshes.get(r);n&&e.destroy(n,!0)}this.colorMeshes.clear()}add(e){if(!this.enabled)return;if(this.isProcessing){console.log("Culler processing not finished yet.");return}this.isProcessing=!0;const r=e instanceof S,{geometry:n,material:o}=e,{colorMaterial:a,code:d}=this.getAvailableMaterial();let l;if(Array.isArray(o)){let P=!0;const g=[];for(const D of o)A.isTransparent(D)?g.push(this._transparentMat):(P=!1,g.push(a));if(P){a.dispose(),this.isProcessing=!1;return}l=g}else if(A.isTransparent(o)){a.dispose(),this.isProcessing=!1;return}else l=a;this._colorCodeMeshMap.set(d,e),this._meshIDColorCodeMap.set(e.uuid,d);const _=r?e.count:1,u=new S(n,l,_);r?u.instanceMatrix=e.instanceMatrix:u.setMatrixAt(0,new L),e.visible=!1,u.applyMatrix4(e.matrix),u.updateMatrix(),this.scene.add(u),this.colorMeshes.set(e.uuid,u),this.increaseColor(),this.isProcessing=!1}remove(e){if(this.isProcessing){console.log("Culler processing not finished yet.");return}this.isProcessing=!0;const r=this.components.get(U);this._currentVisibleMeshes.delete(e),this._recentlyHiddenMeshes.delete(e);const n=this.colorMeshes.get(e.uuid),o=this._meshIDColorCodeMap.get(e.uuid);if(!n||!o){this.isProcessing=!1,console.log(e.visible);return}this._colorCodeMeshMap.delete(o),this._meshIDColorCodeMap.delete(e.uuid),this.colorMeshes.delete(e.uuid),n.geometry=void 0,n.material=[],r.destroy(n,!0),this._recentlyHiddenMeshes.delete(e),this._currentVisibleMeshes.delete(e),this.isProcessing=!1}getAvailableMaterial(){const{r:e,g:r,b:n,code:o}=this.getAvailableColor(),a=m.enabled;m.enabled=!1;const d=new F(`rgb(${e}, ${r}, ${n})`);if(!this.world.renderer)throw new Error("Renderer not found in the world!");const l=this.world.renderer.clippingPlanes,_=new E({color:d,clippingPlanes:l,side:V});return m.enabled=a,{colorMaterial:_,code:o}}}const p=class p extends N{constructor(e){super(e);i(this,"_enabled",!0);i(this,"list",new Map);i(this,"onDisposed",new w);e.add(p.uuid,this)}get enabled(){return this._enabled}set enabled(e){this._enabled=e;for(const[r,n]of this.list)n.enabled=e}create(e,r){if(this.list.has(e.uuid))return this.list.get(e.uuid);const n=new Z(this.components,e,r);return this.list.set(e.uuid,n),n}delete(e){const r=this.list.get(e.uuid);r&&r.dispose(),this.list.delete(e.uuid)}dispose(){this.enabled=!1,this.onDisposed.trigger(p.uuid),this.onDisposed.reset();for(const[e,r]of this.list)r.dispose();this.list.clear()}};i(p,"uuid","69f2a50d-c266-44fc-b1bd-fa4d34be89e6");let C=p;const ee=document.getElementById("container"),h=new O,te=h.get($),c=te.create();c.scene=new z(h);c.renderer=new X(h,ee);c.camera=new K(h);h.init();c.camera.controls.setLookAt(13,13,13,0,0,0);c.scene.setup();const se=h.get(j);se.create(c);const re=new C(h),f=re.create(c);f.threshold=200;f.renderDebugFrame=!0;const b=f.renderer.domElement;document.body.appendChild(b);b.style.position="fixed";b.style.left="0";b.style.bottom="0";b.style.visibility="collapse";function y(s){return Math.random()*s}const v=[],ie=new W(2,2,2),ne=new k({color:"#6528D7"});function oe(){for(const s of v)s.removeFromParent();v.length=0}function ae(){oe();for(let s=0;s<300;s++){const t=new G(ie,ne);t.position.x=y(10),t.position.y=y(10),t.position.z=y(10),t.updateMatrix(),c.scene.three.add(t),f.add(t),v.push(t)}}ae();f.needsUpdate=!0;c.camera.controls.addEventListener("controlend",()=>{f.needsUpdate=!0});const M=new H;M.showPanel(2);document.body.append(M.dom);M.dom.style.left="0px";c.renderer.onBeforeUpdate.add(()=>M.begin());c.renderer.onAfterUpdate.add(()=>M.end());
