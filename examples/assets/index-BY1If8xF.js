var qs=Object.defineProperty;var Ws=(n,e,t)=>e in n?qs(n,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):n[e]=t;var L=(n,e,t)=>(Ws(n,typeof e!="symbol"?e+"":e,t),t);import{e as Bs,V as S,f as ht,P as zs,r as lt,T as Qt,y as Fs,a as ut,p as st,aO as $s,Z as Ks,ar as is,M as Rs,as as Qs,u as Gs,c as ns,C as Pe,n as js,a_ as Js,a$ as ti,ah as os,o as ei,at as si,au as ii,v as ni,Q as oi,av as ri,z as ai,h as ci}from"./web-ifc-api-BC8YMRiS.js";const Is=0,li=1,hi=2,rs=2,ve=1.25,as=1,Te=6*4+4+4,Ce=65535,ui=Math.pow(2,-24),Ue=Symbol("SKIP_GENERATION");function fi(n){return n.index?n.index.count:n.attributes.position.count}function zt(n){return fi(n)/3}function di(n,e=ArrayBuffer){return n>65535?new Uint32Array(new e(4*n)):new Uint16Array(new e(2*n))}function pi(n,e){if(!n.index){const t=n.attributes.position.count,s=e.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,i=di(t,s);n.setIndex(new Bs(i,1));for(let r=0;r<t;r++)i[r]=r}}function Hs(n){const e=zt(n),t=n.drawRange,s=t.start/3,i=(t.start+t.count)/3,r=Math.max(0,s),o=Math.min(e,i)-r;return[{offset:Math.floor(r),count:Math.floor(o)}]}function ks(n){if(!n.groups||!n.groups.length)return Hs(n);const e=[],t=new Set,s=n.drawRange,i=s.start/3,r=(s.start+s.count)/3;for(const a of n.groups){const c=a.start/3,d=(a.start+a.count)/3;t.add(Math.max(i,c)),t.add(Math.min(r,d))}const o=Array.from(t.values()).sort((a,c)=>a-c);for(let a=0;a<o.length-1;a++){const c=o[a],d=o[a+1];e.push({offset:Math.floor(c),count:Math.floor(d-c)})}return e}function _i(n){if(n.groups.length===0)return!1;const e=zt(n),t=ks(n).sort((r,o)=>r.offset-o.offset),s=t[t.length-1];s.count=Math.min(e-s.offset,s.count);let i=0;return t.forEach(({count:r})=>i+=r),e!==i}function Y(n,e,t){return t.min.x=e[n],t.min.y=e[n+1],t.min.z=e[n+2],t.max.x=e[n+3],t.max.y=e[n+4],t.max.z=e[n+5],t}function mi(n){n[0]=n[1]=n[2]=1/0,n[3]=n[4]=n[5]=-1/0}function cs(n){let e=-1,t=-1/0;for(let s=0;s<3;s++){const i=n[s+3]-n[s];i>t&&(t=i,e=s)}return e}function ls(n,e){e.set(n)}function hs(n,e,t){let s,i;for(let r=0;r<3;r++){const o=r+3;s=n[r],i=e[r],t[r]=s<i?s:i,s=n[o],i=e[o],t[o]=s>i?s:i}}function te(n,e,t){for(let s=0;s<3;s++){const i=e[n+2*s],r=e[n+2*s+1],o=i-r,a=i+r;o<t[s]&&(t[s]=o),a>t[s+3]&&(t[s+3]=a)}}function Ht(n){const e=n[3]-n[0],t=n[4]-n[1],s=n[5]-n[2];return 2*(e*t+t*s+s*e)}function Le(n,e,t,s,i=null){let r=1/0,o=1/0,a=1/0,c=-1/0,d=-1/0,f=-1/0,u=1/0,l=1/0,p=1/0,y=-1/0,O=-1/0,T=-1/0;const m=i!==null;for(let g=e*6,E=(e+t)*6;g<E;g+=6){const h=n[g+0],_=n[g+1],x=h-_,w=h+_;x<r&&(r=x),w>c&&(c=w),m&&h<u&&(u=h),m&&h>y&&(y=h);const C=n[g+2],b=n[g+3],P=C-b,U=C+b;P<o&&(o=P),U>d&&(d=U),m&&C<l&&(l=C),m&&C>O&&(O=C);const v=n[g+4],D=n[g+5],M=v-D,R=v+D;M<a&&(a=M),R>f&&(f=R),m&&v<p&&(p=v),m&&v>T&&(T=v)}s[0]=r,s[1]=o,s[2]=a,s[3]=c,s[4]=d,s[5]=f,m&&(i[0]=u,i[1]=l,i[2]=p,i[3]=y,i[4]=O,i[5]=T)}function yi(n,e,t,s){let i=1/0,r=1/0,o=1/0,a=-1/0,c=-1/0,d=-1/0;for(let f=e*6,u=(e+t)*6;f<u;f+=6){const l=n[f+0];l<i&&(i=l),l>a&&(a=l);const p=n[f+2];p<r&&(r=p),p>c&&(c=p);const y=n[f+4];y<o&&(o=y),y>d&&(d=y)}s[0]=i,s[1]=r,s[2]=o,s[3]=a,s[4]=c,s[5]=d}function gi(n,e){mi(e);const t=n.attributes.position,s=n.index?n.index.array:null,i=zt(n),r=new Float32Array(i*6),o=t.normalized,a=t.array,c=t.offset||0;let d=3;t.isInterleavedBufferAttribute&&(d=t.data.stride);const f=["getX","getY","getZ"];for(let u=0;u<i;u++){const l=u*3,p=u*6;let y=l+0,O=l+1,T=l+2;s&&(y=s[y],O=s[O],T=s[T]),o||(y=y*d+c,O=O*d+c,T=T*d+c);for(let m=0;m<3;m++){let g,E,h;o?(g=t[f[m]](y),E=t[f[m]](O),h=t[f[m]](T)):(g=a[y+m],E=a[O+m],h=a[T+m]);let _=g;E<_&&(_=E),h<_&&(_=h);let x=g;E>x&&(x=E),h>x&&(x=h);const w=(x-_)/2,C=m*2;r[p+C+0]=_+w,r[p+C+1]=w+(Math.abs(_)+w)*ui,_<e[m]&&(e[m]=_),x>e[m+3]&&(e[m+3]=x)}}return r}const ct=32,Ti=(n,e)=>n.candidate-e.candidate,dt=new Array(ct).fill().map(()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0})),ee=new Float32Array(6);function Ei(n,e,t,s,i,r){let o=-1,a=0;if(r===Is)o=cs(e),o!==-1&&(a=(e[o]+e[o+3])/2);else if(r===li)o=cs(n),o!==-1&&(a=xi(t,s,i,o));else if(r===hi){const c=Ht(n);let d=ve*i;const f=s*6,u=(s+i)*6;for(let l=0;l<3;l++){const p=e[l],T=(e[l+3]-p)/ct;if(i<ct/4){const m=[...dt];m.length=i;let g=0;for(let h=f;h<u;h+=6,g++){const _=m[g];_.candidate=t[h+2*l],_.count=0;const{bounds:x,leftCacheBounds:w,rightCacheBounds:C}=_;for(let b=0;b<3;b++)C[b]=1/0,C[b+3]=-1/0,w[b]=1/0,w[b+3]=-1/0,x[b]=1/0,x[b+3]=-1/0;te(h,t,x)}m.sort(Ti);let E=i;for(let h=0;h<E;h++){const _=m[h];for(;h+1<E&&m[h+1].candidate===_.candidate;)m.splice(h+1,1),E--}for(let h=f;h<u;h+=6){const _=t[h+2*l];for(let x=0;x<E;x++){const w=m[x];_>=w.candidate?te(h,t,w.rightCacheBounds):(te(h,t,w.leftCacheBounds),w.count++)}}for(let h=0;h<E;h++){const _=m[h],x=_.count,w=i-_.count,C=_.leftCacheBounds,b=_.rightCacheBounds;let P=0;x!==0&&(P=Ht(C)/c);let U=0;w!==0&&(U=Ht(b)/c);const v=as+ve*(P*x+U*w);v<d&&(o=l,d=v,a=_.candidate)}}else{for(let E=0;E<ct;E++){const h=dt[E];h.count=0,h.candidate=p+T+E*T;const _=h.bounds;for(let x=0;x<3;x++)_[x]=1/0,_[x+3]=-1/0}for(let E=f;E<u;E+=6){let x=~~((t[E+2*l]-p)/T);x>=ct&&(x=ct-1);const w=dt[x];w.count++,te(E,t,w.bounds)}const m=dt[ct-1];ls(m.bounds,m.rightCacheBounds);for(let E=ct-2;E>=0;E--){const h=dt[E],_=dt[E+1];hs(h.bounds,_.rightCacheBounds,h.rightCacheBounds)}let g=0;for(let E=0;E<ct-1;E++){const h=dt[E],_=h.count,x=h.bounds,C=dt[E+1].rightCacheBounds;_!==0&&(g===0?ls(x,ee):hs(x,ee,ee)),g+=_;let b=0,P=0;g!==0&&(b=Ht(ee)/c);const U=i-g;U!==0&&(P=Ht(C)/c);const v=as+ve*(b*g+P*U);v<d&&(o=l,d=v,a=h.candidate)}}}}else console.warn(`MeshBVH: Invalid build strategy value ${r} used.`);return{axis:o,pos:a}}function xi(n,e,t,s){let i=0;for(let r=e,o=e+t;r<o;r++)i+=n[r*6+s*2];return i/t}class se{constructor(){}}function wi(n,e,t,s,i,r){let o=s,a=s+i-1;const c=r.pos,d=r.axis*2;for(;;){for(;o<=a&&t[o*6+d]<c;)o++;for(;o<=a&&t[a*6+d]>=c;)a--;if(o<a){for(let f=0;f<3;f++){let u=e[o*3+f];e[o*3+f]=e[a*3+f],e[a*3+f]=u}for(let f=0;f<6;f++){let u=t[o*6+f];t[o*6+f]=t[a*6+f],t[a*6+f]=u}o++,a--}else return o}}function Oi(n,e,t,s,i,r){let o=s,a=s+i-1;const c=r.pos,d=r.axis*2;for(;;){for(;o<=a&&t[o*6+d]<c;)o++;for(;o<=a&&t[a*6+d]>=c;)a--;if(o<a){let f=n[o];n[o]=n[a],n[a]=f;for(let u=0;u<6;u++){let l=t[o*6+u];t[o*6+u]=t[a*6+u],t[a*6+u]=l}o++,a--}else return o}}function Ai(n,e){const t=(n.index?n.index.count:n.attributes.position.count)/3,s=t>2**16,i=s?4:2,r=e?new SharedArrayBuffer(t*i):new ArrayBuffer(t*i),o=s?new Uint32Array(r):new Uint16Array(r);for(let a=0,c=o.length;a<c;a++)o[a]=a;return o}function Ci(n,e){const t=n.geometry,s=t.index?t.index.array:null,i=e.maxDepth,r=e.verbose,o=e.maxLeafTris,a=e.strategy,c=e.onProgress,d=zt(t),f=n._indirectBuffer;let u=!1;const l=new Float32Array(6),p=new Float32Array(6),y=gi(t,l),O=e.indirect?Oi:wi,T=[],m=e.indirect?Hs(t):ks(t);if(m.length===1){const h=m[0],_=new se;_.boundingData=l,yi(y,h.offset,h.count,p),E(_,h.offset,h.count,p),T.push(_)}else for(let h of m){const _=new se;_.boundingData=new Float32Array(6),Le(y,h.offset,h.count,_.boundingData,p),E(_,h.offset,h.count,p),T.push(_)}return T;function g(h){c&&c(h/d)}function E(h,_,x,w=null,C=0){if(!u&&C>=i&&(u=!0,r&&(console.warn(`MeshBVH: Max depth of ${i} reached when generating BVH. Consider increasing maxDepth.`),console.warn(t))),x<=o||C>=i)return g(_+x),h.offset=_,h.count=x,h;const b=Ei(h.boundingData,w,y,_,x,a);if(b.axis===-1)return g(_+x),h.offset=_,h.count=x,h;const P=O(f,s,y,_,x,b);if(P===_||P===_+x)g(_+x),h.offset=_,h.count=x;else{h.splitAxis=b.axis;const U=new se,v=_,D=P-_;h.left=U,U.boundingData=new Float32Array(6),Le(y,v,D,U.boundingData,p),E(U,v,D,p,C+1);const M=new se,R=P,N=x-D;h.right=M,M.boundingData=new Float32Array(6),Le(y,R,N,M.boundingData,p),E(M,R,N,p,C+1)}return h}}function bi(n,e){const t=n.geometry;e.indirect&&(n._indirectBuffer=Ai(t,e.useSharedArrayBuffer),_i(t)&&!e.verbose&&console.warn('MeshBVH: Provided geometry contains groups that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.')),n._indirectBuffer||pi(t,e);const s=Ci(n,e);let i,r,o;const a=[],c=e.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer;for(let u=0;u<s.length;u++){const l=s[u];let p=d(l);const y=new c(Te*p);i=new Float32Array(y),r=new Uint32Array(y),o=new Uint16Array(y),f(0,l),a.push(y)}n._roots=a;return;function d(u){return u.count?1:1+d(u.left)+d(u.right)}function f(u,l){const p=u/4,y=u/2,O=!!l.count,T=l.boundingData;for(let m=0;m<6;m++)i[p+m]=T[m];if(O){const m=l.offset,g=l.count;return r[p+6]=m,o[y+14]=g,o[y+15]=Ce,u+Te}else{const m=l.left,g=l.right,E=l.splitAxis;let h;if(h=f(u+Te,m),h/4>Math.pow(2,32))throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return r[p+6]=h/4,h=f(h,g),r[p+7]=E,h}}}class ft{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(e,t){let s=1/0,i=-1/0;for(let r=0,o=e.length;r<o;r++){const c=e[r][t];s=c<s?c:s,i=c>i?c:i}this.min=s,this.max=i}setFromPoints(e,t){let s=1/0,i=-1/0;for(let r=0,o=t.length;r<o;r++){const a=t[r],c=e.dot(a);s=c<s?c:s,i=c>i?c:i}this.min=s,this.max=i}isSeparated(e){return this.min>e.max||e.min>this.max}}ft.prototype.setFromBox=function(){const n=new S;return function(t,s){const i=s.min,r=s.max;let o=1/0,a=-1/0;for(let c=0;c<=1;c++)for(let d=0;d<=1;d++)for(let f=0;f<=1;f++){n.x=i.x*c+r.x*(1-c),n.y=i.y*d+r.y*(1-d),n.z=i.z*f+r.z*(1-f);const u=t.dot(n);o=Math.min(u,o),a=Math.max(u,a)}this.min=o,this.max=a}}();const Pi=function(){const n=new S,e=new S,t=new S;return function(i,r,o){const a=i.start,c=n,d=r.start,f=e;t.subVectors(a,d),n.subVectors(i.end,i.start),e.subVectors(r.end,r.start);const u=t.dot(f),l=f.dot(c),p=f.dot(f),y=t.dot(c),T=c.dot(c)*p-l*l;let m,g;T!==0?m=(u*l-y*p)/T:m=0,g=(u+m*l)/p,o.x=m,o.y=g}}(),je=function(){const n=new ht,e=new S,t=new S;return function(i,r,o,a){Pi(i,r,n);let c=n.x,d=n.y;if(c>=0&&c<=1&&d>=0&&d<=1){i.at(c,o),r.at(d,a);return}else if(c>=0&&c<=1){d<0?r.at(0,a):r.at(1,a),i.closestPointToPoint(a,!0,o);return}else if(d>=0&&d<=1){c<0?i.at(0,o):i.at(1,o),r.closestPointToPoint(o,!0,a);return}else{let f;c<0?f=i.start:f=i.end;let u;d<0?u=r.start:u=r.end;const l=e,p=t;if(i.closestPointToPoint(u,!0,e),r.closestPointToPoint(f,!0,t),l.distanceToSquared(u)<=p.distanceToSquared(f)){o.copy(l),a.copy(u);return}else{o.copy(f),a.copy(p);return}}}}(),vi=function(){const n=new S,e=new S,t=new zs,s=new lt;return function(r,o){const{radius:a,center:c}=r,{a:d,b:f,c:u}=o;if(s.start=d,s.end=f,s.closestPointToPoint(c,!0,n).distanceTo(c)<=a||(s.start=d,s.end=u,s.closestPointToPoint(c,!0,n).distanceTo(c)<=a)||(s.start=f,s.end=u,s.closestPointToPoint(c,!0,n).distanceTo(c)<=a))return!0;const O=o.getPlane(t);if(Math.abs(O.distanceToPoint(c))<=a){const m=O.projectPoint(c,e);if(o.containsPoint(m))return!0}return!1}}(),Ui=1e-15;function De(n){return Math.abs(n)<Ui}class ot extends Qt{constructor(...e){super(...e),this.isExtendedTriangle=!0,this.satAxes=new Array(4).fill().map(()=>new S),this.satBounds=new Array(4).fill().map(()=>new ft),this.points=[this.a,this.b,this.c],this.sphere=new Fs,this.plane=new zs,this.needsUpdate=!0}intersectsSphere(e){return vi(e,this)}update(){const e=this.a,t=this.b,s=this.c,i=this.points,r=this.satAxes,o=this.satBounds,a=r[0],c=o[0];this.getNormal(a),c.setFromPoints(a,i);const d=r[1],f=o[1];d.subVectors(e,t),f.setFromPoints(d,i);const u=r[2],l=o[2];u.subVectors(t,s),l.setFromPoints(u,i);const p=r[3],y=o[3];p.subVectors(s,e),y.setFromPoints(p,i),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(a,e),this.needsUpdate=!1}}ot.prototype.closestPointToSegment=function(){const n=new S,e=new S,t=new lt;return function(i,r=null,o=null){const{start:a,end:c}=i,d=this.points;let f,u=1/0;for(let l=0;l<3;l++){const p=(l+1)%3;t.start.copy(d[l]),t.end.copy(d[p]),je(t,i,n,e),f=n.distanceToSquared(e),f<u&&(u=f,r&&r.copy(n),o&&o.copy(e))}return this.closestPointToPoint(a,n),f=a.distanceToSquared(n),f<u&&(u=f,r&&r.copy(n),o&&o.copy(a)),this.closestPointToPoint(c,n),f=c.distanceToSquared(n),f<u&&(u=f,r&&r.copy(n),o&&o.copy(c)),Math.sqrt(u)}}();ot.prototype.intersectsTriangle=function(){const n=new ot,e=new Array(3),t=new Array(3),s=new ft,i=new ft,r=new S,o=new S,a=new S,c=new S,d=new S,f=new lt,u=new lt,l=new lt,p=new S;function y(O,T,m){const g=O.points;let E=0,h=-1;for(let _=0;_<3;_++){const{start:x,end:w}=f;x.copy(g[_]),w.copy(g[(_+1)%3]),f.delta(o);const C=De(T.distanceToPoint(x));if(De(T.normal.dot(o))&&C){m.copy(f),E=2;break}const b=T.intersectLine(f,p);if(!b&&C&&p.copy(x),(b||C)&&!De(p.distanceTo(w))){if(E<=1)(E===1?m.start:m.end).copy(p),C&&(h=E);else if(E>=2){(h===1?m.start:m.end).copy(p),E=2;break}if(E++,E===2&&h===-1)break}}return E}return function(T,m=null,g=!1){this.needsUpdate&&this.update(),T.isExtendedTriangle?T.needsUpdate&&T.update():(n.copy(T),n.update(),T=n);const E=this.plane,h=T.plane;if(Math.abs(E.normal.dot(h.normal))>1-1e-10){const _=this.satBounds,x=this.satAxes;t[0]=T.a,t[1]=T.b,t[2]=T.c;for(let b=0;b<4;b++){const P=_[b],U=x[b];if(s.setFromPoints(U,t),P.isSeparated(s))return!1}const w=T.satBounds,C=T.satAxes;e[0]=this.a,e[1]=this.b,e[2]=this.c;for(let b=0;b<4;b++){const P=w[b],U=C[b];if(s.setFromPoints(U,e),P.isSeparated(s))return!1}for(let b=0;b<4;b++){const P=x[b];for(let U=0;U<4;U++){const v=C[U];if(r.crossVectors(P,v),s.setFromPoints(r,e),i.setFromPoints(r,t),s.isSeparated(i))return!1}}return m&&(g||console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),m.start.set(0,0,0),m.end.set(0,0,0)),!0}else{const _=y(this,h,u);if(_===1&&T.containsPoint(u.end))return m&&(m.start.copy(u.end),m.end.copy(u.end)),!0;if(_!==2)return!1;const x=y(T,E,l);if(x===1&&this.containsPoint(l.end))return m&&(m.start.copy(l.end),m.end.copy(l.end)),!0;if(x!==2)return!1;if(u.delta(a),l.delta(c),a.dot(c)<0){let D=l.start;l.start=l.end,l.end=D}const w=u.start.dot(a),C=u.end.dot(a),b=l.start.dot(a),P=l.end.dot(a),U=C<b,v=w<P;return w!==P&&b!==C&&U===v?!1:(m&&(d.subVectors(u.start,l.start),d.dot(a)>0?m.start.copy(u.start):m.start.copy(l.start),d.subVectors(u.end,l.end),d.dot(a)<0?m.end.copy(u.end):m.end.copy(l.end)),!0)}}}();ot.prototype.distanceToPoint=function(){const n=new S;return function(t){return this.closestPointToPoint(t,n),t.distanceTo(n)}}();ot.prototype.distanceToTriangle=function(){const n=new S,e=new S,t=["a","b","c"],s=new lt,i=new lt;return function(o,a=null,c=null){const d=a||c?s:null;if(this.intersectsTriangle(o,d))return(a||c)&&(a&&d.getCenter(a),c&&d.getCenter(c)),0;let f=1/0;for(let u=0;u<3;u++){let l;const p=t[u],y=o[p];this.closestPointToPoint(y,n),l=y.distanceToSquared(n),l<f&&(f=l,a&&a.copy(n),c&&c.copy(y));const O=this[p];o.closestPointToPoint(O,n),l=O.distanceToSquared(n),l<f&&(f=l,a&&a.copy(O),c&&c.copy(n))}for(let u=0;u<3;u++){const l=t[u],p=t[(u+1)%3];s.set(this[l],this[p]);for(let y=0;y<3;y++){const O=t[y],T=t[(y+1)%3];i.set(o[O],o[T]),je(s,i,n,e);const m=n.distanceToSquared(e);m<f&&(f=m,a&&a.copy(n),c&&c.copy(e))}}return Math.sqrt(f)}}();class W{constructor(e,t,s){this.isOrientedBox=!0,this.min=new S,this.max=new S,this.matrix=new ut,this.invMatrix=new ut,this.points=new Array(8).fill().map(()=>new S),this.satAxes=new Array(3).fill().map(()=>new S),this.satBounds=new Array(3).fill().map(()=>new ft),this.alignedSatBounds=new Array(3).fill().map(()=>new ft),this.needsUpdate=!1,e&&this.min.copy(e),t&&this.max.copy(t),s&&this.matrix.copy(s)}set(e,t,s){this.min.copy(e),this.max.copy(t),this.matrix.copy(s),this.needsUpdate=!0}copy(e){this.min.copy(e.min),this.max.copy(e.max),this.matrix.copy(e.matrix),this.needsUpdate=!0}}W.prototype.update=function(){return function(){const e=this.matrix,t=this.min,s=this.max,i=this.points;for(let d=0;d<=1;d++)for(let f=0;f<=1;f++)for(let u=0;u<=1;u++){const l=1*d|2*f|4*u,p=i[l];p.x=d?s.x:t.x,p.y=f?s.y:t.y,p.z=u?s.z:t.z,p.applyMatrix4(e)}const r=this.satBounds,o=this.satAxes,a=i[0];for(let d=0;d<3;d++){const f=o[d],u=r[d],l=1<<d,p=i[l];f.subVectors(a,p),u.setFromPoints(f,i)}const c=this.alignedSatBounds;c[0].setFromPointsField(i,"x"),c[1].setFromPointsField(i,"y"),c[2].setFromPointsField(i,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1}}();W.prototype.intersectsBox=function(){const n=new ft;return function(t){this.needsUpdate&&this.update();const s=t.min,i=t.max,r=this.satBounds,o=this.satAxes,a=this.alignedSatBounds;if(n.min=s.x,n.max=i.x,a[0].isSeparated(n)||(n.min=s.y,n.max=i.y,a[1].isSeparated(n))||(n.min=s.z,n.max=i.z,a[2].isSeparated(n)))return!1;for(let c=0;c<3;c++){const d=o[c],f=r[c];if(n.setFromBox(d,t),f.isSeparated(n))return!1}return!0}}();W.prototype.intersectsTriangle=function(){const n=new ot,e=new Array(3),t=new ft,s=new ft,i=new S;return function(o){this.needsUpdate&&this.update(),o.isExtendedTriangle?o.needsUpdate&&o.update():(n.copy(o),n.update(),o=n);const a=this.satBounds,c=this.satAxes;e[0]=o.a,e[1]=o.b,e[2]=o.c;for(let l=0;l<3;l++){const p=a[l],y=c[l];if(t.setFromPoints(y,e),p.isSeparated(t))return!1}const d=o.satBounds,f=o.satAxes,u=this.points;for(let l=0;l<3;l++){const p=d[l],y=f[l];if(t.setFromPoints(y,u),p.isSeparated(t))return!1}for(let l=0;l<3;l++){const p=c[l];for(let y=0;y<4;y++){const O=f[y];if(i.crossVectors(p,O),t.setFromPoints(i,e),s.setFromPoints(i,u),t.isSeparated(s))return!1}}return!0}}();W.prototype.closestPointToPoint=function(){return function(e,t){return this.needsUpdate&&this.update(),t.copy(e).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),t}}();W.prototype.distanceToPoint=function(){const n=new S;return function(t){return this.closestPointToPoint(t,n),t.distanceTo(n)}}();W.prototype.distanceToBox=function(){const n=["x","y","z"],e=new Array(12).fill().map(()=>new lt),t=new Array(12).fill().map(()=>new lt),s=new S,i=new S;return function(o,a=0,c=null,d=null){if(this.needsUpdate&&this.update(),this.intersectsBox(o))return(c||d)&&(o.getCenter(i),this.closestPointToPoint(i,s),o.closestPointToPoint(s,i),c&&c.copy(s),d&&d.copy(i)),0;const f=a*a,u=o.min,l=o.max,p=this.points;let y=1/0;for(let T=0;T<8;T++){const m=p[T];i.copy(m).clamp(u,l);const g=m.distanceToSquared(i);if(g<y&&(y=g,c&&c.copy(m),d&&d.copy(i),g<f))return Math.sqrt(g)}let O=0;for(let T=0;T<3;T++)for(let m=0;m<=1;m++)for(let g=0;g<=1;g++){const E=(T+1)%3,h=(T+2)%3,_=m<<E|g<<h,x=1<<T|m<<E|g<<h,w=p[_],C=p[x];e[O].set(w,C);const P=n[T],U=n[E],v=n[h],D=t[O],M=D.start,R=D.end;M[P]=u[P],M[U]=m?u[U]:l[U],M[v]=g?u[v]:l[U],R[P]=l[P],R[U]=m?u[U]:l[U],R[v]=g?u[v]:l[U],O++}for(let T=0;T<=1;T++)for(let m=0;m<=1;m++)for(let g=0;g<=1;g++){i.x=T?l.x:u.x,i.y=m?l.y:u.y,i.z=g?l.z:u.z,this.closestPointToPoint(i,s);const E=i.distanceToSquared(s);if(E<y&&(y=E,c&&c.copy(s),d&&d.copy(i),E<f))return Math.sqrt(E)}for(let T=0;T<12;T++){const m=e[T];for(let g=0;g<12;g++){const E=t[g];je(m,E,s,i);const h=s.distanceToSquared(i);if(h<y&&(y=h,c&&c.copy(s),d&&d.copy(i),h<f))return Math.sqrt(h)}}return Math.sqrt(y)}}();class Je{constructor(e){this._getNewPrimitive=e,this._primitives=[]}getPrimitive(){const e=this._primitives;return e.length===0?this._getNewPrimitive():e.pop()}releasePrimitive(e){this._primitives.push(e)}}class Li extends Je{constructor(){super(()=>new ot)}}const j=new Li;function K(n,e){return e[n+15]===65535}function Q(n,e){return e[n+6]}function J(n,e){return e[n+14]}function tt(n){return n+8}function et(n,e){return e[n+6]}function Vs(n,e){return e[n+7]}class Di{constructor(){this.float32Array=null,this.uint16Array=null,this.uint32Array=null;const e=[];let t=null;this.setBuffer=s=>{t&&e.push(t),t=s,this.float32Array=new Float32Array(s),this.uint16Array=new Uint16Array(s),this.uint32Array=new Uint32Array(s)},this.clearBuffer=()=>{t=null,this.float32Array=null,this.uint16Array=null,this.uint32Array=null,e.length!==0&&this.setBuffer(e.pop())}}}const V=new Di;let mt,Bt;const Et=[],ie=new Je(()=>new st);function Si(n,e,t,s,i,r){mt=ie.getPrimitive(),Bt=ie.getPrimitive(),Et.push(mt,Bt),V.setBuffer(n._roots[e]);const o=Xe(0,n.geometry,t,s,i,r);V.clearBuffer(),ie.releasePrimitive(mt),ie.releasePrimitive(Bt),Et.pop(),Et.pop();const a=Et.length;return a>0&&(Bt=Et[a-1],mt=Et[a-2]),o}function Xe(n,e,t,s,i=null,r=0,o=0){const{float32Array:a,uint16Array:c,uint32Array:d}=V;let f=n*2;if(K(f,c)){const l=Q(n,d),p=J(f,c);return Y(n,a,mt),s(l,p,!1,o,r+n,mt)}else{let P=function(v){const{uint16Array:D,uint32Array:M}=V;let R=v*2;for(;!K(R,D);)v=tt(v),R=v*2;return Q(v,M)},U=function(v){const{uint16Array:D,uint32Array:M}=V;let R=v*2;for(;!K(R,D);)v=et(v,M),R=v*2;return Q(v,M)+J(R,D)};const l=tt(n),p=et(n,d);let y=l,O=p,T,m,g,E;if(i&&(g=mt,E=Bt,Y(y,a,g),Y(O,a,E),T=i(g),m=i(E),m<T)){y=p,O=l;const v=T;T=m,m=v,g=E}g||(g=mt,Y(y,a,g));const h=K(y*2,c),_=t(g,h,T,o+1,r+y);let x;if(_===rs){const v=P(y),M=U(y)-v;x=s(v,M,!0,o+1,r+y,g)}else x=_&&Xe(y,e,t,s,i,r,o+1);if(x)return!0;E=Bt,Y(O,a,E);const w=K(O*2,c),C=t(E,w,m,o+1,r+O);let b;if(C===rs){const v=P(O),M=U(O)-v;b=s(v,M,!0,o+1,r+O,E)}else b=C&&Xe(O,e,t,s,i,r,o+1);return!!b}}const kt=new S,Se=new S;function Mi(n,e,t={},s=0,i=1/0){const r=s*s,o=i*i;let a=1/0,c=null;if(n.shapecast({boundsTraverseOrder:f=>(kt.copy(e).clamp(f.min,f.max),kt.distanceToSquared(e)),intersectsBounds:(f,u,l)=>l<a&&l<o,intersectsTriangle:(f,u)=>{f.closestPointToPoint(e,kt);const l=e.distanceToSquared(kt);return l<a&&(Se.copy(kt),a=l,c=u),l<r}}),a===1/0)return null;const d=Math.sqrt(a);return t.point?t.point.copy(Se):t.point=Se.clone(),t.distance=d,t.faceIndex=c,t}const xt=new S,wt=new S,Ot=new S,ne=new ht,oe=new ht,re=new ht,us=new S,fs=new S,ds=new S,ae=new S;function Bi(n,e,t,s,i,r){let o;return r===$s?o=n.intersectTriangle(s,t,e,!0,i):o=n.intersectTriangle(e,t,s,r!==Ks,i),o===null?null:{distance:n.origin.distanceTo(i),point:i.clone()}}function zi(n,e,t,s,i,r,o,a,c){xt.fromBufferAttribute(e,r),wt.fromBufferAttribute(e,o),Ot.fromBufferAttribute(e,a);const d=Bi(n,xt,wt,Ot,ae,c);if(d){s&&(ne.fromBufferAttribute(s,r),oe.fromBufferAttribute(s,o),re.fromBufferAttribute(s,a),d.uv=Qt.getInterpolation(ae,xt,wt,Ot,ne,oe,re,new ht)),i&&(ne.fromBufferAttribute(i,r),oe.fromBufferAttribute(i,o),re.fromBufferAttribute(i,a),d.uv1=Qt.getInterpolation(ae,xt,wt,Ot,ne,oe,re,new ht)),t&&(us.fromBufferAttribute(t,r),fs.fromBufferAttribute(t,o),ds.fromBufferAttribute(t,a),d.normal=Qt.getInterpolation(ae,xt,wt,Ot,us,fs,ds,new S),d.normal.dot(n.direction)>0&&d.normal.multiplyScalar(-1));const f={a:r,b:o,c:a,normal:new S,materialIndex:0};Qt.getNormal(xt,wt,Ot,f.normal),d.face=f,d.faceIndex=r}return d}function be(n,e,t,s,i){const r=s*3;let o=r+0,a=r+1,c=r+2;const d=n.index;n.index&&(o=d.getX(o),a=d.getX(a),c=d.getX(c));const{position:f,normal:u,uv:l,uv1:p}=n.attributes,y=zi(t,f,u,l,p,o,a,c,e);return y?(y.faceIndex=s,i&&i.push(y),y):null}function q(n,e,t,s){const i=n.a,r=n.b,o=n.c;let a=e,c=e+1,d=e+2;t&&(a=t.getX(a),c=t.getX(c),d=t.getX(d)),i.x=s.getX(a),i.y=s.getY(a),i.z=s.getZ(a),r.x=s.getX(c),r.y=s.getY(c),r.z=s.getZ(c),o.x=s.getX(d),o.y=s.getY(d),o.z=s.getZ(d)}function Fi(n,e,t,s,i,r){const{geometry:o,_indirectBuffer:a}=n;for(let c=s,d=s+i;c<d;c++)be(o,e,t,c,r)}function Ri(n,e,t,s,i){const{geometry:r,_indirectBuffer:o}=n;let a=1/0,c=null;for(let d=s,f=s+i;d<f;d++){let u;u=be(r,e,t,d),u&&u.distance<a&&(c=u,a=u.distance)}return c}function Ii(n,e,t,s,i,r,o){const{geometry:a}=t,{index:c}=a,d=a.attributes.position;for(let f=n,u=e+n;f<u;f++){let l;if(l=f,q(o,l*3,c,d),o.needsUpdate=!0,s(o,l,i,r))return!0}return!1}function Hi(n,e=null){e&&Array.isArray(e)&&(e=new Set(e));const t=n.geometry,s=t.index?t.index.array:null,i=t.attributes.position;let r,o,a,c,d=0;const f=n._roots;for(let l=0,p=f.length;l<p;l++)r=f[l],o=new Uint32Array(r),a=new Uint16Array(r),c=new Float32Array(r),u(0,d),d+=r.byteLength;function u(l,p,y=!1){const O=l*2;if(a[O+15]===Ce){const m=o[l+6],g=a[O+14];let E=1/0,h=1/0,_=1/0,x=-1/0,w=-1/0,C=-1/0;for(let b=3*m,P=3*(m+g);b<P;b++){let U=s[b];const v=i.getX(U),D=i.getY(U),M=i.getZ(U);v<E&&(E=v),v>x&&(x=v),D<h&&(h=D),D>w&&(w=D),M<_&&(_=M),M>C&&(C=M)}return c[l+0]!==E||c[l+1]!==h||c[l+2]!==_||c[l+3]!==x||c[l+4]!==w||c[l+5]!==C?(c[l+0]=E,c[l+1]=h,c[l+2]=_,c[l+3]=x,c[l+4]=w,c[l+5]=C,!0):!1}else{const m=l+8,g=o[l+6],E=m+p,h=g+p;let _=y,x=!1,w=!1;e?_||(x=e.has(E),w=e.has(h),_=!x&&!w):(x=!0,w=!0);const C=_||x,b=_||w;let P=!1;C&&(P=u(m,p,_));let U=!1;b&&(U=u(g,p,_));const v=P||U;if(v)for(let D=0;D<3;D++){const M=m+D,R=g+D,N=c[M],Ft=c[M+3],Rt=c[R],It=c[R+3];c[l+D]=N<Rt?N:Rt,c[l+D+3]=Ft>It?Ft:It}return v}}}const ps=new st;function yt(n,e,t,s){return Y(n,e,ps),t.intersectBox(ps,s)}function ki(n,e,t,s,i,r){const{geometry:o,_indirectBuffer:a}=n;for(let c=s,d=s+i;c<d;c++){let f=a?a[c]:c;be(o,e,t,f,r)}}function Vi(n,e,t,s,i){const{geometry:r,_indirectBuffer:o}=n;let a=1/0,c=null;for(let d=s,f=s+i;d<f;d++){let u;u=be(r,e,t,o?o[d]:d),u&&u.distance<a&&(c=u,a=u.distance)}return c}function Yi(n,e,t,s,i,r,o){const{geometry:a}=t,{index:c}=a,d=a.attributes.position;for(let f=n,u=e+n;f<u;f++){let l;if(l=t.resolveTriangleIndex(f),q(o,l*3,c,d),o.needsUpdate=!0,s(o,l,i,r))return!0}return!1}const _s=new S;function Ni(n,e,t,s,i){V.setBuffer(n._roots[e]),qe(0,n,t,s,i),V.clearBuffer()}function qe(n,e,t,s,i){const{float32Array:r,uint16Array:o,uint32Array:a}=V,c=n*2;if(K(c,o)){const f=Q(n,a),u=J(c,o);Fi(e,t,s,f,u,i)}else{const f=tt(n);yt(f,r,s,_s)&&qe(f,e,t,s,i);const u=et(n,a);yt(u,r,s,_s)&&qe(u,e,t,s,i)}}const ms=new S,Zi=["x","y","z"];function Xi(n,e,t,s){V.setBuffer(n._roots[e]);const i=We(0,n,t,s);return V.clearBuffer(),i}function We(n,e,t,s){const{float32Array:i,uint16Array:r,uint32Array:o}=V;let a=n*2;if(K(a,r)){const d=Q(n,o),f=J(a,r);return Ri(e,t,s,d,f)}else{const d=Vs(n,o),f=Zi[d],l=s.direction[f]>=0;let p,y;l?(p=tt(n),y=et(n,o)):(p=et(n,o),y=tt(n));const T=yt(p,i,s,ms)?We(p,e,t,s):null;if(T){const E=T.point[f];if(l?E<=i[y+d]:E>=i[y+d+3])return T}const g=yt(y,i,s,ms)?We(y,e,t,s):null;return T&&g?T.distance<=g.distance?T:g:T||g||null}}const ce=new st,At=new ot,Ct=new ot,Vt=new ut,ys=new W,le=new W;function qi(n,e,t,s){V.setBuffer(n._roots[e]);const i=$e(0,n,t,s);return V.clearBuffer(),i}function $e(n,e,t,s,i=null){const{float32Array:r,uint16Array:o,uint32Array:a}=V;let c=n*2;if(i===null&&(t.boundingBox||t.computeBoundingBox(),ys.set(t.boundingBox.min,t.boundingBox.max,s),i=ys),K(c,o)){const f=e.geometry,u=f.index,l=f.attributes.position,p=t.index,y=t.attributes.position,O=Q(n,a),T=J(c,o);if(Vt.copy(s).invert(),t.boundsTree)return Y(n,r,le),le.matrix.copy(Vt),le.needsUpdate=!0,t.boundsTree.shapecast({intersectsBounds:g=>le.intersectsBox(g),intersectsTriangle:g=>{g.a.applyMatrix4(s),g.b.applyMatrix4(s),g.c.applyMatrix4(s),g.needsUpdate=!0;for(let E=O*3,h=(T+O)*3;E<h;E+=3)if(q(Ct,E,u,l),Ct.needsUpdate=!0,g.intersectsTriangle(Ct))return!0;return!1}});for(let m=O*3,g=(T+O)*3;m<g;m+=3){q(At,m,u,l),At.a.applyMatrix4(Vt),At.b.applyMatrix4(Vt),At.c.applyMatrix4(Vt),At.needsUpdate=!0;for(let E=0,h=p.count;E<h;E+=3)if(q(Ct,E,p,y),Ct.needsUpdate=!0,At.intersectsTriangle(Ct))return!0}}else{const f=n+8,u=a[n+6];return Y(f,r,ce),!!(i.intersectsBox(ce)&&$e(f,e,t,s,i)||(Y(u,r,ce),i.intersectsBox(ce)&&$e(u,e,t,s,i)))}}const he=new ut,Me=new W,Yt=new W,Wi=new S,$i=new S,Ki=new S,Qi=new S;function Gi(n,e,t,s={},i={},r=0,o=1/0){e.boundingBox||e.computeBoundingBox(),Me.set(e.boundingBox.min,e.boundingBox.max,t),Me.needsUpdate=!0;const a=n.geometry,c=a.attributes.position,d=a.index,f=e.attributes.position,u=e.index,l=j.getPrimitive(),p=j.getPrimitive();let y=Wi,O=$i,T=null,m=null;i&&(T=Ki,m=Qi);let g=1/0,E=null,h=null;return he.copy(t).invert(),Yt.matrix.copy(he),n.shapecast({boundsTraverseOrder:_=>Me.distanceToBox(_),intersectsBounds:(_,x,w)=>w<g&&w<o?(x&&(Yt.min.copy(_.min),Yt.max.copy(_.max),Yt.needsUpdate=!0),!0):!1,intersectsRange:(_,x)=>{if(e.boundsTree)return e.boundsTree.shapecast({boundsTraverseOrder:C=>Yt.distanceToBox(C),intersectsBounds:(C,b,P)=>P<g&&P<o,intersectsRange:(C,b)=>{for(let P=C,U=C+b;P<U;P++){q(p,3*P,u,f),p.a.applyMatrix4(t),p.b.applyMatrix4(t),p.c.applyMatrix4(t),p.needsUpdate=!0;for(let v=_,D=_+x;v<D;v++){q(l,3*v,d,c),l.needsUpdate=!0;const M=l.distanceToTriangle(p,y,T);if(M<g&&(O.copy(y),m&&m.copy(T),g=M,E=v,h=P),M<r)return!0}}}});{const w=zt(e);for(let C=0,b=w;C<b;C++){q(p,3*C,u,f),p.a.applyMatrix4(t),p.b.applyMatrix4(t),p.c.applyMatrix4(t),p.needsUpdate=!0;for(let P=_,U=_+x;P<U;P++){q(l,3*P,d,c),l.needsUpdate=!0;const v=l.distanceToTriangle(p,y,T);if(v<g&&(O.copy(y),m&&m.copy(T),g=v,E=P,h=C),v<r)return!0}}}}}),j.releasePrimitive(l),j.releasePrimitive(p),g===1/0?null:(s.point?s.point.copy(O):s.point=O.clone(),s.distance=g,s.faceIndex=E,i&&(i.point?i.point.copy(m):i.point=m.clone(),i.point.applyMatrix4(he),O.applyMatrix4(he),i.distance=O.sub(i.point).length(),i.faceIndex=h),s)}function ji(n,e=null){e&&Array.isArray(e)&&(e=new Set(e));const t=n.geometry,s=t.index?t.index.array:null,i=t.attributes.position;let r,o,a,c,d=0;const f=n._roots;for(let l=0,p=f.length;l<p;l++)r=f[l],o=new Uint32Array(r),a=new Uint16Array(r),c=new Float32Array(r),u(0,d),d+=r.byteLength;function u(l,p,y=!1){const O=l*2;if(a[O+15]===Ce){const m=o[l+6],g=a[O+14];let E=1/0,h=1/0,_=1/0,x=-1/0,w=-1/0,C=-1/0;for(let b=m,P=m+g;b<P;b++){const U=3*n.resolveTriangleIndex(b);for(let v=0;v<3;v++){let D=U+v;D=s?s[D]:D;const M=i.getX(D),R=i.getY(D),N=i.getZ(D);M<E&&(E=M),M>x&&(x=M),R<h&&(h=R),R>w&&(w=R),N<_&&(_=N),N>C&&(C=N)}}return c[l+0]!==E||c[l+1]!==h||c[l+2]!==_||c[l+3]!==x||c[l+4]!==w||c[l+5]!==C?(c[l+0]=E,c[l+1]=h,c[l+2]=_,c[l+3]=x,c[l+4]=w,c[l+5]=C,!0):!1}else{const m=l+8,g=o[l+6],E=m+p,h=g+p;let _=y,x=!1,w=!1;e?_||(x=e.has(E),w=e.has(h),_=!x&&!w):(x=!0,w=!0);const C=_||x,b=_||w;let P=!1;C&&(P=u(m,p,_));let U=!1;b&&(U=u(g,p,_));const v=P||U;if(v)for(let D=0;D<3;D++){const M=m+D,R=g+D,N=c[M],Ft=c[M+3],Rt=c[R],It=c[R+3];c[l+D]=N<Rt?N:Rt,c[l+D+3]=Ft>It?Ft:It}return v}}}const gs=new S;function Ji(n,e,t,s,i){V.setBuffer(n._roots[e]),Ke(0,n,t,s,i),V.clearBuffer()}function Ke(n,e,t,s,i){const{float32Array:r,uint16Array:o,uint32Array:a}=V,c=n*2;if(K(c,o)){const f=Q(n,a),u=J(c,o);ki(e,t,s,f,u,i)}else{const f=tt(n);yt(f,r,s,gs)&&Ke(f,e,t,s,i);const u=et(n,a);yt(u,r,s,gs)&&Ke(u,e,t,s,i)}}const Ts=new S,tn=["x","y","z"];function en(n,e,t,s){V.setBuffer(n._roots[e]);const i=Qe(0,n,t,s);return V.clearBuffer(),i}function Qe(n,e,t,s){const{float32Array:i,uint16Array:r,uint32Array:o}=V;let a=n*2;if(K(a,r)){const d=Q(n,o),f=J(a,r);return Vi(e,t,s,d,f)}else{const d=Vs(n,o),f=tn[d],l=s.direction[f]>=0;let p,y;l?(p=tt(n),y=et(n,o)):(p=et(n,o),y=tt(n));const T=yt(p,i,s,Ts)?Qe(p,e,t,s):null;if(T){const E=T.point[f];if(l?E<=i[y+d]:E>=i[y+d+3])return T}const g=yt(y,i,s,Ts)?Qe(y,e,t,s):null;return T&&g?T.distance<=g.distance?T:g:T||g||null}}const ue=new st,bt=new ot,Pt=new ot,Nt=new ut,Es=new W,fe=new W;function sn(n,e,t,s){V.setBuffer(n._roots[e]);const i=Ge(0,n,t,s);return V.clearBuffer(),i}function Ge(n,e,t,s,i=null){const{float32Array:r,uint16Array:o,uint32Array:a}=V;let c=n*2;if(i===null&&(t.boundingBox||t.computeBoundingBox(),Es.set(t.boundingBox.min,t.boundingBox.max,s),i=Es),K(c,o)){const f=e.geometry,u=f.index,l=f.attributes.position,p=t.index,y=t.attributes.position,O=Q(n,a),T=J(c,o);if(Nt.copy(s).invert(),t.boundsTree)return Y(n,r,fe),fe.matrix.copy(Nt),fe.needsUpdate=!0,t.boundsTree.shapecast({intersectsBounds:g=>fe.intersectsBox(g),intersectsTriangle:g=>{g.a.applyMatrix4(s),g.b.applyMatrix4(s),g.c.applyMatrix4(s),g.needsUpdate=!0;for(let E=O,h=T+O;E<h;E++)if(q(Pt,3*e.resolveTriangleIndex(E),u,l),Pt.needsUpdate=!0,g.intersectsTriangle(Pt))return!0;return!1}});for(let m=O,g=T+O;m<g;m++){const E=e.resolveTriangleIndex(m);q(bt,3*E,u,l),bt.a.applyMatrix4(Nt),bt.b.applyMatrix4(Nt),bt.c.applyMatrix4(Nt),bt.needsUpdate=!0;for(let h=0,_=p.count;h<_;h+=3)if(q(Pt,h,p,y),Pt.needsUpdate=!0,bt.intersectsTriangle(Pt))return!0}}else{const f=n+8,u=a[n+6];return Y(f,r,ue),!!(i.intersectsBox(ue)&&Ge(f,e,t,s,i)||(Y(u,r,ue),i.intersectsBox(ue)&&Ge(u,e,t,s,i)))}}const de=new ut,Be=new W,Zt=new W,nn=new S,on=new S,rn=new S,an=new S;function cn(n,e,t,s={},i={},r=0,o=1/0){e.boundingBox||e.computeBoundingBox(),Be.set(e.boundingBox.min,e.boundingBox.max,t),Be.needsUpdate=!0;const a=n.geometry,c=a.attributes.position,d=a.index,f=e.attributes.position,u=e.index,l=j.getPrimitive(),p=j.getPrimitive();let y=nn,O=on,T=null,m=null;i&&(T=rn,m=an);let g=1/0,E=null,h=null;return de.copy(t).invert(),Zt.matrix.copy(de),n.shapecast({boundsTraverseOrder:_=>Be.distanceToBox(_),intersectsBounds:(_,x,w)=>w<g&&w<o?(x&&(Zt.min.copy(_.min),Zt.max.copy(_.max),Zt.needsUpdate=!0),!0):!1,intersectsRange:(_,x)=>{if(e.boundsTree){const w=e.boundsTree;return w.shapecast({boundsTraverseOrder:C=>Zt.distanceToBox(C),intersectsBounds:(C,b,P)=>P<g&&P<o,intersectsRange:(C,b)=>{for(let P=C,U=C+b;P<U;P++){const v=w.resolveTriangleIndex(P);q(p,3*v,u,f),p.a.applyMatrix4(t),p.b.applyMatrix4(t),p.c.applyMatrix4(t),p.needsUpdate=!0;for(let D=_,M=_+x;D<M;D++){const R=n.resolveTriangleIndex(D);q(l,3*R,d,c),l.needsUpdate=!0;const N=l.distanceToTriangle(p,y,T);if(N<g&&(O.copy(y),m&&m.copy(T),g=N,E=D,h=P),N<r)return!0}}}})}else{const w=zt(e);for(let C=0,b=w;C<b;C++){q(p,3*C,u,f),p.a.applyMatrix4(t),p.b.applyMatrix4(t),p.c.applyMatrix4(t),p.needsUpdate=!0;for(let P=_,U=_+x;P<U;P++){const v=n.resolveTriangleIndex(P);q(l,3*v,d,c),l.needsUpdate=!0;const D=l.distanceToTriangle(p,y,T);if(D<g&&(O.copy(y),m&&m.copy(T),g=D,E=P,h=C),D<r)return!0}}}}}),j.releasePrimitive(l),j.releasePrimitive(p),g===1/0?null:(s.point?s.point.copy(O):s.point=O.clone(),s.distance=g,s.faceIndex=E,i&&(i.point?i.point.copy(m):i.point=m.clone(),i.point.applyMatrix4(de),O.applyMatrix4(de),i.distance=O.sub(i.point).length(),i.faceIndex=h),s)}function ln(){return typeof SharedArrayBuffer<"u"}const Gt=new V.constructor,Ee=new V.constructor,_t=new Je(()=>new st),vt=new st,Ut=new st,ze=new st,Fe=new st;let Re=!1;function hn(n,e,t,s){if(Re)throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");Re=!0;const i=n._roots,r=e._roots;let o,a=0,c=0;const d=new ut().copy(t).invert();for(let f=0,u=i.length;f<u;f++){Gt.setBuffer(i[f]),c=0;const l=_t.getPrimitive();Y(0,Gt.float32Array,l),l.applyMatrix4(d);for(let p=0,y=r.length;p<y&&(Ee.setBuffer(r[f]),o=it(0,0,t,d,s,a,c,0,0,l),Ee.clearBuffer(),c+=r[p].length,!o);p++);if(_t.releasePrimitive(l),Gt.clearBuffer(),a+=i[f].length,o)break}return Re=!1,o}function it(n,e,t,s,i,r=0,o=0,a=0,c=0,d=null,f=!1){let u,l;f?(u=Ee,l=Gt):(u=Gt,l=Ee);const p=u.float32Array,y=u.uint32Array,O=u.uint16Array,T=l.float32Array,m=l.uint32Array,g=l.uint16Array,E=n*2,h=e*2,_=K(E,O),x=K(h,g);let w=!1;if(x&&_)f?w=i(Q(e,m),J(e*2,g),Q(n,y),J(n*2,O),c,o+e,a,r+n):w=i(Q(n,y),J(n*2,O),Q(e,m),J(e*2,g),a,r+n,c,o+e);else if(x){const C=_t.getPrimitive();Y(e,T,C),C.applyMatrix4(t);const b=tt(n),P=et(n,y);Y(b,p,vt),Y(P,p,Ut);const U=C.intersectsBox(vt),v=C.intersectsBox(Ut);w=U&&it(e,b,s,t,i,o,r,c,a+1,C,!f)||v&&it(e,P,s,t,i,o,r,c,a+1,C,!f),_t.releasePrimitive(C)}else{const C=tt(e),b=et(e,m);Y(C,T,ze),Y(b,T,Fe);const P=d.intersectsBox(ze),U=d.intersectsBox(Fe);if(P&&U)w=it(n,C,t,s,i,r,o,a,c+1,d,f)||it(n,b,t,s,i,r,o,a,c+1,d,f);else if(P)if(_)w=it(n,C,t,s,i,r,o,a,c+1,d,f);else{const v=_t.getPrimitive();v.copy(ze).applyMatrix4(t);const D=tt(n),M=et(n,y);Y(D,p,vt),Y(M,p,Ut);const R=v.intersectsBox(vt),N=v.intersectsBox(Ut);w=R&&it(C,D,s,t,i,o,r,c,a+1,v,!f)||N&&it(C,M,s,t,i,o,r,c,a+1,v,!f),_t.releasePrimitive(v)}else if(U)if(_)w=it(n,b,t,s,i,r,o,a,c+1,d,f);else{const v=_t.getPrimitive();v.copy(Fe).applyMatrix4(t);const D=tt(n),M=et(n,y);Y(D,p,vt),Y(M,p,Ut);const R=v.intersectsBox(vt),N=v.intersectsBox(Ut);w=R&&it(b,D,s,t,i,o,r,c,a+1,v,!f)||N&&it(b,M,s,t,i,o,r,c,a+1,v,!f),_t.releasePrimitive(v)}}return w}const pe=new W,xs=new st;class ts{static serialize(e,t={}){t={cloneBuffers:!0,...t};const s=e.geometry,i=e._roots,r=e._indirectBuffer,o=s.getIndex();let a;return t.cloneBuffers?a={roots:i.map(c=>c.slice()),index:o.array.slice(),indirectBuffer:r?r.slice():null}:a={roots:i,index:o.array,indirectBuffer:r},a}static deserialize(e,t,s={}){s={setIndex:!0,indirect:!!e.indirectBuffer,...s};const{index:i,roots:r,indirectBuffer:o}=e,a=new ts(t,{...s,[Ue]:!0});if(a._roots=r,a._indirectBuffer=o||null,s.setIndex){const c=t.getIndex();if(c===null){const d=new Bs(e.index,1,!1);t.setIndex(d)}else c.array!==i&&(c.array.set(i),c.needsUpdate=!0)}return a}get indirect(){return!!this._indirectBuffer}constructor(e,t={}){if(e.isBufferGeometry){if(e.index&&e.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.")}else throw new Error("MeshBVH: Only BufferGeometries are supported.");if(t=Object.assign({strategy:Is,maxDepth:40,maxLeafTris:10,verbose:!0,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,indirect:!1,[Ue]:!1},t),t.useSharedArrayBuffer&&!ln())throw new Error("MeshBVH: SharedArrayBuffer is not available.");this.geometry=e,this._roots=null,this._indirectBuffer=null,t[Ue]||(bi(this,t),!e.boundingBox&&t.setBoundingBox&&(e.boundingBox=this.getBoundingBox(new st)));const{_indirectBuffer:s}=this;this.resolveTriangleIndex=t.indirect?i=>s[i]:i=>i}refit(e=null){return(this.indirect?ji:Hi)(this,e)}traverse(e,t=0){const s=this._roots[t],i=new Uint32Array(s),r=new Uint16Array(s);o(0);function o(a,c=0){const d=a*2,f=r[d+15]===Ce;if(f){const u=i[a+6],l=r[d+14];e(c,f,new Float32Array(s,a*4,6),u,l)}else{const u=a+Te/4,l=i[a+6],p=i[a+7];e(c,f,new Float32Array(s,a*4,6),p)||(o(u,c+1),o(l,c+1))}}}raycast(e,t=is){const s=this._roots,i=this.geometry,r=[],o=t.isMaterial,a=Array.isArray(t),c=i.groups,d=o?t.side:t,f=this.indirect?Ji:Ni;for(let u=0,l=s.length;u<l;u++){const p=a?t[c[u].materialIndex].side:d,y=r.length;if(f(this,u,p,e,r),a){const O=c[u].materialIndex;for(let T=y,m=r.length;T<m;T++)r[T].face.materialIndex=O}}return r}raycastFirst(e,t=is){const s=this._roots,i=this.geometry,r=t.isMaterial,o=Array.isArray(t);let a=null;const c=i.groups,d=r?t.side:t,f=this.indirect?en:Xi;for(let u=0,l=s.length;u<l;u++){const p=o?t[c[u].materialIndex].side:d,y=f(this,u,p,e);y!=null&&(a==null||y.distance<a.distance)&&(a=y,o&&(y.face.materialIndex=c[u].materialIndex))}return a}intersectsGeometry(e,t){let s=!1;const i=this._roots,r=this.indirect?sn:qi;for(let o=0,a=i.length;o<a&&(s=r(this,o,e,t),!s);o++);return s}shapecast(e){const t=j.getPrimitive(),s=this.indirect?Yi:Ii;let{boundsTraverseOrder:i,intersectsBounds:r,intersectsRange:o,intersectsTriangle:a}=e;if(o&&a){const u=o;o=(l,p,y,O,T)=>u(l,p,y,O,T)?!0:s(l,p,this,a,y,O,t)}else o||(a?o=(u,l,p,y)=>s(u,l,this,a,p,y,t):o=(u,l,p)=>p);let c=!1,d=0;const f=this._roots;for(let u=0,l=f.length;u<l;u++){const p=f[u];if(c=Si(this,u,r,o,i,d),c)break;d+=p.byteLength}return j.releasePrimitive(t),c}bvhcast(e,t,s){let{intersectsRanges:i,intersectsTriangles:r}=s;const o=j.getPrimitive(),a=this.geometry.index,c=this.geometry.attributes.position,d=this.indirect?y=>{const O=this.resolveTriangleIndex(y);q(o,O*3,a,c)}:y=>{q(o,y*3,a,c)},f=j.getPrimitive(),u=e.geometry.index,l=e.geometry.attributes.position,p=e.indirect?y=>{const O=e.resolveTriangleIndex(y);q(f,O*3,u,l)}:y=>{q(f,y*3,u,l)};if(r){const y=(O,T,m,g,E,h,_,x)=>{for(let w=m,C=m+g;w<C;w++){p(w),f.a.applyMatrix4(t),f.b.applyMatrix4(t),f.c.applyMatrix4(t),f.needsUpdate=!0;for(let b=O,P=O+T;b<P;b++)if(d(b),o.needsUpdate=!0,r(o,f,b,w,E,h,_,x))return!0}return!1};if(i){const O=i;i=function(T,m,g,E,h,_,x,w){return O(T,m,g,E,h,_,x,w)?!0:y(T,m,g,E,h,_,x,w)}}else i=y}return hn(this,e,t,i)}intersectsBox(e,t){return pe.set(e.min,e.max,t),pe.needsUpdate=!0,this.shapecast({intersectsBounds:s=>pe.intersectsBox(s),intersectsTriangle:s=>pe.intersectsTriangle(s)})}intersectsSphere(e){return this.shapecast({intersectsBounds:t=>e.intersectsBox(t),intersectsTriangle:t=>t.intersectsSphere(e)})}closestPointToGeometry(e,t,s={},i={},r=0,o=1/0){return(this.indirect?cn:Gi)(this,e,t,s,i,r,o)}closestPointToPoint(e,t={},s=0,i=1/0){return Mi(this,e,t,s,i)}getBoundingBox(e){return e.makeEmpty(),this._roots.forEach(s=>{Y(0,new Float32Array(s),xs),e.union(xs)}),e}}function ws(n,e,t){return n===null||(n.point.applyMatrix4(e.matrixWorld),n.distance=n.point.distanceTo(t.ray.origin),n.object=e,n.distance<t.near||n.distance>t.far)?null:n}const Ie=new Qs,Os=new ut,un=Rs.prototype.raycast;function fn(n,e){if(this.geometry.boundsTree){if(this.material===void 0)return;Os.copy(this.matrixWorld).invert(),Ie.copy(n.ray).applyMatrix4(Os);const t=this.geometry.boundsTree;if(n.firstHitOnly===!0){const s=ws(t.raycastFirst(Ie,this.material),this,n);s&&e.push(s)}else{const s=t.raycast(Ie,this.material);for(let i=0,r=s.length;i<r;i++){const o=ws(s[i],this,n);o&&e.push(o)}}}else un.call(this,n,e)}function dn(n){return this.boundsTree=new ts(this,n),this.boundsTree}function pn(){this.boundsTree=null}class X{constructor(){L(this,"trigger",e=>{const t=this.handlers.slice(0);for(const s of t)s(e)});L(this,"handlers",[])}add(e){this.handlers.push(e)}remove(e){this.handlers=this.handlers.filter(t=>t!==e)}reset(){this.handlers.length=0}}class es{constructor(e){L(this,"isDisposeable",()=>"dispose"in this&&"onDisposed"in this);L(this,"isResizeable",()=>"resize"in this&&"getSize"in this);L(this,"isUpdateable",()=>"onAfterUpdate"in this&&"onBeforeUpdate"in this&&"update"in this);L(this,"isHideable",()=>"visible"in this);L(this,"isConfigurable",()=>"setup"in this&&"config"in this&&"onSetup"in this);this.components=e}}class Ys extends es{}class ss extends es{constructor(t){super(t);L(this,"worlds",new Map);L(this,"onWorldChanged",new X);L(this,"currentWorld",null);this.onWorldChanged.add(({world:s,action:i})=>{i==="removed"&&this.worlds.delete(s.uuid)})}}class _n extends ss{constructor(){super(...arguments);L(this,"hasCameraControls",()=>"controls"in this)}}class mn extends ss{constructor(){super(...arguments);L(this,"onAfterUpdate",new X);L(this,"onBeforeUpdate",new X);L(this,"onDisposed",new X);L(this,"onResize",new X);L(this,"onClippingPlanesUpdated",new X);L(this,"clippingPlanes",[])}updateClippingPlanes(){this.onClippingPlanesUpdated.trigger()}setPlane(t,s,i){s.isLocal=i;const r=this.clippingPlanes.indexOf(s);t&&r===-1?this.clippingPlanes.push(s):!t&&r>-1&&this.clippingPlanes.splice(r,1),this.three.clippingPlanes=this.clippingPlanes.filter(o=>!o.isLocal)}}const jt=class jt extends Ys{constructor(t){super(t);L(this,"_disposedComponents",new Set);L(this,"enabled",!0);t.add(jt.uuid,this)}get(){return this._disposedComponents}destroy(t,s=!0,i=!0){t.removeFromParent();const r=t;r.dispose&&r.dispose(),this.disposeGeometryAndMaterials(t,s),i&&r.children&&r.children.length&&this.disposeChildren(r),t.children.length=0}disposeGeometry(t){const s=t;s.boundsTree&&s.disposeBoundsTree(),t.dispose()}disposeGeometryAndMaterials(t,s){const i=t;i.geometry&&this.disposeGeometry(i.geometry),s&&i.material&&jt.disposeMaterial(i),i.material=[],i.geometry=null}disposeChildren(t){for(const s of t.children)this.destroy(s)}static disposeMaterial(t){if(t.material)if(Array.isArray(t.material))for(const s of t.material)s.dispose();else t.material.dispose()}};L(jt,"uuid","76e9cd8e-ad8f-4753-9ef6-cbc60f7247fe");let xe=jt;class yn extends ss{constructor(t){super(t);L(this,"onDisposed",new X)}dispose(){const t=this.components.get(xe);for(const s of this.three.children){const i=s;i.geometry&&t.destroy(i)}this.three.children=[],this.onDisposed.trigger(),this.onDisposed.reset()}}const Z=class Z{static create(){const e=Math.random()*4294967295|0,t=Math.random()*4294967295|0,s=Math.random()*4294967295|0,i=Math.random()*4294967295|0;return`${Z._lut[e&255]+Z._lut[e>>8&255]+Z._lut[e>>16&255]+Z._lut[e>>24&255]}-${Z._lut[t&255]}${Z._lut[t>>8&255]}-${Z._lut[t>>16&15|64]}${Z._lut[t>>24&255]}-${Z._lut[s&63|128]}${Z._lut[s>>8&255]}-${Z._lut[s>>16&255]}${Z._lut[s>>24&255]}${Z._lut[i&255]}${Z._lut[i>>8&255]}${Z._lut[i>>16&255]}${Z._lut[i>>24&255]}`.toLowerCase()}static validate(e){if(!Z._pattern.test(e))throw new Error(`${e} is not a valid UUID v4.

- If you're the tool creator, you can take one from https://www.uuidgenerator.net/.

- If you're using a platform tool, verify the uuid isn't misspelled or contact the tool creator.`)}};L(Z,"_pattern",/^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-4[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$/),L(Z,"_lut",["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"]);let we=Z;const Oe=class Oe{constructor(){L(this,"onDisposed",new X);L(this,"list",new Map);L(this,"enabled",!1);L(this,"_clock");L(this,"update",()=>{if(!this.enabled)return;const e=this._clock.getDelta();for(const[t,s]of this.list)s.enabled&&s.isUpdateable()&&s.update(e);requestAnimationFrame(this.update)});this._clock=new Gs,Oe.setupBVH()}add(e,t){if(this.list.has(e))throw new Error("You're trying to add a component that already exists in the components intance. Use Components.get() instead.");we.validate(e),this.list.set(e,t)}get(e){const t=e.uuid;if(!this.list.has(t)){const s=new e(this);return this.list.has(t)||this.add(t,s),s}return this.list.get(t)}init(){this.enabled=!0,this._clock.start(),this.update()}dispose(){this.enabled=!1;for(const[e,t]of this.list)t.enabled=!1,t.isDisposeable()&&t.dispose();this._clock.stop(),this.onDisposed.trigger(),this.onDisposed.reset()}static setupBVH(){ns.prototype.computeBoundsTree=dn,ns.prototype.disposeBoundsTree=pn,Rs.prototype.raycast=fn}};L(Oe,"release","1.4.21");let As=Oe;class gn extends es{constructor(t){super(t);L(this,"meshes",new Set);L(this,"onAfterUpdate",new X);L(this,"onBeforeUpdate",new X);L(this,"enabled",!0);L(this,"uuid",we.create());L(this,"onDisposed",new X);L(this,"_scene");L(this,"_camera");L(this,"_renderer",null)}get scene(){if(!this._scene)throw new Error("No scene initialized!");return this._scene}set scene(t){this._scene=t,t.worlds.set(this.uuid,this),t.currentWorld=this,t.onWorldChanged.trigger({world:this,action:"added"})}get camera(){if(!this._camera)throw new Error("No camera initialized!");return this._camera}set camera(t){this._camera=t,t.worlds.set(this.uuid,this),t.currentWorld=this,t.onWorldChanged.trigger({world:this,action:"added"})}get renderer(){return this._renderer}set renderer(t){this._renderer=t,t&&(t.worlds.set(this.uuid,this),t.currentWorld=this,t.onWorldChanged.trigger({world:this,action:"added"}))}update(t){this.enabled&&(!this._scene||!this._camera||(this.scene.currentWorld=this,this.camera.currentWorld=this,this.renderer&&(this.renderer.currentWorld=this),this.onBeforeUpdate.trigger(),this.scene.isUpdateable()&&this.scene.update(t),this.camera.isUpdateable()&&this.camera.update(t),this.renderer&&this.renderer.update(t),this.onAfterUpdate.trigger()))}dispose(t=!0){if(this.enabled=!1,this.scene.onWorldChanged.trigger({world:this,action:"removed"}),this.camera.onWorldChanged.trigger({world:this,action:"removed"}),this.renderer&&this.renderer.onWorldChanged.trigger({world:this,action:"removed"}),t){const s=this.components.get(xe);this.scene.dispose(),this.camera.isDisposeable()&&this.camera.dispose(),this.renderer&&this.renderer.dispose();for(const i of this.meshes)s.destroy(i);this.meshes.clear()}this._scene=null,this._camera=null,this._renderer=null,this.onDisposed.trigger()}}class Cn extends yn{constructor(t){super(t);L(this,"isSetup",!1);L(this,"three");L(this,"onSetup",new X);L(this,"config",{directionalLight:{color:new Pe("white"),intensity:1.5,position:new S(5,10,3)},ambientLight:{color:new Pe("white"),intensity:1}});this.three=new js,this.three.background=new Pe(2107698)}setup(t){this.config={...this.config,...t};const s=new Js(this.config.directionalLight.color,this.config.directionalLight.intensity);s.position.copy(this.config.directionalLight.position);const i=new ti(this.config.ambientLight.color,this.config.ambientLight.intensity);this.three.add(s,i),this.isSetup=!0,this.onSetup.trigger(this)}}class bn extends mn{constructor(t,s,i){super(t);L(this,"enabled",!0);L(this,"container");L(this,"three");L(this,"_canvas");L(this,"_parameters");L(this,"_resizeObserver",null);L(this,"onContainerUpdated",new X);L(this,"_resizing",!1);L(this,"resize",t=>{if(this._resizing)return;this._resizing=!0,this.onContainerUpdated.trigger();const s=t?t.x:this.container.clientWidth,i=t?t.y:this.container.clientHeight;this.three.setSize(s,i),this.onResize.trigger(new ht(s,i)),this._resizing=!1});L(this,"resizeEvent",()=>{this.resize()});L(this,"onContextLost",t=>{t.preventDefault(),this.enabled=!1});L(this,"onContextBack",()=>{this.three.setRenderTarget(null),this.three.dispose(),this.three=new os({canvas:this._canvas,antialias:!0,alpha:!0,...this._parameters}),this.enabled=!0});this.container=s,this._parameters=i,this.three=new os({antialias:!0,alpha:!0,...i}),this.three.setPixelRatio(Math.min(window.devicePixelRatio,2)),this.setupRenderer(),this.setupEvents(!0),this.resize(),this._canvas=this.three.domElement;const r=this.three.getContext(),{canvas:o}=r;o.addEventListener("webglcontextlost",this.onContextLost,!1),o.addEventListener("webglcontextrestored",this.onContextBack,!1)}update(){if(!this.enabled||!this.currentWorld)return;this.onBeforeUpdate.trigger(this);const t=this.currentWorld.scene.three,s=this.currentWorld.camera.three;this.three.render(t,s),this.onAfterUpdate.trigger(this)}dispose(){this.enabled=!1,this.setupEvents(!1),this.three.domElement.remove(),this.three.dispose(),this.onResize.reset(),this.onAfterUpdate.reset(),this.onBeforeUpdate.reset(),this.onDisposed.trigger(),this.onDisposed.reset()}getSize(){return new ht(this.three.domElement.clientWidth,this.three.domElement.clientHeight)}setupEvents(t){const s=this.three.domElement.parentElement;if(!s)throw new Error("This renderer needs to have an HTML container!");this._resizeObserver&&(this._resizeObserver.disconnect(),this._resizeObserver=null),window.removeEventListener("resize",this.resizeEvent),t&&(this._resizeObserver=new ResizeObserver(this.resizeEvent),this._resizeObserver.observe(s),window.addEventListener("resize",this.resizeEvent))}setupRenderer(){this.three.localClippingEnabled=!0,this.container&&this.container.appendChild(this.three.domElement),this.onContainerUpdated.trigger()}}/*!
 * camera-controls
 * https://github.com/yomotsu/camera-controls
 * (c) 2017 @yomotsu
 * Released under the MIT License.
 */const z={LEFT:1,RIGHT:2,MIDDLE:4},A=Object.freeze({NONE:0,ROTATE:1,TRUCK:2,OFFSET:4,DOLLY:8,ZOOM:16,TOUCH_ROTATE:32,TOUCH_TRUCK:64,TOUCH_OFFSET:128,TOUCH_DOLLY:256,TOUCH_ZOOM:512,TOUCH_DOLLY_TRUCK:1024,TOUCH_DOLLY_OFFSET:2048,TOUCH_DOLLY_ROTATE:4096,TOUCH_ZOOM_TRUCK:8192,TOUCH_ZOOM_OFFSET:16384,TOUCH_ZOOM_ROTATE:32768}),Lt={NONE:0,IN:1,OUT:-1};function gt(n){return n.isPerspectiveCamera}function pt(n){return n.isOrthographicCamera}const Dt=Math.PI*2,Cs=Math.PI/2,Ns=1e-5,Xt=Math.PI/180;function nt(n,e,t){return Math.max(e,Math.min(t,n))}function k(n,e=Ns){return Math.abs(n)<e}function H(n,e,t=Ns){return k(n-e,t)}function bs(n,e){return Math.round(n/e)*e}function qt(n){return isFinite(n)?n:n<0?-Number.MAX_VALUE:Number.MAX_VALUE}function Wt(n){return Math.abs(n)<Number.MAX_VALUE?n:n*(1/0)}function _e(n,e,t,s,i=1/0,r){s=Math.max(1e-4,s);const o=2/s,a=o*r,c=1/(1+a+.48*a*a+.235*a*a*a);let d=n-e;const f=e,u=i*s;d=nt(d,-u,u),e=n-d;const l=(t.value+o*d)*r;t.value=(t.value-o*l)*c;let p=e+(d+l)*c;return f-n>0==p>f&&(p=f,t.value=(p-f)/r),p}function Ps(n,e,t,s,i=1/0,r,o){s=Math.max(1e-4,s);const a=2/s,c=a*r,d=1/(1+c+.48*c*c+.235*c*c*c);let f=e.x,u=e.y,l=e.z,p=n.x-f,y=n.y-u,O=n.z-l;const T=f,m=u,g=l,E=i*s,h=E*E,_=p*p+y*y+O*O;if(_>h){const R=Math.sqrt(_);p=p/R*E,y=y/R*E,O=O/R*E}f=n.x-p,u=n.y-y,l=n.z-O;const x=(t.x+a*p)*r,w=(t.y+a*y)*r,C=(t.z+a*O)*r;t.x=(t.x-a*x)*d,t.y=(t.y-a*w)*d,t.z=(t.z-a*C)*d,o.x=f+(p+x)*d,o.y=u+(y+w)*d,o.z=l+(O+C)*d;const b=T-n.x,P=m-n.y,U=g-n.z,v=o.x-T,D=o.y-m,M=o.z-g;return b*v+P*D+U*M>0&&(o.x=T,o.y=m,o.z=g,t.x=(o.x-T)/r,t.y=(o.y-m)/r,t.z=(o.z-g)/r),o}function He(n,e){e.set(0,0),n.forEach(t=>{e.x+=t.clientX,e.y+=t.clientY}),e.x/=n.length,e.y/=n.length}function ke(n,e){return pt(n)?(console.warn(`${e} is not supported in OrthographicCamera`),!0):!1}class Tn{constructor(){this._listeners={}}addEventListener(e,t){const s=this._listeners;s[e]===void 0&&(s[e]=[]),s[e].indexOf(t)===-1&&s[e].push(t)}hasEventListener(e,t){const s=this._listeners;return s[e]!==void 0&&s[e].indexOf(t)!==-1}removeEventListener(e,t){const i=this._listeners[e];if(i!==void 0){const r=i.indexOf(t);r!==-1&&i.splice(r,1)}}removeAllEventListeners(e){if(!e){this._listeners={};return}Array.isArray(this._listeners[e])&&(this._listeners[e].length=0)}dispatchEvent(e){const s=this._listeners[e.type];if(s!==void 0){e.target=this;const i=s.slice(0);for(let r=0,o=i.length;r<o;r++)i[r].call(this,e)}}}const En="2.7.3",me=1/8,Zs=typeof window<"u",xn=Zs&&/Mac/.test(navigator.platform),wn=!(Zs&&"PointerEvent"in window);let B,vs,ye,Ve,$,F,I,St,$t,rt,at,Tt,Us,Ls,G,Kt,Mt,Ds,Ye,Ss,Ne,Ze,ge;class Jt extends Tn{static install(e){B=e.THREE,vs=Object.freeze(new B.Vector3(0,0,0)),ye=Object.freeze(new B.Vector3(0,1,0)),Ve=Object.freeze(new B.Vector3(0,0,1)),$=new B.Vector2,F=new B.Vector3,I=new B.Vector3,St=new B.Vector3,$t=new B.Vector3,rt=new B.Vector3,at=new B.Vector3,Tt=new B.Vector3,Us=new B.Vector3,Ls=new B.Vector3,G=new B.Spherical,Kt=new B.Spherical,Mt=new B.Box3,Ds=new B.Box3,Ye=new B.Sphere,Ss=new B.Quaternion,Ne=new B.Quaternion,Ze=new B.Matrix4,ge=new B.Raycaster}static get ACTION(){return A}constructor(e,t){super(),this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-1/0,this.maxAzimuthAngle=1/0,this.minDistance=Number.EPSILON,this.maxDistance=1/0,this.infinityDolly=!1,this.minZoom=.01,this.maxZoom=1/0,this.smoothTime=.25,this.draggingSmoothTime=.125,this.maxSpeed=1/0,this.azimuthRotateSpeed=1,this.polarRotateSpeed=1,this.dollySpeed=1,this.dollyDragInverted=!1,this.truckSpeed=2,this.dollyToCursor=!1,this.dragToOffset=!1,this.verticalDragToForward=!1,this.boundaryFriction=0,this.restThreshold=.01,this.colliderMeshes=[],this.cancel=()=>{},this._enabled=!0,this._state=A.NONE,this._viewport=null,this._changedDolly=0,this._changedZoom=0,this._hasRested=!0,this._boundaryEnclosesCamera=!1,this._needsUpdate=!0,this._updatedLastTime=!1,this._elementRect=new DOMRect,this._isDragging=!1,this._dragNeedsUpdate=!0,this._activePointers=[],this._lockedPointer=null,this._interactiveArea=new DOMRect(0,0,1,1),this._isUserControllingRotate=!1,this._isUserControllingDolly=!1,this._isUserControllingTruck=!1,this._isUserControllingOffset=!1,this._isUserControllingZoom=!1,this._lastDollyDirection=Lt.NONE,this._thetaVelocity={value:0},this._phiVelocity={value:0},this._radiusVelocity={value:0},this._targetVelocity=new B.Vector3,this._focalOffsetVelocity=new B.Vector3,this._zoomVelocity={value:0},this._truckInternal=(h,_,x)=>{let w,C;if(gt(this._camera)){const b=F.copy(this._camera.position).sub(this._target),P=this._camera.getEffectiveFOV()*Xt,U=b.length()*Math.tan(P*.5);w=this.truckSpeed*h*U/this._elementRect.height,C=this.truckSpeed*_*U/this._elementRect.height}else if(pt(this._camera)){const b=this._camera;w=h*(b.right-b.left)/b.zoom/this._elementRect.width,C=_*(b.top-b.bottom)/b.zoom/this._elementRect.height}else return;this.verticalDragToForward?(x?this.setFocalOffset(this._focalOffsetEnd.x+w,this._focalOffsetEnd.y,this._focalOffsetEnd.z,!0):this.truck(w,0,!0),this.forward(-C,!0)):x?this.setFocalOffset(this._focalOffsetEnd.x+w,this._focalOffsetEnd.y+C,this._focalOffsetEnd.z,!0):this.truck(w,C,!0)},this._rotateInternal=(h,_)=>{const x=Dt*this.azimuthRotateSpeed*h/this._elementRect.height,w=Dt*this.polarRotateSpeed*_/this._elementRect.height;this.rotate(x,w,!0)},this._dollyInternal=(h,_,x)=>{const w=Math.pow(.95,-h*this.dollySpeed),C=this._sphericalEnd.radius,b=this._sphericalEnd.radius*w,P=nt(b,this.minDistance,this.maxDistance),U=P-b;this.infinityDolly&&this.dollyToCursor?this._dollyToNoClamp(b,!0):this.infinityDolly&&!this.dollyToCursor?(this.dollyInFixed(U,!0),this._dollyToNoClamp(P,!0)):this._dollyToNoClamp(P,!0),this.dollyToCursor&&(this._changedDolly+=(this.infinityDolly?b:P)-C,this._dollyControlCoord.set(_,x)),this._lastDollyDirection=Math.sign(-h)},this._zoomInternal=(h,_,x)=>{const w=Math.pow(.95,h*this.dollySpeed),C=this._zoom,b=this._zoom*w;this.zoomTo(b,!0),this.dollyToCursor&&(this._changedZoom+=b-C,this._dollyControlCoord.set(_,x))},typeof B>"u"&&console.error("camera-controls: `THREE` is undefined. You must first run `CameraControls.install( { THREE: THREE } )`. Check the docs for further information."),this._camera=e,this._yAxisUpSpace=new B.Quaternion().setFromUnitVectors(this._camera.up,ye),this._yAxisUpSpaceInverse=this._yAxisUpSpace.clone().invert(),this._state=A.NONE,this._target=new B.Vector3,this._targetEnd=this._target.clone(),this._focalOffset=new B.Vector3,this._focalOffsetEnd=this._focalOffset.clone(),this._spherical=new B.Spherical().setFromVector3(F.copy(this._camera.position).applyQuaternion(this._yAxisUpSpace)),this._sphericalEnd=this._spherical.clone(),this._lastDistance=this._spherical.radius,this._zoom=this._camera.zoom,this._zoomEnd=this._zoom,this._lastZoom=this._zoom,this._nearPlaneCorners=[new B.Vector3,new B.Vector3,new B.Vector3,new B.Vector3],this._updateNearPlaneCorners(),this._boundary=new B.Box3(new B.Vector3(-1/0,-1/0,-1/0),new B.Vector3(1/0,1/0,1/0)),this._cameraUp0=this._camera.up.clone(),this._target0=this._target.clone(),this._position0=this._camera.position.clone(),this._zoom0=this._zoom,this._focalOffset0=this._focalOffset.clone(),this._dollyControlCoord=new B.Vector2,this.mouseButtons={left:A.ROTATE,middle:A.DOLLY,right:A.TRUCK,wheel:gt(this._camera)?A.DOLLY:pt(this._camera)?A.ZOOM:A.NONE},this.touches={one:A.TOUCH_ROTATE,two:gt(this._camera)?A.TOUCH_DOLLY_TRUCK:pt(this._camera)?A.TOUCH_ZOOM_TRUCK:A.NONE,three:A.TOUCH_TRUCK};const s=new B.Vector2,i=new B.Vector2,r=new B.Vector2,o=h=>{if(!this._enabled||!this._domElement)return;if(this._interactiveArea.left!==0||this._interactiveArea.top!==0||this._interactiveArea.width!==1||this._interactiveArea.height!==1){const w=this._domElement.getBoundingClientRect(),C=h.clientX/w.width,b=h.clientY/w.height;if(C<this._interactiveArea.left||C>this._interactiveArea.right||b<this._interactiveArea.top||b>this._interactiveArea.bottom)return}const _=h.pointerType!=="mouse"?null:(h.buttons&z.LEFT)===z.LEFT?z.LEFT:(h.buttons&z.MIDDLE)===z.MIDDLE?z.MIDDLE:(h.buttons&z.RIGHT)===z.RIGHT?z.RIGHT:null;if(_!==null){const w=this._findPointerByMouseButton(_);w&&this._disposePointer(w)}if((h.buttons&z.LEFT)===z.LEFT&&this._lockedPointer)return;const x={pointerId:h.pointerId,clientX:h.clientX,clientY:h.clientY,deltaX:0,deltaY:0,mouseButton:_};this._activePointers.push(x),this._domElement.ownerDocument.removeEventListener("pointermove",c,{passive:!1}),this._domElement.ownerDocument.removeEventListener("pointerup",f),this._domElement.ownerDocument.addEventListener("pointermove",c,{passive:!1}),this._domElement.ownerDocument.addEventListener("pointerup",f),this._isDragging=!0,O(h)},a=h=>{if(!this._enabled||!this._domElement||this._lockedPointer)return;if(this._interactiveArea.left!==0||this._interactiveArea.top!==0||this._interactiveArea.width!==1||this._interactiveArea.height!==1){const w=this._domElement.getBoundingClientRect(),C=h.clientX/w.width,b=h.clientY/w.height;if(C<this._interactiveArea.left||C>this._interactiveArea.right||b<this._interactiveArea.top||b>this._interactiveArea.bottom)return}const _=(h.buttons&z.LEFT)===z.LEFT?z.LEFT:(h.buttons&z.MIDDLE)===z.MIDDLE?z.MIDDLE:(h.buttons&z.RIGHT)===z.RIGHT?z.RIGHT:null;if(_!==null){const w=this._findPointerByMouseButton(_);w&&this._disposePointer(w)}const x={pointerId:1,clientX:h.clientX,clientY:h.clientY,deltaX:0,deltaY:0,mouseButton:(h.buttons&z.LEFT)===z.LEFT?z.LEFT:(h.buttons&z.MIDDLE)===z.LEFT?z.MIDDLE:(h.buttons&z.RIGHT)===z.LEFT?z.RIGHT:null};this._activePointers.push(x),this._domElement.ownerDocument.removeEventListener("mousemove",d),this._domElement.ownerDocument.removeEventListener("mouseup",u),this._domElement.ownerDocument.addEventListener("mousemove",d),this._domElement.ownerDocument.addEventListener("mouseup",u),this._isDragging=!0,O(h)},c=h=>{h.cancelable&&h.preventDefault();const _=h.pointerId,x=this._lockedPointer||this._findPointerById(_);if(x){if(x.clientX=h.clientX,x.clientY=h.clientY,x.deltaX=h.movementX,x.deltaY=h.movementY,this._state=0,h.pointerType==="touch")switch(this._activePointers.length){case 1:this._state=this.touches.one;break;case 2:this._state=this.touches.two;break;case 3:this._state=this.touches.three;break}else(!this._isDragging&&this._lockedPointer||this._isDragging&&(h.buttons&z.LEFT)===z.LEFT)&&(this._state=this._state|this.mouseButtons.left),this._isDragging&&(h.buttons&z.MIDDLE)===z.MIDDLE&&(this._state=this._state|this.mouseButtons.middle),this._isDragging&&(h.buttons&z.RIGHT)===z.RIGHT&&(this._state=this._state|this.mouseButtons.right);T()}},d=h=>{const _=this._lockedPointer||this._findPointerById(1);_&&(_.clientX=h.clientX,_.clientY=h.clientY,_.deltaX=h.movementX,_.deltaY=h.movementY,this._state=0,(this._lockedPointer||(h.buttons&z.LEFT)===z.LEFT)&&(this._state=this._state|this.mouseButtons.left),(h.buttons&z.MIDDLE)===z.MIDDLE&&(this._state=this._state|this.mouseButtons.middle),(h.buttons&z.RIGHT)===z.RIGHT&&(this._state=this._state|this.mouseButtons.right),T())},f=h=>{const _=this._findPointerById(h.pointerId);if(!(_&&_===this._lockedPointer)){if(_&&this._disposePointer(_),h.pointerType==="touch")switch(this._activePointers.length){case 0:this._state=A.NONE;break;case 1:this._state=this.touches.one;break;case 2:this._state=this.touches.two;break;case 3:this._state=this.touches.three;break}else this._state=A.NONE;m()}},u=()=>{const h=this._findPointerById(1);h&&h===this._lockedPointer||(h&&this._disposePointer(h),this._state=A.NONE,m())};let l=-1;const p=h=>{if(!this._domElement||!this._enabled||this.mouseButtons.wheel===A.NONE)return;if(this._interactiveArea.left!==0||this._interactiveArea.top!==0||this._interactiveArea.width!==1||this._interactiveArea.height!==1){const b=this._domElement.getBoundingClientRect(),P=h.clientX/b.width,U=h.clientY/b.height;if(P<this._interactiveArea.left||P>this._interactiveArea.right||U<this._interactiveArea.top||U>this._interactiveArea.bottom)return}if(h.preventDefault(),this.dollyToCursor||this.mouseButtons.wheel===A.ROTATE||this.mouseButtons.wheel===A.TRUCK){const b=performance.now();l-b<1e3&&this._getClientRect(this._elementRect),l=b}const _=xn?-1:-3,x=h.deltaMode===1?h.deltaY/_:h.deltaY/(_*10),w=this.dollyToCursor?(h.clientX-this._elementRect.x)/this._elementRect.width*2-1:0,C=this.dollyToCursor?(h.clientY-this._elementRect.y)/this._elementRect.height*-2+1:0;switch(this.mouseButtons.wheel){case A.ROTATE:{this._rotateInternal(h.deltaX,h.deltaY),this._isUserControllingRotate=!0;break}case A.TRUCK:{this._truckInternal(h.deltaX,h.deltaY,!1),this._isUserControllingTruck=!0;break}case A.OFFSET:{this._truckInternal(h.deltaX,h.deltaY,!0),this._isUserControllingOffset=!0;break}case A.DOLLY:{this._dollyInternal(-x,w,C),this._isUserControllingDolly=!0;break}case A.ZOOM:{this._zoomInternal(-x,w,C),this._isUserControllingZoom=!0;break}}this.dispatchEvent({type:"control"})},y=h=>{if(!(!this._domElement||!this._enabled)){if(this.mouseButtons.right===Jt.ACTION.NONE){const _=h instanceof PointerEvent?h.pointerId:(h instanceof MouseEvent,0),x=this._findPointerById(_);x&&this._disposePointer(x),this._domElement.ownerDocument.removeEventListener("pointermove",c,{passive:!1}),this._domElement.ownerDocument.removeEventListener("pointerup",f),this._domElement.ownerDocument.removeEventListener("mousemove",d),this._domElement.ownerDocument.removeEventListener("mouseup",u);return}h.preventDefault()}},O=h=>{if(!this._enabled)return;if(He(this._activePointers,$),this._getClientRect(this._elementRect),s.copy($),i.copy($),this._activePointers.length>=2){const x=$.x-this._activePointers[1].clientX,w=$.y-this._activePointers[1].clientY,C=Math.sqrt(x*x+w*w);r.set(0,C);const b=(this._activePointers[0].clientX+this._activePointers[1].clientX)*.5,P=(this._activePointers[0].clientY+this._activePointers[1].clientY)*.5;i.set(b,P)}if(this._state=0,!h)this._lockedPointer&&(this._state=this._state|this.mouseButtons.left);else if("pointerType"in h&&h.pointerType==="touch")switch(this._activePointers.length){case 1:this._state=this.touches.one;break;case 2:this._state=this.touches.two;break;case 3:this._state=this.touches.three;break}else!this._lockedPointer&&(h.buttons&z.LEFT)===z.LEFT&&(this._state=this._state|this.mouseButtons.left),(h.buttons&z.MIDDLE)===z.MIDDLE&&(this._state=this._state|this.mouseButtons.middle),(h.buttons&z.RIGHT)===z.RIGHT&&(this._state=this._state|this.mouseButtons.right);((this._state&A.ROTATE)===A.ROTATE||(this._state&A.TOUCH_ROTATE)===A.TOUCH_ROTATE||(this._state&A.TOUCH_DOLLY_ROTATE)===A.TOUCH_DOLLY_ROTATE||(this._state&A.TOUCH_ZOOM_ROTATE)===A.TOUCH_ZOOM_ROTATE)&&(this._sphericalEnd.theta=this._spherical.theta,this._sphericalEnd.phi=this._spherical.phi,this._thetaVelocity.value=0,this._phiVelocity.value=0),((this._state&A.TRUCK)===A.TRUCK||(this._state&A.TOUCH_TRUCK)===A.TOUCH_TRUCK||(this._state&A.TOUCH_DOLLY_TRUCK)===A.TOUCH_DOLLY_TRUCK||(this._state&A.TOUCH_ZOOM_TRUCK)===A.TOUCH_ZOOM_TRUCK)&&(this._targetEnd.copy(this._target),this._targetVelocity.set(0,0,0)),((this._state&A.DOLLY)===A.DOLLY||(this._state&A.TOUCH_DOLLY)===A.TOUCH_DOLLY||(this._state&A.TOUCH_DOLLY_TRUCK)===A.TOUCH_DOLLY_TRUCK||(this._state&A.TOUCH_DOLLY_OFFSET)===A.TOUCH_DOLLY_OFFSET||(this._state&A.TOUCH_DOLLY_ROTATE)===A.TOUCH_DOLLY_ROTATE)&&(this._sphericalEnd.radius=this._spherical.radius,this._radiusVelocity.value=0),((this._state&A.ZOOM)===A.ZOOM||(this._state&A.TOUCH_ZOOM)===A.TOUCH_ZOOM||(this._state&A.TOUCH_ZOOM_TRUCK)===A.TOUCH_ZOOM_TRUCK||(this._state&A.TOUCH_ZOOM_OFFSET)===A.TOUCH_ZOOM_OFFSET||(this._state&A.TOUCH_ZOOM_ROTATE)===A.TOUCH_ZOOM_ROTATE)&&(this._zoomEnd=this._zoom,this._zoomVelocity.value=0),((this._state&A.OFFSET)===A.OFFSET||(this._state&A.TOUCH_OFFSET)===A.TOUCH_OFFSET||(this._state&A.TOUCH_DOLLY_OFFSET)===A.TOUCH_DOLLY_OFFSET||(this._state&A.TOUCH_ZOOM_OFFSET)===A.TOUCH_ZOOM_OFFSET)&&(this._focalOffsetEnd.copy(this._focalOffset),this._focalOffsetVelocity.set(0,0,0)),this.dispatchEvent({type:"controlstart"})},T=()=>{if(!this._enabled||!this._dragNeedsUpdate)return;this._dragNeedsUpdate=!1,He(this._activePointers,$);const _=this._domElement&&document.pointerLockElement===this._domElement?this._lockedPointer||this._activePointers[0]:null,x=_?-_.deltaX:i.x-$.x,w=_?-_.deltaY:i.y-$.y;if(i.copy($),((this._state&A.ROTATE)===A.ROTATE||(this._state&A.TOUCH_ROTATE)===A.TOUCH_ROTATE||(this._state&A.TOUCH_DOLLY_ROTATE)===A.TOUCH_DOLLY_ROTATE||(this._state&A.TOUCH_ZOOM_ROTATE)===A.TOUCH_ZOOM_ROTATE)&&(this._rotateInternal(x,w),this._isUserControllingRotate=!0),(this._state&A.DOLLY)===A.DOLLY||(this._state&A.ZOOM)===A.ZOOM){const C=this.dollyToCursor?(s.x-this._elementRect.x)/this._elementRect.width*2-1:0,b=this.dollyToCursor?(s.y-this._elementRect.y)/this._elementRect.height*-2+1:0,P=this.dollyDragInverted?-1:1;(this._state&A.DOLLY)===A.DOLLY?(this._dollyInternal(P*w*me,C,b),this._isUserControllingDolly=!0):(this._zoomInternal(P*w*me,C,b),this._isUserControllingZoom=!0)}if((this._state&A.TOUCH_DOLLY)===A.TOUCH_DOLLY||(this._state&A.TOUCH_ZOOM)===A.TOUCH_ZOOM||(this._state&A.TOUCH_DOLLY_TRUCK)===A.TOUCH_DOLLY_TRUCK||(this._state&A.TOUCH_ZOOM_TRUCK)===A.TOUCH_ZOOM_TRUCK||(this._state&A.TOUCH_DOLLY_OFFSET)===A.TOUCH_DOLLY_OFFSET||(this._state&A.TOUCH_ZOOM_OFFSET)===A.TOUCH_ZOOM_OFFSET||(this._state&A.TOUCH_DOLLY_ROTATE)===A.TOUCH_DOLLY_ROTATE||(this._state&A.TOUCH_ZOOM_ROTATE)===A.TOUCH_ZOOM_ROTATE){const C=$.x-this._activePointers[1].clientX,b=$.y-this._activePointers[1].clientY,P=Math.sqrt(C*C+b*b),U=r.y-P;r.set(0,P);const v=this.dollyToCursor?(i.x-this._elementRect.x)/this._elementRect.width*2-1:0,D=this.dollyToCursor?(i.y-this._elementRect.y)/this._elementRect.height*-2+1:0;(this._state&A.TOUCH_DOLLY)===A.TOUCH_DOLLY||(this._state&A.TOUCH_DOLLY_ROTATE)===A.TOUCH_DOLLY_ROTATE||(this._state&A.TOUCH_DOLLY_TRUCK)===A.TOUCH_DOLLY_TRUCK||(this._state&A.TOUCH_DOLLY_OFFSET)===A.TOUCH_DOLLY_OFFSET?(this._dollyInternal(U*me,v,D),this._isUserControllingDolly=!0):(this._zoomInternal(U*me,v,D),this._isUserControllingZoom=!0)}((this._state&A.TRUCK)===A.TRUCK||(this._state&A.TOUCH_TRUCK)===A.TOUCH_TRUCK||(this._state&A.TOUCH_DOLLY_TRUCK)===A.TOUCH_DOLLY_TRUCK||(this._state&A.TOUCH_ZOOM_TRUCK)===A.TOUCH_ZOOM_TRUCK)&&(this._truckInternal(x,w,!1),this._isUserControllingTruck=!0),((this._state&A.OFFSET)===A.OFFSET||(this._state&A.TOUCH_OFFSET)===A.TOUCH_OFFSET||(this._state&A.TOUCH_DOLLY_OFFSET)===A.TOUCH_DOLLY_OFFSET||(this._state&A.TOUCH_ZOOM_OFFSET)===A.TOUCH_ZOOM_OFFSET)&&(this._truckInternal(x,w,!0),this._isUserControllingOffset=!0),this.dispatchEvent({type:"control"})},m=()=>{He(this._activePointers,$),i.copy($),this._dragNeedsUpdate=!1,(this._activePointers.length===0||this._activePointers.length===1&&this._activePointers[0]===this._lockedPointer)&&(this._isDragging=!1),this._activePointers.length===0&&this._domElement&&(this._domElement.ownerDocument.removeEventListener("pointermove",c,{passive:!1}),this._domElement.ownerDocument.removeEventListener("mousemove",d),this._domElement.ownerDocument.removeEventListener("pointerup",f),this._domElement.ownerDocument.removeEventListener("mouseup",u),this.dispatchEvent({type:"controlend"}))};this.lockPointer=()=>{!this._enabled||!this._domElement||(this.cancel(),this._lockedPointer={pointerId:-1,clientX:0,clientY:0,deltaX:0,deltaY:0,mouseButton:null},this._activePointers.push(this._lockedPointer),this._domElement.ownerDocument.removeEventListener("pointermove",c,{passive:!1}),this._domElement.ownerDocument.removeEventListener("pointerup",f),this._domElement.requestPointerLock(),this._domElement.ownerDocument.addEventListener("pointerlockchange",g),this._domElement.ownerDocument.addEventListener("pointerlockerror",E),this._domElement.ownerDocument.addEventListener("pointermove",c,{passive:!1}),this._domElement.ownerDocument.addEventListener("pointerup",f),O())},this.unlockPointer=()=>{this._lockedPointer!==null&&(this._disposePointer(this._lockedPointer),this._lockedPointer=null),document.exitPointerLock(),this.cancel(),this._domElement&&(this._domElement.ownerDocument.removeEventListener("pointerlockchange",g),this._domElement.ownerDocument.removeEventListener("pointerlockerror",E))};const g=()=>{this._domElement&&this._domElement.ownerDocument.pointerLockElement===this._domElement||this.unlockPointer()},E=()=>{this.unlockPointer()};this._addAllEventListeners=h=>{this._domElement=h,this._domElement.style.touchAction="none",this._domElement.style.userSelect="none",this._domElement.style.webkitUserSelect="none",this._domElement.addEventListener("pointerdown",o),wn&&this._domElement.addEventListener("mousedown",a),this._domElement.addEventListener("pointercancel",f),this._domElement.addEventListener("wheel",p,{passive:!1}),this._domElement.addEventListener("contextmenu",y)},this._removeAllEventListeners=()=>{this._domElement&&(this._domElement.style.touchAction="",this._domElement.style.userSelect="",this._domElement.style.webkitUserSelect="",this._domElement.removeEventListener("pointerdown",o),this._domElement.removeEventListener("mousedown",a),this._domElement.removeEventListener("pointercancel",f),this._domElement.removeEventListener("wheel",p,{passive:!1}),this._domElement.removeEventListener("contextmenu",y),this._domElement.ownerDocument.removeEventListener("pointermove",c,{passive:!1}),this._domElement.ownerDocument.removeEventListener("mousemove",d),this._domElement.ownerDocument.removeEventListener("pointerup",f),this._domElement.ownerDocument.removeEventListener("mouseup",u),this._domElement.ownerDocument.removeEventListener("pointerlockchange",g),this._domElement.ownerDocument.removeEventListener("pointerlockerror",E))},this.cancel=()=>{this._state!==A.NONE&&(this._state=A.NONE,this._activePointers.length=0,m())},t&&this.connect(t),this.update(0)}get camera(){return this._camera}set camera(e){this._camera=e,this.updateCameraUp(),this._camera.updateProjectionMatrix(),this._updateNearPlaneCorners(),this._needsUpdate=!0}get enabled(){return this._enabled}set enabled(e){this._enabled=e,this._domElement&&(e?(this._domElement.style.touchAction="none",this._domElement.style.userSelect="none",this._domElement.style.webkitUserSelect="none"):(this.cancel(),this._domElement.style.touchAction="",this._domElement.style.userSelect="",this._domElement.style.webkitUserSelect=""))}get active(){return!this._hasRested}get currentAction(){return this._state}get distance(){return this._spherical.radius}set distance(e){this._spherical.radius===e&&this._sphericalEnd.radius===e||(this._spherical.radius=e,this._sphericalEnd.radius=e,this._needsUpdate=!0)}get azimuthAngle(){return this._spherical.theta}set azimuthAngle(e){this._spherical.theta===e&&this._sphericalEnd.theta===e||(this._spherical.theta=e,this._sphericalEnd.theta=e,this._needsUpdate=!0)}get polarAngle(){return this._spherical.phi}set polarAngle(e){this._spherical.phi===e&&this._sphericalEnd.phi===e||(this._spherical.phi=e,this._sphericalEnd.phi=e,this._needsUpdate=!0)}get boundaryEnclosesCamera(){return this._boundaryEnclosesCamera}set boundaryEnclosesCamera(e){this._boundaryEnclosesCamera=e,this._needsUpdate=!0}set interactiveArea(e){this._interactiveArea.width=nt(e.width,0,1),this._interactiveArea.height=nt(e.height,0,1),this._interactiveArea.x=nt(e.x,0,1-this._interactiveArea.width),this._interactiveArea.y=nt(e.y,0,1-this._interactiveArea.height)}addEventListener(e,t){super.addEventListener(e,t)}removeEventListener(e,t){super.removeEventListener(e,t)}rotate(e,t,s=!1){return this.rotateTo(this._sphericalEnd.theta+e,this._sphericalEnd.phi+t,s)}rotateAzimuthTo(e,t=!1){return this.rotateTo(e,this._sphericalEnd.phi,t)}rotatePolarTo(e,t=!1){return this.rotateTo(this._sphericalEnd.theta,e,t)}rotateTo(e,t,s=!1){this._isUserControllingRotate=!1;const i=nt(e,this.minAzimuthAngle,this.maxAzimuthAngle),r=nt(t,this.minPolarAngle,this.maxPolarAngle);this._sphericalEnd.theta=i,this._sphericalEnd.phi=r,this._sphericalEnd.makeSafe(),this._needsUpdate=!0,s||(this._spherical.theta=this._sphericalEnd.theta,this._spherical.phi=this._sphericalEnd.phi);const o=!s||H(this._spherical.theta,this._sphericalEnd.theta,this.restThreshold)&&H(this._spherical.phi,this._sphericalEnd.phi,this.restThreshold);return this._createOnRestPromise(o)}dolly(e,t=!1){return this.dollyTo(this._sphericalEnd.radius-e,t)}dollyTo(e,t=!1){return this._isUserControllingDolly=!1,this._lastDollyDirection=Lt.NONE,this._changedDolly=0,this._dollyToNoClamp(nt(e,this.minDistance,this.maxDistance),t)}_dollyToNoClamp(e,t=!1){const s=this._sphericalEnd.radius;if(this.colliderMeshes.length>=1){const o=this._collisionTest(),a=H(o,this._spherical.radius);if(!(s>e)&&a)return Promise.resolve();this._sphericalEnd.radius=Math.min(e,o)}else this._sphericalEnd.radius=e;this._needsUpdate=!0,t||(this._spherical.radius=this._sphericalEnd.radius);const r=!t||H(this._spherical.radius,this._sphericalEnd.radius,this.restThreshold);return this._createOnRestPromise(r)}dollyInFixed(e,t=!1){this._targetEnd.add(this._getCameraDirection($t).multiplyScalar(e)),t||this._target.copy(this._targetEnd);const s=!t||H(this._target.x,this._targetEnd.x,this.restThreshold)&&H(this._target.y,this._targetEnd.y,this.restThreshold)&&H(this._target.z,this._targetEnd.z,this.restThreshold);return this._createOnRestPromise(s)}zoom(e,t=!1){return this.zoomTo(this._zoomEnd+e,t)}zoomTo(e,t=!1){this._isUserControllingZoom=!1,this._zoomEnd=nt(e,this.minZoom,this.maxZoom),this._needsUpdate=!0,t||(this._zoom=this._zoomEnd);const s=!t||H(this._zoom,this._zoomEnd,this.restThreshold);return this._changedZoom=0,this._createOnRestPromise(s)}pan(e,t,s=!1){return console.warn("`pan` has been renamed to `truck`"),this.truck(e,t,s)}truck(e,t,s=!1){this._camera.updateMatrix(),rt.setFromMatrixColumn(this._camera.matrix,0),at.setFromMatrixColumn(this._camera.matrix,1),rt.multiplyScalar(e),at.multiplyScalar(-t);const i=F.copy(rt).add(at),r=I.copy(this._targetEnd).add(i);return this.moveTo(r.x,r.y,r.z,s)}forward(e,t=!1){F.setFromMatrixColumn(this._camera.matrix,0),F.crossVectors(this._camera.up,F),F.multiplyScalar(e);const s=I.copy(this._targetEnd).add(F);return this.moveTo(s.x,s.y,s.z,t)}elevate(e,t=!1){return F.copy(this._camera.up).multiplyScalar(e),this.moveTo(this._targetEnd.x+F.x,this._targetEnd.y+F.y,this._targetEnd.z+F.z,t)}moveTo(e,t,s,i=!1){this._isUserControllingTruck=!1;const r=F.set(e,t,s).sub(this._targetEnd);this._encloseToBoundary(this._targetEnd,r,this.boundaryFriction),this._needsUpdate=!0,i||this._target.copy(this._targetEnd);const o=!i||H(this._target.x,this._targetEnd.x,this.restThreshold)&&H(this._target.y,this._targetEnd.y,this.restThreshold)&&H(this._target.z,this._targetEnd.z,this.restThreshold);return this._createOnRestPromise(o)}lookInDirectionOf(e,t,s,i=!1){const a=F.set(e,t,s).sub(this._targetEnd).normalize().multiplyScalar(-this._sphericalEnd.radius);return this.setPosition(a.x,a.y,a.z,i)}fitToBox(e,t,{cover:s=!1,paddingLeft:i=0,paddingRight:r=0,paddingBottom:o=0,paddingTop:a=0}={}){const c=[],d=e.isBox3?Mt.copy(e):Mt.setFromObject(e);d.isEmpty()&&(console.warn("camera-controls: fitTo() cannot be used with an empty box. Aborting"),Promise.resolve());const f=bs(this._sphericalEnd.theta,Cs),u=bs(this._sphericalEnd.phi,Cs);c.push(this.rotateTo(f,u,t));const l=F.setFromSpherical(this._sphericalEnd).normalize(),p=Ss.setFromUnitVectors(l,Ve),y=H(Math.abs(l.y),1);y&&p.multiply(Ne.setFromAxisAngle(ye,f)),p.multiply(this._yAxisUpSpaceInverse);const O=Ds.makeEmpty();I.copy(d.min).applyQuaternion(p),O.expandByPoint(I),I.copy(d.min).setX(d.max.x).applyQuaternion(p),O.expandByPoint(I),I.copy(d.min).setY(d.max.y).applyQuaternion(p),O.expandByPoint(I),I.copy(d.max).setZ(d.min.z).applyQuaternion(p),O.expandByPoint(I),I.copy(d.min).setZ(d.max.z).applyQuaternion(p),O.expandByPoint(I),I.copy(d.max).setY(d.min.y).applyQuaternion(p),O.expandByPoint(I),I.copy(d.max).setX(d.min.x).applyQuaternion(p),O.expandByPoint(I),I.copy(d.max).applyQuaternion(p),O.expandByPoint(I),O.min.x-=i,O.min.y-=o,O.max.x+=r,O.max.y+=a,p.setFromUnitVectors(Ve,l),y&&p.premultiply(Ne.invert()),p.premultiply(this._yAxisUpSpace);const T=O.getSize(F),m=O.getCenter(I).applyQuaternion(p);if(gt(this._camera)){const g=this.getDistanceToFitBox(T.x,T.y,T.z,s);c.push(this.moveTo(m.x,m.y,m.z,t)),c.push(this.dollyTo(g,t)),c.push(this.setFocalOffset(0,0,0,t))}else if(pt(this._camera)){const g=this._camera,E=g.right-g.left,h=g.top-g.bottom,_=s?Math.max(E/T.x,h/T.y):Math.min(E/T.x,h/T.y);c.push(this.moveTo(m.x,m.y,m.z,t)),c.push(this.zoomTo(_,t)),c.push(this.setFocalOffset(0,0,0,t))}return Promise.all(c)}fitToSphere(e,t){const s=[],r=e instanceof B.Sphere?Ye.copy(e):Jt.createBoundingSphere(e,Ye);if(s.push(this.moveTo(r.center.x,r.center.y,r.center.z,t)),gt(this._camera)){const o=this.getDistanceToFitSphere(r.radius);s.push(this.dollyTo(o,t))}else if(pt(this._camera)){const o=this._camera.right-this._camera.left,a=this._camera.top-this._camera.bottom,c=2*r.radius,d=Math.min(o/c,a/c);s.push(this.zoomTo(d,t))}return s.push(this.setFocalOffset(0,0,0,t)),Promise.all(s)}setLookAt(e,t,s,i,r,o,a=!1){this._isUserControllingRotate=!1,this._isUserControllingDolly=!1,this._isUserControllingTruck=!1,this._lastDollyDirection=Lt.NONE,this._changedDolly=0;const c=I.set(i,r,o),d=F.set(e,t,s);this._targetEnd.copy(c),this._sphericalEnd.setFromVector3(d.sub(c).applyQuaternion(this._yAxisUpSpace)),this.normalizeRotations(),this._needsUpdate=!0,a||(this._target.copy(this._targetEnd),this._spherical.copy(this._sphericalEnd));const f=!a||H(this._target.x,this._targetEnd.x,this.restThreshold)&&H(this._target.y,this._targetEnd.y,this.restThreshold)&&H(this._target.z,this._targetEnd.z,this.restThreshold)&&H(this._spherical.theta,this._sphericalEnd.theta,this.restThreshold)&&H(this._spherical.phi,this._sphericalEnd.phi,this.restThreshold)&&H(this._spherical.radius,this._sphericalEnd.radius,this.restThreshold);return this._createOnRestPromise(f)}lerpLookAt(e,t,s,i,r,o,a,c,d,f,u,l,p,y=!1){this._isUserControllingRotate=!1,this._isUserControllingDolly=!1,this._isUserControllingTruck=!1,this._lastDollyDirection=Lt.NONE,this._changedDolly=0;const O=F.set(i,r,o),T=I.set(e,t,s);G.setFromVector3(T.sub(O).applyQuaternion(this._yAxisUpSpace));const m=St.set(f,u,l),g=I.set(a,c,d);Kt.setFromVector3(g.sub(m).applyQuaternion(this._yAxisUpSpace)),this._targetEnd.copy(O.lerp(m,p));const E=Kt.theta-G.theta,h=Kt.phi-G.phi,_=Kt.radius-G.radius;this._sphericalEnd.set(G.radius+_*p,G.phi+h*p,G.theta+E*p),this.normalizeRotations(),this._needsUpdate=!0,y||(this._target.copy(this._targetEnd),this._spherical.copy(this._sphericalEnd));const x=!y||H(this._target.x,this._targetEnd.x,this.restThreshold)&&H(this._target.y,this._targetEnd.y,this.restThreshold)&&H(this._target.z,this._targetEnd.z,this.restThreshold)&&H(this._spherical.theta,this._sphericalEnd.theta,this.restThreshold)&&H(this._spherical.phi,this._sphericalEnd.phi,this.restThreshold)&&H(this._spherical.radius,this._sphericalEnd.radius,this.restThreshold);return this._createOnRestPromise(x)}setPosition(e,t,s,i=!1){return this.setLookAt(e,t,s,this._targetEnd.x,this._targetEnd.y,this._targetEnd.z,i)}setTarget(e,t,s,i=!1){const r=this.getPosition(F),o=this.setLookAt(r.x,r.y,r.z,e,t,s,i);return this._sphericalEnd.phi=nt(this._sphericalEnd.phi,this.minPolarAngle,this.maxPolarAngle),o}setFocalOffset(e,t,s,i=!1){this._isUserControllingOffset=!1,this._focalOffsetEnd.set(e,t,s),this._needsUpdate=!0,i||this._focalOffset.copy(this._focalOffsetEnd);const r=!i||H(this._focalOffset.x,this._focalOffsetEnd.x,this.restThreshold)&&H(this._focalOffset.y,this._focalOffsetEnd.y,this.restThreshold)&&H(this._focalOffset.z,this._focalOffsetEnd.z,this.restThreshold);return this._createOnRestPromise(r)}setOrbitPoint(e,t,s){this._camera.updateMatrixWorld(),rt.setFromMatrixColumn(this._camera.matrixWorldInverse,0),at.setFromMatrixColumn(this._camera.matrixWorldInverse,1),Tt.setFromMatrixColumn(this._camera.matrixWorldInverse,2);const i=F.set(e,t,s),r=i.distanceTo(this._camera.position),o=i.sub(this._camera.position);rt.multiplyScalar(o.x),at.multiplyScalar(o.y),Tt.multiplyScalar(o.z),F.copy(rt).add(at).add(Tt),F.z=F.z+r,this.dollyTo(r,!1),this.setFocalOffset(-F.x,F.y,-F.z,!1),this.moveTo(e,t,s,!1)}setBoundary(e){if(!e){this._boundary.min.set(-1/0,-1/0,-1/0),this._boundary.max.set(1/0,1/0,1/0),this._needsUpdate=!0;return}this._boundary.copy(e),this._boundary.clampPoint(this._targetEnd,this._targetEnd),this._needsUpdate=!0}setViewport(e,t,s,i){if(e===null){this._viewport=null;return}this._viewport=this._viewport||new B.Vector4,typeof e=="number"?this._viewport.set(e,t,s,i):this._viewport.copy(e)}getDistanceToFitBox(e,t,s,i=!1){if(ke(this._camera,"getDistanceToFitBox"))return this._spherical.radius;const r=e/t,o=this._camera.getEffectiveFOV()*Xt,a=this._camera.aspect;return((i?r>a:r<a)?t:e/a)*.5/Math.tan(o*.5)+s*.5}getDistanceToFitSphere(e){if(ke(this._camera,"getDistanceToFitSphere"))return this._spherical.radius;const t=this._camera.getEffectiveFOV()*Xt,s=Math.atan(Math.tan(t*.5)*this._camera.aspect)*2,i=1<this._camera.aspect?t:s;return e/Math.sin(i*.5)}getTarget(e,t=!0){return(e&&e.isVector3?e:new B.Vector3).copy(t?this._targetEnd:this._target)}getPosition(e,t=!0){return(e&&e.isVector3?e:new B.Vector3).setFromSpherical(t?this._sphericalEnd:this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(t?this._targetEnd:this._target)}getSpherical(e,t=!0){return(e&&e instanceof B.Spherical?e:new B.Spherical).copy(t?this._sphericalEnd:this._spherical)}getFocalOffset(e,t=!0){return(e&&e.isVector3?e:new B.Vector3).copy(t?this._focalOffsetEnd:this._focalOffset)}normalizeRotations(){this._sphericalEnd.theta=this._sphericalEnd.theta%Dt,this._sphericalEnd.theta<0&&(this._sphericalEnd.theta+=Dt),this._spherical.theta+=Dt*Math.round((this._sphericalEnd.theta-this._spherical.theta)/Dt)}reset(e=!1){if(!H(this._camera.up.x,this._cameraUp0.x)||!H(this._camera.up.y,this._cameraUp0.y)||!H(this._camera.up.z,this._cameraUp0.z)){this._camera.up.copy(this._cameraUp0);const s=this.getPosition(F);this.updateCameraUp(),this.setPosition(s.x,s.y,s.z)}const t=[this.setLookAt(this._position0.x,this._position0.y,this._position0.z,this._target0.x,this._target0.y,this._target0.z,e),this.setFocalOffset(this._focalOffset0.x,this._focalOffset0.y,this._focalOffset0.z,e),this.zoomTo(this._zoom0,e)];return Promise.all(t)}saveState(){this._cameraUp0.copy(this._camera.up),this.getTarget(this._target0),this.getPosition(this._position0),this._zoom0=this._zoom,this._focalOffset0.copy(this._focalOffset)}updateCameraUp(){this._yAxisUpSpace.setFromUnitVectors(this._camera.up,ye),this._yAxisUpSpaceInverse.copy(this._yAxisUpSpace).invert()}applyCameraUp(){const e=F.subVectors(this._target,this._camera.position).normalize(),t=I.crossVectors(e,this._camera.up);this._camera.up.crossVectors(t,e).normalize(),this._camera.updateMatrixWorld();const s=this.getPosition(F);this.updateCameraUp(),this.setPosition(s.x,s.y,s.z)}update(e){const t=this._sphericalEnd.theta-this._spherical.theta,s=this._sphericalEnd.phi-this._spherical.phi,i=this._sphericalEnd.radius-this._spherical.radius,r=Us.subVectors(this._targetEnd,this._target),o=Ls.subVectors(this._focalOffsetEnd,this._focalOffset),a=this._zoomEnd-this._zoom;if(k(t))this._thetaVelocity.value=0,this._spherical.theta=this._sphericalEnd.theta;else{const u=this._isUserControllingRotate?this.draggingSmoothTime:this.smoothTime;this._spherical.theta=_e(this._spherical.theta,this._sphericalEnd.theta,this._thetaVelocity,u,1/0,e),this._needsUpdate=!0}if(k(s))this._phiVelocity.value=0,this._spherical.phi=this._sphericalEnd.phi;else{const u=this._isUserControllingRotate?this.draggingSmoothTime:this.smoothTime;this._spherical.phi=_e(this._spherical.phi,this._sphericalEnd.phi,this._phiVelocity,u,1/0,e),this._needsUpdate=!0}if(k(i))this._radiusVelocity.value=0,this._spherical.radius=this._sphericalEnd.radius;else{const u=this._isUserControllingDolly?this.draggingSmoothTime:this.smoothTime;this._spherical.radius=_e(this._spherical.radius,this._sphericalEnd.radius,this._radiusVelocity,u,this.maxSpeed,e),this._needsUpdate=!0}if(k(r.x)&&k(r.y)&&k(r.z))this._targetVelocity.set(0,0,0),this._target.copy(this._targetEnd);else{const u=this._isUserControllingTruck?this.draggingSmoothTime:this.smoothTime;Ps(this._target,this._targetEnd,this._targetVelocity,u,this.maxSpeed,e,this._target),this._needsUpdate=!0}if(k(o.x)&&k(o.y)&&k(o.z))this._focalOffsetVelocity.set(0,0,0),this._focalOffset.copy(this._focalOffsetEnd);else{const u=this._isUserControllingOffset?this.draggingSmoothTime:this.smoothTime;Ps(this._focalOffset,this._focalOffsetEnd,this._focalOffsetVelocity,u,this.maxSpeed,e,this._focalOffset),this._needsUpdate=!0}if(k(a))this._zoomVelocity.value=0,this._zoom=this._zoomEnd;else{const u=this._isUserControllingZoom?this.draggingSmoothTime:this.smoothTime;this._zoom=_e(this._zoom,this._zoomEnd,this._zoomVelocity,u,1/0,e)}if(this.dollyToCursor){if(gt(this._camera)&&this._changedDolly!==0){const u=this._spherical.radius-this._lastDistance,l=this._camera,p=this._getCameraDirection($t),y=F.copy(p).cross(l.up).normalize();y.lengthSq()===0&&(y.x=1);const O=I.crossVectors(y,p),T=this._sphericalEnd.radius*Math.tan(l.getEffectiveFOV()*Xt*.5),g=(this._sphericalEnd.radius-u-this._sphericalEnd.radius)/this._sphericalEnd.radius,E=St.copy(this._targetEnd).add(y.multiplyScalar(this._dollyControlCoord.x*T*l.aspect)).add(O.multiplyScalar(this._dollyControlCoord.y*T)),h=F.copy(this._targetEnd).lerp(E,g),_=this._lastDollyDirection===Lt.IN&&this._spherical.radius<=this.minDistance,x=this._lastDollyDirection===Lt.OUT&&this.maxDistance<=this._spherical.radius;if(this.infinityDolly&&(_||x)){this._sphericalEnd.radius-=u,this._spherical.radius-=u;const C=I.copy(p).multiplyScalar(-u);h.add(C)}this._boundary.clampPoint(h,h);const w=I.subVectors(h,this._targetEnd);this._targetEnd.copy(h),this._target.add(w),this._changedDolly-=u,k(this._changedDolly)&&(this._changedDolly=0)}else if(pt(this._camera)&&this._changedZoom!==0){const u=this._zoom-this._lastZoom,l=this._camera,p=F.set(this._dollyControlCoord.x,this._dollyControlCoord.y,(l.near+l.far)/(l.near-l.far)).unproject(l),y=I.set(0,0,-1).applyQuaternion(l.quaternion),O=St.copy(p).add(y.multiplyScalar(-p.dot(l.up))),m=-(this._zoom-u-this._zoom)/this._zoom,g=this._getCameraDirection($t),E=this._targetEnd.dot(g),h=F.copy(this._targetEnd).lerp(O,m),_=h.dot(g),x=g.multiplyScalar(_-E);h.sub(x),this._boundary.clampPoint(h,h);const w=I.subVectors(h,this._targetEnd);this._targetEnd.copy(h),this._target.add(w),this._changedZoom-=u,k(this._changedZoom)&&(this._changedZoom=0)}}this._camera.zoom!==this._zoom&&(this._camera.zoom=this._zoom,this._camera.updateProjectionMatrix(),this._updateNearPlaneCorners(),this._needsUpdate=!0),this._dragNeedsUpdate=!0;const c=this._collisionTest();this._spherical.radius=Math.min(this._spherical.radius,c),this._spherical.makeSafe(),this._camera.position.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(this._target),this._camera.lookAt(this._target),(!k(this._focalOffset.x)||!k(this._focalOffset.y)||!k(this._focalOffset.z))&&(this._camera.updateMatrixWorld(),rt.setFromMatrixColumn(this._camera.matrix,0),at.setFromMatrixColumn(this._camera.matrix,1),Tt.setFromMatrixColumn(this._camera.matrix,2),rt.multiplyScalar(this._focalOffset.x),at.multiplyScalar(-this._focalOffset.y),Tt.multiplyScalar(this._focalOffset.z),F.copy(rt).add(at).add(Tt),this._camera.position.add(F)),this._boundaryEnclosesCamera&&this._encloseToBoundary(this._camera.position.copy(this._target),F.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse),1);const f=this._needsUpdate;return f&&!this._updatedLastTime?(this._hasRested=!1,this.dispatchEvent({type:"wake"}),this.dispatchEvent({type:"update"})):f?(this.dispatchEvent({type:"update"}),k(t,this.restThreshold)&&k(s,this.restThreshold)&&k(i,this.restThreshold)&&k(r.x,this.restThreshold)&&k(r.y,this.restThreshold)&&k(r.z,this.restThreshold)&&k(o.x,this.restThreshold)&&k(o.y,this.restThreshold)&&k(o.z,this.restThreshold)&&k(a,this.restThreshold)&&!this._hasRested&&(this._hasRested=!0,this.dispatchEvent({type:"rest"}))):!f&&this._updatedLastTime&&this.dispatchEvent({type:"sleep"}),this._lastDistance=this._spherical.radius,this._lastZoom=this._zoom,this._updatedLastTime=f,this._needsUpdate=!1,f}toJSON(){return JSON.stringify({enabled:this._enabled,minDistance:this.minDistance,maxDistance:qt(this.maxDistance),minZoom:this.minZoom,maxZoom:qt(this.maxZoom),minPolarAngle:this.minPolarAngle,maxPolarAngle:qt(this.maxPolarAngle),minAzimuthAngle:qt(this.minAzimuthAngle),maxAzimuthAngle:qt(this.maxAzimuthAngle),smoothTime:this.smoothTime,draggingSmoothTime:this.draggingSmoothTime,dollySpeed:this.dollySpeed,truckSpeed:this.truckSpeed,dollyToCursor:this.dollyToCursor,verticalDragToForward:this.verticalDragToForward,target:this._targetEnd.toArray(),position:F.setFromSpherical(this._sphericalEnd).add(this._targetEnd).toArray(),zoom:this._zoomEnd,focalOffset:this._focalOffsetEnd.toArray(),target0:this._target0.toArray(),position0:this._position0.toArray(),zoom0:this._zoom0,focalOffset0:this._focalOffset0.toArray()})}fromJSON(e,t=!1){const s=JSON.parse(e);this.enabled=s.enabled,this.minDistance=s.minDistance,this.maxDistance=Wt(s.maxDistance),this.minZoom=s.minZoom,this.maxZoom=Wt(s.maxZoom),this.minPolarAngle=s.minPolarAngle,this.maxPolarAngle=Wt(s.maxPolarAngle),this.minAzimuthAngle=Wt(s.minAzimuthAngle),this.maxAzimuthAngle=Wt(s.maxAzimuthAngle),this.smoothTime=s.smoothTime,this.draggingSmoothTime=s.draggingSmoothTime,this.dollySpeed=s.dollySpeed,this.truckSpeed=s.truckSpeed,this.dollyToCursor=s.dollyToCursor,this.verticalDragToForward=s.verticalDragToForward,this._target0.fromArray(s.target0),this._position0.fromArray(s.position0),this._zoom0=s.zoom0,this._focalOffset0.fromArray(s.focalOffset0),this.moveTo(s.target[0],s.target[1],s.target[2],t),G.setFromVector3(F.fromArray(s.position).sub(this._targetEnd).applyQuaternion(this._yAxisUpSpace)),this.rotateTo(G.theta,G.phi,t),this.dollyTo(G.radius,t),this.zoomTo(s.zoom,t),this.setFocalOffset(s.focalOffset[0],s.focalOffset[1],s.focalOffset[2],t),this._needsUpdate=!0}connect(e){if(this._domElement){console.warn("camera-controls is already connected.");return}e.setAttribute("data-camera-controls-version",En),this._addAllEventListeners(e),this._getClientRect(this._elementRect)}disconnect(){this.cancel(),this._removeAllEventListeners(),this._domElement&&(this._domElement.removeAttribute("data-camera-controls-version"),this._domElement=void 0)}dispose(){this.removeAllEventListeners(),this.disconnect()}_getTargetDirection(e){return e.setFromSpherical(this._spherical).divideScalar(this._spherical.radius).applyQuaternion(this._yAxisUpSpaceInverse)}_getCameraDirection(e){return this._getTargetDirection(e).negate()}_findPointerById(e){return this._activePointers.find(t=>t.pointerId===e)}_findPointerByMouseButton(e){return this._activePointers.find(t=>t.mouseButton===e)}_disposePointer(e){this._activePointers.splice(this._activePointers.indexOf(e),1)}_encloseToBoundary(e,t,s){const i=t.lengthSq();if(i===0)return e;const r=I.copy(t).add(e),a=this._boundary.clampPoint(r,St).sub(r),c=a.lengthSq();if(c===0)return e.add(t);if(c===i)return e;if(s===0)return e.add(t).add(a);{const d=1+s*c/t.dot(a);return e.add(I.copy(t).multiplyScalar(d)).add(a.multiplyScalar(1-s))}}_updateNearPlaneCorners(){if(gt(this._camera)){const e=this._camera,t=e.near,s=e.getEffectiveFOV()*Xt,i=Math.tan(s*.5)*t,r=i*e.aspect;this._nearPlaneCorners[0].set(-r,-i,0),this._nearPlaneCorners[1].set(r,-i,0),this._nearPlaneCorners[2].set(r,i,0),this._nearPlaneCorners[3].set(-r,i,0)}else if(pt(this._camera)){const e=this._camera,t=1/e.zoom,s=e.left*t,i=e.right*t,r=e.top*t,o=e.bottom*t;this._nearPlaneCorners[0].set(s,r,0),this._nearPlaneCorners[1].set(i,r,0),this._nearPlaneCorners[2].set(i,o,0),this._nearPlaneCorners[3].set(s,o,0)}}_collisionTest(){let e=1/0;if(!(this.colliderMeshes.length>=1)||ke(this._camera,"_collisionTest"))return e;const s=this._getTargetDirection($t);Ze.lookAt(vs,s,this._camera.up);for(let i=0;i<4;i++){const r=I.copy(this._nearPlaneCorners[i]);r.applyMatrix4(Ze);const o=St.addVectors(this._target,r);ge.set(o,s),ge.far=this._spherical.radius+1;const a=ge.intersectObjects(this.colliderMeshes);a.length!==0&&a[0].distance<e&&(e=a[0].distance)}return e}_getClientRect(e){if(!this._domElement)return;const t=this._domElement.getBoundingClientRect();return e.x=t.left,e.y=t.top,this._viewport?(e.x+=this._viewport.x,e.y+=t.height-this._viewport.w-this._viewport.y,e.width=this._viewport.z,e.height=this._viewport.w):(e.width=t.width,e.height=t.height),e}_createOnRestPromise(e){return e?Promise.resolve():(this._hasRested=!1,this.dispatchEvent({type:"transitionstart"}),new Promise(t=>{const s=()=>{this.removeEventListener("rest",s),t()};this.addEventListener("rest",s)}))}_addAllEventListeners(e){}_removeAllEventListeners(){}get dampingFactor(){return console.warn(".dampingFactor has been deprecated. use smoothTime (in seconds) instead."),0}set dampingFactor(e){console.warn(".dampingFactor has been deprecated. use smoothTime (in seconds) instead.")}get draggingDampingFactor(){return console.warn(".draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead."),0}set draggingDampingFactor(e){console.warn(".draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead.")}static createBoundingSphere(e,t=new B.Sphere){const s=t,i=s.center;Mt.makeEmpty(),e.traverseVisible(o=>{o.isMesh&&Mt.expandByObject(o)}),Mt.getCenter(i);let r=0;return e.traverseVisible(o=>{if(!o.isMesh)return;const a=o,c=a.geometry.clone();c.applyMatrix4(a.matrixWorld);const f=c.attributes.position;for(let u=0,l=f.count;u<l;u++)F.fromBufferAttribute(f,u),r=Math.max(r,i.distanceToSquared(F))}),s.radius=Math.sqrt(r),s}}class Xs extends _n{constructor(t){super(t);L(this,"onBeforeUpdate",new X);L(this,"onAfterUpdate",new X);L(this,"onAspectUpdated",new X);L(this,"onDisposed",new X);L(this,"three");L(this,"_allControls",new Map);L(this,"updateAspect",()=>{var t;if(!(!this.currentWorld||!this.currentWorld.renderer)){if(this.three instanceof ei){this.onAspectUpdated.trigger();return}if((t=this.currentWorld.renderer)!=null&&t.isResizeable()){const s=this.currentWorld.renderer.getSize();this.three.aspect=s.width/s.height,this.three.updateProjectionMatrix(),this.onAspectUpdated.trigger()}}});this.three=this.setupCamera(),this.setupEvents(!0),this.onWorldChanged.add(({action:s,world:i})=>{if(s==="added"){const r=this.newCameraControls();this._allControls.set(i.uuid,r)}if(s==="removed"){const r=this._allControls.get(i.uuid);r&&(r.dispose(),this._allControls.delete(i.uuid))}})}get controls(){if(!this.currentWorld)throw new Error("This camera needs a world to work!");const t=this._allControls.get(this.currentWorld.uuid);if(!t)throw new Error("Controls not found!");return t}get enabled(){return this.currentWorld===null?!1:this.controls.enabled}set enabled(t){this.controls.enabled=t}dispose(){this.setupEvents(!1),this.enabled=!1,this.onAspectUpdated.reset(),this.onBeforeUpdate.reset(),this.onAfterUpdate.reset(),this.three.removeFromParent(),this.onDisposed.trigger(),this.onDisposed.reset();for(const[t,s]of this._allControls)s.dispose()}update(t){this.enabled&&(this.onBeforeUpdate.trigger(this),this.controls.update(t),this.onAfterUpdate.trigger(this))}setupCamera(){const t=window.innerWidth/window.innerHeight,s=new si(60,t,1,1e3);return s.position.set(50,50,50),s.lookAt(new S(0,0,0)),s}newCameraControls(){if(!this.currentWorld)throw new Error("This camera needs a world to work!");if(!this.currentWorld.renderer)throw new Error("This camera needs a renderer to work!");Jt.install({THREE:Xs.getSubsetOfThree()});const{domElement:t}=this.currentWorld.renderer.three,s=new Jt(this.three,t);return s.smoothTime=.2,s.dollyToCursor=!0,s.infinityDolly=!0,s}setupEvents(t){t?window.addEventListener("resize",this.updateAspect):window.removeEventListener("resize",this.updateAspect)}static getSubsetOfThree(){return{MOUSE:ii,Vector2:ht,Vector3:S,Vector4:ni,Quaternion:oi,Matrix4:ut,Spherical:ri,Box3:st,Sphere:Fs,Raycaster:ai,MathUtils:ci}}}const Ae=class Ae extends Ys{constructor(t){super(t);L(this,"onAfterUpdate",new X);L(this,"onBeforeUpdate",new X);L(this,"onDisposed",new X);L(this,"list",new Map);L(this,"enabled",!0);t.add(Ae.uuid,this)}create(){const t=new gn(this.components),s=t.uuid;if(this.list.has(s))throw new Error("There is already a world with this name!");return this.list.set(s,t),t}delete(t){this.list.delete(t.uuid),t.dispose()}dispose(){this.enabled=!1;for(const[t,s]of this.list)s.dispose();this.list.clear(),this.onDisposed.trigger()}update(t){if(this.enabled)for(const[s,i]of this.list)i.update(t)}};L(Ae,"uuid","fdb61dc4-2ec1-4966-b83d-54ea795fad4a");let Ms=Ae;export{Ys as C,xe as D,X as E,Cn as S,Ms as W,As as a,bn as b,Xs as c};
