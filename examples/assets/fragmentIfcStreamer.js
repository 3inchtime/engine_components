var Te=Object.defineProperty;var Me=(d,t,e)=>t in d?Te(d,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):d[t]=e;var g=(d,t,e)=>(Me(d,typeof t!="symbol"?t+"":t,e),e);import{V as S,L as Ae,P as Ge,T as De,z as R,a as O,Z as te,F as _e,G as Le,J as Re,K as ke,X as Ve,Y as Ne,ab as Be,ac as Ue,ad as Oe,ae as qe,a0 as be,$ as He,v as je,a1 as We}from"./unzipit.module-aSGGZIxN.js";import{S as $e}from"./stats.min-GTpOrGrX.js";import{c as Fe,E as T,C as Ye,W as Je,S as Xe,a as Ke,b as Ze}from"./index-CB6lCoIW.js";import{G as Qe}from"./index-Bm-te9Ra.js";import{I as ve,G as et,S as tt,a as st,C as nt}from"./ifc-metadata-reader-CKjAdewm.js";import{S as it,a as ot}from"./serializer-BuFxedjR.js";import{S as at}from"./stream-serializer-CqeLpR-5.js";import"./_commonjsHelpers-Cpj98o6Y.js";const ee=0,rt=1,ct=new S,Ie=new Ae,re=new Ge,xe=new S,Q=new De;class lt{constructor(){this.tolerance=-1,this.faces=[],this.newFaces=[],this.assigned=new Se,this.unassigned=new Se,this.vertices=[]}setFromPoints(t){if(t.length>=4){this.makeEmpty();for(let e=0,s=t.length;e<s;e++)this.vertices.push(new ht(t[e]));this.compute()}return this}setFromObject(t){const e=[];return t.updateMatrixWorld(!0),t.traverse(function(s){const i=s.geometry;if(i!==void 0){const n=i.attributes.position;if(n!==void 0)for(let a=0,o=n.count;a<o;a++){const c=new S;c.fromBufferAttribute(n,a).applyMatrix4(s.matrixWorld),e.push(c)}}}),this.setFromPoints(e)}containsPoint(t){const e=this.faces;for(let s=0,i=e.length;s<i;s++)if(e[s].distanceToPoint(t)>this.tolerance)return!1;return!0}intersectRay(t,e){const s=this.faces;let i=-1/0,n=1/0;for(let a=0,o=s.length;a<o;a++){const c=s[a],r=c.distanceToPoint(t.origin),m=c.normal.dot(t.direction);if(r>0&&m>=0)return null;const u=m!==0?-r/m:0;if(!(u<=0)&&(m>0?n=Math.min(u,n):i=Math.max(u,i),i>n))return null}return i!==-1/0?t.at(i,e):t.at(n,e),e}intersectsRay(t){return this.intersectRay(t,ct)!==null}makeEmpty(){return this.faces=[],this.vertices=[],this}addVertexToFace(t,e){return t.face=e,e.outside===null?this.assigned.append(t):this.assigned.insertBefore(e.outside,t),e.outside=t,this}removeVertexFromFace(t,e){return t===e.outside&&(t.next!==null&&t.next.face===e?e.outside=t.next:e.outside=null),this.assigned.remove(t),this}removeAllVerticesFromFace(t){if(t.outside!==null){const e=t.outside;let s=t.outside;for(;s.next!==null&&s.next.face===t;)s=s.next;return this.assigned.removeSubList(e,s),e.prev=s.next=null,t.outside=null,e}}deleteFaceVertices(t,e){const s=this.removeAllVerticesFromFace(t);if(s!==void 0)if(e===void 0)this.unassigned.appendChain(s);else{let i=s;do{const n=i.next;e.distanceToPoint(i.point)>this.tolerance?this.addVertexToFace(i,e):this.unassigned.append(i),i=n}while(i!==null)}return this}resolveUnassignedPoints(t){if(this.unassigned.isEmpty()===!1){let e=this.unassigned.first();do{const s=e.next;let i=this.tolerance,n=null;for(let a=0;a<t.length;a++){const o=t[a];if(o.mark===ee){const c=o.distanceToPoint(e.point);if(c>i&&(i=c,n=o),i>1e3*this.tolerance)break}}n!==null&&this.addVertexToFace(e,n),e=s}while(e!==null)}return this}computeExtremes(){const t=new S,e=new S,s=[],i=[];for(let n=0;n<3;n++)s[n]=i[n]=this.vertices[0];t.copy(this.vertices[0].point),e.copy(this.vertices[0].point);for(let n=0,a=this.vertices.length;n<a;n++){const o=this.vertices[n],c=o.point;for(let r=0;r<3;r++)c.getComponent(r)<t.getComponent(r)&&(t.setComponent(r,c.getComponent(r)),s[r]=o);for(let r=0;r<3;r++)c.getComponent(r)>e.getComponent(r)&&(e.setComponent(r,c.getComponent(r)),i[r]=o)}return this.tolerance=3*Number.EPSILON*(Math.max(Math.abs(t.x),Math.abs(e.x))+Math.max(Math.abs(t.y),Math.abs(e.y))+Math.max(Math.abs(t.z),Math.abs(e.z))),{min:s,max:i}}computeInitialHull(){const t=this.vertices,e=this.computeExtremes(),s=e.min,i=e.max;let n=0,a=0;for(let h=0;h<3;h++){const l=i[h].point.getComponent(h)-s[h].point.getComponent(h);l>n&&(n=l,a=h)}const o=s[a],c=i[a];let r,m;n=0,Ie.set(o.point,c.point);for(let h=0,l=this.vertices.length;h<l;h++){const f=t[h];if(f!==o&&f!==c){Ie.closestPointToPoint(f.point,!0,xe);const y=xe.distanceToSquared(f.point);y>n&&(n=y,r=f)}}n=-1,re.setFromCoplanarPoints(o.point,c.point,r.point);for(let h=0,l=this.vertices.length;h<l;h++){const f=t[h];if(f!==o&&f!==c&&f!==r){const y=Math.abs(re.distanceToPoint(f.point));y>n&&(n=y,m=f)}}const u=[];if(re.distanceToPoint(m.point)<0){u.push(P.create(o,c,r),P.create(m,c,o),P.create(m,r,c),P.create(m,o,r));for(let h=0;h<3;h++){const l=(h+1)%3;u[h+1].getEdge(2).setTwin(u[0].getEdge(l)),u[h+1].getEdge(1).setTwin(u[l+1].getEdge(0))}}else{u.push(P.create(o,r,c),P.create(m,o,c),P.create(m,c,r),P.create(m,r,o));for(let h=0;h<3;h++){const l=(h+1)%3;u[h+1].getEdge(2).setTwin(u[0].getEdge((3-h)%3)),u[h+1].getEdge(0).setTwin(u[l+1].getEdge(1))}}for(let h=0;h<4;h++)this.faces.push(u[h]);for(let h=0,l=t.length;h<l;h++){const f=t[h];if(f!==o&&f!==c&&f!==r&&f!==m){n=this.tolerance;let y=null;for(let I=0;I<4;I++){const x=this.faces[I].distanceToPoint(f.point);x>n&&(n=x,y=this.faces[I])}y!==null&&this.addVertexToFace(f,y)}}return this}reindexFaces(){const t=[];for(let e=0;e<this.faces.length;e++){const s=this.faces[e];s.mark===ee&&t.push(s)}return this.faces=t,this}nextVertexToAdd(){if(this.assigned.isEmpty()===!1){let t,e=0;const s=this.assigned.first().face;let i=s.outside;do{const n=s.distanceToPoint(i.point);n>e&&(e=n,t=i),i=i.next}while(i!==null&&i.face===s);return t}}computeHorizon(t,e,s,i){this.deleteFaceVertices(s),s.mark=rt;let n;e===null?n=e=s.getEdge(0):n=e.next;do{const a=n.twin,o=a.face;o.mark===ee&&(o.distanceToPoint(t)>this.tolerance?this.computeHorizon(t,a,o,i):i.push(n)),n=n.next}while(n!==e);return this}addAdjoiningFace(t,e){const s=P.create(t,e.tail(),e.head());return this.faces.push(s),s.getEdge(-1).setTwin(e.twin),s.getEdge(0)}addNewFaces(t,e){this.newFaces=[];let s=null,i=null;for(let n=0;n<e.length;n++){const a=e[n],o=this.addAdjoiningFace(t,a);s===null?s=o:o.next.setTwin(i),this.newFaces.push(o.face),i=o}return s.next.setTwin(i),this}addVertexToHull(t){const e=[];return this.unassigned.clear(),this.removeVertexFromFace(t,t.face),this.computeHorizon(t.point,null,t.face,e),this.addNewFaces(t,e),this.resolveUnassignedPoints(this.newFaces),this}cleanup(){return this.assigned.clear(),this.unassigned.clear(),this.newFaces=[],this}compute(){let t;for(this.computeInitialHull();(t=this.nextVertexToAdd())!==void 0;)this.addVertexToHull(t);return this.reindexFaces(),this.cleanup(),this}}class P{constructor(){this.normal=new S,this.midpoint=new S,this.area=0,this.constant=0,this.outside=null,this.mark=ee,this.edge=null}static create(t,e,s){const i=new P,n=new ce(t,i),a=new ce(e,i),o=new ce(s,i);return n.next=o.prev=a,a.next=n.prev=o,o.next=a.prev=n,i.edge=n,i.compute()}getEdge(t){let e=this.edge;for(;t>0;)e=e.next,t--;for(;t<0;)e=e.prev,t++;return e}compute(){const t=this.edge.tail(),e=this.edge.head(),s=this.edge.next.head();return Q.set(t.point,e.point,s.point),Q.getNormal(this.normal),Q.getMidpoint(this.midpoint),this.area=Q.getArea(),this.constant=this.normal.dot(this.midpoint),this}distanceToPoint(t){return this.normal.dot(t)-this.constant}}class ce{constructor(t,e){this.vertex=t,this.prev=null,this.next=null,this.twin=null,this.face=e}head(){return this.vertex}tail(){return this.prev?this.prev.vertex:null}length(){const t=this.head(),e=this.tail();return e!==null?e.point.distanceTo(t.point):-1}lengthSquared(){const t=this.head(),e=this.tail();return e!==null?e.point.distanceToSquared(t.point):-1}setTwin(t){return this.twin=t,t.twin=this,this}}class ht{constructor(t){this.point=t,this.prev=null,this.next=null,this.face=null}}class Se{constructor(){this.head=null,this.tail=null}first(){return this.head}last(){return this.tail}clear(){return this.head=this.tail=null,this}insertBefore(t,e){return e.prev=t.prev,e.next=t,e.prev===null?this.head=e:e.prev.next=e,t.prev=e,this}insertAfter(t,e){return e.prev=t,e.next=t.next,e.next===null?this.tail=e:e.next.prev=e,t.next=e,this}append(t){return this.head===null?this.head=t:this.tail.next=t,t.prev=this.tail,t.next=null,this.tail=t,this}appendChain(t){for(this.head===null?this.head=t:this.tail.next=t,t.prev=this.tail;t.next!==null;)t=t.next;return this.tail=t,this}remove(t){return t.prev===null?this.head=t.next:t.prev.next=t.next,t.next===null?this.tail=t.prev:t.next.prev=t.prev,this}removeSubList(t,e){return t.prev===null?this.head=e.next:t.prev.next=e.next,e.next===null?this.tail=t.prev:e.next.prev=t.prev,this}isEmpty(){return this.head===null}}const le=[2,2,1],he=[1,0,0];function z(d,t){return d*3+t}function dt(d){const t=d.elements;let e=0;for(let s=0;s<9;s++)e+=t[s]*t[s];return Math.sqrt(e)}function mt(d){const t=d.elements;let e=0;for(let s=0;s<3;s++){const i=t[z(le[s],he[s])];e+=2*i*i}return Math.sqrt(e)}function ft(d,t){let e=0,s=1;const i=d.elements;for(let r=0;r<3;r++){const m=Math.abs(i[z(le[r],he[r])]);m>e&&(e=m,s=r)}let n=1,a=0;const o=he[s],c=le[s];if(Math.abs(i[z(c,o)])>Number.EPSILON){const r=i[z(c,c)],m=i[z(o,o)],u=i[z(c,o)],h=(r-m)/2/u;let l;h<0?l=-1/(-h+Math.sqrt(1+h*h)):l=1/(h+Math.sqrt(1+h*h)),n=1/Math.sqrt(1+l*l),a=l*n}return t.identity(),t.elements[z(o,o)]=n,t.elements[z(c,c)]=n,t.elements[z(c,o)]=a,t.elements[z(o,c)]=-a,t}function ut(d,t){let e=0,s=0;const i=10;t.unitary.identity(),t.diagonal.copy(d);const n=t.unitary,a=t.diagonal,o=new R,c=new R,r=Number.EPSILON*dt(a);for(;s<i&&mt(a)>r;)ft(a,o),c.copy(o).transpose(),a.multiply(o),a.premultiply(c),n.multiply(o),++e>2&&(s++,e=0);return t}function pt(d){const t=[];for(let v=0;v<d.length-2;v+=3){const G=d[v],b=d[v+1],L=d[v+2];t.push(new S(G,b,L))}const e=new lt;e.setFromPoints(t);const s={unitary:new R,diagonal:new R},i=e.faces,n=[],a=[];for(let v=0,G=i.length;v<G;v++){const b=i[v];let L=b.edge;n.length=0;do n.push(L),L=L.next;while(L!==b.edge);const Pe=n.length-2;for(let Z=1,ze=Pe;Z<=ze;Z++){const ie=n[0].vertex,oe=n[Z+0].vertex,ae=n[Z+1].vertex;a.push(ie.point.x,ie.point.y,ie.point.z),a.push(oe.point.x,oe.point.y,oe.point.z),a.push(ae.point.x,ae.point.y,ae.point.z)}}const o=new S,c=new S,r=new S,m=new S,u=new S,h=new S,l=new S,f=new S;let y=0,I=0,x=0,p=0,w=0,F=0,C=0;for(let v=0,G=a.length;v<G;v+=9){o.fromArray(a,v),c.fromArray(a,v+3),r.fromArray(a,v+6),l.set(0,0,0),l.add(o).add(c).add(r).divideScalar(3),m.subVectors(c,o),u.subVectors(r,o);const b=h.crossVectors(m,u).length()/2;f.add(h.copy(l).multiplyScalar(b)),y+=b,I+=(9*l.x*l.x+o.x*o.x+c.x*c.x+r.x*r.x)*(b/12),x+=(9*l.x*l.y+o.x*o.y+c.x*c.y+r.x*r.y)*(b/12),p+=(9*l.x*l.z+o.x*o.z+c.x*c.z+r.x*r.z)*(b/12),w+=(9*l.y*l.y+o.y*o.y+c.y*c.y+r.y*r.y)*(b/12),F+=(9*l.y*l.z+o.y*o.z+c.y*c.z+r.y*r.z)*(b/12),C+=(9*l.z*l.z+o.z*o.z+c.z*c.z+r.z*r.z)*(b/12)}f.divideScalar(y),I/=y,x/=y,p/=y,w/=y,F/=y,C/=y,I-=f.x*f.x,x-=f.x*f.y,p-=f.x*f.z,w-=f.y*f.y,F-=f.y*f.z,C-=f.z*f.z;const E=new R;E.elements[0]=I,E.elements[1]=x,E.elements[2]=p,E.elements[3]=x,E.elements[4]=w,E.elements[5]=F,E.elements[6]=p,E.elements[7]=F,E.elements[8]=C,ut(E,s);const j=s.unitary,k=new S,V=new S,N=new S;j.extractBasis(k,V,N);let W=-1/0,$=-1/0,Y=-1/0,J=1/0,X=1/0,K=1/0;for(let v=0,G=t.length;v<G;v++){const b=t[v];W=Math.max(k.dot(b),W),$=Math.max(V.dot(b),$),Y=Math.max(N.dot(b),Y),J=Math.min(k.dot(b),J),X=Math.min(V.dot(b),X),K=Math.min(N.dot(b),K)}k.multiplyScalar(.5*(J+W)),V.multiplyScalar(.5*(X+$)),N.multiplyScalar(.5*(K+Y));const B=new S,_=new S,ne=new R;B.add(k).add(V).add(N),_.x=W-J,_.y=$-X,_.z=Y-K,_.multiplyScalar(.5),ne.copy(j);const{x:me,y:fe,z:ue}=_,pe=new O;pe.makeScale(me*2,fe*2,ue*2);const ge=new O;ge.makeTranslation(-me,-fe,-ue);const we=new O;we.makeTranslation(B.x,B.y,B.z);const ye=new O;ye.setFromMatrix3(ne);const U=new O;return U.multiply(we),U.multiply(ye),U.multiply(ge),U.multiply(pe),{center:B,halfSizes:_,rotation:ne,transformation:U}}function gt(d,t,e){const s=[d[0]-t[0],d[1]-t[1],d[2]-t[2]];return e[0]*s[0]+e[1]*s[1]+e[2]*s[2]>0}class wt extends ve{constructor(){super(...arguments);g(this,"minGeometrySize",10);g(this,"minAssetsSize",1e3)}}class yt extends ve{constructor(){super(...arguments);g(this,"propertiesSize",100)}}class Ee extends Fe{constructor(){super(...arguments);g(this,"onPropertiesStreamed",new T);g(this,"onProgress",new T);g(this,"onIndicesStreamed",new T);g(this,"onDisposed",new T);g(this,"enabled",!0);g(this,"settings",new yt);g(this,"webIfc",new te)}async dispose(){this.onIndicesStreamed.reset(),this.onPropertiesStreamed.reset(),this.webIfc=null,this.onDisposed.reset()}async streamFromBuffer(e){const s=performance.now();await this.readIfcFile(e),await this.streamAllProperties(),this.cleanUp(),console.log(`Streaming the IFC took ${performance.now()-s} ms!`)}async streamFromCallBack(e){const s=performance.now();await this.streamIfcFile(e),await this.streamAllProperties(),this.cleanUp(),console.log(`Streaming the IFC took ${performance.now()-s} ms!`)}async readIfcFile(e){const{path:s,absolute:i,logLevel:n}=this.settings.wasm;this.webIfc.SetWasmPath(s,i),await this.webIfc.Init(),n&&this.webIfc.SetLogLevel(n),this.webIfc.OpenModel(e,this.settings.webIfc)}async streamIfcFile(e){const{path:s,absolute:i,logLevel:n}=this.settings.wasm;this.webIfc.SetWasmPath(s,i),await this.webIfc.Init(),n&&this.webIfc.SetLogLevel(n),this.webIfc.OpenModelFromCallback(e,this.settings.webIfc)}async streamAllProperties(){const{propertiesSize:e}=this.settings,s=new Set(this.webIfc.GetIfcEntityList(0)),i=[_e,Le,Re,ke,Ve,Ne],n=new Map,a=new Set([Be,Ue,Oe,qe,be]);for(const m of a)s.add(m);let o=.01,c=0;for(const m of s){if(c++,et.has(m))continue;const u=a.has(m),h=this.webIfc.GetLineIDsWithType(0,m),l=h.size();let f=0;for(let I=0;I<l-e;I+=e){const x={};for(let p=0;p<e;p++){f++;const w=h.get(I+p);try{const F=this.webIfc.GetLine(0,w,u);i.includes(m)&&this.getIndices(F,w,n),x[F.expressID]=F}catch{console.log(`Could not get property: ${w}`)}}await this.onPropertiesStreamed.trigger({type:m,data:x})}if(f!==l){const I={};for(let x=f;x<l;x++){const p=h.get(x);try{const w=this.webIfc.GetLine(0,p,u);i.includes(m)&&this.getIndices(w,p,n),I[w.expressID]=w}catch{console.log(`Could not get property: ${p}`)}}await this.onPropertiesStreamed.trigger({type:m,data:I})}const y=c/s.size;y>o&&(o+=.01,o=Math.max(o,y),await this.onProgress.trigger(Math.round(o*100)/100))}const r=[];for(const[m,u]of n)r.push([m,...u]);await this.onIndicesStreamed.trigger(r)}getIndices(e,s,i){const n=e.RelatedObjects||e.RelatedElements;if(!n){console.log(`Related objects not found: ${s}`);return}const a=e.RelatingType||e.RelatingMaterial||e.RelatingStructure||e.RelatingPropertyDefinition||e.RelatingGroup||e.RelatingClassification;if(!a){console.log(`Relating object not found: ${s}`);return}if(!Array.isArray(n)||a.value===void 0)return;const o=a.value;for(const c of n){if(c.value===void 0||c.value===null)continue;const r=c.value;i.has(r)||i.set(r,new Set),i.get(r).add(o)}}cleanUp(){this.webIfc=null,this.webIfc=new te}}g(Ee,"uuid","88d2c89c-ce32-47d7-8cb6-d51e4b311a0b");const se=class se extends Fe{constructor(e){super(e);g(this,"onGeometryStreamed",new T);g(this,"onAssetStreamed",new T);g(this,"onProgress",new T);g(this,"onIfcLoaded",new T);g(this,"onDisposed",new T);g(this,"settings",new wt);g(this,"enabled",!0);g(this,"webIfc",new te);g(this,"_spatialTree",new tt);g(this,"_metaData",new st);g(this,"_visitedGeometries",new Map);g(this,"_streamSerializer",new at);g(this,"_geometries",new Map);g(this,"_geometryCount",0);g(this,"_civil",new nt);g(this,"_groupSerializer",new it);g(this,"_assets",[]);g(this,"_meshesWithHoles",new Set);this.components.add(se.uuid,this),this.settings.excludedCategories.add(He)}dispose(){this.onIfcLoaded.reset(),this.onGeometryStreamed.reset(),this.onAssetStreamed.reset(),this.webIfc=null,this.onDisposed.trigger(),this.onDisposed.reset()}async streamFromBuffer(e){const s=performance.now();await this.readIfcFile(e),await this.streamAllGeometries(),this.cleanUp(),console.log(`Streaming the IFC took ${performance.now()-s} ms!`)}async streamFromCallBack(e){const s=performance.now();await this.streamIfcFile(e),await this.streamAllGeometries(),this.cleanUp(),console.log(`Streaming the IFC took ${performance.now()-s} ms!`)}async readIfcFile(e){const{path:s,absolute:i,logLevel:n}=this.settings.wasm;this.webIfc.SetWasmPath(s,i),await this.webIfc.Init(),n&&this.webIfc.SetLogLevel(n),this.webIfc.OpenModel(e,this.settings.webIfc)}async streamIfcFile(e){const{path:s,absolute:i,logLevel:n}=this.settings.wasm;this.webIfc.SetWasmPath(s,i),await this.webIfc.Init(),n&&this.webIfc.SetLogLevel(n),this.webIfc.OpenModelFromCallback(e,this.settings.webIfc)}async streamAllGeometries(){const{minGeometrySize:e,minAssetsSize:s}=this.settings;this._spatialTree.setUp(this.webIfc);const i=this.webIfc.GetIfcEntityList(0),n=[[]],a=new ot,{FILE_NAME:o,FILE_DESCRIPTION:c}=We;a.ifcMetadata={name:this._metaData.get(this.webIfc,o),description:this._metaData.get(this.webIfc,c),schema:this.webIfc.GetModelSchema(0)||"IFC2X3",maxExpressID:this.webIfc.GetMaxExpressID(0)};let r=0,m=0;for(const p of i){if(!this.webIfc.IsIfcElement(p)&&p!==be||this.settings.excludedCategories.has(p))continue;const w=this.webIfc.GetLineIDsWithType(0,p),F=w.size();for(let C=0;C<F;C++){r>e&&(r=0,m++,n.push([]));const E=w.get(C);n[m].push(E);const j=this._spatialTree.itemsByFloor[E]||0;a.data.set(E,[[],[j,p]]),r++}}this._spatialTree.cleanUp();let u=.01,h=0;for(const p of n){h++,this.webIfc.StreamMeshes(0,p,F=>{this.getMesh(this.webIfc,F,a)}),this._geometryCount>e&&await this.streamGeometries(),this._assets.length>s&&await this.streamAssets();const w=h/n.length;w>u&&(u+=.01,u=Math.max(u,w),this.onProgress.trigger(Math.round(u*100)/100))}this._geometryCount&&await this.streamGeometries(),this._assets.length&&await this.streamAssets();const{opaque:l,transparent:f}=a.geometryIDs;for(const[p,{index:w,uuid:F}]of this._visitedGeometries)a.keyFragments.set(w,F),(p>1?l:f).set(p,w);const y=a.data.keys();for(const p of y){const[w]=a.data.get(p);w.length||a.data.delete(p)}const I=this.webIfc.GetCoordinationMatrix(0);a.coordinationMatrix.fromArray(I),a.civilData=this._civil.read(this.webIfc);const x=this._groupSerializer.export(a);this.onIfcLoaded.trigger(x),a.dispose(!0)}cleanUp(){this.webIfc=null,this.webIfc=new te,this._visitedGeometries.clear(),this._geometries.clear(),this._assets=[],this._meshesWithHoles.clear()}getMesh(e,s,i){const n=s.geometries.size(),a=s.expressID,o={id:a,geometries:[]};s.expressID===664833&&console.log("Heyyy");for(let c=0;c<n;c++){const r=s.geometries.get(c),m=r.geometryExpressID,u=r.color.w===1?1:-1,h=m*u;if(!this._visitedGeometries.has(h)){this._visitedGeometries.has(m)||this.getGeometry(e,m);const C=this._visitedGeometries.size,E=je.generateUUID();this._visitedGeometries.set(h,{uuid:E,index:C})}const l=this._visitedGeometries.get(h);if(l===void 0)throw new Error("Error getting geometry data for streaming!");const f=i.data.get(a);if(!f)throw new Error("Data not found!");f[0].push(l.index);const{x:y,y:I,z:x,w:p}=r.color,w=[y,I,x,p],F=r.flatTransformation;o.geometries.push({color:w,geometryID:m,transformation:F})}this._assets.push(o)}getGeometry(e,s){const i=e.GetGeometry(0,s),n=e.GetIndexArray(i.GetIndexData(),i.GetIndexDataSize()),a=e.GetVertexArray(i.GetVertexData(),i.GetVertexDataSize()),o=new Float32Array(a.length/2),c=new Float32Array(a.length/2);for(let l=0;l<a.length;l+=6)o[l/2]=a[l],o[l/2+1]=a[l+1],o[l/2+2]=a[l+2],c[l/2]=a[l+3],c[l/2+1]=a[l+4],c[l/2+2]=a[l+5];const r=pt(o),m=new Float32Array(r.transformation.elements),u=[r.center.x,r.center.y,r.center.z];let h=!1;for(let l=0;l<o.length-2;l+=3){const f=o[l],y=o[l+1],I=o[l+2],x=c[l],p=c[l+1],w=c[l+2];if(gt(u,[f,y,I],[x,p,w])){h=!0;break}}this._geometries.set(s,{position:o,normal:c,index:n,boundingBox:m,hasHoles:h}),i.delete(),this._geometryCount++}async streamAssets(){await this.onAssetStreamed.trigger(this._assets),this._assets=null,this._assets=[]}async streamGeometries(){let e=this._streamSerializer.export(this._geometries),s={};for(const[i,{boundingBox:n,hasHoles:a}]of this._geometries)s[i]={boundingBox:n,hasHoles:a};this.onGeometryStreamed.trigger({data:s,buffer:e}),s=null,e=null,this._geometries.clear(),this._geometryCount=0}};g(se,"uuid","d9999a00-e1f5-4d3f-8cfe-c56e08609764");let de=se;const It=document.getElementById("container"),M=new Ye,xt=M.get(Je),D=xt.create();D.scene=new Xe(M);D.renderer=new Ke(M,It);D.camera=new Ze(M);M.init();D.camera.controls.setLookAt(12,6,8,0,0,-10);const St=M.get(Qe);St.create(D);const A=new de(M);A.settings.wasm={path:"https://unpkg.com/web-ifc@0.0.53/",absolute:!0};A.onGeometryStreamed.add(d=>{console.log(d)});A.settings.minGeometrySize=20;A.onAssetStreamed.add(d=>{console.log(d)});A.settings.minAssetsSize=1e3;A.onIfcLoaded.add(async d=>{console.log(d)});A.onProgress.add(d=>{console.log(d)});const bt=await fetch("../../../resources/small.ifc"),Ce=await bt.arrayBuffer();A.streamFromBuffer(new Uint8Array(Ce));const q=new Ee(M);q.settings.wasm={path:"https://unpkg.com/web-ifc@0.0.53/",absolute:!0};q.onPropertiesStreamed.add(async d=>{console.log(d)});q.onProgress.add(async d=>{console.log(d)});q.onIndicesStreamed.add(async d=>{console.log(d)});q.streamFromBuffer(new Uint8Array(Ce));const H=new $e;H.showPanel(2);document.body.append(H.dom);H.dom.style.left="0px";D.renderer.onBeforeUpdate.add(()=>H.begin());D.renderer.onAfterUpdate.add(()=>H.end());
