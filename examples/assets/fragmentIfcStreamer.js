var J=Object.defineProperty;var K=(C,x,e)=>x in C?J(C,x,{enumerable:!0,configurable:!0,writable:!0,value:e}):C[x]=e;var d=(C,x,e)=>(K(C,typeof x!="symbol"?x+"":x,e),e);import{d as X,B as $,l as S,a as j,N as z,G as Q,C as O,X as Z,m as q,c as ee,e as H}from"./web-ifc-api-eJ7dR4yy.js";import{S as te}from"./stats.min-GTpOrGrX.js";import{g as se}from"./lil-gui.module.min-Bc0DeA9g.js";import{Y as oe,K as re,D as ie,J as ne,U as R,u as k,b as ae,f as de,p as ce,s as le,i as me,k as fe,N as he}from"./import-wrapper-prod-Dt8pgrvp.js";import"./_commonjsHelpers-Cpj98o6Y.js";class ge extends oe{constructor(e,t,o){super(e,t,o);d(this,"threshold",50);d(this,"bboxThreshold",200);d(this,"maxLostTime",3e4);d(this,"maxHiddenTime",5e3);d(this,"boxes",new Map);d(this,"_geometry");d(this,"_material",new X({transparent:!0,side:2,opacity:1}));d(this,"onViewUpdated",new re);d(this,"_modelIDIndex",new Map);d(this,"_indexModelID",new Map);d(this,"_nextModelID",0);d(this,"_geometries",new Map);d(this,"_geometriesGroups",new Map);d(this,"_foundGeometries",new Set);d(this,"_intervalID",null);d(this,"codes",new Map);d(this,"handleWorkerMessage",async e=>{const t=e.data.colors,o={},s={},r={},n={},a=performance.now();let c=!1;const f=new Set(this._foundGeometries);for(const[h,p]of t){const i=this._geometries.get(h);if(!i)continue;const g=p>this.threshold,{exists:u}=i;if(!g&&!u)continue;const m=this._indexModelID.get(i.modelIndex);f.delete(h),g&&u?(i.time=a,n[m]||(n[m]=new Set),n[m].add(i.geometryID),this._foundGeometries.add(h),c=!0):g&&!u?(o[m]||(o[m]=new Map),i.time=a,i.exists=!0,o[m].has(p)||o[m].set(p,new Set),o[m].get(p).add(i.geometryID),this._foundGeometries.add(h),c=!0):!g&&u&&(this.handleLostGeometries(a,h,i,s,r),c=!0)}c&&await this.onViewUpdated.trigger({toLoad:o,toRemove:s,toHide:r,toShow:n}),this._isWorkerBusy=!1});this.updateInterval=500,this._geometry=new $(1,1,1),this._geometry.groups=[],this._geometry.deleteAttribute("uv");const s=this._geometry.attributes.position.array;for(let r=0;r<s.length;r++)s[r]+=.5;this._geometry.attributes.position.needsUpdate=!0,this.worker.addEventListener("message",this.handleWorkerMessage),this.autoUpdate&&(this._intervalID=window.setInterval(this.updateVisibility,this.updateInterval))}dispose(){super.dispose(),this.onViewUpdated.reset(),this._intervalID!==null&&(window.clearInterval(this._intervalID),this._intervalID=null);for(const[e,t]of this._geometriesGroups){t.removeFromParent();const o=[...t.children];for(const s of o)s.removeFromParent()}this._geometriesGroups.clear();for(const[e,t]of this.boxes)t.dispose(!0);this.boxes.clear();for(const[e,t]of this._geometries)t.fragment&&(t.fragment.dispose(!0),t.fragment=void 0);this._geometries.clear(),this._geometry.dispose(),this._material.dispose(),this._modelIDIndex.clear(),this._indexModelID.clear(),this.codes.clear()}add(e,t,o){const s=this.createModelIndex(e),r=S.enabled;S.enabled=!1;const n=new Map,a=new j,c=new z(this._geometry,this._material,10);this.boxes.set(s,c),this.scene.add(c.mesh);const f=new Q;this.scene.add(f),this._geometriesGroups.set(s,f);const h=new Map;for(const i of t)for(const g of i.geometries){const{geometryID:u,transformation:m,color:l}=g,_=new O;_.setRGB(l[0],l[1],l[2],"srgb");const w=this.getInstanceID(i.id,u),D=o[u];if(!D){console.log(`Geometry not found: ${u}`);continue}const{boundingBox:G}=D;let y;n.has(u)?y=n.get(u):(y=this.getAvailableColor(),this.increaseColor(),n.set(u,y));const{r:F,g:b,b:M,code:I}=y,E=new O;E.setRGB(F/255,b/255,M/255,"srgb"),this.codes.has(s)||this.codes.set(s,new Map),this.codes.get(s).set(u,I);const V=new j,P=Object.values(G);if(V.fromArray(m),a.fromArray(P),V.multiply(a),h.has(w)){const v=h.get(w);if(v===void 0||!v.colors)throw new Error("Malformed item!");v.colors.push(E),v.geometryColors.push(_),v.transforms.push(V)}else h.set(w,{id:w,colors:[E],geometryColors:[_],transforms:[V]});if(this._geometries.has(I))this._geometries.get(I).assetIDs.add(i.id);else{const v=new Set([i.id]);this._geometries.set(I,{modelIndex:s,geometryID:u,assetIDs:v,exists:!1,hidden:!1,time:0})}}const p=Array.from(h.values());c.add(p),S.enabled=r}remove(e){const t=this._modelIDIndex.get(e);if(t===void 0)throw new Error("Model doesn't exist!");const o=this._geometriesGroups.get(t);o.removeFromParent();const s=[...o.children];for(const a of s)a.removeFromParent();this._geometriesGroups.delete(t),this.boxes.get(t).dispose(!1),this.boxes.delete(t);const n=this.codes.get(t);this.codes.delete(t);for(const[a,c]of n){const f=this._geometries.get(c);f&&f.fragment&&(f.fragment.dispose(!1),f.fragment=void 0),this._geometries.delete(c)}this._modelIDIndex.delete(e),this._indexModelID.delete(t),this._foundGeometries.clear()}addFragment(e,t,o){const s=S.enabled;S.enabled=!1;const r=this._modelIDIndex.get(e),a=this.codes.get(r).get(t),c=this._geometries.get(a);if(this.setGeometryVisibility(c,!1,!1),!c.fragment){c.fragment=new z(o.mesh.geometry,this._material,o.capacity);const g=this._geometriesGroups.get(r);if(!g)throw new Error("Group not found!");g.add(c.fragment.mesh)}const[f,h,p]=a.split("-").map(g=>parseInt(g,10)),i=[];for(const g of o.ids){const u=o.get(g);if(!u.colors)throw new Error("Malformed fragments!");for(const m of u.colors)m.setRGB(f/255,h/255,p/255,"srgb");i.push(u)}c.fragment.add(i),S.enabled=s,this.needsUpdate=!0}removeFragment(e,t){const o=this._modelIDIndex.get(e),r=this.codes.get(o).get(t),n=this._geometries.get(r);if(n.hidden||this.setGeometryVisibility(n,!0,!1),n.fragment){const{fragment:a}=n;a.dispose(!1),n.fragment=void 0}}setModelTransformation(e,t){const o=this._modelIDIndex.get(e);if(o===void 0)throw new Error("Model not found!");const s=this.boxes.get(o);s&&(s.mesh.position.set(0,0,0),s.mesh.rotation.set(0,0,0),s.mesh.scale.set(1,1,1),s.mesh.applyMatrix4(t));const r=this._geometriesGroups.get(o);r&&(r.position.set(0,0,0),r.rotation.set(0,0,0),r.scale.set(1,1,1),r.applyMatrix4(t))}setVisibility(e,t,o){const s=this._modelIDIndex.get(t);if(s!==void 0)for(const[r,n]of o){const a=this.codes.get(s);if(a===void 0)throw new Error("Map not found!");const c=a.get(r),f=this._geometries.get(c);if(f===void 0)throw new Error("Geometry not found!");f.hidden=!e,this.setGeometryVisibility(f,e,!0,n)}}setGeometryVisibility(e,t,o,s){const{modelIndex:r,geometryID:n,assetIDs:a}=e,c=this.boxes.get(r);if(c===void 0)throw new Error("Model not found!");const f=s||a;if(o&&e.fragment)e.fragment.setVisibility(t,f);else{const h=new Set;for(const p of f){const i=this.getInstanceID(p,n);h.add(i)}c.setVisibility(t,h)}}handleLostGeometries(e,t,o,s,r){const n=this._indexModelID.get(o.modelIndex),a=e-o.time;a>this.maxLostTime?(s[n]||(s[n]=new Set),o.exists=!1,s[n].add(o.geometryID),this._foundGeometries.delete(t)):a>this.maxHiddenTime&&(r[n]||(r[n]=new Set),r[n].add(o.geometryID))}createModelIndex(e){if(this._modelIDIndex.has(e))throw new Error("Can't load the same model twice!");const t=this._nextModelID;return this._nextModelID++,this._modelIDIndex.set(e,t),this._indexModelID.set(t,e),t}getInstanceID(e,t){const s=10**(Math.log(t)*Math.LOG10E+1|0);return e+t/s}}class ue extends ie{constructor(){super("MyAppDatabase");d(this,"files");this.version(1).stores({files:"id, file"})}}const L=class L extends ne{constructor(e){super(e);d(this,"enabled",!0);d(this,"onFragmentsDeleted",new R);d(this,"onFragmentsLoaded",new R);d(this,"onDisposed",new R);d(this,"models",{});d(this,"serializer",new Z);d(this,"maxRamTime",5e3);d(this,"useCache",!0);d(this,"_culler",null);d(this,"_world",null);d(this,"_ramCache",new Map);d(this,"_fileCache",new ue);d(this,"_url",null);d(this,"_isDisposing",!1);d(this,"_geometryInstances",{});d(this,"_loadedFragments",{});d(this,"fragIDData",new Map);d(this,"_baseMaterial",new q);d(this,"_baseMaterialT",new q({transparent:!0,opacity:.5}));this.components.add(L.uuid,this)}get url(){if(!this._url)throw new Error("url must be set before using the streaming service!");return this._url}set url(e){this._url=e}get world(){if(!this._world)throw new Error("You must set a world before using the streamer!");return this._world}set world(e){var t;this._world=e,(t=this._culler)==null||t.dispose(),this._culler=new ge(this.components,e),this._culler.onViewUpdated.add(async({toLoad:o,toRemove:s,toShow:r,toHide:n})=>{await this.loadFoundGeometries(o),await this.unloadLostGeometries(s),this.setMeshVisibility(r,!0),this.setMeshVisibility(n,!1)})}get culler(){if(!this._culler)throw new Error("You must set a world before using the streamer!");return this._culler}dispose(){var e;this._isDisposing=!0,this.onFragmentsLoaded.reset(),this.onFragmentsDeleted.reset(),this._ramCache.clear(),this.models={},this._geometryInstances={},this._loadedFragments={},this.fragIDData.clear(),this._baseMaterial.dispose(),this._baseMaterialT.dispose(),(e=this._culler)==null||e.dispose(),this.onDisposed.trigger(L.uuid),this.onDisposed.reset(),this._isDisposing=!1}async load(e,t,o){const{assets:s,geometries:r,globalDataFileId:n}=e,a=this.url+n,f=await(await fetch(a)).arrayBuffer(),h=new Uint8Array(f),i=this.components.get(k).load(h,{coordinate:t});this.world.scene.three.add(i);const{opaque:g,transparent:u}=i.geometryIDs;for(const[l,_]of g){const w=i.keyFragments.get(_);if(w===void 0)throw new Error("Malformed fragments group!");this.fragIDData.set(w,[i,l,new Set])}for(const[l,_]of u){const w=i.keyFragments.get(_);if(w===void 0)throw new Error("Malformed fragments group!");this.fragIDData.set(w,[i,Math.abs(l),new Set])}this.culler.add(i.uuid,s,r),this.models[i.uuid]={assets:s,geometries:r};const m=new Map;for(const l of s){const _=l.id;for(const{transformation:w,geometryID:D,color:G}of l.geometries){m.has(D)||m.set(D,[]);const y=m.get(D);if(!y)throw new Error("Malformed instances");y.push({id:_,transformation:w,color:G})}}if(this._geometryInstances[i.uuid]=m,o){const l=new Map,_=new Map;for(const b in o.ids){const M=o.ids[b],I=parseInt(b,10);l.set(I,M)}for(const b in o.types){const M=o.types[b],I=parseInt(b,10);_.set(I,M)}const w=n.replace("-global","-properties");i.streamSettings={baseUrl:this.url,baseFileName:w,ids:l,types:_};const{indexesFile:D}=o,y=await(await fetch(this.url+D)).text(),F=this.components.get(ae);F.setRelationMap(i,F.getRelationsMapFromJSON(y))}return this.culler.needsUpdate=!0,i}remove(e){this._isDisposing=!0;const o=this.components.get(k).groups.get(e);if(o===void 0){console.log("Group to delete not found.");return}delete this.models[e],delete this._geometryInstances[e],delete this._loadedFragments[e];const s=o.keyFragments.values();for(const r of s)this.fragIDData.delete(r);this.culler.remove(e),this._isDisposing=!1}setVisibility(e,t){const o=new Map;for(const s in t){const r=this.fragIDData.get(s);if(r===void 0)throw new Error("Geometry not found!");const[n,a,c]=r,f=n.uuid;o.has(f)||o.set(f,new Map);const h=o.get(f),p=t[s];for(const g of p)e?c.delete(g):c.add(g);h.get(a)||h.set(a,new Set);const i=h.get(a);for(const g of p)i.add(g)}for(const[s,r]of o){this.culler.setVisibility(e,s,r);for(const[n]of r){const a=this._loadedFragments[s];if(!a)continue;const c=a[n];if(c)for(const f of c){const h=t[f.id];h&&f.setVisibility(e,h)}}}this.culler.needsUpdate=!0}async clearCache(){await this._fileCache.delete()}get(){}update(){}async loadFoundGeometries(e){for(const t in e){if(this._isDisposing)return;const s=this.components.get(k).groups.get(t);if(!s)return;const{geometries:r}=this.models[t],n=new Map,a=new Set;for(const[p,i]of e[t])for(const g of i){a.add(g);const u=r[g];if(!u)throw new Error("Geometry not found");if(u.geometryFile){const m=u.geometryFile,l=n.get(m)||0;n.set(m,l+p)}}const c=Array.from(n).sort((p,i)=>i[1]-p[1]);for(const[p]of c){const i=this.url+p;if(!this._ramCache.has(i)){let m=new Uint8Array;if(this.useCache){const _=await this._fileCache.files.get(i);if(_)m=_.file;else{const D=await(await fetch(i)).arrayBuffer();m=new Uint8Array(D),this._fileCache.files.add({file:m,id:i})}}else{const w=await(await fetch(i)).arrayBuffer();m=new Uint8Array(w)}const l=this.serializer.import(m);this._ramCache.set(i,{data:l,time:performance.now()})}const g=this._ramCache.get(i);if(!g)continue;g.time=performance.now();const u=[];if(g)for(const[m,{position:l,index:_,normal:w}]of g.data){if(this._isDisposing)return;if(!a.has(m)||!this._geometryInstances[t]||!this._geometryInstances[t].has(m))continue;const G=this._geometryInstances[t].get(m);if(!G)throw new Error("Instances not found!");const y=new ee,F=new H(l,3),b=new H(w,3);y.setAttribute("position",F),y.setAttribute("normal",b),y.setIndex(Array.from(_));const M=[],I=[];for(const E of G)E.color[3]===1?I.push(E):M.push(E);this.newFragment(s,m,y,M,!0,u),this.newFragment(s,m,y,I,!1,u)}u.length&&!this._isDisposing&&this.onFragmentsLoaded.trigger(u)}const f=new Set,h=performance.now();for(const[p,{time:i}]of this._ramCache)h-i>this.maxRamTime&&f.add(p);for(const p of f)this._ramCache.delete(p)}}async unloadLostGeometries(e){if(this._isDisposing)return;const t=[],o=this.components.get(k);for(const s in e){const r=o.groups.get(s);if(!r)throw new Error("Fragment group not found!");if(!this._loadedFragments[s])continue;const n=this._loadedFragments[s],a=e[s];for(const c of a){if(this.culler.removeFragment(r.uuid,c),!n[c])continue;const f=n[c];for(const h of f)r.items.splice(r.items.indexOf(h),1),t.push(h);delete n[c]}}t.length&&this.onFragmentsDeleted.trigger(t);for(const s of t)o.list.delete(s.id),this.world.meshes.delete(s.mesh),s.mesh.material=[],s.dispose(!0)}setMeshVisibility(e,t){for(const o in e)for(const s of e[o]){const r=this._loadedFragments[o];if(!r)continue;const n=r[s];if(n)for(const a of n)a.mesh.visible=t}}newFragment(e,t,o,s,r,n){if(s.length===0||this._isDisposing)return;const a=e.geometryIDs,c=r?a.transparent:a.opaque,h=t*(r?-1:1),p=c.get(h);if(p===void 0)return;const i=e.keyFragments.get(p);if(i===void 0)return;const g=this.components.get(k);if(g.list.has(i))return;const m=r?this._baseMaterialT:this._baseMaterial,l=new z(o,m,s.length);l.id=i,l.mesh.uuid=i,l.group=e,e.add(l.mesh),e.items.push(l),g.list.set(l.id,l),this.world.meshes.add(l.mesh),this._loadedFragments[e.uuid]||(this._loadedFragments[e.uuid]={});const _=this._loadedFragments[e.uuid];_[t]||(_[t]=[]),_[t].push(l);const w=new Map;for(let F=0;F<s.length;F++){const b=new j,M=new O,{id:I,transformation:E,color:Y}=s[F];b.fromArray(E);const[V,P,v]=Y;if(M.setRGB(V,P,v,"srgb"),w.has(I)){const N=w.get(I);if(!N)continue;N.transforms.push(b),N.colors&&N.colors.push(M)}else w.set(I,{id:I,colors:[M],transforms:[b]})}const D=Array.from(w.values());l.add(D);const G=this.fragIDData.get(l.id);if(!G)throw new Error("Fragment data not found!");const y=G[2];y.size&&l.setVisibility(!1,y),this.culler.addFragment(e.uuid,t,l),n.push(l)}};d(L,"uuid","22437e8d-9dbc-4b99-a04f-d2da280d50c8");let W=L;const pe=document.getElementById("container"),B=new de,we=B.get(ce),A=we.create();A.scene=new le(B);A.renderer=new me(B,pe);A.camera=new fe(B);B.init();A.scene.setup();A.camera.controls.setLookAt(12,6,8,0,0,-10);const _e=B.get(he);_e.create(A);const U=new W(B);U.world=A;U.url="../../../../../resources/streaming/";async function ye(C,x){const t=await(await fetch(C)).json();let o;o=await(await fetch(x)).json();const s=await U.load(t,!0,o);console.log(s);const r=await s.getProperties(186);console.log(r)}await ye("../../../../../resources/streaming/small.ifc-processed.json","../../../../../resources/streaming/small.ifc-processed-properties.json");A.camera.controls.addEventListener("sleep",()=>{U.culler.needsUpdate=!0});U.useCache=!0;async function Ie(){await U.clearCache(),window.location.reload()}U.culler.threshold=10;U.culler.maxHiddenTime=1e3;U.culler.maxLostTime=4e4;const De=new se,be={clearCache:Ie};De.add(be,"clearCache");const T=new te;T.showPanel(2);document.body.append(T.dom);T.dom.style.left="0px";A.renderer.onBeforeUpdate.add(()=>T.begin());A.renderer.onAfterUpdate.add(()=>T.end());
