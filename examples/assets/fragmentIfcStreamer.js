var J=Object.defineProperty;var K=(A,x,e)=>x in A?J(A,x,{enumerable:!0,configurable:!0,writable:!0,value:e}):A[x]=e;var d=(A,x,e)=>(K(A,typeof x!="symbol"?x+"":x,e),e);import{d as Y,B as $,v as V,a as j,N as z,G as Q,C as O,X as Z,w as q,c as ee,e as H}from"./web-ifc-api-Glg4rFxW.js";import{S as te}from"./stats.min-GTpOrGrX.js";import{g as se}from"./lil-gui.module.min-Bc0DeA9g.js";import{v as oe,K as ie,c as re,J as ne,D as N,b as L,p as ae,u as de,I as ce,s as le,i as me,X as fe,S as he}from"./import-wrapper-prod-DOkjDpKP.js";import"./_commonjsHelpers-Cpj98o6Y.js";class ge extends oe{constructor(e,t,o){super(e,t,o);d(this,"threshold",50);d(this,"bboxThreshold",200);d(this,"maxLostTime",3e4);d(this,"maxHiddenTime",5e3);d(this,"boxes",new Map);d(this,"_geometry");d(this,"_material",new Y({transparent:!0,side:2,opacity:1}));d(this,"onViewUpdated",new ie);d(this,"_modelIDIndex",new Map);d(this,"_indexModelID",new Map);d(this,"_nextModelID",0);d(this,"_geometries",new Map);d(this,"_geometriesGroups",new Map);d(this,"_foundGeometries",new Set);d(this,"_intervalID",null);d(this,"codes",new Map);d(this,"handleWorkerMessage",async e=>{const t=e.data.colors,o={},s={},i={},n={},a=performance.now();let c=!1;const f=new Set(this._foundGeometries);for(const[h,p]of t){const r=this._geometries.get(h);if(!r)continue;const g=p>this.threshold,{exists:u}=r;if(!g&&!u)continue;const m=this._indexModelID.get(r.modelIndex);f.delete(h),g&&u?(r.time=a,n[m]||(n[m]=new Set),n[m].add(r.geometryID),this._foundGeometries.add(h),c=!0):g&&!u?(o[m]||(o[m]=new Map),r.time=a,r.exists=!0,o[m].has(p)||o[m].set(p,new Set),o[m].get(p).add(r.geometryID),this._foundGeometries.add(h),c=!0):!g&&u&&(this.handleLostGeometries(a,h,r,s,i),c=!0)}c&&await this.onViewUpdated.trigger({toLoad:o,toRemove:s,toHide:i,toShow:n}),this._isWorkerBusy=!1});this.updateInterval=500,this._geometry=new $(1,1,1),this._geometry.groups=[],this._geometry.deleteAttribute("uv");const s=this._geometry.attributes.position.array;for(let i=0;i<s.length;i++)s[i]+=.5;this._geometry.attributes.position.needsUpdate=!0,this.worker.addEventListener("message",this.handleWorkerMessage),this.autoUpdate&&(this._intervalID=window.setInterval(this.updateVisibility,this.updateInterval))}dispose(){super.dispose(),this.onViewUpdated.reset(),this._intervalID!==null&&(window.clearInterval(this._intervalID),this._intervalID=null);for(const[e,t]of this._geometriesGroups){t.removeFromParent();const o=[...t.children];for(const s of o)s.removeFromParent()}this._geometriesGroups.clear();for(const[e,t]of this.boxes)t.dispose(!0);this.boxes.clear();for(const[e,t]of this._geometries)t.fragment&&(t.fragment.dispose(!0),t.fragment=void 0);this._geometries.clear(),this._geometry.dispose(),this._material.dispose(),this._modelIDIndex.clear(),this._indexModelID.clear(),this.codes.clear()}add(e,t,o){const s=this.createModelIndex(e),i=V.enabled;V.enabled=!1;const n=new Map,a=new j,c=new z(this._geometry,this._material,10);this.boxes.set(s,c),this.scene.add(c.mesh);const f=new Q;this.scene.add(f),this._geometriesGroups.set(s,f);const h=new Map;for(const r of t)for(const g of r.geometries){const{geometryID:u,transformation:m,color:l}=g,_=new O;_.setRGB(l[0],l[1],l[2],"srgb");const w=this.getInstanceID(r.id,u),D=o[u];if(!D){console.log(`Geometry not found: ${u}`);continue}const{boundingBox:v}=D;let y;n.has(u)?y=n.get(u):(y=this.getAvailableColor(),this.increaseColor(),n.set(u,y));const{r:G,g:b,b:M,code:I}=y,E=new O;E.setRGB(G/255,b/255,M/255,"srgb"),this.codes.has(s)||this.codes.set(s,new Map),this.codes.get(s).set(u,I);const U=new j,R=Object.values(v);if(U.fromArray(m),a.fromArray(R),U.multiply(a),h.has(w)){const F=h.get(w);if(F===void 0||!F.colors)throw new Error("Malformed item!");F.colors.push(E),F.geometryColors.push(_),F.transforms.push(U)}else h.set(w,{id:w,colors:[E],geometryColors:[_],transforms:[U]});if(this._geometries.has(I))this._geometries.get(I).assetIDs.add(r.id);else{const F=new Set([r.id]);this._geometries.set(I,{modelIndex:s,geometryID:u,assetIDs:F,exists:!1,hidden:!1,time:0})}}const p=Array.from(h.values());c.add(p),V.enabled=i}remove(e){const t=this._modelIDIndex.get(e);if(t===void 0)throw new Error("Model doesn't exist!");const o=this._geometriesGroups.get(t);o.removeFromParent();const s=[...o.children];for(const a of s)a.removeFromParent();this._geometriesGroups.delete(t),this.boxes.get(t).dispose(!1),this.boxes.delete(t);const n=this.codes.get(t);this.codes.delete(t);for(const[a,c]of n){const f=this._geometries.get(c);f&&f.fragment&&(f.fragment.dispose(!1),f.fragment=void 0),this._geometries.delete(c)}this._modelIDIndex.delete(e),this._indexModelID.delete(t),this._foundGeometries.clear()}addFragment(e,t,o){const s=V.enabled;V.enabled=!1;const i=this._modelIDIndex.get(e),a=this.codes.get(i).get(t),c=this._geometries.get(a);if(this.setGeometryVisibility(c,!1,!1),!c.fragment){c.fragment=new z(o.mesh.geometry,this._material,o.capacity);const g=this._geometriesGroups.get(i);if(!g)throw new Error("Group not found!");g.add(c.fragment.mesh)}const[f,h,p]=a.split("-").map(g=>parseInt(g,10)),r=[];for(const g of o.ids){const u=o.get(g);if(!u.colors)throw new Error("Malformed fragments!");for(const m of u.colors)m.setRGB(f/255,h/255,p/255,"srgb");r.push(u)}c.fragment.add(r),V.enabled=s,this.needsUpdate=!0}removeFragment(e,t){const o=this._modelIDIndex.get(e),i=this.codes.get(o).get(t),n=this._geometries.get(i);if(n.hidden||this.setGeometryVisibility(n,!0,!1),n.fragment){const{fragment:a}=n;a.dispose(!1),n.fragment=void 0}}setModelTransformation(e,t){const o=this._modelIDIndex.get(e);if(o===void 0)throw new Error("Model not found!");const s=this.boxes.get(o);s&&(s.mesh.position.set(0,0,0),s.mesh.rotation.set(0,0,0),s.mesh.scale.set(1,1,1),s.mesh.applyMatrix4(t));const i=this._geometriesGroups.get(o);i&&(i.position.set(0,0,0),i.rotation.set(0,0,0),i.scale.set(1,1,1),i.applyMatrix4(t))}setVisibility(e,t,o){const s=this._modelIDIndex.get(t);if(s!==void 0)for(const[i,n]of o){const a=this.codes.get(s);if(a===void 0)throw new Error("Map not found!");const c=a.get(i),f=this._geometries.get(c);if(f===void 0)throw new Error("Geometry not found!");f.hidden=!e,this.setGeometryVisibility(f,e,!0,n)}}setGeometryVisibility(e,t,o,s){const{modelIndex:i,geometryID:n,assetIDs:a}=e,c=this.boxes.get(i);if(c===void 0)throw new Error("Model not found!");const f=s||a;if(o&&e.fragment)e.fragment.setVisibility(t,f);else{const h=new Set;for(const p of f){const r=this.getInstanceID(p,n);h.add(r)}c.setVisibility(t,h)}}handleLostGeometries(e,t,o,s,i){const n=this._indexModelID.get(o.modelIndex),a=e-o.time;a>this.maxLostTime?(s[n]||(s[n]=new Set),o.exists=!1,s[n].add(o.geometryID),this._foundGeometries.delete(t)):a>this.maxHiddenTime&&(i[n]||(i[n]=new Set),i[n].add(o.geometryID))}createModelIndex(e){if(this._modelIDIndex.has(e))throw new Error("Can't load the same model twice!");const t=this._nextModelID;return this._nextModelID++,this._modelIDIndex.set(e,t),this._indexModelID.set(t,e),t}getInstanceID(e,t){const s=10**(Math.log(t)*Math.LOG10E+1|0);return e+t/s}}class ue extends re{constructor(){super("MyAppDatabase");d(this,"files");this.version(1).stores({files:"id, file"})}}const T=class T extends ne{constructor(e){super(e);d(this,"enabled",!0);d(this,"onFragmentsDeleted",new N);d(this,"onFragmentsLoaded",new N);d(this,"onDisposed",new N);d(this,"models",{});d(this,"serializer",new Z);d(this,"maxRamTime",5e3);d(this,"useCache",!0);d(this,"_culler",null);d(this,"_world",null);d(this,"_ramCache",new Map);d(this,"_fileCache",new ue);d(this,"_url",null);d(this,"_isDisposing",!1);d(this,"_geometryInstances",{});d(this,"_loadedFragments",{});d(this,"fragIDData",new Map);d(this,"_baseMaterial",new q);d(this,"_baseMaterialT",new q({transparent:!0,opacity:.5}));this.components.add(T.uuid,this)}get url(){if(!this._url)throw new Error("url must be set before using the streaming service!");return this._url}set url(e){this._url=e}get world(){if(!this._world)throw new Error("You must set a world before using the streamer!");return this._world}set world(e){var t;this._world=e,(t=this._culler)==null||t.dispose(),this._culler=new ge(this.components,e),this._culler.onViewUpdated.add(async({toLoad:o,toRemove:s,toShow:i,toHide:n})=>{await this.loadFoundGeometries(o),await this.unloadLostGeometries(s),this.setMeshVisibility(i,!0),this.setMeshVisibility(n,!1)})}get culler(){if(!this._culler)throw new Error("You must set a world before using the streamer!");return this._culler}dispose(){var e;this._isDisposing=!0,this.onFragmentsLoaded.reset(),this.onFragmentsDeleted.reset(),this._ramCache.clear(),this.models={},this._geometryInstances={},this._loadedFragments={},this.fragIDData.clear(),this._baseMaterial.dispose(),this._baseMaterialT.dispose(),(e=this._culler)==null||e.dispose(),this.onDisposed.trigger(T.uuid),this.onDisposed.reset(),this._isDisposing=!1}async load(e,t,o){const{assets:s,geometries:i,globalDataFileId:n}=e,a=this.url+n,f=await(await fetch(a)).arrayBuffer(),h=new Uint8Array(f),r=this.components.get(L).load(h,t);this.world.scene.three.add(r);const{opaque:g,transparent:u}=r.geometryIDs;for(const[l,_]of g){const w=r.keyFragments.get(_);if(w===void 0)throw new Error("Malformed fragments group!");this.fragIDData.set(w,[r,l,new Set])}for(const[l,_]of u){const w=r.keyFragments.get(_);if(w===void 0)throw new Error("Malformed fragments group!");this.fragIDData.set(w,[r,Math.abs(l),new Set])}this.culler.add(r.uuid,s,i),this.models[r.uuid]={assets:s,geometries:i};const m=new Map;for(const l of s){const _=l.id;for(const{transformation:w,geometryID:D,color:v}of l.geometries){m.has(D)||m.set(D,[]);const y=m.get(D);if(!y)throw new Error("Malformed instances");y.push({id:_,transformation:w,color:v})}}if(this._geometryInstances[r.uuid]=m,o){const l=new Map,_=new Map;for(const b in o.ids){const M=o.ids[b],I=parseInt(b,10);l.set(I,M)}for(const b in o.types){const M=o.types[b],I=parseInt(b,10);_.set(I,M)}const w=n.replace("-global","-properties");r.streamSettings={baseUrl:this.url,baseFileName:w,ids:l,types:_};const{indexesFile:D}=o,y=await(await fetch(this.url+D)).text(),G=this.components.get(ae);G.relationMaps[r.uuid]=G.getRelationsMapFromJSON(y)}return this.culler.needsUpdate=!0,r}remove(e){this._isDisposing=!0;const o=this.components.get(L).groups.get(e);if(o===void 0){console.log("Group to delete not found.");return}delete this.models[e],delete this._geometryInstances[e],delete this._loadedFragments[e];const s=o.keyFragments.values();for(const i of s)this.fragIDData.delete(i);this.culler.remove(e),this._isDisposing=!1}setVisibility(e,t){const o=new Map;for(const s in t){const i=this.fragIDData.get(s);if(i===void 0)throw new Error("Geometry not found!");const[n,a,c]=i,f=n.uuid;o.has(f)||o.set(f,new Map);const h=o.get(f),p=t[s];for(const g of p)e?c.delete(g):c.add(g);h.get(a)||h.set(a,new Set);const r=h.get(a);for(const g of p)r.add(g)}for(const[s,i]of o){this.culler.setVisibility(e,s,i);for(const[n]of i){const a=this._loadedFragments[s];if(!a)continue;const c=a[n];if(c)for(const f of c){const h=t[f.id];h&&f.setVisibility(e,h)}}}this.culler.needsUpdate=!0}async clearCache(){await this._fileCache.delete()}get(){}update(){}async loadFoundGeometries(e){for(const t in e){if(this._isDisposing)return;const s=this.components.get(L).groups.get(t);if(!s)return;const{geometries:i}=this.models[t],n=new Map,a=new Set;for(const[p,r]of e[t])for(const g of r){a.add(g);const u=i[g];if(!u)throw new Error("Geometry not found");if(u.geometryFile){const m=u.geometryFile,l=n.get(m)||0;n.set(m,l+p)}}const c=Array.from(n).sort((p,r)=>r[1]-p[1]);for(const[p]of c){const r=this.url+p;if(!this._ramCache.has(r)){let m=new Uint8Array;if(this.useCache){const _=await this._fileCache.files.get(r);if(_)m=_.file;else{const D=await(await fetch(r)).arrayBuffer();m=new Uint8Array(D),this._fileCache.files.add({file:m,id:r})}}else{const w=await(await fetch(r)).arrayBuffer();m=new Uint8Array(w)}const l=this.serializer.import(m);this._ramCache.set(r,{data:l,time:performance.now()})}const g=this._ramCache.get(r);if(!g)continue;g.time=performance.now();const u=[];if(g)for(const[m,{position:l,index:_,normal:w}]of g.data){if(this._isDisposing)return;if(!a.has(m)||!this._geometryInstances[t]||!this._geometryInstances[t].has(m))continue;const v=this._geometryInstances[t].get(m);if(!v)throw new Error("Instances not found!");const y=new ee,G=new H(l,3),b=new H(w,3);y.setAttribute("position",G),y.setAttribute("normal",b),y.setIndex(Array.from(_));const M=[],I=[];for(const E of v)E.color[3]===1?I.push(E):M.push(E);this.newFragment(s,m,y,M,!0,u),this.newFragment(s,m,y,I,!1,u)}u.length&&!this._isDisposing&&this.onFragmentsLoaded.trigger(u)}const f=new Set,h=performance.now();for(const[p,{time:r}]of this._ramCache)h-r>this.maxRamTime&&f.add(p);for(const p of f)this._ramCache.delete(p)}}async unloadLostGeometries(e){if(this._isDisposing)return;const t=[],o=this.components.get(L);for(const s in e){const i=o.groups.get(s);if(!i)throw new Error("Fragment group not found!");if(!this._loadedFragments[s])continue;const n=this._loadedFragments[s],a=e[s];for(const c of a){if(this.culler.removeFragment(i.uuid,c),!n[c])continue;const f=n[c];for(const h of f)i.items.splice(i.items.indexOf(h),1),t.push(h);delete n[c]}}t.length&&this.onFragmentsDeleted.trigger(t);for(const s of t)o.list.delete(s.id),this.world.meshes.delete(s.mesh),s.mesh.material=[],s.dispose(!0)}setMeshVisibility(e,t){for(const o in e)for(const s of e[o]){const i=this._loadedFragments[o];if(!i)continue;const n=i[s];if(n)for(const a of n)a.mesh.visible=t}}newFragment(e,t,o,s,i,n){if(s.length===0||this._isDisposing)return;const a=e.geometryIDs,c=i?a.transparent:a.opaque,h=t*(i?-1:1),p=c.get(h);if(p===void 0)return;const r=e.keyFragments.get(p);if(r===void 0)return;const g=this.components.get(L);if(g.list.has(r))return;const m=i?this._baseMaterialT:this._baseMaterial,l=new z(o,m,s.length);l.id=r,l.mesh.uuid=r,l.group=e,e.add(l.mesh),e.items.push(l),g.list.set(l.id,l),this.world.meshes.add(l.mesh),this._loadedFragments[e.uuid]||(this._loadedFragments[e.uuid]={});const _=this._loadedFragments[e.uuid];_[t]||(_[t]=[]),_[t].push(l);const w=new Map;for(let G=0;G<s.length;G++){const b=new j,M=new O,{id:I,transformation:E,color:X}=s[G];b.fromArray(E);const[U,R,F]=X;if(M.setRGB(U,R,F,"srgb"),w.has(I)){const P=w.get(I);if(!P)continue;P.transforms.push(b),P.colors&&P.colors.push(M)}else w.set(I,{id:I,colors:[M],transforms:[b]})}const D=Array.from(w.values());l.add(D);const v=this.fragIDData.get(l.id);if(!v)throw new Error("Fragment data not found!");const y=v[2];y.size&&l.setVisibility(!1,y),this.culler.addFragment(e.uuid,t,l),n.push(l)}};d(T,"uuid","22437e8d-9dbc-4b99-a04f-d2da280d50c8");let W=T;const pe=document.getElementById("container"),S=new de,we=S.get(ce),C=we.create();C.scene=new le(S);C.renderer=new me(S,pe);C.camera=new fe(S);S.init();C.scene.setup();C.camera.controls.setLookAt(12,6,8,0,0,-10);const _e=S.get(he);_e.create(C);const B=new W(S);B.world=C;B.url="../../../../../resources/streaming/";async function ye(A,x){const t=await(await fetch(A)).json();let o;o=await(await fetch(x)).json();const s=await B.load(t,!0,o);console.log(s);const i=await s.getProperties(186);console.log(i)}await ye("../../../../../resources/streaming/small.ifc-processed.json","../../../../../resources/streaming/small.ifc-processed-properties.json");C.camera.controls.addEventListener("sleep",()=>{B.culler.needsUpdate=!0});B.useCache=!0;async function Ie(){await B.clearCache(),window.location.reload()}B.culler.threshold=10;B.culler.maxHiddenTime=1e3;B.culler.maxLostTime=4e4;const De=new se,be={clearCache:Ie};De.add(be,"clearCache");const k=new te;k.showPanel(2);document.body.append(k.dom);k.dom.style.left="0px";C.renderer.onBeforeUpdate.add(()=>k.begin());C.renderer.onAfterUpdate.add(()=>k.end());
