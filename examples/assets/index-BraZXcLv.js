var qs=Object.defineProperty;var $s=(n,e,t)=>e in n?qs(n,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):n[e]=t;var U=(n,e,t)=>($s(n,typeof e!="symbol"?e+"":e,t),t);import{e as Rs,V as S,f as ht,P as Is,r as lt,T as Gt,y as Hs,a as ut,p as st,aO as Ks,Z as ks,ar as rs,M as Je,as as Gs,u as Qs,c as as,C as Ee,n as js,a_ as Js,a$ as ti,ah as cs,o as ei,at as si,au as ii,v as ni,Q as oi,av as ri,z as ai,h as ci,m as li,q as hi}from"./web-ifc-api-BC8YMRiS.js";const Vs=0,ui=1,di=2,ls=2,Ue=1.25,hs=1,we=6*4+4+4,be=65535,fi=Math.pow(2,-24),De=Symbol("SKIP_GENERATION");function pi(n){return n.index?n.index.count:n.attributes.position.count}function Bt(n){return pi(n)/3}function mi(n,e=ArrayBuffer){return n>65535?new Uint32Array(new e(4*n)):new Uint16Array(new e(2*n))}function _i(n,e){if(!n.index){const t=n.attributes.position.count,s=e.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,i=mi(t,s);n.setIndex(new Rs(i,1));for(let r=0;r<t;r++)i[r]=r}}function Ys(n){const e=Bt(n),t=n.drawRange,s=t.start/3,i=(t.start+t.count)/3,r=Math.max(0,s),o=Math.min(e,i)-r;return[{offset:Math.floor(r),count:Math.floor(o)}]}function Ns(n){if(!n.groups||!n.groups.length)return Ys(n);const e=[],t=new Set,s=n.drawRange,i=s.start/3,r=(s.start+s.count)/3;for(const a of n.groups){const c=a.start/3,f=(a.start+a.count)/3;t.add(Math.max(i,c)),t.add(Math.min(r,f))}const o=Array.from(t.values()).sort((a,c)=>a-c);for(let a=0;a<o.length-1;a++){const c=o[a],f=o[a+1];e.push({offset:Math.floor(c),count:Math.floor(f-c)})}return e}function yi(n){if(n.groups.length===0)return!1;const e=Bt(n),t=Ns(n).sort((r,o)=>r.offset-o.offset),s=t[t.length-1];s.count=Math.min(e-s.offset,s.count);let i=0;return t.forEach(({count:r})=>i+=r),e!==i}function N(n,e,t){return t.min.x=e[n],t.min.y=e[n+1],t.min.z=e[n+2],t.max.x=e[n+3],t.max.y=e[n+4],t.max.z=e[n+5],t}function gi(n){n[0]=n[1]=n[2]=1/0,n[3]=n[4]=n[5]=-1/0}function us(n){let e=-1,t=-1/0;for(let s=0;s<3;s++){const i=n[s+3]-n[s];i>t&&(t=i,e=s)}return e}function ds(n,e){e.set(n)}function fs(n,e,t){let s,i;for(let r=0;r<3;r++){const o=r+3;s=n[r],i=e[r],t[r]=s<i?s:i,s=n[o],i=e[o],t[o]=s>i?s:i}}function ee(n,e,t){for(let s=0;s<3;s++){const i=e[n+2*s],r=e[n+2*s+1],o=i-r,a=i+r;o<t[s]&&(t[s]=o),a>t[s+3]&&(t[s+3]=a)}}function Ht(n){const e=n[3]-n[0],t=n[4]-n[1],s=n[5]-n[2];return 2*(e*t+t*s+s*e)}function Le(n,e,t,s,i=null){let r=1/0,o=1/0,a=1/0,c=-1/0,f=-1/0,d=-1/0,u=1/0,l=1/0,p=1/0,y=-1/0,O=-1/0,T=-1/0;const _=i!==null;for(let g=e*6,E=(e+t)*6;g<E;g+=6){const h=n[g+0],m=n[g+1],w=h-m,x=h+m;w<r&&(r=w),x>c&&(c=x),_&&h<u&&(u=h),_&&h>y&&(y=h);const C=n[g+2],v=n[g+3],b=C-v,D=C+v;b<o&&(o=b),D>f&&(f=D),_&&C<l&&(l=C),_&&C>O&&(O=C);const P=n[g+4],L=n[g+5],M=P-L,R=P+L;M<a&&(a=M),R>d&&(d=R),_&&P<p&&(p=P),_&&P>T&&(T=P)}s[0]=r,s[1]=o,s[2]=a,s[3]=c,s[4]=f,s[5]=d,_&&(i[0]=u,i[1]=l,i[2]=p,i[3]=y,i[4]=O,i[5]=T)}function Ti(n,e,t,s){let i=1/0,r=1/0,o=1/0,a=-1/0,c=-1/0,f=-1/0;for(let d=e*6,u=(e+t)*6;d<u;d+=6){const l=n[d+0];l<i&&(i=l),l>a&&(a=l);const p=n[d+2];p<r&&(r=p),p>c&&(c=p);const y=n[d+4];y<o&&(o=y),y>f&&(f=y)}s[0]=i,s[1]=r,s[2]=o,s[3]=a,s[4]=c,s[5]=f}function Ei(n,e){gi(e);const t=n.attributes.position,s=n.index?n.index.array:null,i=Bt(n),r=new Float32Array(i*6),o=t.normalized,a=t.array,c=t.offset||0;let f=3;t.isInterleavedBufferAttribute&&(f=t.data.stride);const d=["getX","getY","getZ"];for(let u=0;u<i;u++){const l=u*3,p=u*6;let y=l+0,O=l+1,T=l+2;s&&(y=s[y],O=s[O],T=s[T]),o||(y=y*f+c,O=O*f+c,T=T*f+c);for(let _=0;_<3;_++){let g,E,h;o?(g=t[d[_]](y),E=t[d[_]](O),h=t[d[_]](T)):(g=a[y+_],E=a[O+_],h=a[T+_]);let m=g;E<m&&(m=E),h<m&&(m=h);let w=g;E>w&&(w=E),h>w&&(w=h);const x=(w-m)/2,C=_*2;r[p+C+0]=m+x,r[p+C+1]=x+(Math.abs(m)+x)*fi,m<e[_]&&(e[_]=m),w>e[_+3]&&(e[_+3]=w)}}return r}const ct=32,wi=(n,e)=>n.candidate-e.candidate,ft=new Array(ct).fill().map(()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0})),se=new Float32Array(6);function xi(n,e,t,s,i,r){let o=-1,a=0;if(r===Vs)o=us(e),o!==-1&&(a=(e[o]+e[o+3])/2);else if(r===ui)o=us(n),o!==-1&&(a=Oi(t,s,i,o));else if(r===di){const c=Ht(n);let f=Ue*i;const d=s*6,u=(s+i)*6;for(let l=0;l<3;l++){const p=e[l],T=(e[l+3]-p)/ct;if(i<ct/4){const _=[...ft];_.length=i;let g=0;for(let h=d;h<u;h+=6,g++){const m=_[g];m.candidate=t[h+2*l],m.count=0;const{bounds:w,leftCacheBounds:x,rightCacheBounds:C}=m;for(let v=0;v<3;v++)C[v]=1/0,C[v+3]=-1/0,x[v]=1/0,x[v+3]=-1/0,w[v]=1/0,w[v+3]=-1/0;ee(h,t,w)}_.sort(wi);let E=i;for(let h=0;h<E;h++){const m=_[h];for(;h+1<E&&_[h+1].candidate===m.candidate;)_.splice(h+1,1),E--}for(let h=d;h<u;h+=6){const m=t[h+2*l];for(let w=0;w<E;w++){const x=_[w];m>=x.candidate?ee(h,t,x.rightCacheBounds):(ee(h,t,x.leftCacheBounds),x.count++)}}for(let h=0;h<E;h++){const m=_[h],w=m.count,x=i-m.count,C=m.leftCacheBounds,v=m.rightCacheBounds;let b=0;w!==0&&(b=Ht(C)/c);let D=0;x!==0&&(D=Ht(v)/c);const P=hs+Ue*(b*w+D*x);P<f&&(o=l,f=P,a=m.candidate)}}else{for(let E=0;E<ct;E++){const h=ft[E];h.count=0,h.candidate=p+T+E*T;const m=h.bounds;for(let w=0;w<3;w++)m[w]=1/0,m[w+3]=-1/0}for(let E=d;E<u;E+=6){let w=~~((t[E+2*l]-p)/T);w>=ct&&(w=ct-1);const x=ft[w];x.count++,ee(E,t,x.bounds)}const _=ft[ct-1];ds(_.bounds,_.rightCacheBounds);for(let E=ct-2;E>=0;E--){const h=ft[E],m=ft[E+1];fs(h.bounds,m.rightCacheBounds,h.rightCacheBounds)}let g=0;for(let E=0;E<ct-1;E++){const h=ft[E],m=h.count,w=h.bounds,C=ft[E+1].rightCacheBounds;m!==0&&(g===0?ds(w,se):fs(w,se,se)),g+=m;let v=0,b=0;g!==0&&(v=Ht(se)/c);const D=i-g;D!==0&&(b=Ht(C)/c);const P=hs+Ue*(v*g+b*D);P<f&&(o=l,f=P,a=h.candidate)}}}}else console.warn(`MeshBVH: Invalid build strategy value ${r} used.`);return{axis:o,pos:a}}function Oi(n,e,t,s){let i=0;for(let r=e,o=e+t;r<o;r++)i+=n[r*6+s*2];return i/t}class ie{constructor(){}}function Ai(n,e,t,s,i,r){let o=s,a=s+i-1;const c=r.pos,f=r.axis*2;for(;;){for(;o<=a&&t[o*6+f]<c;)o++;for(;o<=a&&t[a*6+f]>=c;)a--;if(o<a){for(let d=0;d<3;d++){let u=e[o*3+d];e[o*3+d]=e[a*3+d],e[a*3+d]=u}for(let d=0;d<6;d++){let u=t[o*6+d];t[o*6+d]=t[a*6+d],t[a*6+d]=u}o++,a--}else return o}}function Ci(n,e,t,s,i,r){let o=s,a=s+i-1;const c=r.pos,f=r.axis*2;for(;;){for(;o<=a&&t[o*6+f]<c;)o++;for(;o<=a&&t[a*6+f]>=c;)a--;if(o<a){let d=n[o];n[o]=n[a],n[a]=d;for(let u=0;u<6;u++){let l=t[o*6+u];t[o*6+u]=t[a*6+u],t[a*6+u]=l}o++,a--}else return o}}function vi(n,e){const t=(n.index?n.index.count:n.attributes.position.count)/3,s=t>2**16,i=s?4:2,r=e?new SharedArrayBuffer(t*i):new ArrayBuffer(t*i),o=s?new Uint32Array(r):new Uint16Array(r);for(let a=0,c=o.length;a<c;a++)o[a]=a;return o}function bi(n,e){const t=n.geometry,s=t.index?t.index.array:null,i=e.maxDepth,r=e.verbose,o=e.maxLeafTris,a=e.strategy,c=e.onProgress,f=Bt(t),d=n._indirectBuffer;let u=!1;const l=new Float32Array(6),p=new Float32Array(6),y=Ei(t,l),O=e.indirect?Ci:Ai,T=[],_=e.indirect?Ys(t):Ns(t);if(_.length===1){const h=_[0],m=new ie;m.boundingData=l,Ti(y,h.offset,h.count,p),E(m,h.offset,h.count,p),T.push(m)}else for(let h of _){const m=new ie;m.boundingData=new Float32Array(6),Le(y,h.offset,h.count,m.boundingData,p),E(m,h.offset,h.count,p),T.push(m)}return T;function g(h){c&&c(h/f)}function E(h,m,w,x=null,C=0){if(!u&&C>=i&&(u=!0,r&&(console.warn(`MeshBVH: Max depth of ${i} reached when generating BVH. Consider increasing maxDepth.`),console.warn(t))),w<=o||C>=i)return g(m+w),h.offset=m,h.count=w,h;const v=xi(h.boundingData,x,y,m,w,a);if(v.axis===-1)return g(m+w),h.offset=m,h.count=w,h;const b=O(d,s,y,m,w,v);if(b===m||b===m+w)g(m+w),h.offset=m,h.count=w;else{h.splitAxis=v.axis;const D=new ie,P=m,L=b-m;h.left=D,D.boundingData=new Float32Array(6),Le(y,P,L,D.boundingData,p),E(D,P,L,p,C+1);const M=new ie,R=b,Z=w-L;h.right=M,M.boundingData=new Float32Array(6),Le(y,R,Z,M.boundingData,p),E(M,R,Z,p,C+1)}return h}}function Pi(n,e){const t=n.geometry;e.indirect&&(n._indirectBuffer=vi(t,e.useSharedArrayBuffer),yi(t)&&!e.verbose&&console.warn('MeshBVH: Provided geometry contains groups that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.')),n._indirectBuffer||_i(t,e);const s=bi(n,e);let i,r,o;const a=[],c=e.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer;for(let u=0;u<s.length;u++){const l=s[u];let p=f(l);const y=new c(we*p);i=new Float32Array(y),r=new Uint32Array(y),o=new Uint16Array(y),d(0,l),a.push(y)}n._roots=a;return;function f(u){return u.count?1:1+f(u.left)+f(u.right)}function d(u,l){const p=u/4,y=u/2,O=!!l.count,T=l.boundingData;for(let _=0;_<6;_++)i[p+_]=T[_];if(O){const _=l.offset,g=l.count;return r[p+6]=_,o[y+14]=g,o[y+15]=be,u+we}else{const _=l.left,g=l.right,E=l.splitAxis;let h;if(h=d(u+we,_),h/4>Math.pow(2,32))throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return r[p+6]=h/4,h=d(h,g),r[p+7]=E,h}}}class dt{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(e,t){let s=1/0,i=-1/0;for(let r=0,o=e.length;r<o;r++){const c=e[r][t];s=c<s?c:s,i=c>i?c:i}this.min=s,this.max=i}setFromPoints(e,t){let s=1/0,i=-1/0;for(let r=0,o=t.length;r<o;r++){const a=t[r],c=e.dot(a);s=c<s?c:s,i=c>i?c:i}this.min=s,this.max=i}isSeparated(e){return this.min>e.max||e.min>this.max}}dt.prototype.setFromBox=function(){const n=new S;return function(t,s){const i=s.min,r=s.max;let o=1/0,a=-1/0;for(let c=0;c<=1;c++)for(let f=0;f<=1;f++)for(let d=0;d<=1;d++){n.x=i.x*c+r.x*(1-c),n.y=i.y*f+r.y*(1-f),n.z=i.z*d+r.z*(1-d);const u=t.dot(n);o=Math.min(u,o),a=Math.max(u,a)}this.min=o,this.max=a}}();const Ui=function(){const n=new S,e=new S,t=new S;return function(i,r,o){const a=i.start,c=n,f=r.start,d=e;t.subVectors(a,f),n.subVectors(i.end,i.start),e.subVectors(r.end,r.start);const u=t.dot(d),l=d.dot(c),p=d.dot(d),y=t.dot(c),T=c.dot(c)*p-l*l;let _,g;T!==0?_=(u*l-y*p)/T:_=0,g=(u+_*l)/p,o.x=_,o.y=g}}(),ts=function(){const n=new ht,e=new S,t=new S;return function(i,r,o,a){Ui(i,r,n);let c=n.x,f=n.y;if(c>=0&&c<=1&&f>=0&&f<=1){i.at(c,o),r.at(f,a);return}else if(c>=0&&c<=1){f<0?r.at(0,a):r.at(1,a),i.closestPointToPoint(a,!0,o);return}else if(f>=0&&f<=1){c<0?i.at(0,o):i.at(1,o),r.closestPointToPoint(o,!0,a);return}else{let d;c<0?d=i.start:d=i.end;let u;f<0?u=r.start:u=r.end;const l=e,p=t;if(i.closestPointToPoint(u,!0,e),r.closestPointToPoint(d,!0,t),l.distanceToSquared(u)<=p.distanceToSquared(d)){o.copy(l),a.copy(u);return}else{o.copy(d),a.copy(p);return}}}}(),Di=function(){const n=new S,e=new S,t=new Is,s=new lt;return function(r,o){const{radius:a,center:c}=r,{a:f,b:d,c:u}=o;if(s.start=f,s.end=d,s.closestPointToPoint(c,!0,n).distanceTo(c)<=a||(s.start=f,s.end=u,s.closestPointToPoint(c,!0,n).distanceTo(c)<=a)||(s.start=d,s.end=u,s.closestPointToPoint(c,!0,n).distanceTo(c)<=a))return!0;const O=o.getPlane(t);if(Math.abs(O.distanceToPoint(c))<=a){const _=O.projectPoint(c,e);if(o.containsPoint(_))return!0}return!1}}(),Li=1e-15;function Se(n){return Math.abs(n)<Li}class ot extends Gt{constructor(...e){super(...e),this.isExtendedTriangle=!0,this.satAxes=new Array(4).fill().map(()=>new S),this.satBounds=new Array(4).fill().map(()=>new dt),this.points=[this.a,this.b,this.c],this.sphere=new Hs,this.plane=new Is,this.needsUpdate=!0}intersectsSphere(e){return Di(e,this)}update(){const e=this.a,t=this.b,s=this.c,i=this.points,r=this.satAxes,o=this.satBounds,a=r[0],c=o[0];this.getNormal(a),c.setFromPoints(a,i);const f=r[1],d=o[1];f.subVectors(e,t),d.setFromPoints(f,i);const u=r[2],l=o[2];u.subVectors(t,s),l.setFromPoints(u,i);const p=r[3],y=o[3];p.subVectors(s,e),y.setFromPoints(p,i),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(a,e),this.needsUpdate=!1}}ot.prototype.closestPointToSegment=function(){const n=new S,e=new S,t=new lt;return function(i,r=null,o=null){const{start:a,end:c}=i,f=this.points;let d,u=1/0;for(let l=0;l<3;l++){const p=(l+1)%3;t.start.copy(f[l]),t.end.copy(f[p]),ts(t,i,n,e),d=n.distanceToSquared(e),d<u&&(u=d,r&&r.copy(n),o&&o.copy(e))}return this.closestPointToPoint(a,n),d=a.distanceToSquared(n),d<u&&(u=d,r&&r.copy(n),o&&o.copy(a)),this.closestPointToPoint(c,n),d=c.distanceToSquared(n),d<u&&(u=d,r&&r.copy(n),o&&o.copy(c)),Math.sqrt(u)}}();ot.prototype.intersectsTriangle=function(){const n=new ot,e=new Array(3),t=new Array(3),s=new dt,i=new dt,r=new S,o=new S,a=new S,c=new S,f=new S,d=new lt,u=new lt,l=new lt,p=new S;function y(O,T,_){const g=O.points;let E=0,h=-1;for(let m=0;m<3;m++){const{start:w,end:x}=d;w.copy(g[m]),x.copy(g[(m+1)%3]),d.delta(o);const C=Se(T.distanceToPoint(w));if(Se(T.normal.dot(o))&&C){_.copy(d),E=2;break}const v=T.intersectLine(d,p);if(!v&&C&&p.copy(w),(v||C)&&!Se(p.distanceTo(x))){if(E<=1)(E===1?_.start:_.end).copy(p),C&&(h=E);else if(E>=2){(h===1?_.start:_.end).copy(p),E=2;break}if(E++,E===2&&h===-1)break}}return E}return function(T,_=null,g=!1){this.needsUpdate&&this.update(),T.isExtendedTriangle?T.needsUpdate&&T.update():(n.copy(T),n.update(),T=n);const E=this.plane,h=T.plane;if(Math.abs(E.normal.dot(h.normal))>1-1e-10){const m=this.satBounds,w=this.satAxes;t[0]=T.a,t[1]=T.b,t[2]=T.c;for(let v=0;v<4;v++){const b=m[v],D=w[v];if(s.setFromPoints(D,t),b.isSeparated(s))return!1}const x=T.satBounds,C=T.satAxes;e[0]=this.a,e[1]=this.b,e[2]=this.c;for(let v=0;v<4;v++){const b=x[v],D=C[v];if(s.setFromPoints(D,e),b.isSeparated(s))return!1}for(let v=0;v<4;v++){const b=w[v];for(let D=0;D<4;D++){const P=C[D];if(r.crossVectors(b,P),s.setFromPoints(r,e),i.setFromPoints(r,t),s.isSeparated(i))return!1}}return _&&(g||console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),_.start.set(0,0,0),_.end.set(0,0,0)),!0}else{const m=y(this,h,u);if(m===1&&T.containsPoint(u.end))return _&&(_.start.copy(u.end),_.end.copy(u.end)),!0;if(m!==2)return!1;const w=y(T,E,l);if(w===1&&this.containsPoint(l.end))return _&&(_.start.copy(l.end),_.end.copy(l.end)),!0;if(w!==2)return!1;if(u.delta(a),l.delta(c),a.dot(c)<0){let L=l.start;l.start=l.end,l.end=L}const x=u.start.dot(a),C=u.end.dot(a),v=l.start.dot(a),b=l.end.dot(a),D=C<v,P=x<b;return x!==b&&v!==C&&D===P?!1:(_&&(f.subVectors(u.start,l.start),f.dot(a)>0?_.start.copy(u.start):_.start.copy(l.start),f.subVectors(u.end,l.end),f.dot(a)<0?_.end.copy(u.end):_.end.copy(l.end)),!0)}}}();ot.prototype.distanceToPoint=function(){const n=new S;return function(t){return this.closestPointToPoint(t,n),t.distanceTo(n)}}();ot.prototype.distanceToTriangle=function(){const n=new S,e=new S,t=["a","b","c"],s=new lt,i=new lt;return function(o,a=null,c=null){const f=a||c?s:null;if(this.intersectsTriangle(o,f))return(a||c)&&(a&&f.getCenter(a),c&&f.getCenter(c)),0;let d=1/0;for(let u=0;u<3;u++){let l;const p=t[u],y=o[p];this.closestPointToPoint(y,n),l=y.distanceToSquared(n),l<d&&(d=l,a&&a.copy(n),c&&c.copy(y));const O=this[p];o.closestPointToPoint(O,n),l=O.distanceToSquared(n),l<d&&(d=l,a&&a.copy(O),c&&c.copy(n))}for(let u=0;u<3;u++){const l=t[u],p=t[(u+1)%3];s.set(this[l],this[p]);for(let y=0;y<3;y++){const O=t[y],T=t[(y+1)%3];i.set(o[O],o[T]),ts(s,i,n,e);const _=n.distanceToSquared(e);_<d&&(d=_,a&&a.copy(n),c&&c.copy(e))}}return Math.sqrt(d)}}();class q{constructor(e,t,s){this.isOrientedBox=!0,this.min=new S,this.max=new S,this.matrix=new ut,this.invMatrix=new ut,this.points=new Array(8).fill().map(()=>new S),this.satAxes=new Array(3).fill().map(()=>new S),this.satBounds=new Array(3).fill().map(()=>new dt),this.alignedSatBounds=new Array(3).fill().map(()=>new dt),this.needsUpdate=!1,e&&this.min.copy(e),t&&this.max.copy(t),s&&this.matrix.copy(s)}set(e,t,s){this.min.copy(e),this.max.copy(t),this.matrix.copy(s),this.needsUpdate=!0}copy(e){this.min.copy(e.min),this.max.copy(e.max),this.matrix.copy(e.matrix),this.needsUpdate=!0}}q.prototype.update=function(){return function(){const e=this.matrix,t=this.min,s=this.max,i=this.points;for(let f=0;f<=1;f++)for(let d=0;d<=1;d++)for(let u=0;u<=1;u++){const l=1*f|2*d|4*u,p=i[l];p.x=f?s.x:t.x,p.y=d?s.y:t.y,p.z=u?s.z:t.z,p.applyMatrix4(e)}const r=this.satBounds,o=this.satAxes,a=i[0];for(let f=0;f<3;f++){const d=o[f],u=r[f],l=1<<f,p=i[l];d.subVectors(a,p),u.setFromPoints(d,i)}const c=this.alignedSatBounds;c[0].setFromPointsField(i,"x"),c[1].setFromPointsField(i,"y"),c[2].setFromPointsField(i,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1}}();q.prototype.intersectsBox=function(){const n=new dt;return function(t){this.needsUpdate&&this.update();const s=t.min,i=t.max,r=this.satBounds,o=this.satAxes,a=this.alignedSatBounds;if(n.min=s.x,n.max=i.x,a[0].isSeparated(n)||(n.min=s.y,n.max=i.y,a[1].isSeparated(n))||(n.min=s.z,n.max=i.z,a[2].isSeparated(n)))return!1;for(let c=0;c<3;c++){const f=o[c],d=r[c];if(n.setFromBox(f,t),d.isSeparated(n))return!1}return!0}}();q.prototype.intersectsTriangle=function(){const n=new ot,e=new Array(3),t=new dt,s=new dt,i=new S;return function(o){this.needsUpdate&&this.update(),o.isExtendedTriangle?o.needsUpdate&&o.update():(n.copy(o),n.update(),o=n);const a=this.satBounds,c=this.satAxes;e[0]=o.a,e[1]=o.b,e[2]=o.c;for(let l=0;l<3;l++){const p=a[l],y=c[l];if(t.setFromPoints(y,e),p.isSeparated(t))return!1}const f=o.satBounds,d=o.satAxes,u=this.points;for(let l=0;l<3;l++){const p=f[l],y=d[l];if(t.setFromPoints(y,u),p.isSeparated(t))return!1}for(let l=0;l<3;l++){const p=c[l];for(let y=0;y<4;y++){const O=d[y];if(i.crossVectors(p,O),t.setFromPoints(i,e),s.setFromPoints(i,u),t.isSeparated(s))return!1}}return!0}}();q.prototype.closestPointToPoint=function(){return function(e,t){return this.needsUpdate&&this.update(),t.copy(e).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),t}}();q.prototype.distanceToPoint=function(){const n=new S;return function(t){return this.closestPointToPoint(t,n),t.distanceTo(n)}}();q.prototype.distanceToBox=function(){const n=["x","y","z"],e=new Array(12).fill().map(()=>new lt),t=new Array(12).fill().map(()=>new lt),s=new S,i=new S;return function(o,a=0,c=null,f=null){if(this.needsUpdate&&this.update(),this.intersectsBox(o))return(c||f)&&(o.getCenter(i),this.closestPointToPoint(i,s),o.closestPointToPoint(s,i),c&&c.copy(s),f&&f.copy(i)),0;const d=a*a,u=o.min,l=o.max,p=this.points;let y=1/0;for(let T=0;T<8;T++){const _=p[T];i.copy(_).clamp(u,l);const g=_.distanceToSquared(i);if(g<y&&(y=g,c&&c.copy(_),f&&f.copy(i),g<d))return Math.sqrt(g)}let O=0;for(let T=0;T<3;T++)for(let _=0;_<=1;_++)for(let g=0;g<=1;g++){const E=(T+1)%3,h=(T+2)%3,m=_<<E|g<<h,w=1<<T|_<<E|g<<h,x=p[m],C=p[w];e[O].set(x,C);const b=n[T],D=n[E],P=n[h],L=t[O],M=L.start,R=L.end;M[b]=u[b],M[D]=_?u[D]:l[D],M[P]=g?u[P]:l[D],R[b]=l[b],R[D]=_?u[D]:l[D],R[P]=g?u[P]:l[D],O++}for(let T=0;T<=1;T++)for(let _=0;_<=1;_++)for(let g=0;g<=1;g++){i.x=T?l.x:u.x,i.y=_?l.y:u.y,i.z=g?l.z:u.z,this.closestPointToPoint(i,s);const E=i.distanceToSquared(s);if(E<y&&(y=E,c&&c.copy(s),f&&f.copy(i),E<d))return Math.sqrt(E)}for(let T=0;T<12;T++){const _=e[T];for(let g=0;g<12;g++){const E=t[g];ts(_,E,s,i);const h=s.distanceToSquared(i);if(h<y&&(y=h,c&&c.copy(s),f&&f.copy(i),h<d))return Math.sqrt(h)}}return Math.sqrt(y)}}();class es{constructor(e){this._getNewPrimitive=e,this._primitives=[]}getPrimitive(){const e=this._primitives;return e.length===0?this._getNewPrimitive():e.pop()}releasePrimitive(e){this._primitives.push(e)}}class Si extends es{constructor(){super(()=>new ot)}}const j=new Si;function K(n,e){return e[n+15]===65535}function G(n,e){return e[n+6]}function J(n,e){return e[n+14]}function tt(n){return n+8}function et(n,e){return e[n+6]}function Zs(n,e){return e[n+7]}class Mi{constructor(){this.float32Array=null,this.uint16Array=null,this.uint32Array=null;const e=[];let t=null;this.setBuffer=s=>{t&&e.push(t),t=s,this.float32Array=new Float32Array(s),this.uint16Array=new Uint16Array(s),this.uint32Array=new Uint32Array(s)},this.clearBuffer=()=>{t=null,this.float32Array=null,this.uint16Array=null,this.uint32Array=null,e.length!==0&&this.setBuffer(e.pop())}}}const V=new Mi;let _t,zt;const Et=[],ne=new es(()=>new st);function zi(n,e,t,s,i,r){_t=ne.getPrimitive(),zt=ne.getPrimitive(),Et.push(_t,zt),V.setBuffer(n._roots[e]);const o=We(0,n.geometry,t,s,i,r);V.clearBuffer(),ne.releasePrimitive(_t),ne.releasePrimitive(zt),Et.pop(),Et.pop();const a=Et.length;return a>0&&(zt=Et[a-1],_t=Et[a-2]),o}function We(n,e,t,s,i=null,r=0,o=0){const{float32Array:a,uint16Array:c,uint32Array:f}=V;let d=n*2;if(K(d,c)){const l=G(n,f),p=J(d,c);return N(n,a,_t),s(l,p,!1,o,r+n,_t)}else{let b=function(P){const{uint16Array:L,uint32Array:M}=V;let R=P*2;for(;!K(R,L);)P=tt(P),R=P*2;return G(P,M)},D=function(P){const{uint16Array:L,uint32Array:M}=V;let R=P*2;for(;!K(R,L);)P=et(P,M),R=P*2;return G(P,M)+J(R,L)};const l=tt(n),p=et(n,f);let y=l,O=p,T,_,g,E;if(i&&(g=_t,E=zt,N(y,a,g),N(O,a,E),T=i(g),_=i(E),_<T)){y=p,O=l;const P=T;T=_,_=P,g=E}g||(g=_t,N(y,a,g));const h=K(y*2,c),m=t(g,h,T,o+1,r+y);let w;if(m===ls){const P=b(y),M=D(y)-P;w=s(P,M,!0,o+1,r+y,g)}else w=m&&We(y,e,t,s,i,r,o+1);if(w)return!0;E=zt,N(O,a,E);const x=K(O*2,c),C=t(E,x,_,o+1,r+O);let v;if(C===ls){const P=b(O),M=D(O)-P;v=s(P,M,!0,o+1,r+O,E)}else v=C&&We(O,e,t,s,i,r,o+1);return!!v}}const kt=new S,Me=new S;function Bi(n,e,t={},s=0,i=1/0){const r=s*s,o=i*i;let a=1/0,c=null;if(n.shapecast({boundsTraverseOrder:d=>(kt.copy(e).clamp(d.min,d.max),kt.distanceToSquared(e)),intersectsBounds:(d,u,l)=>l<a&&l<o,intersectsTriangle:(d,u)=>{d.closestPointToPoint(e,kt);const l=e.distanceToSquared(kt);return l<a&&(Me.copy(kt),a=l,c=u),l<r}}),a===1/0)return null;const f=Math.sqrt(a);return t.point?t.point.copy(Me):t.point=Me.clone(),t.distance=f,t.faceIndex=c,t}const wt=new S,xt=new S,Ot=new S,oe=new ht,re=new ht,ae=new ht,ps=new S,ms=new S,_s=new S,ce=new S;function Fi(n,e,t,s,i,r){let o;return r===Ks?o=n.intersectTriangle(s,t,e,!0,i):o=n.intersectTriangle(e,t,s,r!==ks,i),o===null?null:{distance:n.origin.distanceTo(i),point:i.clone()}}function Ri(n,e,t,s,i,r,o,a,c){wt.fromBufferAttribute(e,r),xt.fromBufferAttribute(e,o),Ot.fromBufferAttribute(e,a);const f=Fi(n,wt,xt,Ot,ce,c);if(f){s&&(oe.fromBufferAttribute(s,r),re.fromBufferAttribute(s,o),ae.fromBufferAttribute(s,a),f.uv=Gt.getInterpolation(ce,wt,xt,Ot,oe,re,ae,new ht)),i&&(oe.fromBufferAttribute(i,r),re.fromBufferAttribute(i,o),ae.fromBufferAttribute(i,a),f.uv1=Gt.getInterpolation(ce,wt,xt,Ot,oe,re,ae,new ht)),t&&(ps.fromBufferAttribute(t,r),ms.fromBufferAttribute(t,o),_s.fromBufferAttribute(t,a),f.normal=Gt.getInterpolation(ce,wt,xt,Ot,ps,ms,_s,new S),f.normal.dot(n.direction)>0&&f.normal.multiplyScalar(-1));const d={a:r,b:o,c:a,normal:new S,materialIndex:0};Gt.getNormal(wt,xt,Ot,d.normal),f.face=d,f.faceIndex=r}return f}function Pe(n,e,t,s,i){const r=s*3;let o=r+0,a=r+1,c=r+2;const f=n.index;n.index&&(o=f.getX(o),a=f.getX(a),c=f.getX(c));const{position:d,normal:u,uv:l,uv1:p}=n.attributes,y=Ri(t,d,u,l,p,o,a,c,e);return y?(y.faceIndex=s,i&&i.push(y),y):null}function W(n,e,t,s){const i=n.a,r=n.b,o=n.c;let a=e,c=e+1,f=e+2;t&&(a=t.getX(a),c=t.getX(c),f=t.getX(f)),i.x=s.getX(a),i.y=s.getY(a),i.z=s.getZ(a),r.x=s.getX(c),r.y=s.getY(c),r.z=s.getZ(c),o.x=s.getX(f),o.y=s.getY(f),o.z=s.getZ(f)}function Ii(n,e,t,s,i,r){const{geometry:o,_indirectBuffer:a}=n;for(let c=s,f=s+i;c<f;c++)Pe(o,e,t,c,r)}function Hi(n,e,t,s,i){const{geometry:r,_indirectBuffer:o}=n;let a=1/0,c=null;for(let f=s,d=s+i;f<d;f++){let u;u=Pe(r,e,t,f),u&&u.distance<a&&(c=u,a=u.distance)}return c}function ki(n,e,t,s,i,r,o){const{geometry:a}=t,{index:c}=a,f=a.attributes.position;for(let d=n,u=e+n;d<u;d++){let l;if(l=d,W(o,l*3,c,f),o.needsUpdate=!0,s(o,l,i,r))return!0}return!1}function Vi(n,e=null){e&&Array.isArray(e)&&(e=new Set(e));const t=n.geometry,s=t.index?t.index.array:null,i=t.attributes.position;let r,o,a,c,f=0;const d=n._roots;for(let l=0,p=d.length;l<p;l++)r=d[l],o=new Uint32Array(r),a=new Uint16Array(r),c=new Float32Array(r),u(0,f),f+=r.byteLength;function u(l,p,y=!1){const O=l*2;if(a[O+15]===be){const _=o[l+6],g=a[O+14];let E=1/0,h=1/0,m=1/0,w=-1/0,x=-1/0,C=-1/0;for(let v=3*_,b=3*(_+g);v<b;v++){let D=s[v];const P=i.getX(D),L=i.getY(D),M=i.getZ(D);P<E&&(E=P),P>w&&(w=P),L<h&&(h=L),L>x&&(x=L),M<m&&(m=M),M>C&&(C=M)}return c[l+0]!==E||c[l+1]!==h||c[l+2]!==m||c[l+3]!==w||c[l+4]!==x||c[l+5]!==C?(c[l+0]=E,c[l+1]=h,c[l+2]=m,c[l+3]=w,c[l+4]=x,c[l+5]=C,!0):!1}else{const _=l+8,g=o[l+6],E=_+p,h=g+p;let m=y,w=!1,x=!1;e?m||(w=e.has(E),x=e.has(h),m=!w&&!x):(w=!0,x=!0);const C=m||w,v=m||x;let b=!1;C&&(b=u(_,p,m));let D=!1;v&&(D=u(g,p,m));const P=b||D;if(P)for(let L=0;L<3;L++){const M=_+L,R=g+L,Z=c[M],Ft=c[M+3],Rt=c[R],It=c[R+3];c[l+L]=Z<Rt?Z:Rt,c[l+L+3]=Ft>It?Ft:It}return P}}}const ys=new st;function yt(n,e,t,s){return N(n,e,ys),t.intersectBox(ys,s)}function Yi(n,e,t,s,i,r){const{geometry:o,_indirectBuffer:a}=n;for(let c=s,f=s+i;c<f;c++){let d=a?a[c]:c;Pe(o,e,t,d,r)}}function Ni(n,e,t,s,i){const{geometry:r,_indirectBuffer:o}=n;let a=1/0,c=null;for(let f=s,d=s+i;f<d;f++){let u;u=Pe(r,e,t,o?o[f]:f),u&&u.distance<a&&(c=u,a=u.distance)}return c}function Zi(n,e,t,s,i,r,o){const{geometry:a}=t,{index:c}=a,f=a.attributes.position;for(let d=n,u=e+n;d<u;d++){let l;if(l=t.resolveTriangleIndex(d),W(o,l*3,c,f),o.needsUpdate=!0,s(o,l,i,r))return!0}return!1}const gs=new S;function Xi(n,e,t,s,i){V.setBuffer(n._roots[e]),qe(0,n,t,s,i),V.clearBuffer()}function qe(n,e,t,s,i){const{float32Array:r,uint16Array:o,uint32Array:a}=V,c=n*2;if(K(c,o)){const d=G(n,a),u=J(c,o);Ii(e,t,s,d,u,i)}else{const d=tt(n);yt(d,r,s,gs)&&qe(d,e,t,s,i);const u=et(n,a);yt(u,r,s,gs)&&qe(u,e,t,s,i)}}const Ts=new S,Wi=["x","y","z"];function qi(n,e,t,s){V.setBuffer(n._roots[e]);const i=$e(0,n,t,s);return V.clearBuffer(),i}function $e(n,e,t,s){const{float32Array:i,uint16Array:r,uint32Array:o}=V;let a=n*2;if(K(a,r)){const f=G(n,o),d=J(a,r);return Hi(e,t,s,f,d)}else{const f=Zs(n,o),d=Wi[f],l=s.direction[d]>=0;let p,y;l?(p=tt(n),y=et(n,o)):(p=et(n,o),y=tt(n));const T=yt(p,i,s,Ts)?$e(p,e,t,s):null;if(T){const E=T.point[d];if(l?E<=i[y+f]:E>=i[y+f+3])return T}const g=yt(y,i,s,Ts)?$e(y,e,t,s):null;return T&&g?T.distance<=g.distance?T:g:T||g||null}}const le=new st,At=new ot,Ct=new ot,Vt=new ut,Es=new q,he=new q;function $i(n,e,t,s){V.setBuffer(n._roots[e]);const i=Ke(0,n,t,s);return V.clearBuffer(),i}function Ke(n,e,t,s,i=null){const{float32Array:r,uint16Array:o,uint32Array:a}=V;let c=n*2;if(i===null&&(t.boundingBox||t.computeBoundingBox(),Es.set(t.boundingBox.min,t.boundingBox.max,s),i=Es),K(c,o)){const d=e.geometry,u=d.index,l=d.attributes.position,p=t.index,y=t.attributes.position,O=G(n,a),T=J(c,o);if(Vt.copy(s).invert(),t.boundsTree)return N(n,r,he),he.matrix.copy(Vt),he.needsUpdate=!0,t.boundsTree.shapecast({intersectsBounds:g=>he.intersectsBox(g),intersectsTriangle:g=>{g.a.applyMatrix4(s),g.b.applyMatrix4(s),g.c.applyMatrix4(s),g.needsUpdate=!0;for(let E=O*3,h=(T+O)*3;E<h;E+=3)if(W(Ct,E,u,l),Ct.needsUpdate=!0,g.intersectsTriangle(Ct))return!0;return!1}});for(let _=O*3,g=(T+O)*3;_<g;_+=3){W(At,_,u,l),At.a.applyMatrix4(Vt),At.b.applyMatrix4(Vt),At.c.applyMatrix4(Vt),At.needsUpdate=!0;for(let E=0,h=p.count;E<h;E+=3)if(W(Ct,E,p,y),Ct.needsUpdate=!0,At.intersectsTriangle(Ct))return!0}}else{const d=n+8,u=a[n+6];return N(d,r,le),!!(i.intersectsBox(le)&&Ke(d,e,t,s,i)||(N(u,r,le),i.intersectsBox(le)&&Ke(u,e,t,s,i)))}}const ue=new ut,ze=new q,Yt=new q,Ki=new S,Gi=new S,Qi=new S,ji=new S;function Ji(n,e,t,s={},i={},r=0,o=1/0){e.boundingBox||e.computeBoundingBox(),ze.set(e.boundingBox.min,e.boundingBox.max,t),ze.needsUpdate=!0;const a=n.geometry,c=a.attributes.position,f=a.index,d=e.attributes.position,u=e.index,l=j.getPrimitive(),p=j.getPrimitive();let y=Ki,O=Gi,T=null,_=null;i&&(T=Qi,_=ji);let g=1/0,E=null,h=null;return ue.copy(t).invert(),Yt.matrix.copy(ue),n.shapecast({boundsTraverseOrder:m=>ze.distanceToBox(m),intersectsBounds:(m,w,x)=>x<g&&x<o?(w&&(Yt.min.copy(m.min),Yt.max.copy(m.max),Yt.needsUpdate=!0),!0):!1,intersectsRange:(m,w)=>{if(e.boundsTree)return e.boundsTree.shapecast({boundsTraverseOrder:C=>Yt.distanceToBox(C),intersectsBounds:(C,v,b)=>b<g&&b<o,intersectsRange:(C,v)=>{for(let b=C,D=C+v;b<D;b++){W(p,3*b,u,d),p.a.applyMatrix4(t),p.b.applyMatrix4(t),p.c.applyMatrix4(t),p.needsUpdate=!0;for(let P=m,L=m+w;P<L;P++){W(l,3*P,f,c),l.needsUpdate=!0;const M=l.distanceToTriangle(p,y,T);if(M<g&&(O.copy(y),_&&_.copy(T),g=M,E=P,h=b),M<r)return!0}}}});{const x=Bt(e);for(let C=0,v=x;C<v;C++){W(p,3*C,u,d),p.a.applyMatrix4(t),p.b.applyMatrix4(t),p.c.applyMatrix4(t),p.needsUpdate=!0;for(let b=m,D=m+w;b<D;b++){W(l,3*b,f,c),l.needsUpdate=!0;const P=l.distanceToTriangle(p,y,T);if(P<g&&(O.copy(y),_&&_.copy(T),g=P,E=b,h=C),P<r)return!0}}}}}),j.releasePrimitive(l),j.releasePrimitive(p),g===1/0?null:(s.point?s.point.copy(O):s.point=O.clone(),s.distance=g,s.faceIndex=E,i&&(i.point?i.point.copy(_):i.point=_.clone(),i.point.applyMatrix4(ue),O.applyMatrix4(ue),i.distance=O.sub(i.point).length(),i.faceIndex=h),s)}function tn(n,e=null){e&&Array.isArray(e)&&(e=new Set(e));const t=n.geometry,s=t.index?t.index.array:null,i=t.attributes.position;let r,o,a,c,f=0;const d=n._roots;for(let l=0,p=d.length;l<p;l++)r=d[l],o=new Uint32Array(r),a=new Uint16Array(r),c=new Float32Array(r),u(0,f),f+=r.byteLength;function u(l,p,y=!1){const O=l*2;if(a[O+15]===be){const _=o[l+6],g=a[O+14];let E=1/0,h=1/0,m=1/0,w=-1/0,x=-1/0,C=-1/0;for(let v=_,b=_+g;v<b;v++){const D=3*n.resolveTriangleIndex(v);for(let P=0;P<3;P++){let L=D+P;L=s?s[L]:L;const M=i.getX(L),R=i.getY(L),Z=i.getZ(L);M<E&&(E=M),M>w&&(w=M),R<h&&(h=R),R>x&&(x=R),Z<m&&(m=Z),Z>C&&(C=Z)}}return c[l+0]!==E||c[l+1]!==h||c[l+2]!==m||c[l+3]!==w||c[l+4]!==x||c[l+5]!==C?(c[l+0]=E,c[l+1]=h,c[l+2]=m,c[l+3]=w,c[l+4]=x,c[l+5]=C,!0):!1}else{const _=l+8,g=o[l+6],E=_+p,h=g+p;let m=y,w=!1,x=!1;e?m||(w=e.has(E),x=e.has(h),m=!w&&!x):(w=!0,x=!0);const C=m||w,v=m||x;let b=!1;C&&(b=u(_,p,m));let D=!1;v&&(D=u(g,p,m));const P=b||D;if(P)for(let L=0;L<3;L++){const M=_+L,R=g+L,Z=c[M],Ft=c[M+3],Rt=c[R],It=c[R+3];c[l+L]=Z<Rt?Z:Rt,c[l+L+3]=Ft>It?Ft:It}return P}}}const ws=new S;function en(n,e,t,s,i){V.setBuffer(n._roots[e]),Ge(0,n,t,s,i),V.clearBuffer()}function Ge(n,e,t,s,i){const{float32Array:r,uint16Array:o,uint32Array:a}=V,c=n*2;if(K(c,o)){const d=G(n,a),u=J(c,o);Yi(e,t,s,d,u,i)}else{const d=tt(n);yt(d,r,s,ws)&&Ge(d,e,t,s,i);const u=et(n,a);yt(u,r,s,ws)&&Ge(u,e,t,s,i)}}const xs=new S,sn=["x","y","z"];function nn(n,e,t,s){V.setBuffer(n._roots[e]);const i=Qe(0,n,t,s);return V.clearBuffer(),i}function Qe(n,e,t,s){const{float32Array:i,uint16Array:r,uint32Array:o}=V;let a=n*2;if(K(a,r)){const f=G(n,o),d=J(a,r);return Ni(e,t,s,f,d)}else{const f=Zs(n,o),d=sn[f],l=s.direction[d]>=0;let p,y;l?(p=tt(n),y=et(n,o)):(p=et(n,o),y=tt(n));const T=yt(p,i,s,xs)?Qe(p,e,t,s):null;if(T){const E=T.point[d];if(l?E<=i[y+f]:E>=i[y+f+3])return T}const g=yt(y,i,s,xs)?Qe(y,e,t,s):null;return T&&g?T.distance<=g.distance?T:g:T||g||null}}const de=new st,vt=new ot,bt=new ot,Nt=new ut,Os=new q,fe=new q;function on(n,e,t,s){V.setBuffer(n._roots[e]);const i=je(0,n,t,s);return V.clearBuffer(),i}function je(n,e,t,s,i=null){const{float32Array:r,uint16Array:o,uint32Array:a}=V;let c=n*2;if(i===null&&(t.boundingBox||t.computeBoundingBox(),Os.set(t.boundingBox.min,t.boundingBox.max,s),i=Os),K(c,o)){const d=e.geometry,u=d.index,l=d.attributes.position,p=t.index,y=t.attributes.position,O=G(n,a),T=J(c,o);if(Nt.copy(s).invert(),t.boundsTree)return N(n,r,fe),fe.matrix.copy(Nt),fe.needsUpdate=!0,t.boundsTree.shapecast({intersectsBounds:g=>fe.intersectsBox(g),intersectsTriangle:g=>{g.a.applyMatrix4(s),g.b.applyMatrix4(s),g.c.applyMatrix4(s),g.needsUpdate=!0;for(let E=O,h=T+O;E<h;E++)if(W(bt,3*e.resolveTriangleIndex(E),u,l),bt.needsUpdate=!0,g.intersectsTriangle(bt))return!0;return!1}});for(let _=O,g=T+O;_<g;_++){const E=e.resolveTriangleIndex(_);W(vt,3*E,u,l),vt.a.applyMatrix4(Nt),vt.b.applyMatrix4(Nt),vt.c.applyMatrix4(Nt),vt.needsUpdate=!0;for(let h=0,m=p.count;h<m;h+=3)if(W(bt,h,p,y),bt.needsUpdate=!0,vt.intersectsTriangle(bt))return!0}}else{const d=n+8,u=a[n+6];return N(d,r,de),!!(i.intersectsBox(de)&&je(d,e,t,s,i)||(N(u,r,de),i.intersectsBox(de)&&je(u,e,t,s,i)))}}const pe=new ut,Be=new q,Zt=new q,rn=new S,an=new S,cn=new S,ln=new S;function hn(n,e,t,s={},i={},r=0,o=1/0){e.boundingBox||e.computeBoundingBox(),Be.set(e.boundingBox.min,e.boundingBox.max,t),Be.needsUpdate=!0;const a=n.geometry,c=a.attributes.position,f=a.index,d=e.attributes.position,u=e.index,l=j.getPrimitive(),p=j.getPrimitive();let y=rn,O=an,T=null,_=null;i&&(T=cn,_=ln);let g=1/0,E=null,h=null;return pe.copy(t).invert(),Zt.matrix.copy(pe),n.shapecast({boundsTraverseOrder:m=>Be.distanceToBox(m),intersectsBounds:(m,w,x)=>x<g&&x<o?(w&&(Zt.min.copy(m.min),Zt.max.copy(m.max),Zt.needsUpdate=!0),!0):!1,intersectsRange:(m,w)=>{if(e.boundsTree){const x=e.boundsTree;return x.shapecast({boundsTraverseOrder:C=>Zt.distanceToBox(C),intersectsBounds:(C,v,b)=>b<g&&b<o,intersectsRange:(C,v)=>{for(let b=C,D=C+v;b<D;b++){const P=x.resolveTriangleIndex(b);W(p,3*P,u,d),p.a.applyMatrix4(t),p.b.applyMatrix4(t),p.c.applyMatrix4(t),p.needsUpdate=!0;for(let L=m,M=m+w;L<M;L++){const R=n.resolveTriangleIndex(L);W(l,3*R,f,c),l.needsUpdate=!0;const Z=l.distanceToTriangle(p,y,T);if(Z<g&&(O.copy(y),_&&_.copy(T),g=Z,E=L,h=b),Z<r)return!0}}}})}else{const x=Bt(e);for(let C=0,v=x;C<v;C++){W(p,3*C,u,d),p.a.applyMatrix4(t),p.b.applyMatrix4(t),p.c.applyMatrix4(t),p.needsUpdate=!0;for(let b=m,D=m+w;b<D;b++){const P=n.resolveTriangleIndex(b);W(l,3*P,f,c),l.needsUpdate=!0;const L=l.distanceToTriangle(p,y,T);if(L<g&&(O.copy(y),_&&_.copy(T),g=L,E=b,h=C),L<r)return!0}}}}}),j.releasePrimitive(l),j.releasePrimitive(p),g===1/0?null:(s.point?s.point.copy(O):s.point=O.clone(),s.distance=g,s.faceIndex=E,i&&(i.point?i.point.copy(_):i.point=_.clone(),i.point.applyMatrix4(pe),O.applyMatrix4(pe),i.distance=O.sub(i.point).length(),i.faceIndex=h),s)}function un(){return typeof SharedArrayBuffer<"u"}const Qt=new V.constructor,xe=new V.constructor,mt=new es(()=>new st),Pt=new st,Ut=new st,Fe=new st,Re=new st;let Ie=!1;function dn(n,e,t,s){if(Ie)throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");Ie=!0;const i=n._roots,r=e._roots;let o,a=0,c=0;const f=new ut().copy(t).invert();for(let d=0,u=i.length;d<u;d++){Qt.setBuffer(i[d]),c=0;const l=mt.getPrimitive();N(0,Qt.float32Array,l),l.applyMatrix4(f);for(let p=0,y=r.length;p<y&&(xe.setBuffer(r[d]),o=it(0,0,t,f,s,a,c,0,0,l),xe.clearBuffer(),c+=r[p].length,!o);p++);if(mt.releasePrimitive(l),Qt.clearBuffer(),a+=i[d].length,o)break}return Ie=!1,o}function it(n,e,t,s,i,r=0,o=0,a=0,c=0,f=null,d=!1){let u,l;d?(u=xe,l=Qt):(u=Qt,l=xe);const p=u.float32Array,y=u.uint32Array,O=u.uint16Array,T=l.float32Array,_=l.uint32Array,g=l.uint16Array,E=n*2,h=e*2,m=K(E,O),w=K(h,g);let x=!1;if(w&&m)d?x=i(G(e,_),J(e*2,g),G(n,y),J(n*2,O),c,o+e,a,r+n):x=i(G(n,y),J(n*2,O),G(e,_),J(e*2,g),a,r+n,c,o+e);else if(w){const C=mt.getPrimitive();N(e,T,C),C.applyMatrix4(t);const v=tt(n),b=et(n,y);N(v,p,Pt),N(b,p,Ut);const D=C.intersectsBox(Pt),P=C.intersectsBox(Ut);x=D&&it(e,v,s,t,i,o,r,c,a+1,C,!d)||P&&it(e,b,s,t,i,o,r,c,a+1,C,!d),mt.releasePrimitive(C)}else{const C=tt(e),v=et(e,_);N(C,T,Fe),N(v,T,Re);const b=f.intersectsBox(Fe),D=f.intersectsBox(Re);if(b&&D)x=it(n,C,t,s,i,r,o,a,c+1,f,d)||it(n,v,t,s,i,r,o,a,c+1,f,d);else if(b)if(m)x=it(n,C,t,s,i,r,o,a,c+1,f,d);else{const P=mt.getPrimitive();P.copy(Fe).applyMatrix4(t);const L=tt(n),M=et(n,y);N(L,p,Pt),N(M,p,Ut);const R=P.intersectsBox(Pt),Z=P.intersectsBox(Ut);x=R&&it(C,L,s,t,i,o,r,c,a+1,P,!d)||Z&&it(C,M,s,t,i,o,r,c,a+1,P,!d),mt.releasePrimitive(P)}else if(D)if(m)x=it(n,v,t,s,i,r,o,a,c+1,f,d);else{const P=mt.getPrimitive();P.copy(Re).applyMatrix4(t);const L=tt(n),M=et(n,y);N(L,p,Pt),N(M,p,Ut);const R=P.intersectsBox(Pt),Z=P.intersectsBox(Ut);x=R&&it(v,L,s,t,i,o,r,c,a+1,P,!d)||Z&&it(v,M,s,t,i,o,r,c,a+1,P,!d),mt.releasePrimitive(P)}}return x}const me=new q,As=new st;class ss{static serialize(e,t={}){t={cloneBuffers:!0,...t};const s=e.geometry,i=e._roots,r=e._indirectBuffer,o=s.getIndex();let a;return t.cloneBuffers?a={roots:i.map(c=>c.slice()),index:o.array.slice(),indirectBuffer:r?r.slice():null}:a={roots:i,index:o.array,indirectBuffer:r},a}static deserialize(e,t,s={}){s={setIndex:!0,indirect:!!e.indirectBuffer,...s};const{index:i,roots:r,indirectBuffer:o}=e,a=new ss(t,{...s,[De]:!0});if(a._roots=r,a._indirectBuffer=o||null,s.setIndex){const c=t.getIndex();if(c===null){const f=new Rs(e.index,1,!1);t.setIndex(f)}else c.array!==i&&(c.array.set(i),c.needsUpdate=!0)}return a}get indirect(){return!!this._indirectBuffer}constructor(e,t={}){if(e.isBufferGeometry){if(e.index&&e.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.")}else throw new Error("MeshBVH: Only BufferGeometries are supported.");if(t=Object.assign({strategy:Vs,maxDepth:40,maxLeafTris:10,verbose:!0,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,indirect:!1,[De]:!1},t),t.useSharedArrayBuffer&&!un())throw new Error("MeshBVH: SharedArrayBuffer is not available.");this.geometry=e,this._roots=null,this._indirectBuffer=null,t[De]||(Pi(this,t),!e.boundingBox&&t.setBoundingBox&&(e.boundingBox=this.getBoundingBox(new st)));const{_indirectBuffer:s}=this;this.resolveTriangleIndex=t.indirect?i=>s[i]:i=>i}refit(e=null){return(this.indirect?tn:Vi)(this,e)}traverse(e,t=0){const s=this._roots[t],i=new Uint32Array(s),r=new Uint16Array(s);o(0);function o(a,c=0){const f=a*2,d=r[f+15]===be;if(d){const u=i[a+6],l=r[f+14];e(c,d,new Float32Array(s,a*4,6),u,l)}else{const u=a+we/4,l=i[a+6],p=i[a+7];e(c,d,new Float32Array(s,a*4,6),p)||(o(u,c+1),o(l,c+1))}}}raycast(e,t=rs){const s=this._roots,i=this.geometry,r=[],o=t.isMaterial,a=Array.isArray(t),c=i.groups,f=o?t.side:t,d=this.indirect?en:Xi;for(let u=0,l=s.length;u<l;u++){const p=a?t[c[u].materialIndex].side:f,y=r.length;if(d(this,u,p,e,r),a){const O=c[u].materialIndex;for(let T=y,_=r.length;T<_;T++)r[T].face.materialIndex=O}}return r}raycastFirst(e,t=rs){const s=this._roots,i=this.geometry,r=t.isMaterial,o=Array.isArray(t);let a=null;const c=i.groups,f=r?t.side:t,d=this.indirect?nn:qi;for(let u=0,l=s.length;u<l;u++){const p=o?t[c[u].materialIndex].side:f,y=d(this,u,p,e);y!=null&&(a==null||y.distance<a.distance)&&(a=y,o&&(y.face.materialIndex=c[u].materialIndex))}return a}intersectsGeometry(e,t){let s=!1;const i=this._roots,r=this.indirect?on:$i;for(let o=0,a=i.length;o<a&&(s=r(this,o,e,t),!s);o++);return s}shapecast(e){const t=j.getPrimitive(),s=this.indirect?Zi:ki;let{boundsTraverseOrder:i,intersectsBounds:r,intersectsRange:o,intersectsTriangle:a}=e;if(o&&a){const u=o;o=(l,p,y,O,T)=>u(l,p,y,O,T)?!0:s(l,p,this,a,y,O,t)}else o||(a?o=(u,l,p,y)=>s(u,l,this,a,p,y,t):o=(u,l,p)=>p);let c=!1,f=0;const d=this._roots;for(let u=0,l=d.length;u<l;u++){const p=d[u];if(c=zi(this,u,r,o,i,f),c)break;f+=p.byteLength}return j.releasePrimitive(t),c}bvhcast(e,t,s){let{intersectsRanges:i,intersectsTriangles:r}=s;const o=j.getPrimitive(),a=this.geometry.index,c=this.geometry.attributes.position,f=this.indirect?y=>{const O=this.resolveTriangleIndex(y);W(o,O*3,a,c)}:y=>{W(o,y*3,a,c)},d=j.getPrimitive(),u=e.geometry.index,l=e.geometry.attributes.position,p=e.indirect?y=>{const O=e.resolveTriangleIndex(y);W(d,O*3,u,l)}:y=>{W(d,y*3,u,l)};if(r){const y=(O,T,_,g,E,h,m,w)=>{for(let x=_,C=_+g;x<C;x++){p(x),d.a.applyMatrix4(t),d.b.applyMatrix4(t),d.c.applyMatrix4(t),d.needsUpdate=!0;for(let v=O,b=O+T;v<b;v++)if(f(v),o.needsUpdate=!0,r(o,d,v,x,E,h,m,w))return!0}return!1};if(i){const O=i;i=function(T,_,g,E,h,m,w,x){return O(T,_,g,E,h,m,w,x)?!0:y(T,_,g,E,h,m,w,x)}}else i=y}return dn(this,e,t,i)}intersectsBox(e,t){return me.set(e.min,e.max,t),me.needsUpdate=!0,this.shapecast({intersectsBounds:s=>me.intersectsBox(s),intersectsTriangle:s=>me.intersectsTriangle(s)})}intersectsSphere(e){return this.shapecast({intersectsBounds:t=>e.intersectsBox(t),intersectsTriangle:t=>t.intersectsSphere(e)})}closestPointToGeometry(e,t,s={},i={},r=0,o=1/0){return(this.indirect?hn:Ji)(this,e,t,s,i,r,o)}closestPointToPoint(e,t={},s=0,i=1/0){return Bi(this,e,t,s,i)}getBoundingBox(e){return e.makeEmpty(),this._roots.forEach(s=>{N(0,new Float32Array(s),As),e.union(As)}),e}}function Cs(n,e,t){return n===null||(n.point.applyMatrix4(e.matrixWorld),n.distance=n.point.distanceTo(t.ray.origin),n.object=e,n.distance<t.near||n.distance>t.far)?null:n}const He=new Gs,vs=new ut,fn=Je.prototype.raycast;function pn(n,e){if(this.geometry.boundsTree){if(this.material===void 0)return;vs.copy(this.matrixWorld).invert(),He.copy(n.ray).applyMatrix4(vs);const t=this.geometry.boundsTree;if(n.firstHitOnly===!0){const s=Cs(t.raycastFirst(He,this.material),this,n);s&&e.push(s)}else{const s=t.raycast(He,this.material);for(let i=0,r=s.length;i<r;i++){const o=Cs(s[i],this,n);o&&e.push(o)}}}else fn.call(this,n,e)}function mn(n){return this.boundsTree=new ss(this,n),this.boundsTree}function _n(){this.boundsTree=null}class Y{constructor(){U(this,"trigger",e=>{const t=this.handlers.slice(0);for(const s of t)s(e)});U(this,"handlers",[])}add(e){this.handlers.push(e)}remove(e){this.handlers=this.handlers.filter(t=>t!==e)}reset(){this.handlers.length=0}}class is{constructor(e){U(this,"isDisposeable",()=>"dispose"in this&&"onDisposed"in this);U(this,"isResizeable",()=>"resize"in this&&"getSize"in this);U(this,"isUpdateable",()=>"onAfterUpdate"in this&&"onBeforeUpdate"in this&&"update"in this);U(this,"isHideable",()=>"visible"in this);U(this,"isConfigurable",()=>"setup"in this&&"config"in this&&"onSetup"in this);this.components=e}}class ns extends is{}class os extends is{constructor(t){super(t);U(this,"worlds",new Map);U(this,"onWorldChanged",new Y);U(this,"currentWorld",null);this.onWorldChanged.add(({world:s,action:i})=>{i==="removed"&&this.worlds.delete(s.uuid)})}}class yn extends os{constructor(){super(...arguments);U(this,"hasCameraControls",()=>"controls"in this)}}class gn extends os{constructor(){super(...arguments);U(this,"onAfterUpdate",new Y);U(this,"onBeforeUpdate",new Y);U(this,"onDisposed",new Y);U(this,"onResize",new Y);U(this,"onClippingPlanesUpdated",new Y);U(this,"clippingPlanes",[])}updateClippingPlanes(){this.onClippingPlanesUpdated.trigger()}setPlane(t,s,i){s.isLocal=i;const r=this.clippingPlanes.indexOf(s);t&&r===-1?this.clippingPlanes.push(s):!t&&r>-1&&this.clippingPlanes.splice(r,1),this.three.clippingPlanes=this.clippingPlanes.filter(o=>!o.isLocal)}}const jt=class jt extends ns{constructor(t){super(t);U(this,"_disposedComponents",new Set);U(this,"enabled",!0);t.add(jt.uuid,this)}get(){return this._disposedComponents}destroy(t,s=!0,i=!0){t.removeFromParent();const r=t;r.dispose&&r.dispose(),this.disposeGeometryAndMaterials(t,s),i&&r.children&&r.children.length&&this.disposeChildren(r),t.children.length=0}disposeGeometry(t){const s=t;s.boundsTree&&s.disposeBoundsTree(),t.dispose()}disposeGeometryAndMaterials(t,s){const i=t;i.geometry&&this.disposeGeometry(i.geometry),s&&i.material&&jt.disposeMaterial(i),i.material=[],i.geometry=null}disposeChildren(t){for(const s of t.children)this.destroy(s)}static disposeMaterial(t){if(t.material)if(Array.isArray(t.material))for(const s of t.material)s.dispose();else t.material.dispose()}};U(jt,"uuid","76e9cd8e-ad8f-4753-9ef6-cbc60f7247fe");let Jt=jt;class Tn extends os{constructor(t){super(t);U(this,"onDisposed",new Y)}dispose(){const t=this.components.get(Jt);for(const s of this.three.children){const i=s;i.geometry&&t.destroy(i)}this.three.children=[],this.onDisposed.trigger(),this.onDisposed.reset()}}const X=class X{static create(){const e=Math.random()*4294967295|0,t=Math.random()*4294967295|0,s=Math.random()*4294967295|0,i=Math.random()*4294967295|0;return`${X._lut[e&255]+X._lut[e>>8&255]+X._lut[e>>16&255]+X._lut[e>>24&255]}-${X._lut[t&255]}${X._lut[t>>8&255]}-${X._lut[t>>16&15|64]}${X._lut[t>>24&255]}-${X._lut[s&63|128]}${X._lut[s>>8&255]}-${X._lut[s>>16&255]}${X._lut[s>>24&255]}${X._lut[i&255]}${X._lut[i>>8&255]}${X._lut[i>>16&255]}${X._lut[i>>24&255]}`.toLowerCase()}static validate(e){if(!X._pattern.test(e))throw new Error(`${e} is not a valid UUID v4.

- If you're the tool creator, you can take one from https://www.uuidgenerator.net/.

- If you're using a platform tool, verify the uuid isn't misspelled or contact the tool creator.`)}};U(X,"_pattern",/^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-4[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$/),U(X,"_lut",["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"]);let Oe=X;const Ce=class Ce{constructor(){U(this,"onDisposed",new Y);U(this,"list",new Map);U(this,"enabled",!1);U(this,"_clock");U(this,"update",()=>{if(!this.enabled)return;const e=this._clock.getDelta();for(const[t,s]of this.list)s.enabled&&s.isUpdateable()&&s.update(e);requestAnimationFrame(this.update)});this._clock=new Qs,Ce.setupBVH()}add(e,t){if(this.list.has(e))throw new Error("You're trying to add a component that already exists in the components intance. Use Components.get() instead.");Oe.validate(e),this.list.set(e,t)}get(e){const t=e.uuid;if(!this.list.has(t)){const s=new e(this);return this.list.has(t)||this.add(t,s),s}return this.list.get(t)}init(){this.enabled=!0,this._clock.start(),this.update()}dispose(){this.enabled=!1;for(const[e,t]of this.list)t.enabled=!1,t.isDisposeable()&&t.dispose();this._clock.stop(),this.onDisposed.trigger(),this.onDisposed.reset()}static setupBVH(){as.prototype.computeBoundsTree=mn,as.prototype.disposeBoundsTree=_n,Je.prototype.raycast=pn}};U(Ce,"release","1.4.21");let bs=Ce;class En extends is{constructor(t){super(t);U(this,"meshes",new Set);U(this,"onAfterUpdate",new Y);U(this,"onBeforeUpdate",new Y);U(this,"isDisposing",!1);U(this,"enabled",!0);U(this,"uuid",Oe.create());U(this,"name");U(this,"onDisposed",new Y);U(this,"_scene");U(this,"_camera");U(this,"_renderer",null)}get scene(){if(!this._scene)throw new Error("No scene initialized!");return this._scene}set scene(t){this._scene=t,t.worlds.set(this.uuid,this),t.currentWorld=this,t.onWorldChanged.trigger({world:this,action:"added"})}get camera(){if(!this._camera)throw new Error("No camera initialized!");return this._camera}set camera(t){this._camera=t,t.worlds.set(this.uuid,this),t.currentWorld=this,t.onWorldChanged.trigger({world:this,action:"added"})}get renderer(){return this._renderer}set renderer(t){this._renderer=t,t&&(t.worlds.set(this.uuid,this),t.currentWorld=this,t.onWorldChanged.trigger({world:this,action:"added"}))}update(t){this.enabled&&(!this._scene||!this._camera||(this.scene.currentWorld=this,this.camera.currentWorld=this,this.renderer&&(this.renderer.currentWorld=this),this.onBeforeUpdate.trigger(),this.scene.isUpdateable()&&this.scene.update(t),this.camera.isUpdateable()&&this.camera.update(t),this.renderer&&this.renderer.update(t),this.onAfterUpdate.trigger()))}dispose(t=!0){if(this.enabled=!1,this.isDisposing=!0,this.scene.onWorldChanged.trigger({world:this,action:"removed"}),this.camera.onWorldChanged.trigger({world:this,action:"removed"}),this.renderer&&this.renderer.onWorldChanged.trigger({world:this,action:"removed"}),t){const s=this.components.get(Jt);this.scene.dispose(),this.camera.isDisposeable()&&this.camera.dispose(),this.renderer&&this.renderer.dispose();for(const i of this.meshes)s.destroy(i);this.meshes.clear()}this._scene=null,this._camera=null,this._renderer=null,this.onDisposed.trigger()}}class Un extends Tn{constructor(t){super(t);U(this,"isSetup",!1);U(this,"three");U(this,"onSetup",new Y);U(this,"config",{directionalLight:{color:new Ee("white"),intensity:1.5,position:new S(5,10,3)},ambientLight:{color:new Ee("white"),intensity:1}});this.three=new js,this.three.background=new Ee(2107698)}setup(t){this.config={...this.config,...t};const s=new Js(this.config.directionalLight.color,this.config.directionalLight.intensity);s.position.copy(this.config.directionalLight.position);const i=new ti(this.config.ambientLight.color,this.config.ambientLight.intensity);this.three.add(s,i),this.isSetup=!0,this.onSetup.trigger(this)}}class Dn extends gn{constructor(t,s,i){super(t);U(this,"enabled",!0);U(this,"container");U(this,"three");U(this,"_canvas");U(this,"_parameters");U(this,"_resizeObserver",null);U(this,"onContainerUpdated",new Y);U(this,"_resizing",!1);U(this,"resize",t=>{if(this._resizing)return;this._resizing=!0,this.onContainerUpdated.trigger();const s=t?t.x:this.container.clientWidth,i=t?t.y:this.container.clientHeight;this.three.setSize(s,i),this.onResize.trigger(new ht(s,i)),this._resizing=!1});U(this,"resizeEvent",()=>{this.resize()});U(this,"onContextLost",t=>{t.preventDefault(),this.enabled=!1});U(this,"onContextBack",()=>{this.three.setRenderTarget(null),this.three.dispose(),this.three=new cs({canvas:this._canvas,antialias:!0,alpha:!0,...this._parameters}),this.enabled=!0});this.container=s,this._parameters=i,this.three=new cs({antialias:!0,alpha:!0,...i}),this.three.setPixelRatio(Math.min(window.devicePixelRatio,2)),this.setupRenderer(),this.setupEvents(!0),this.resize(),this._canvas=this.three.domElement;const r=this.three.getContext(),{canvas:o}=r;o.addEventListener("webglcontextlost",this.onContextLost,!1),o.addEventListener("webglcontextrestored",this.onContextBack,!1)}update(){if(!this.enabled||!this.currentWorld)return;this.onBeforeUpdate.trigger(this);const t=this.currentWorld.scene.three,s=this.currentWorld.camera.three;this.three.render(t,s),this.onAfterUpdate.trigger(this)}dispose(){this.enabled=!1,this.setupEvents(!1),this.three.domElement.remove(),this.three.dispose(),this.onResize.reset(),this.onAfterUpdate.reset(),this.onBeforeUpdate.reset(),this.onDisposed.trigger(),this.onDisposed.reset()}getSize(){return new ht(this.three.domElement.clientWidth,this.three.domElement.clientHeight)}setupEvents(t){const s=this.three.domElement.parentElement;if(!s)throw new Error("This renderer needs to have an HTML container!");this._resizeObserver&&(this._resizeObserver.disconnect(),this._resizeObserver=null),window.removeEventListener("resize",this.resizeEvent),t&&(this._resizeObserver=new ResizeObserver(this.resizeEvent),this._resizeObserver.observe(s),window.addEventListener("resize",this.resizeEvent))}setupRenderer(){this.three.localClippingEnabled=!0,this.container&&this.container.appendChild(this.three.domElement),this.onContainerUpdated.trigger()}}/*!
 * camera-controls
 * https://github.com/yomotsu/camera-controls
 * (c) 2017 @yomotsu
 * Released under the MIT License.
 */const B={LEFT:1,RIGHT:2,MIDDLE:4},A=Object.freeze({NONE:0,ROTATE:1,TRUCK:2,OFFSET:4,DOLLY:8,ZOOM:16,TOUCH_ROTATE:32,TOUCH_TRUCK:64,TOUCH_OFFSET:128,TOUCH_DOLLY:256,TOUCH_ZOOM:512,TOUCH_DOLLY_TRUCK:1024,TOUCH_DOLLY_OFFSET:2048,TOUCH_DOLLY_ROTATE:4096,TOUCH_ZOOM_TRUCK:8192,TOUCH_ZOOM_OFFSET:16384,TOUCH_ZOOM_ROTATE:32768}),Dt={NONE:0,IN:1,OUT:-1};function gt(n){return n.isPerspectiveCamera}function pt(n){return n.isOrthographicCamera}const Lt=Math.PI*2,Ps=Math.PI/2,Xs=1e-5,Xt=Math.PI/180;function nt(n,e,t){return Math.max(e,Math.min(t,n))}function k(n,e=Xs){return Math.abs(n)<e}function H(n,e,t=Xs){return k(n-e,t)}function Us(n,e){return Math.round(n/e)*e}function Wt(n){return isFinite(n)?n:n<0?-Number.MAX_VALUE:Number.MAX_VALUE}function qt(n){return Math.abs(n)<Number.MAX_VALUE?n:n*(1/0)}function _e(n,e,t,s,i=1/0,r){s=Math.max(1e-4,s);const o=2/s,a=o*r,c=1/(1+a+.48*a*a+.235*a*a*a);let f=n-e;const d=e,u=i*s;f=nt(f,-u,u),e=n-f;const l=(t.value+o*f)*r;t.value=(t.value-o*l)*c;let p=e+(f+l)*c;return d-n>0==p>d&&(p=d,t.value=(p-d)/r),p}function Ds(n,e,t,s,i=1/0,r,o){s=Math.max(1e-4,s);const a=2/s,c=a*r,f=1/(1+c+.48*c*c+.235*c*c*c);let d=e.x,u=e.y,l=e.z,p=n.x-d,y=n.y-u,O=n.z-l;const T=d,_=u,g=l,E=i*s,h=E*E,m=p*p+y*y+O*O;if(m>h){const R=Math.sqrt(m);p=p/R*E,y=y/R*E,O=O/R*E}d=n.x-p,u=n.y-y,l=n.z-O;const w=(t.x+a*p)*r,x=(t.y+a*y)*r,C=(t.z+a*O)*r;t.x=(t.x-a*w)*f,t.y=(t.y-a*x)*f,t.z=(t.z-a*C)*f,o.x=d+(p+w)*f,o.y=u+(y+x)*f,o.z=l+(O+C)*f;const v=T-n.x,b=_-n.y,D=g-n.z,P=o.x-T,L=o.y-_,M=o.z-g;return v*P+b*L+D*M>0&&(o.x=T,o.y=_,o.z=g,t.x=(o.x-T)/r,t.y=(o.y-_)/r,t.z=(o.z-g)/r),o}function ke(n,e){e.set(0,0),n.forEach(t=>{e.x+=t.clientX,e.y+=t.clientY}),e.x/=n.length,e.y/=n.length}function Ve(n,e){return pt(n)?(console.warn(`${e} is not supported in OrthographicCamera`),!0):!1}class wn{constructor(){this._listeners={}}addEventListener(e,t){const s=this._listeners;s[e]===void 0&&(s[e]=[]),s[e].indexOf(t)===-1&&s[e].push(t)}hasEventListener(e,t){const s=this._listeners;return s[e]!==void 0&&s[e].indexOf(t)!==-1}removeEventListener(e,t){const i=this._listeners[e];if(i!==void 0){const r=i.indexOf(t);r!==-1&&i.splice(r,1)}}removeAllEventListeners(e){if(!e){this._listeners={};return}Array.isArray(this._listeners[e])&&(this._listeners[e].length=0)}dispatchEvent(e){const s=this._listeners[e.type];if(s!==void 0){e.target=this;const i=s.slice(0);for(let r=0,o=i.length;r<o;r++)i[r].call(this,e)}}}const xn="2.7.3",ye=1/8,Ws=typeof window<"u",On=Ws&&/Mac/.test(navigator.platform),An=!(Ws&&"PointerEvent"in window);let z,Ls,ge,Ye,$,F,I,St,$t,rt,at,Tt,Ss,Ms,Q,Kt,Mt,zs,Ne,Bs,Ze,Xe,Te;class te extends wn{static install(e){z=e.THREE,Ls=Object.freeze(new z.Vector3(0,0,0)),ge=Object.freeze(new z.Vector3(0,1,0)),Ye=Object.freeze(new z.Vector3(0,0,1)),$=new z.Vector2,F=new z.Vector3,I=new z.Vector3,St=new z.Vector3,$t=new z.Vector3,rt=new z.Vector3,at=new z.Vector3,Tt=new z.Vector3,Ss=new z.Vector3,Ms=new z.Vector3,Q=new z.Spherical,Kt=new z.Spherical,Mt=new z.Box3,zs=new z.Box3,Ne=new z.Sphere,Bs=new z.Quaternion,Ze=new z.Quaternion,Xe=new z.Matrix4,Te=new z.Raycaster}static get ACTION(){return A}constructor(e,t){super(),this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-1/0,this.maxAzimuthAngle=1/0,this.minDistance=Number.EPSILON,this.maxDistance=1/0,this.infinityDolly=!1,this.minZoom=.01,this.maxZoom=1/0,this.smoothTime=.25,this.draggingSmoothTime=.125,this.maxSpeed=1/0,this.azimuthRotateSpeed=1,this.polarRotateSpeed=1,this.dollySpeed=1,this.dollyDragInverted=!1,this.truckSpeed=2,this.dollyToCursor=!1,this.dragToOffset=!1,this.verticalDragToForward=!1,this.boundaryFriction=0,this.restThreshold=.01,this.colliderMeshes=[],this.cancel=()=>{},this._enabled=!0,this._state=A.NONE,this._viewport=null,this._changedDolly=0,this._changedZoom=0,this._hasRested=!0,this._boundaryEnclosesCamera=!1,this._needsUpdate=!0,this._updatedLastTime=!1,this._elementRect=new DOMRect,this._isDragging=!1,this._dragNeedsUpdate=!0,this._activePointers=[],this._lockedPointer=null,this._interactiveArea=new DOMRect(0,0,1,1),this._isUserControllingRotate=!1,this._isUserControllingDolly=!1,this._isUserControllingTruck=!1,this._isUserControllingOffset=!1,this._isUserControllingZoom=!1,this._lastDollyDirection=Dt.NONE,this._thetaVelocity={value:0},this._phiVelocity={value:0},this._radiusVelocity={value:0},this._targetVelocity=new z.Vector3,this._focalOffsetVelocity=new z.Vector3,this._zoomVelocity={value:0},this._truckInternal=(h,m,w)=>{let x,C;if(gt(this._camera)){const v=F.copy(this._camera.position).sub(this._target),b=this._camera.getEffectiveFOV()*Xt,D=v.length()*Math.tan(b*.5);x=this.truckSpeed*h*D/this._elementRect.height,C=this.truckSpeed*m*D/this._elementRect.height}else if(pt(this._camera)){const v=this._camera;x=h*(v.right-v.left)/v.zoom/this._elementRect.width,C=m*(v.top-v.bottom)/v.zoom/this._elementRect.height}else return;this.verticalDragToForward?(w?this.setFocalOffset(this._focalOffsetEnd.x+x,this._focalOffsetEnd.y,this._focalOffsetEnd.z,!0):this.truck(x,0,!0),this.forward(-C,!0)):w?this.setFocalOffset(this._focalOffsetEnd.x+x,this._focalOffsetEnd.y+C,this._focalOffsetEnd.z,!0):this.truck(x,C,!0)},this._rotateInternal=(h,m)=>{const w=Lt*this.azimuthRotateSpeed*h/this._elementRect.height,x=Lt*this.polarRotateSpeed*m/this._elementRect.height;this.rotate(w,x,!0)},this._dollyInternal=(h,m,w)=>{const x=Math.pow(.95,-h*this.dollySpeed),C=this._sphericalEnd.radius,v=this._sphericalEnd.radius*x,b=nt(v,this.minDistance,this.maxDistance),D=b-v;this.infinityDolly&&this.dollyToCursor?this._dollyToNoClamp(v,!0):this.infinityDolly&&!this.dollyToCursor?(this.dollyInFixed(D,!0),this._dollyToNoClamp(b,!0)):this._dollyToNoClamp(b,!0),this.dollyToCursor&&(this._changedDolly+=(this.infinityDolly?v:b)-C,this._dollyControlCoord.set(m,w)),this._lastDollyDirection=Math.sign(-h)},this._zoomInternal=(h,m,w)=>{const x=Math.pow(.95,h*this.dollySpeed),C=this._zoom,v=this._zoom*x;this.zoomTo(v,!0),this.dollyToCursor&&(this._changedZoom+=v-C,this._dollyControlCoord.set(m,w))},typeof z>"u"&&console.error("camera-controls: `THREE` is undefined. You must first run `CameraControls.install( { THREE: THREE } )`. Check the docs for further information."),this._camera=e,this._yAxisUpSpace=new z.Quaternion().setFromUnitVectors(this._camera.up,ge),this._yAxisUpSpaceInverse=this._yAxisUpSpace.clone().invert(),this._state=A.NONE,this._target=new z.Vector3,this._targetEnd=this._target.clone(),this._focalOffset=new z.Vector3,this._focalOffsetEnd=this._focalOffset.clone(),this._spherical=new z.Spherical().setFromVector3(F.copy(this._camera.position).applyQuaternion(this._yAxisUpSpace)),this._sphericalEnd=this._spherical.clone(),this._lastDistance=this._spherical.radius,this._zoom=this._camera.zoom,this._zoomEnd=this._zoom,this._lastZoom=this._zoom,this._nearPlaneCorners=[new z.Vector3,new z.Vector3,new z.Vector3,new z.Vector3],this._updateNearPlaneCorners(),this._boundary=new z.Box3(new z.Vector3(-1/0,-1/0,-1/0),new z.Vector3(1/0,1/0,1/0)),this._cameraUp0=this._camera.up.clone(),this._target0=this._target.clone(),this._position0=this._camera.position.clone(),this._zoom0=this._zoom,this._focalOffset0=this._focalOffset.clone(),this._dollyControlCoord=new z.Vector2,this.mouseButtons={left:A.ROTATE,middle:A.DOLLY,right:A.TRUCK,wheel:gt(this._camera)?A.DOLLY:pt(this._camera)?A.ZOOM:A.NONE},this.touches={one:A.TOUCH_ROTATE,two:gt(this._camera)?A.TOUCH_DOLLY_TRUCK:pt(this._camera)?A.TOUCH_ZOOM_TRUCK:A.NONE,three:A.TOUCH_TRUCK};const s=new z.Vector2,i=new z.Vector2,r=new z.Vector2,o=h=>{if(!this._enabled||!this._domElement)return;if(this._interactiveArea.left!==0||this._interactiveArea.top!==0||this._interactiveArea.width!==1||this._interactiveArea.height!==1){const x=this._domElement.getBoundingClientRect(),C=h.clientX/x.width,v=h.clientY/x.height;if(C<this._interactiveArea.left||C>this._interactiveArea.right||v<this._interactiveArea.top||v>this._interactiveArea.bottom)return}const m=h.pointerType!=="mouse"?null:(h.buttons&B.LEFT)===B.LEFT?B.LEFT:(h.buttons&B.MIDDLE)===B.MIDDLE?B.MIDDLE:(h.buttons&B.RIGHT)===B.RIGHT?B.RIGHT:null;if(m!==null){const x=this._findPointerByMouseButton(m);x&&this._disposePointer(x)}if((h.buttons&B.LEFT)===B.LEFT&&this._lockedPointer)return;const w={pointerId:h.pointerId,clientX:h.clientX,clientY:h.clientY,deltaX:0,deltaY:0,mouseButton:m};this._activePointers.push(w),this._domElement.ownerDocument.removeEventListener("pointermove",c,{passive:!1}),this._domElement.ownerDocument.removeEventListener("pointerup",d),this._domElement.ownerDocument.addEventListener("pointermove",c,{passive:!1}),this._domElement.ownerDocument.addEventListener("pointerup",d),this._isDragging=!0,O(h)},a=h=>{if(!this._enabled||!this._domElement||this._lockedPointer)return;if(this._interactiveArea.left!==0||this._interactiveArea.top!==0||this._interactiveArea.width!==1||this._interactiveArea.height!==1){const x=this._domElement.getBoundingClientRect(),C=h.clientX/x.width,v=h.clientY/x.height;if(C<this._interactiveArea.left||C>this._interactiveArea.right||v<this._interactiveArea.top||v>this._interactiveArea.bottom)return}const m=(h.buttons&B.LEFT)===B.LEFT?B.LEFT:(h.buttons&B.MIDDLE)===B.MIDDLE?B.MIDDLE:(h.buttons&B.RIGHT)===B.RIGHT?B.RIGHT:null;if(m!==null){const x=this._findPointerByMouseButton(m);x&&this._disposePointer(x)}const w={pointerId:1,clientX:h.clientX,clientY:h.clientY,deltaX:0,deltaY:0,mouseButton:(h.buttons&B.LEFT)===B.LEFT?B.LEFT:(h.buttons&B.MIDDLE)===B.LEFT?B.MIDDLE:(h.buttons&B.RIGHT)===B.LEFT?B.RIGHT:null};this._activePointers.push(w),this._domElement.ownerDocument.removeEventListener("mousemove",f),this._domElement.ownerDocument.removeEventListener("mouseup",u),this._domElement.ownerDocument.addEventListener("mousemove",f),this._domElement.ownerDocument.addEventListener("mouseup",u),this._isDragging=!0,O(h)},c=h=>{h.cancelable&&h.preventDefault();const m=h.pointerId,w=this._lockedPointer||this._findPointerById(m);if(w){if(w.clientX=h.clientX,w.clientY=h.clientY,w.deltaX=h.movementX,w.deltaY=h.movementY,this._state=0,h.pointerType==="touch")switch(this._activePointers.length){case 1:this._state=this.touches.one;break;case 2:this._state=this.touches.two;break;case 3:this._state=this.touches.three;break}else(!this._isDragging&&this._lockedPointer||this._isDragging&&(h.buttons&B.LEFT)===B.LEFT)&&(this._state=this._state|this.mouseButtons.left),this._isDragging&&(h.buttons&B.MIDDLE)===B.MIDDLE&&(this._state=this._state|this.mouseButtons.middle),this._isDragging&&(h.buttons&B.RIGHT)===B.RIGHT&&(this._state=this._state|this.mouseButtons.right);T()}},f=h=>{const m=this._lockedPointer||this._findPointerById(1);m&&(m.clientX=h.clientX,m.clientY=h.clientY,m.deltaX=h.movementX,m.deltaY=h.movementY,this._state=0,(this._lockedPointer||(h.buttons&B.LEFT)===B.LEFT)&&(this._state=this._state|this.mouseButtons.left),(h.buttons&B.MIDDLE)===B.MIDDLE&&(this._state=this._state|this.mouseButtons.middle),(h.buttons&B.RIGHT)===B.RIGHT&&(this._state=this._state|this.mouseButtons.right),T())},d=h=>{const m=this._findPointerById(h.pointerId);if(!(m&&m===this._lockedPointer)){if(m&&this._disposePointer(m),h.pointerType==="touch")switch(this._activePointers.length){case 0:this._state=A.NONE;break;case 1:this._state=this.touches.one;break;case 2:this._state=this.touches.two;break;case 3:this._state=this.touches.three;break}else this._state=A.NONE;_()}},u=()=>{const h=this._findPointerById(1);h&&h===this._lockedPointer||(h&&this._disposePointer(h),this._state=A.NONE,_())};let l=-1;const p=h=>{if(!this._domElement||!this._enabled||this.mouseButtons.wheel===A.NONE)return;if(this._interactiveArea.left!==0||this._interactiveArea.top!==0||this._interactiveArea.width!==1||this._interactiveArea.height!==1){const v=this._domElement.getBoundingClientRect(),b=h.clientX/v.width,D=h.clientY/v.height;if(b<this._interactiveArea.left||b>this._interactiveArea.right||D<this._interactiveArea.top||D>this._interactiveArea.bottom)return}if(h.preventDefault(),this.dollyToCursor||this.mouseButtons.wheel===A.ROTATE||this.mouseButtons.wheel===A.TRUCK){const v=performance.now();l-v<1e3&&this._getClientRect(this._elementRect),l=v}const m=On?-1:-3,w=h.deltaMode===1?h.deltaY/m:h.deltaY/(m*10),x=this.dollyToCursor?(h.clientX-this._elementRect.x)/this._elementRect.width*2-1:0,C=this.dollyToCursor?(h.clientY-this._elementRect.y)/this._elementRect.height*-2+1:0;switch(this.mouseButtons.wheel){case A.ROTATE:{this._rotateInternal(h.deltaX,h.deltaY),this._isUserControllingRotate=!0;break}case A.TRUCK:{this._truckInternal(h.deltaX,h.deltaY,!1),this._isUserControllingTruck=!0;break}case A.OFFSET:{this._truckInternal(h.deltaX,h.deltaY,!0),this._isUserControllingOffset=!0;break}case A.DOLLY:{this._dollyInternal(-w,x,C),this._isUserControllingDolly=!0;break}case A.ZOOM:{this._zoomInternal(-w,x,C),this._isUserControllingZoom=!0;break}}this.dispatchEvent({type:"control"})},y=h=>{if(!(!this._domElement||!this._enabled)){if(this.mouseButtons.right===te.ACTION.NONE){const m=h instanceof PointerEvent?h.pointerId:(h instanceof MouseEvent,0),w=this._findPointerById(m);w&&this._disposePointer(w),this._domElement.ownerDocument.removeEventListener("pointermove",c,{passive:!1}),this._domElement.ownerDocument.removeEventListener("pointerup",d),this._domElement.ownerDocument.removeEventListener("mousemove",f),this._domElement.ownerDocument.removeEventListener("mouseup",u);return}h.preventDefault()}},O=h=>{if(!this._enabled)return;if(ke(this._activePointers,$),this._getClientRect(this._elementRect),s.copy($),i.copy($),this._activePointers.length>=2){const w=$.x-this._activePointers[1].clientX,x=$.y-this._activePointers[1].clientY,C=Math.sqrt(w*w+x*x);r.set(0,C);const v=(this._activePointers[0].clientX+this._activePointers[1].clientX)*.5,b=(this._activePointers[0].clientY+this._activePointers[1].clientY)*.5;i.set(v,b)}if(this._state=0,!h)this._lockedPointer&&(this._state=this._state|this.mouseButtons.left);else if("pointerType"in h&&h.pointerType==="touch")switch(this._activePointers.length){case 1:this._state=this.touches.one;break;case 2:this._state=this.touches.two;break;case 3:this._state=this.touches.three;break}else!this._lockedPointer&&(h.buttons&B.LEFT)===B.LEFT&&(this._state=this._state|this.mouseButtons.left),(h.buttons&B.MIDDLE)===B.MIDDLE&&(this._state=this._state|this.mouseButtons.middle),(h.buttons&B.RIGHT)===B.RIGHT&&(this._state=this._state|this.mouseButtons.right);((this._state&A.ROTATE)===A.ROTATE||(this._state&A.TOUCH_ROTATE)===A.TOUCH_ROTATE||(this._state&A.TOUCH_DOLLY_ROTATE)===A.TOUCH_DOLLY_ROTATE||(this._state&A.TOUCH_ZOOM_ROTATE)===A.TOUCH_ZOOM_ROTATE)&&(this._sphericalEnd.theta=this._spherical.theta,this._sphericalEnd.phi=this._spherical.phi,this._thetaVelocity.value=0,this._phiVelocity.value=0),((this._state&A.TRUCK)===A.TRUCK||(this._state&A.TOUCH_TRUCK)===A.TOUCH_TRUCK||(this._state&A.TOUCH_DOLLY_TRUCK)===A.TOUCH_DOLLY_TRUCK||(this._state&A.TOUCH_ZOOM_TRUCK)===A.TOUCH_ZOOM_TRUCK)&&(this._targetEnd.copy(this._target),this._targetVelocity.set(0,0,0)),((this._state&A.DOLLY)===A.DOLLY||(this._state&A.TOUCH_DOLLY)===A.TOUCH_DOLLY||(this._state&A.TOUCH_DOLLY_TRUCK)===A.TOUCH_DOLLY_TRUCK||(this._state&A.TOUCH_DOLLY_OFFSET)===A.TOUCH_DOLLY_OFFSET||(this._state&A.TOUCH_DOLLY_ROTATE)===A.TOUCH_DOLLY_ROTATE)&&(this._sphericalEnd.radius=this._spherical.radius,this._radiusVelocity.value=0),((this._state&A.ZOOM)===A.ZOOM||(this._state&A.TOUCH_ZOOM)===A.TOUCH_ZOOM||(this._state&A.TOUCH_ZOOM_TRUCK)===A.TOUCH_ZOOM_TRUCK||(this._state&A.TOUCH_ZOOM_OFFSET)===A.TOUCH_ZOOM_OFFSET||(this._state&A.TOUCH_ZOOM_ROTATE)===A.TOUCH_ZOOM_ROTATE)&&(this._zoomEnd=this._zoom,this._zoomVelocity.value=0),((this._state&A.OFFSET)===A.OFFSET||(this._state&A.TOUCH_OFFSET)===A.TOUCH_OFFSET||(this._state&A.TOUCH_DOLLY_OFFSET)===A.TOUCH_DOLLY_OFFSET||(this._state&A.TOUCH_ZOOM_OFFSET)===A.TOUCH_ZOOM_OFFSET)&&(this._focalOffsetEnd.copy(this._focalOffset),this._focalOffsetVelocity.set(0,0,0)),this.dispatchEvent({type:"controlstart"})},T=()=>{if(!this._enabled||!this._dragNeedsUpdate)return;this._dragNeedsUpdate=!1,ke(this._activePointers,$);const m=this._domElement&&document.pointerLockElement===this._domElement?this._lockedPointer||this._activePointers[0]:null,w=m?-m.deltaX:i.x-$.x,x=m?-m.deltaY:i.y-$.y;if(i.copy($),((this._state&A.ROTATE)===A.ROTATE||(this._state&A.TOUCH_ROTATE)===A.TOUCH_ROTATE||(this._state&A.TOUCH_DOLLY_ROTATE)===A.TOUCH_DOLLY_ROTATE||(this._state&A.TOUCH_ZOOM_ROTATE)===A.TOUCH_ZOOM_ROTATE)&&(this._rotateInternal(w,x),this._isUserControllingRotate=!0),(this._state&A.DOLLY)===A.DOLLY||(this._state&A.ZOOM)===A.ZOOM){const C=this.dollyToCursor?(s.x-this._elementRect.x)/this._elementRect.width*2-1:0,v=this.dollyToCursor?(s.y-this._elementRect.y)/this._elementRect.height*-2+1:0,b=this.dollyDragInverted?-1:1;(this._state&A.DOLLY)===A.DOLLY?(this._dollyInternal(b*x*ye,C,v),this._isUserControllingDolly=!0):(this._zoomInternal(b*x*ye,C,v),this._isUserControllingZoom=!0)}if((this._state&A.TOUCH_DOLLY)===A.TOUCH_DOLLY||(this._state&A.TOUCH_ZOOM)===A.TOUCH_ZOOM||(this._state&A.TOUCH_DOLLY_TRUCK)===A.TOUCH_DOLLY_TRUCK||(this._state&A.TOUCH_ZOOM_TRUCK)===A.TOUCH_ZOOM_TRUCK||(this._state&A.TOUCH_DOLLY_OFFSET)===A.TOUCH_DOLLY_OFFSET||(this._state&A.TOUCH_ZOOM_OFFSET)===A.TOUCH_ZOOM_OFFSET||(this._state&A.TOUCH_DOLLY_ROTATE)===A.TOUCH_DOLLY_ROTATE||(this._state&A.TOUCH_ZOOM_ROTATE)===A.TOUCH_ZOOM_ROTATE){const C=$.x-this._activePointers[1].clientX,v=$.y-this._activePointers[1].clientY,b=Math.sqrt(C*C+v*v),D=r.y-b;r.set(0,b);const P=this.dollyToCursor?(i.x-this._elementRect.x)/this._elementRect.width*2-1:0,L=this.dollyToCursor?(i.y-this._elementRect.y)/this._elementRect.height*-2+1:0;(this._state&A.TOUCH_DOLLY)===A.TOUCH_DOLLY||(this._state&A.TOUCH_DOLLY_ROTATE)===A.TOUCH_DOLLY_ROTATE||(this._state&A.TOUCH_DOLLY_TRUCK)===A.TOUCH_DOLLY_TRUCK||(this._state&A.TOUCH_DOLLY_OFFSET)===A.TOUCH_DOLLY_OFFSET?(this._dollyInternal(D*ye,P,L),this._isUserControllingDolly=!0):(this._zoomInternal(D*ye,P,L),this._isUserControllingZoom=!0)}((this._state&A.TRUCK)===A.TRUCK||(this._state&A.TOUCH_TRUCK)===A.TOUCH_TRUCK||(this._state&A.TOUCH_DOLLY_TRUCK)===A.TOUCH_DOLLY_TRUCK||(this._state&A.TOUCH_ZOOM_TRUCK)===A.TOUCH_ZOOM_TRUCK)&&(this._truckInternal(w,x,!1),this._isUserControllingTruck=!0),((this._state&A.OFFSET)===A.OFFSET||(this._state&A.TOUCH_OFFSET)===A.TOUCH_OFFSET||(this._state&A.TOUCH_DOLLY_OFFSET)===A.TOUCH_DOLLY_OFFSET||(this._state&A.TOUCH_ZOOM_OFFSET)===A.TOUCH_ZOOM_OFFSET)&&(this._truckInternal(w,x,!0),this._isUserControllingOffset=!0),this.dispatchEvent({type:"control"})},_=()=>{ke(this._activePointers,$),i.copy($),this._dragNeedsUpdate=!1,(this._activePointers.length===0||this._activePointers.length===1&&this._activePointers[0]===this._lockedPointer)&&(this._isDragging=!1),this._activePointers.length===0&&this._domElement&&(this._domElement.ownerDocument.removeEventListener("pointermove",c,{passive:!1}),this._domElement.ownerDocument.removeEventListener("mousemove",f),this._domElement.ownerDocument.removeEventListener("pointerup",d),this._domElement.ownerDocument.removeEventListener("mouseup",u),this.dispatchEvent({type:"controlend"}))};this.lockPointer=()=>{!this._enabled||!this._domElement||(this.cancel(),this._lockedPointer={pointerId:-1,clientX:0,clientY:0,deltaX:0,deltaY:0,mouseButton:null},this._activePointers.push(this._lockedPointer),this._domElement.ownerDocument.removeEventListener("pointermove",c,{passive:!1}),this._domElement.ownerDocument.removeEventListener("pointerup",d),this._domElement.requestPointerLock(),this._domElement.ownerDocument.addEventListener("pointerlockchange",g),this._domElement.ownerDocument.addEventListener("pointerlockerror",E),this._domElement.ownerDocument.addEventListener("pointermove",c,{passive:!1}),this._domElement.ownerDocument.addEventListener("pointerup",d),O())},this.unlockPointer=()=>{this._lockedPointer!==null&&(this._disposePointer(this._lockedPointer),this._lockedPointer=null),document.exitPointerLock(),this.cancel(),this._domElement&&(this._domElement.ownerDocument.removeEventListener("pointerlockchange",g),this._domElement.ownerDocument.removeEventListener("pointerlockerror",E))};const g=()=>{this._domElement&&this._domElement.ownerDocument.pointerLockElement===this._domElement||this.unlockPointer()},E=()=>{this.unlockPointer()};this._addAllEventListeners=h=>{this._domElement=h,this._domElement.style.touchAction="none",this._domElement.style.userSelect="none",this._domElement.style.webkitUserSelect="none",this._domElement.addEventListener("pointerdown",o),An&&this._domElement.addEventListener("mousedown",a),this._domElement.addEventListener("pointercancel",d),this._domElement.addEventListener("wheel",p,{passive:!1}),this._domElement.addEventListener("contextmenu",y)},this._removeAllEventListeners=()=>{this._domElement&&(this._domElement.style.touchAction="",this._domElement.style.userSelect="",this._domElement.style.webkitUserSelect="",this._domElement.removeEventListener("pointerdown",o),this._domElement.removeEventListener("mousedown",a),this._domElement.removeEventListener("pointercancel",d),this._domElement.removeEventListener("wheel",p,{passive:!1}),this._domElement.removeEventListener("contextmenu",y),this._domElement.ownerDocument.removeEventListener("pointermove",c,{passive:!1}),this._domElement.ownerDocument.removeEventListener("mousemove",f),this._domElement.ownerDocument.removeEventListener("pointerup",d),this._domElement.ownerDocument.removeEventListener("mouseup",u),this._domElement.ownerDocument.removeEventListener("pointerlockchange",g),this._domElement.ownerDocument.removeEventListener("pointerlockerror",E))},this.cancel=()=>{this._state!==A.NONE&&(this._state=A.NONE,this._activePointers.length=0,_())},t&&this.connect(t),this.update(0)}get camera(){return this._camera}set camera(e){this._camera=e,this.updateCameraUp(),this._camera.updateProjectionMatrix(),this._updateNearPlaneCorners(),this._needsUpdate=!0}get enabled(){return this._enabled}set enabled(e){this._enabled=e,this._domElement&&(e?(this._domElement.style.touchAction="none",this._domElement.style.userSelect="none",this._domElement.style.webkitUserSelect="none"):(this.cancel(),this._domElement.style.touchAction="",this._domElement.style.userSelect="",this._domElement.style.webkitUserSelect=""))}get active(){return!this._hasRested}get currentAction(){return this._state}get distance(){return this._spherical.radius}set distance(e){this._spherical.radius===e&&this._sphericalEnd.radius===e||(this._spherical.radius=e,this._sphericalEnd.radius=e,this._needsUpdate=!0)}get azimuthAngle(){return this._spherical.theta}set azimuthAngle(e){this._spherical.theta===e&&this._sphericalEnd.theta===e||(this._spherical.theta=e,this._sphericalEnd.theta=e,this._needsUpdate=!0)}get polarAngle(){return this._spherical.phi}set polarAngle(e){this._spherical.phi===e&&this._sphericalEnd.phi===e||(this._spherical.phi=e,this._sphericalEnd.phi=e,this._needsUpdate=!0)}get boundaryEnclosesCamera(){return this._boundaryEnclosesCamera}set boundaryEnclosesCamera(e){this._boundaryEnclosesCamera=e,this._needsUpdate=!0}set interactiveArea(e){this._interactiveArea.width=nt(e.width,0,1),this._interactiveArea.height=nt(e.height,0,1),this._interactiveArea.x=nt(e.x,0,1-this._interactiveArea.width),this._interactiveArea.y=nt(e.y,0,1-this._interactiveArea.height)}addEventListener(e,t){super.addEventListener(e,t)}removeEventListener(e,t){super.removeEventListener(e,t)}rotate(e,t,s=!1){return this.rotateTo(this._sphericalEnd.theta+e,this._sphericalEnd.phi+t,s)}rotateAzimuthTo(e,t=!1){return this.rotateTo(e,this._sphericalEnd.phi,t)}rotatePolarTo(e,t=!1){return this.rotateTo(this._sphericalEnd.theta,e,t)}rotateTo(e,t,s=!1){this._isUserControllingRotate=!1;const i=nt(e,this.minAzimuthAngle,this.maxAzimuthAngle),r=nt(t,this.minPolarAngle,this.maxPolarAngle);this._sphericalEnd.theta=i,this._sphericalEnd.phi=r,this._sphericalEnd.makeSafe(),this._needsUpdate=!0,s||(this._spherical.theta=this._sphericalEnd.theta,this._spherical.phi=this._sphericalEnd.phi);const o=!s||H(this._spherical.theta,this._sphericalEnd.theta,this.restThreshold)&&H(this._spherical.phi,this._sphericalEnd.phi,this.restThreshold);return this._createOnRestPromise(o)}dolly(e,t=!1){return this.dollyTo(this._sphericalEnd.radius-e,t)}dollyTo(e,t=!1){return this._isUserControllingDolly=!1,this._lastDollyDirection=Dt.NONE,this._changedDolly=0,this._dollyToNoClamp(nt(e,this.minDistance,this.maxDistance),t)}_dollyToNoClamp(e,t=!1){const s=this._sphericalEnd.radius;if(this.colliderMeshes.length>=1){const o=this._collisionTest(),a=H(o,this._spherical.radius);if(!(s>e)&&a)return Promise.resolve();this._sphericalEnd.radius=Math.min(e,o)}else this._sphericalEnd.radius=e;this._needsUpdate=!0,t||(this._spherical.radius=this._sphericalEnd.radius);const r=!t||H(this._spherical.radius,this._sphericalEnd.radius,this.restThreshold);return this._createOnRestPromise(r)}dollyInFixed(e,t=!1){this._targetEnd.add(this._getCameraDirection($t).multiplyScalar(e)),t||this._target.copy(this._targetEnd);const s=!t||H(this._target.x,this._targetEnd.x,this.restThreshold)&&H(this._target.y,this._targetEnd.y,this.restThreshold)&&H(this._target.z,this._targetEnd.z,this.restThreshold);return this._createOnRestPromise(s)}zoom(e,t=!1){return this.zoomTo(this._zoomEnd+e,t)}zoomTo(e,t=!1){this._isUserControllingZoom=!1,this._zoomEnd=nt(e,this.minZoom,this.maxZoom),this._needsUpdate=!0,t||(this._zoom=this._zoomEnd);const s=!t||H(this._zoom,this._zoomEnd,this.restThreshold);return this._changedZoom=0,this._createOnRestPromise(s)}pan(e,t,s=!1){return console.warn("`pan` has been renamed to `truck`"),this.truck(e,t,s)}truck(e,t,s=!1){this._camera.updateMatrix(),rt.setFromMatrixColumn(this._camera.matrix,0),at.setFromMatrixColumn(this._camera.matrix,1),rt.multiplyScalar(e),at.multiplyScalar(-t);const i=F.copy(rt).add(at),r=I.copy(this._targetEnd).add(i);return this.moveTo(r.x,r.y,r.z,s)}forward(e,t=!1){F.setFromMatrixColumn(this._camera.matrix,0),F.crossVectors(this._camera.up,F),F.multiplyScalar(e);const s=I.copy(this._targetEnd).add(F);return this.moveTo(s.x,s.y,s.z,t)}elevate(e,t=!1){return F.copy(this._camera.up).multiplyScalar(e),this.moveTo(this._targetEnd.x+F.x,this._targetEnd.y+F.y,this._targetEnd.z+F.z,t)}moveTo(e,t,s,i=!1){this._isUserControllingTruck=!1;const r=F.set(e,t,s).sub(this._targetEnd);this._encloseToBoundary(this._targetEnd,r,this.boundaryFriction),this._needsUpdate=!0,i||this._target.copy(this._targetEnd);const o=!i||H(this._target.x,this._targetEnd.x,this.restThreshold)&&H(this._target.y,this._targetEnd.y,this.restThreshold)&&H(this._target.z,this._targetEnd.z,this.restThreshold);return this._createOnRestPromise(o)}lookInDirectionOf(e,t,s,i=!1){const a=F.set(e,t,s).sub(this._targetEnd).normalize().multiplyScalar(-this._sphericalEnd.radius);return this.setPosition(a.x,a.y,a.z,i)}fitToBox(e,t,{cover:s=!1,paddingLeft:i=0,paddingRight:r=0,paddingBottom:o=0,paddingTop:a=0}={}){const c=[],f=e.isBox3?Mt.copy(e):Mt.setFromObject(e);f.isEmpty()&&(console.warn("camera-controls: fitTo() cannot be used with an empty box. Aborting"),Promise.resolve());const d=Us(this._sphericalEnd.theta,Ps),u=Us(this._sphericalEnd.phi,Ps);c.push(this.rotateTo(d,u,t));const l=F.setFromSpherical(this._sphericalEnd).normalize(),p=Bs.setFromUnitVectors(l,Ye),y=H(Math.abs(l.y),1);y&&p.multiply(Ze.setFromAxisAngle(ge,d)),p.multiply(this._yAxisUpSpaceInverse);const O=zs.makeEmpty();I.copy(f.min).applyQuaternion(p),O.expandByPoint(I),I.copy(f.min).setX(f.max.x).applyQuaternion(p),O.expandByPoint(I),I.copy(f.min).setY(f.max.y).applyQuaternion(p),O.expandByPoint(I),I.copy(f.max).setZ(f.min.z).applyQuaternion(p),O.expandByPoint(I),I.copy(f.min).setZ(f.max.z).applyQuaternion(p),O.expandByPoint(I),I.copy(f.max).setY(f.min.y).applyQuaternion(p),O.expandByPoint(I),I.copy(f.max).setX(f.min.x).applyQuaternion(p),O.expandByPoint(I),I.copy(f.max).applyQuaternion(p),O.expandByPoint(I),O.min.x-=i,O.min.y-=o,O.max.x+=r,O.max.y+=a,p.setFromUnitVectors(Ye,l),y&&p.premultiply(Ze.invert()),p.premultiply(this._yAxisUpSpace);const T=O.getSize(F),_=O.getCenter(I).applyQuaternion(p);if(gt(this._camera)){const g=this.getDistanceToFitBox(T.x,T.y,T.z,s);c.push(this.moveTo(_.x,_.y,_.z,t)),c.push(this.dollyTo(g,t)),c.push(this.setFocalOffset(0,0,0,t))}else if(pt(this._camera)){const g=this._camera,E=g.right-g.left,h=g.top-g.bottom,m=s?Math.max(E/T.x,h/T.y):Math.min(E/T.x,h/T.y);c.push(this.moveTo(_.x,_.y,_.z,t)),c.push(this.zoomTo(m,t)),c.push(this.setFocalOffset(0,0,0,t))}return Promise.all(c)}fitToSphere(e,t){const s=[],r=e instanceof z.Sphere?Ne.copy(e):te.createBoundingSphere(e,Ne);if(s.push(this.moveTo(r.center.x,r.center.y,r.center.z,t)),gt(this._camera)){const o=this.getDistanceToFitSphere(r.radius);s.push(this.dollyTo(o,t))}else if(pt(this._camera)){const o=this._camera.right-this._camera.left,a=this._camera.top-this._camera.bottom,c=2*r.radius,f=Math.min(o/c,a/c);s.push(this.zoomTo(f,t))}return s.push(this.setFocalOffset(0,0,0,t)),Promise.all(s)}setLookAt(e,t,s,i,r,o,a=!1){this._isUserControllingRotate=!1,this._isUserControllingDolly=!1,this._isUserControllingTruck=!1,this._lastDollyDirection=Dt.NONE,this._changedDolly=0;const c=I.set(i,r,o),f=F.set(e,t,s);this._targetEnd.copy(c),this._sphericalEnd.setFromVector3(f.sub(c).applyQuaternion(this._yAxisUpSpace)),this.normalizeRotations(),this._needsUpdate=!0,a||(this._target.copy(this._targetEnd),this._spherical.copy(this._sphericalEnd));const d=!a||H(this._target.x,this._targetEnd.x,this.restThreshold)&&H(this._target.y,this._targetEnd.y,this.restThreshold)&&H(this._target.z,this._targetEnd.z,this.restThreshold)&&H(this._spherical.theta,this._sphericalEnd.theta,this.restThreshold)&&H(this._spherical.phi,this._sphericalEnd.phi,this.restThreshold)&&H(this._spherical.radius,this._sphericalEnd.radius,this.restThreshold);return this._createOnRestPromise(d)}lerpLookAt(e,t,s,i,r,o,a,c,f,d,u,l,p,y=!1){this._isUserControllingRotate=!1,this._isUserControllingDolly=!1,this._isUserControllingTruck=!1,this._lastDollyDirection=Dt.NONE,this._changedDolly=0;const O=F.set(i,r,o),T=I.set(e,t,s);Q.setFromVector3(T.sub(O).applyQuaternion(this._yAxisUpSpace));const _=St.set(d,u,l),g=I.set(a,c,f);Kt.setFromVector3(g.sub(_).applyQuaternion(this._yAxisUpSpace)),this._targetEnd.copy(O.lerp(_,p));const E=Kt.theta-Q.theta,h=Kt.phi-Q.phi,m=Kt.radius-Q.radius;this._sphericalEnd.set(Q.radius+m*p,Q.phi+h*p,Q.theta+E*p),this.normalizeRotations(),this._needsUpdate=!0,y||(this._target.copy(this._targetEnd),this._spherical.copy(this._sphericalEnd));const w=!y||H(this._target.x,this._targetEnd.x,this.restThreshold)&&H(this._target.y,this._targetEnd.y,this.restThreshold)&&H(this._target.z,this._targetEnd.z,this.restThreshold)&&H(this._spherical.theta,this._sphericalEnd.theta,this.restThreshold)&&H(this._spherical.phi,this._sphericalEnd.phi,this.restThreshold)&&H(this._spherical.radius,this._sphericalEnd.radius,this.restThreshold);return this._createOnRestPromise(w)}setPosition(e,t,s,i=!1){return this.setLookAt(e,t,s,this._targetEnd.x,this._targetEnd.y,this._targetEnd.z,i)}setTarget(e,t,s,i=!1){const r=this.getPosition(F),o=this.setLookAt(r.x,r.y,r.z,e,t,s,i);return this._sphericalEnd.phi=nt(this._sphericalEnd.phi,this.minPolarAngle,this.maxPolarAngle),o}setFocalOffset(e,t,s,i=!1){this._isUserControllingOffset=!1,this._focalOffsetEnd.set(e,t,s),this._needsUpdate=!0,i||this._focalOffset.copy(this._focalOffsetEnd);const r=!i||H(this._focalOffset.x,this._focalOffsetEnd.x,this.restThreshold)&&H(this._focalOffset.y,this._focalOffsetEnd.y,this.restThreshold)&&H(this._focalOffset.z,this._focalOffsetEnd.z,this.restThreshold);return this._createOnRestPromise(r)}setOrbitPoint(e,t,s){this._camera.updateMatrixWorld(),rt.setFromMatrixColumn(this._camera.matrixWorldInverse,0),at.setFromMatrixColumn(this._camera.matrixWorldInverse,1),Tt.setFromMatrixColumn(this._camera.matrixWorldInverse,2);const i=F.set(e,t,s),r=i.distanceTo(this._camera.position),o=i.sub(this._camera.position);rt.multiplyScalar(o.x),at.multiplyScalar(o.y),Tt.multiplyScalar(o.z),F.copy(rt).add(at).add(Tt),F.z=F.z+r,this.dollyTo(r,!1),this.setFocalOffset(-F.x,F.y,-F.z,!1),this.moveTo(e,t,s,!1)}setBoundary(e){if(!e){this._boundary.min.set(-1/0,-1/0,-1/0),this._boundary.max.set(1/0,1/0,1/0),this._needsUpdate=!0;return}this._boundary.copy(e),this._boundary.clampPoint(this._targetEnd,this._targetEnd),this._needsUpdate=!0}setViewport(e,t,s,i){if(e===null){this._viewport=null;return}this._viewport=this._viewport||new z.Vector4,typeof e=="number"?this._viewport.set(e,t,s,i):this._viewport.copy(e)}getDistanceToFitBox(e,t,s,i=!1){if(Ve(this._camera,"getDistanceToFitBox"))return this._spherical.radius;const r=e/t,o=this._camera.getEffectiveFOV()*Xt,a=this._camera.aspect;return((i?r>a:r<a)?t:e/a)*.5/Math.tan(o*.5)+s*.5}getDistanceToFitSphere(e){if(Ve(this._camera,"getDistanceToFitSphere"))return this._spherical.radius;const t=this._camera.getEffectiveFOV()*Xt,s=Math.atan(Math.tan(t*.5)*this._camera.aspect)*2,i=1<this._camera.aspect?t:s;return e/Math.sin(i*.5)}getTarget(e,t=!0){return(e&&e.isVector3?e:new z.Vector3).copy(t?this._targetEnd:this._target)}getPosition(e,t=!0){return(e&&e.isVector3?e:new z.Vector3).setFromSpherical(t?this._sphericalEnd:this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(t?this._targetEnd:this._target)}getSpherical(e,t=!0){return(e&&e instanceof z.Spherical?e:new z.Spherical).copy(t?this._sphericalEnd:this._spherical)}getFocalOffset(e,t=!0){return(e&&e.isVector3?e:new z.Vector3).copy(t?this._focalOffsetEnd:this._focalOffset)}normalizeRotations(){this._sphericalEnd.theta=this._sphericalEnd.theta%Lt,this._sphericalEnd.theta<0&&(this._sphericalEnd.theta+=Lt),this._spherical.theta+=Lt*Math.round((this._sphericalEnd.theta-this._spherical.theta)/Lt)}reset(e=!1){if(!H(this._camera.up.x,this._cameraUp0.x)||!H(this._camera.up.y,this._cameraUp0.y)||!H(this._camera.up.z,this._cameraUp0.z)){this._camera.up.copy(this._cameraUp0);const s=this.getPosition(F);this.updateCameraUp(),this.setPosition(s.x,s.y,s.z)}const t=[this.setLookAt(this._position0.x,this._position0.y,this._position0.z,this._target0.x,this._target0.y,this._target0.z,e),this.setFocalOffset(this._focalOffset0.x,this._focalOffset0.y,this._focalOffset0.z,e),this.zoomTo(this._zoom0,e)];return Promise.all(t)}saveState(){this._cameraUp0.copy(this._camera.up),this.getTarget(this._target0),this.getPosition(this._position0),this._zoom0=this._zoom,this._focalOffset0.copy(this._focalOffset)}updateCameraUp(){this._yAxisUpSpace.setFromUnitVectors(this._camera.up,ge),this._yAxisUpSpaceInverse.copy(this._yAxisUpSpace).invert()}applyCameraUp(){const e=F.subVectors(this._target,this._camera.position).normalize(),t=I.crossVectors(e,this._camera.up);this._camera.up.crossVectors(t,e).normalize(),this._camera.updateMatrixWorld();const s=this.getPosition(F);this.updateCameraUp(),this.setPosition(s.x,s.y,s.z)}update(e){const t=this._sphericalEnd.theta-this._spherical.theta,s=this._sphericalEnd.phi-this._spherical.phi,i=this._sphericalEnd.radius-this._spherical.radius,r=Ss.subVectors(this._targetEnd,this._target),o=Ms.subVectors(this._focalOffsetEnd,this._focalOffset),a=this._zoomEnd-this._zoom;if(k(t))this._thetaVelocity.value=0,this._spherical.theta=this._sphericalEnd.theta;else{const u=this._isUserControllingRotate?this.draggingSmoothTime:this.smoothTime;this._spherical.theta=_e(this._spherical.theta,this._sphericalEnd.theta,this._thetaVelocity,u,1/0,e),this._needsUpdate=!0}if(k(s))this._phiVelocity.value=0,this._spherical.phi=this._sphericalEnd.phi;else{const u=this._isUserControllingRotate?this.draggingSmoothTime:this.smoothTime;this._spherical.phi=_e(this._spherical.phi,this._sphericalEnd.phi,this._phiVelocity,u,1/0,e),this._needsUpdate=!0}if(k(i))this._radiusVelocity.value=0,this._spherical.radius=this._sphericalEnd.radius;else{const u=this._isUserControllingDolly?this.draggingSmoothTime:this.smoothTime;this._spherical.radius=_e(this._spherical.radius,this._sphericalEnd.radius,this._radiusVelocity,u,this.maxSpeed,e),this._needsUpdate=!0}if(k(r.x)&&k(r.y)&&k(r.z))this._targetVelocity.set(0,0,0),this._target.copy(this._targetEnd);else{const u=this._isUserControllingTruck?this.draggingSmoothTime:this.smoothTime;Ds(this._target,this._targetEnd,this._targetVelocity,u,this.maxSpeed,e,this._target),this._needsUpdate=!0}if(k(o.x)&&k(o.y)&&k(o.z))this._focalOffsetVelocity.set(0,0,0),this._focalOffset.copy(this._focalOffsetEnd);else{const u=this._isUserControllingOffset?this.draggingSmoothTime:this.smoothTime;Ds(this._focalOffset,this._focalOffsetEnd,this._focalOffsetVelocity,u,this.maxSpeed,e,this._focalOffset),this._needsUpdate=!0}if(k(a))this._zoomVelocity.value=0,this._zoom=this._zoomEnd;else{const u=this._isUserControllingZoom?this.draggingSmoothTime:this.smoothTime;this._zoom=_e(this._zoom,this._zoomEnd,this._zoomVelocity,u,1/0,e)}if(this.dollyToCursor){if(gt(this._camera)&&this._changedDolly!==0){const u=this._spherical.radius-this._lastDistance,l=this._camera,p=this._getCameraDirection($t),y=F.copy(p).cross(l.up).normalize();y.lengthSq()===0&&(y.x=1);const O=I.crossVectors(y,p),T=this._sphericalEnd.radius*Math.tan(l.getEffectiveFOV()*Xt*.5),g=(this._sphericalEnd.radius-u-this._sphericalEnd.radius)/this._sphericalEnd.radius,E=St.copy(this._targetEnd).add(y.multiplyScalar(this._dollyControlCoord.x*T*l.aspect)).add(O.multiplyScalar(this._dollyControlCoord.y*T)),h=F.copy(this._targetEnd).lerp(E,g),m=this._lastDollyDirection===Dt.IN&&this._spherical.radius<=this.minDistance,w=this._lastDollyDirection===Dt.OUT&&this.maxDistance<=this._spherical.radius;if(this.infinityDolly&&(m||w)){this._sphericalEnd.radius-=u,this._spherical.radius-=u;const C=I.copy(p).multiplyScalar(-u);h.add(C)}this._boundary.clampPoint(h,h);const x=I.subVectors(h,this._targetEnd);this._targetEnd.copy(h),this._target.add(x),this._changedDolly-=u,k(this._changedDolly)&&(this._changedDolly=0)}else if(pt(this._camera)&&this._changedZoom!==0){const u=this._zoom-this._lastZoom,l=this._camera,p=F.set(this._dollyControlCoord.x,this._dollyControlCoord.y,(l.near+l.far)/(l.near-l.far)).unproject(l),y=I.set(0,0,-1).applyQuaternion(l.quaternion),O=St.copy(p).add(y.multiplyScalar(-p.dot(l.up))),_=-(this._zoom-u-this._zoom)/this._zoom,g=this._getCameraDirection($t),E=this._targetEnd.dot(g),h=F.copy(this._targetEnd).lerp(O,_),m=h.dot(g),w=g.multiplyScalar(m-E);h.sub(w),this._boundary.clampPoint(h,h);const x=I.subVectors(h,this._targetEnd);this._targetEnd.copy(h),this._target.add(x),this._changedZoom-=u,k(this._changedZoom)&&(this._changedZoom=0)}}this._camera.zoom!==this._zoom&&(this._camera.zoom=this._zoom,this._camera.updateProjectionMatrix(),this._updateNearPlaneCorners(),this._needsUpdate=!0),this._dragNeedsUpdate=!0;const c=this._collisionTest();this._spherical.radius=Math.min(this._spherical.radius,c),this._spherical.makeSafe(),this._camera.position.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(this._target),this._camera.lookAt(this._target),(!k(this._focalOffset.x)||!k(this._focalOffset.y)||!k(this._focalOffset.z))&&(this._camera.updateMatrixWorld(),rt.setFromMatrixColumn(this._camera.matrix,0),at.setFromMatrixColumn(this._camera.matrix,1),Tt.setFromMatrixColumn(this._camera.matrix,2),rt.multiplyScalar(this._focalOffset.x),at.multiplyScalar(-this._focalOffset.y),Tt.multiplyScalar(this._focalOffset.z),F.copy(rt).add(at).add(Tt),this._camera.position.add(F)),this._boundaryEnclosesCamera&&this._encloseToBoundary(this._camera.position.copy(this._target),F.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse),1);const d=this._needsUpdate;return d&&!this._updatedLastTime?(this._hasRested=!1,this.dispatchEvent({type:"wake"}),this.dispatchEvent({type:"update"})):d?(this.dispatchEvent({type:"update"}),k(t,this.restThreshold)&&k(s,this.restThreshold)&&k(i,this.restThreshold)&&k(r.x,this.restThreshold)&&k(r.y,this.restThreshold)&&k(r.z,this.restThreshold)&&k(o.x,this.restThreshold)&&k(o.y,this.restThreshold)&&k(o.z,this.restThreshold)&&k(a,this.restThreshold)&&!this._hasRested&&(this._hasRested=!0,this.dispatchEvent({type:"rest"}))):!d&&this._updatedLastTime&&this.dispatchEvent({type:"sleep"}),this._lastDistance=this._spherical.radius,this._lastZoom=this._zoom,this._updatedLastTime=d,this._needsUpdate=!1,d}toJSON(){return JSON.stringify({enabled:this._enabled,minDistance:this.minDistance,maxDistance:Wt(this.maxDistance),minZoom:this.minZoom,maxZoom:Wt(this.maxZoom),minPolarAngle:this.minPolarAngle,maxPolarAngle:Wt(this.maxPolarAngle),minAzimuthAngle:Wt(this.minAzimuthAngle),maxAzimuthAngle:Wt(this.maxAzimuthAngle),smoothTime:this.smoothTime,draggingSmoothTime:this.draggingSmoothTime,dollySpeed:this.dollySpeed,truckSpeed:this.truckSpeed,dollyToCursor:this.dollyToCursor,verticalDragToForward:this.verticalDragToForward,target:this._targetEnd.toArray(),position:F.setFromSpherical(this._sphericalEnd).add(this._targetEnd).toArray(),zoom:this._zoomEnd,focalOffset:this._focalOffsetEnd.toArray(),target0:this._target0.toArray(),position0:this._position0.toArray(),zoom0:this._zoom0,focalOffset0:this._focalOffset0.toArray()})}fromJSON(e,t=!1){const s=JSON.parse(e);this.enabled=s.enabled,this.minDistance=s.minDistance,this.maxDistance=qt(s.maxDistance),this.minZoom=s.minZoom,this.maxZoom=qt(s.maxZoom),this.minPolarAngle=s.minPolarAngle,this.maxPolarAngle=qt(s.maxPolarAngle),this.minAzimuthAngle=qt(s.minAzimuthAngle),this.maxAzimuthAngle=qt(s.maxAzimuthAngle),this.smoothTime=s.smoothTime,this.draggingSmoothTime=s.draggingSmoothTime,this.dollySpeed=s.dollySpeed,this.truckSpeed=s.truckSpeed,this.dollyToCursor=s.dollyToCursor,this.verticalDragToForward=s.verticalDragToForward,this._target0.fromArray(s.target0),this._position0.fromArray(s.position0),this._zoom0=s.zoom0,this._focalOffset0.fromArray(s.focalOffset0),this.moveTo(s.target[0],s.target[1],s.target[2],t),Q.setFromVector3(F.fromArray(s.position).sub(this._targetEnd).applyQuaternion(this._yAxisUpSpace)),this.rotateTo(Q.theta,Q.phi,t),this.dollyTo(Q.radius,t),this.zoomTo(s.zoom,t),this.setFocalOffset(s.focalOffset[0],s.focalOffset[1],s.focalOffset[2],t),this._needsUpdate=!0}connect(e){if(this._domElement){console.warn("camera-controls is already connected.");return}e.setAttribute("data-camera-controls-version",xn),this._addAllEventListeners(e),this._getClientRect(this._elementRect)}disconnect(){this.cancel(),this._removeAllEventListeners(),this._domElement&&(this._domElement.removeAttribute("data-camera-controls-version"),this._domElement=void 0)}dispose(){this.removeAllEventListeners(),this.disconnect()}_getTargetDirection(e){return e.setFromSpherical(this._spherical).divideScalar(this._spherical.radius).applyQuaternion(this._yAxisUpSpaceInverse)}_getCameraDirection(e){return this._getTargetDirection(e).negate()}_findPointerById(e){return this._activePointers.find(t=>t.pointerId===e)}_findPointerByMouseButton(e){return this._activePointers.find(t=>t.mouseButton===e)}_disposePointer(e){this._activePointers.splice(this._activePointers.indexOf(e),1)}_encloseToBoundary(e,t,s){const i=t.lengthSq();if(i===0)return e;const r=I.copy(t).add(e),a=this._boundary.clampPoint(r,St).sub(r),c=a.lengthSq();if(c===0)return e.add(t);if(c===i)return e;if(s===0)return e.add(t).add(a);{const f=1+s*c/t.dot(a);return e.add(I.copy(t).multiplyScalar(f)).add(a.multiplyScalar(1-s))}}_updateNearPlaneCorners(){if(gt(this._camera)){const e=this._camera,t=e.near,s=e.getEffectiveFOV()*Xt,i=Math.tan(s*.5)*t,r=i*e.aspect;this._nearPlaneCorners[0].set(-r,-i,0),this._nearPlaneCorners[1].set(r,-i,0),this._nearPlaneCorners[2].set(r,i,0),this._nearPlaneCorners[3].set(-r,i,0)}else if(pt(this._camera)){const e=this._camera,t=1/e.zoom,s=e.left*t,i=e.right*t,r=e.top*t,o=e.bottom*t;this._nearPlaneCorners[0].set(s,r,0),this._nearPlaneCorners[1].set(i,r,0),this._nearPlaneCorners[2].set(i,o,0),this._nearPlaneCorners[3].set(s,o,0)}}_collisionTest(){let e=1/0;if(!(this.colliderMeshes.length>=1)||Ve(this._camera,"_collisionTest"))return e;const s=this._getTargetDirection($t);Xe.lookAt(Ls,s,this._camera.up);for(let i=0;i<4;i++){const r=I.copy(this._nearPlaneCorners[i]);r.applyMatrix4(Xe);const o=St.addVectors(this._target,r);Te.set(o,s),Te.far=this._spherical.radius+1;const a=Te.intersectObjects(this.colliderMeshes);a.length!==0&&a[0].distance<e&&(e=a[0].distance)}return e}_getClientRect(e){if(!this._domElement)return;const t=this._domElement.getBoundingClientRect();return e.x=t.left,e.y=t.top,this._viewport?(e.x+=this._viewport.x,e.y+=t.height-this._viewport.w-this._viewport.y,e.width=this._viewport.z,e.height=this._viewport.w):(e.width=t.width,e.height=t.height),e}_createOnRestPromise(e){return e?Promise.resolve():(this._hasRested=!1,this.dispatchEvent({type:"transitionstart"}),new Promise(t=>{const s=()=>{this.removeEventListener("rest",s),t()};this.addEventListener("rest",s)}))}_addAllEventListeners(e){}_removeAllEventListeners(){}get dampingFactor(){return console.warn(".dampingFactor has been deprecated. use smoothTime (in seconds) instead."),0}set dampingFactor(e){console.warn(".dampingFactor has been deprecated. use smoothTime (in seconds) instead.")}get draggingDampingFactor(){return console.warn(".draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead."),0}set draggingDampingFactor(e){console.warn(".draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead.")}static createBoundingSphere(e,t=new z.Sphere){const s=t,i=s.center;Mt.makeEmpty(),e.traverseVisible(o=>{o.isMesh&&Mt.expandByObject(o)}),Mt.getCenter(i);let r=0;return e.traverseVisible(o=>{if(!o.isMesh)return;const a=o,c=a.geometry.clone();c.applyMatrix4(a.matrixWorld);const d=c.attributes.position;for(let u=0,l=d.count;u<l;u++)F.fromBufferAttribute(d,u),r=Math.max(r,i.distanceToSquared(F))}),s.radius=Math.sqrt(r),s}}class Ae extends yn{constructor(t){super(t);U(this,"onBeforeUpdate",new Y);U(this,"onAfterUpdate",new Y);U(this,"onAspectUpdated",new Y);U(this,"onDisposed",new Y);U(this,"three");U(this,"_allControls",new Map);U(this,"updateAspect",()=>{var t;if(!(!this.currentWorld||!this.currentWorld.renderer)){if(this.three instanceof ei){this.onAspectUpdated.trigger();return}if((t=this.currentWorld.renderer)!=null&&t.isResizeable()){const s=this.currentWorld.renderer.getSize();this.three.aspect=s.width/s.height,this.three.updateProjectionMatrix(),this.onAspectUpdated.trigger()}}});this.three=this.setupCamera(),this.setupEvents(!0),this.onWorldChanged.add(({action:s,world:i})=>{if(s==="added"){const r=this.newCameraControls();this._allControls.set(i.uuid,r)}if(s==="removed"){const r=this._allControls.get(i.uuid);r&&(r.dispose(),this._allControls.delete(i.uuid))}})}get controls(){if(!this.currentWorld)throw new Error("This camera needs a world to work!");const t=this._allControls.get(this.currentWorld.uuid);if(!t)throw new Error("Controls not found!");return t}get enabled(){return this.currentWorld===null?!1:this.controls.enabled}set enabled(t){this.controls.enabled=t}dispose(){this.setupEvents(!1),this.onAspectUpdated.reset(),this.onBeforeUpdate.reset(),this.onAfterUpdate.reset(),this.three.removeFromParent(),this.onDisposed.trigger(),this.onDisposed.reset();for(const[t,s]of this._allControls)s.dispose()}update(t){this.enabled&&(this.onBeforeUpdate.trigger(this),this.controls.update(t),this.onAfterUpdate.trigger(this))}setupCamera(){const t=window.innerWidth/window.innerHeight,s=new si(60,t,1,1e3);return s.position.set(50,50,50),s.lookAt(new S(0,0,0)),s}newCameraControls(){if(!this.currentWorld)throw new Error("This camera needs a world to work!");if(!this.currentWorld.renderer)throw new Error("This camera needs a renderer to work!");te.install({THREE:Ae.getSubsetOfThree()});const{domElement:t}=this.currentWorld.renderer.three,s=new te(this.three,t);return s.smoothTime=.2,s.dollyToCursor=!0,s.infinityDolly=!0,s}setupEvents(t){t?window.addEventListener("resize",this.updateAspect):window.removeEventListener("resize",this.updateAspect)}static getSubsetOfThree(){return{MOUSE:ii,Vector2:ht,Vector3:S,Vector4:ni,Quaternion:oi,Matrix4:ut,Spherical:ri,Box3:st,Sphere:Hs,Raycaster:ai,MathUtils:ci}}}const ve=class ve extends ns{constructor(t){super(t);U(this,"onAfterUpdate",new Y);U(this,"onBeforeUpdate",new Y);U(this,"onDisposed",new Y);U(this,"onWorldCreated",new Y);U(this,"onWorldDeleted",new Y);U(this,"list",new Map);U(this,"enabled",!0);t.add(ve.uuid,this)}create(){const t=new En(this.components),s=t.uuid;if(this.list.has(s))throw new Error("There is already a world with this name!");return this.list.set(s,t),this.onWorldCreated.trigger(t),t}delete(t){const s=t.uuid;this.list.delete(t.uuid),t.dispose(),this.onWorldDeleted.trigger(s)}dispose(){this.enabled=!1;for(const[t,s]of this.list)s.dispose();this.list.clear(),this.onDisposed.trigger()}update(t){if(this.enabled)for(const[s,i]of this.list)i.update(t)}};U(ve,"uuid","fdb61dc4-2ec1-4966-b83d-54ea795fad4a");let Fs=ve;class Cn{constructor(e,t,s){U(this,"onDisposed",new Y);U(this,"world");U(this,"components");U(this,"three");U(this,"_fade",3);U(this,"updateZoom",()=>{this.world.camera instanceof Ae&&(this.material.uniforms.uZoom.value=this.world.camera.three.zoom)});this.world=t;const{color:i,size1:r,size2:o,distance:a}=s;this.components=e;const c=new li(2,2,1,1),f=new hi({side:ks,uniforms:{uSize1:{value:r},uSize2:{value:o},uColor:{value:i},uDistance:{value:a},uFade:{value:this._fade},uZoom:{value:1}},transparent:!0,vertexShader:`
            
            varying vec3 worldPosition;
            
            uniform float uDistance;
            
            void main() {
            
                    vec3 pos = position.xzy * uDistance;
                    pos.xz += cameraPosition.xz;
                    
                    worldPosition = pos;
                    
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
            
            }
            `,fragmentShader:`
            
            varying vec3 worldPosition;
            
            uniform float uZoom;
            uniform float uFade;
            uniform float uSize1;
            uniform float uSize2;
            uniform vec3 uColor;
            uniform float uDistance;
                
                
                
                float getGrid(float size) {
                
                    vec2 r = worldPosition.xz / size;
                    
                    
                    vec2 grid = abs(fract(r - 0.5) - 0.5) / fwidth(r);
                    float line = min(grid.x, grid.y);
                    
                
                    return 1.0 - min(line, 1.0);
                }
                
            void main() {
            
                    
                    float d = 1.0 - min(distance(cameraPosition.xz, worldPosition.xz) / uDistance, 1.0);
                    
                    float g1 = getGrid(uSize1);
                    float g2 = getGrid(uSize2);
                    
                    // Ortho camera fades the grid away when zooming out
                    float minZoom = step(0.2, uZoom);
                    float zoomFactor = pow(min(uZoom, 1.), 2.) * minZoom;
                    
                    gl_FragColor = vec4(uColor.rgb, mix(g2, g1, g1) * pow(d, uFade));
                    gl_FragColor.a = mix(0.5 * gl_FragColor.a, gl_FragColor.a, g2) * zoomFactor;
                    
                    if ( gl_FragColor.a <= 0.0 ) discard;
                    
            
            }
            
            `,extensions:{derivatives:!0}});this.three=new Je(c,f),this.three.frustumCulled=!1,t.scene.three.add(this.three),this.setupEvents(!0)}get visible(){return this.three.visible}set visible(e){e?this.world.scene.three.add(this.three):this.three.removeFromParent()}get material(){return this.three.material}get fade(){return this._fade===3}set fade(e){this._fade=e?3:0,this.material.uniforms.uFade.value=this._fade}[Symbol.dispose](){throw new Error("Method not implemented.")}dispose(){this.setupEvents(!1),this.components.get(Jt).destroy(this.three),this.onDisposed.trigger(),this.onDisposed.reset(),this.world=null,this.components=null}setupEvents(e){if(this.world.isDisposing||!(this.world.camera instanceof Ae))return;const t=this.world.camera.controls;e?t.addEventListener("update",this.updateZoom):t.removeEventListener("update",this.updateZoom)}}class vn extends ns{constructor(){super(...arguments);U(this,"list",new Map);U(this,"onDisposed",new Y);U(this,"config",{color:new Ee(12303291),size1:1,size2:10,distance:500});U(this,"enabled",!0)}create(t){if(this.list.has(t.uuid))throw new Error("This world already has a grid!");const s=new Cn(this.components,t,this.config);return this.list.set(t.uuid,s),t.onDisposed.add(()=>{this.delete(t)}),s}delete(t){const s=this.list.get(t.uuid);s&&s.dispose(),this.list.delete(t.uuid)}dispose(){for(const[t,s]of this.list)s.dispose();this.list.clear(),this.onDisposed.trigger()}}U(vn,"uuid","d1e814d5-b81c-4452-87a2-f039375e0489");export{ns as C,Jt as D,Y as E,vn as G,Un as S,Fs as W,bs as a,Dn as b,Ae as c};
