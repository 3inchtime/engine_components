var V=Object.defineProperty;var A=(e,t,o)=>t in e?V(e,t,{enumerable:!0,configurable:!0,writable:!0,value:o}):e[t]=o;var v=(e,t,o)=>(A(e,typeof t!="symbol"?t+"":t,o),o);import"./web-ifc-api-z0lP7pyY.js";import{p as B,C as D,i as K,o as E,a as I,u as x}from"./index-CDtayhLQ.js";import{p as H}from"./index-DyM33b1I.js";import{b as $,c as F,Z as N,C as R,a as T}from"./index-D3pLdVAu.js";import{S as U}from"./stats.min-GTpOrGrX.js";import{R as W}from"./renderer-with-2d-ChbkiKqX.js";import"./import-wrapper-prod-QYycmO-A.js";import"./index-BhKBO6Dw.js";import"./mark-C_hqAPZ-.js";import"./Line2-CLLb6Jgt.js";import"./index-DVRunJPb.js";import"./_commonjsHelpers-Cpj98o6Y.js";const S=class S extends ${constructor(o){super(o);v(this,"view","vertical");v(this,"enabled",!0);this.components.add(S.uuid,this)}get world(){return super.world}set world(o){this.world!==o&&(super.world=o,this._highlighter&&this._highlighter.onSelect.add(g=>{if(!this.world)throw new Error("A world is needed to work with this component!");const s=this.components.get(F);s.deleteByType(["Slope","Height","InitialKPV","FinalKPV"]);const{alignment:r}=g.curve,d=[];for(const a of r.vertical){const f=a.mesh.geometry.attributes.position.array;d.push(f)}const{defSegments:p,slope:u}=this.setDefSegments(d),w=this.world.scene.three;for(let a=0;a<r.vertical.length;a++){const f=r.vertical[a];s.addVerticalMarker(this.world,`S: ${u[a].slope}%`,f.mesh,"Slope",w),s.addVerticalMarker(this.world,`H: ${p[a].end.y.toFixed(2)}`,f.mesh,"Height",w)}s.addVerticalMarker(this.world,"KP: 0",r.vertical[0].mesh,"InitialKPV",w),s.addVerticalMarker(this.world,`KP: ${r.vertical.length}`,r.vertical[r.vertical.length-1].mesh,"FinalKPV",w)}))}};v(S,"uuid","097eea29-2d5a-431a-a247-204d44670621");let M=S;H.init();N.init();const C=document.getElementById("container"),n=new B,L=n.get(D),i=L.create();i.scene=new K(n);i.renderer=new W(n,C);i.camera=new E(n);n.init();i.scene.setup();i.camera.controls.setLookAt(5,5,5,0,0,0);C.appendChild(i.renderer.three2D.domElement);const Z=n.get(I);Z.create(i);const z=n.get(x),_=await fetch("https://thatopen.github.io/engine_components/resources/road.frag"),j=await _.arrayBuffer(),q=new Uint8Array(j),k=z.load(q);i.scene.three.add(k);const l=new R(n);l.world=i;l.draw(k);l.highlighter.hoverCurve.material.color.set(1,1,1);const{material:y}=l.highlighter.hoverPoints;if(Array.isArray(y)){const e=y[0];"color"in e&&e.color.set(1,1,1)}else"color"in y&&y.color.set(1,1,1);const P=document.getElementById("scene-2d-left");P.components=n;if(!P.world)throw new Error("World not found!");const b=new T(n);b.world=P.world;b.draw(k);const c=document.getElementById("scene-2d-right");c.components=n;if(!c.world)throw new Error("World not found!");const h=new M(n);h.world=c.world;h.draw(k);b.onMarkerChange.add(({alignment:e,percentage:t})=>{h.setMarker(e,t,"hover"),l.setMarker(e,t,"hover")});b.onHighlight.add(({mesh:e,point:t})=>{const{index:o,alignment:g}=e.curve,s=g.getPercentageAt(t,"horizontal");if(s===null)return;const{curve:r}=g.getCurveAt(s,"vertical");if(h.highlighter.select(r.mesh),h.setMarker(r.alignment,s,"select"),c.world){r.mesh.geometry.boundingSphere||r.mesh.geometry.computeBoundingSphere();const u=r.mesh.geometry.boundingSphere.clone();u.radius*=1.5,c.world.camera.controls.fitToSphere(u,!0)}l.highlighter.select(e);const d=e.curve.alignment.absolute[o];d.mesh.geometry.computeBoundingSphere();const p=d.mesh.geometry.boundingSphere;p&&i.camera.controls.fitToSphere(p,!0)});const m=new U;m.showPanel(2);document.body.append(m.dom);m.dom.style.left="0px";i.renderer.onBeforeUpdate.add(()=>m.begin());i.renderer.onAfterUpdate.add(()=>m.end());
