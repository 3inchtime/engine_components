var x=Object.defineProperty;var v=(n,t,e)=>t in n?x(n,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):n[t]=e;var o=(n,t,e)=>(v(n,typeof t!="symbol"?t+"":t,e),e);import{V as u,r as w,w as z,q as S,B,b as I,M}from"./web-ifc-api-BFxa4VQ4.js";import{S as y}from"./stats.min-GTpOrGrX.js";import{k as A,C as T,b as j}from"./index-CA2cPfXk.js";import{E as D,C as F}from"./index-2WRq2SpB.js";import{C as h,b as N,W as U,S as k,a as E}from"./index-BSY2u5SV.js";import{G as L}from"./index-5vXSe8tN.js";import"./_commonjsHelpers-Cpj98o6Y.js";class R{constructor(t){o(this,"enabled",!1);o(this,"id","FirstPerson");this.camera=t}set(t){if(this.enabled=t,t){if(this.camera.projection.current!=="Perspective"){this.camera.set("Orbit");return}this.setupFirstPersonCamera()}}setupFirstPersonCamera(){const t=this.camera.controls,e=new u;t.distance--,t.getPosition(e),t.minDistance=1,t.maxDistance=1,t.distance=1,t.moveTo(e.x,e.y,e.z),t.truckSpeed=50,t.mouseButtons.wheel=h.ACTION.DOLLY,t.touches.two=h.ACTION.TOUCH_ZOOM_TRUCK}}class W{constructor(t){o(this,"enabled",!0);o(this,"id","Orbit");this.camera=t,this.activateOrbitControls()}set(t){this.enabled=t,t&&this.activateOrbitControls()}activateOrbitControls(){const t=this.camera.controls;t.minDistance=1,t.maxDistance=300;const e=new u;t.getPosition(e);const s=e.length();t.distance=s,t.truckSpeed=2;const{rotation:r}=this.camera.three,p=new u(0,0,-1).applyEuler(r),a=e.addScaledVector(p,s);t.moveTo(a.x,a.y,a.z)}}class q{constructor(t){o(this,"enabled",!1);o(this,"id","Plan");o(this,"mouseAction1");o(this,"mouseAction2");o(this,"mouseInitialized",!1);o(this,"defaultAzimuthSpeed");o(this,"defaultPolarSpeed");this.camera=t,this.defaultAzimuthSpeed=t.controls.azimuthRotateSpeed,this.defaultPolarSpeed=t.controls.polarRotateSpeed}set(t){this.enabled=t;const e=this.camera.controls;e.azimuthRotateSpeed=t?0:this.defaultAzimuthSpeed,e.polarRotateSpeed=t?0:this.defaultPolarSpeed,this.mouseInitialized||(this.mouseAction1=e.touches.one,this.mouseAction2=e.touches.two,this.mouseInitialized=!0),t?(e.mouseButtons.left=h.ACTION.TRUCK,e.touches.one=h.ACTION.TOUCH_TRUCK,e.touches.two=h.ACTION.TOUCH_ZOOM):(e.mouseButtons.left=h.ACTION.ROTATE,e.touches.one=this.mouseAction1,e.touches.two=this.mouseAction2)}}class V{constructor(t){o(this,"onChanged",new D);o(this,"current","Perspective");o(this,"camera");o(this,"_component");o(this,"_previousDistance",-1);o(this,"matchOrthoDistanceEnabled",!1);this._component=t,this.camera=t.three}async set(t){this.current!==t&&(t==="Orthographic"?this.setOrthoCamera():await this.setPerspectiveCamera(),this.onChanged.trigger(this.camera))}async toggle(){const e=this.current==="Perspective"?"Orthographic":"Perspective";await this.set(e)}setOrthoCamera(){if(this._component.mode===null||this._component.mode.id==="FirstPerson")return;this._previousDistance=this._component.controls.distance,this._component.controls.distance=200;const t=this.getPerspectiveDims();if(!t)return;const{width:e,height:s}=t;this.setupOrthoCamera(s,e),this.camera=this._component.threeOrtho,this.current="Orthographic"}getPerspectiveDims(){const t=this._component.currentWorld;if(!t||!t.renderer)return null;const e=new u;this._component.threePersp.getWorldDirection(e);const s=new u;this._component.controls.getTarget(s);const p=s.clone().sub(this._component.threePersp.position).dot(e),a=t.renderer.getSize(),m=a.x/a.y,f=this._component.threePersp,d=p*2*Math.atan(f.fov*(Math.PI/180)/2);return{width:d*m,height:d}}setupOrthoCamera(t,e){this._component.controls.mouseButtons.wheel=h.ACTION.ZOOM,this._component.controls.mouseButtons.middle=h.ACTION.ZOOM;const s=this._component.threePersp,r=this._component.threeOrtho;r.zoom=1,r.left=e/-2,r.right=e/2,r.top=t/2,r.bottom=t/-2,r.updateProjectionMatrix(),r.position.copy(s.position),r.quaternion.copy(s.quaternion),this._component.controls.camera=r}getDistance(){const t=this._component.threePersp,e=this._component.threeOrtho;return(e.top-e.bottom)/e.zoom/(2*Math.atan(t.fov*(Math.PI/180)/2))}async setPerspectiveCamera(){this._component.controls.mouseButtons.wheel=h.ACTION.DOLLY,this._component.controls.mouseButtons.middle=h.ACTION.DOLLY;const t=this._component.threePersp,e=this._component.threeOrtho;t.position.copy(e.position),t.quaternion.copy(e.quaternion),this._component.controls.mouseButtons.wheel=h.ACTION.DOLLY,this.matchOrthoDistanceEnabled?this._component.controls.distance=this.getDistance():this._component.controls.distance=this._previousDistance,await this._component.controls.zoomTo(1),t.updateProjectionMatrix(),this._component.controls.camera=t,this.camera=t,this.current="Perspective"}}class G extends N{constructor(e){super(e);o(this,"_mode",null);o(this,"projection");o(this,"threeOrtho");o(this,"threePersp");o(this,"_userInputButtons",{});o(this,"_frustumSize",50);o(this,"_navigationModes",new Map);this.threePersp=this.three,this.threeOrtho=this.newOrthoCamera(),this.projection=new V(this),this.onAspectUpdated.add(()=>{this.setOrthoCameraAspect()}),this.projection.onChanged.add(s=>{this.three=s}),this.onWorldChanged.add(()=>{this._navigationModes.clear(),this._navigationModes.set("Orbit",new W(this)),this._navigationModes.set("FirstPerson",new R(this)),this._navigationModes.set("Plan",new q(this)),this._mode=this._navigationModes.get("Orbit"),this.mode.set(!0,{preventTargetAdjustment:!0})})}get mode(){if(!this._mode)throw new Error("Mode not found, camera not initialized");return this._mode}dispose(){super.dispose(),this.threeOrtho.removeFromParent()}set(e){if(this.mode!==null&&this.mode.id!==e){if(this.mode.set(!1),!this._navigationModes.has(e))throw new Error("The specified mode does not exist!");this._mode=this._navigationModes.get(e),this.mode.set(!0)}}async fit(e,s=1.5){if(!this.enabled)return;const r=Number.MAX_VALUE,p=Number.MIN_VALUE,a=new u(r,r,r),m=new u(p,p,p);for(const P of e){const c=new w().setFromObject(P);c.min.x<a.x&&(a.x=c.min.x),c.min.y<a.y&&(a.y=c.min.y),c.min.z<a.z&&(a.z=c.min.z),c.max.x>m.x&&(m.x=c.max.x),c.max.y>m.y&&(m.y=c.max.y),c.max.z>m.z&&(m.z=c.max.z)}const f=new w(a,m),d=new u;f.getSize(d);const g=new u;f.getCenter(g);const _=Math.max(d.x,d.y,d.z)*s,C=new z(g,_);await this.controls.fitToSphere(C,!0)}setUserInput(e){e?this.enableUserInput():this.disableUserInput()}disableUserInput(){this._userInputButtons.left=this.controls.mouseButtons.left,this._userInputButtons.right=this.controls.mouseButtons.right,this._userInputButtons.middle=this.controls.mouseButtons.middle,this._userInputButtons.wheel=this.controls.mouseButtons.wheel,this.controls.mouseButtons.left=0,this.controls.mouseButtons.right=0,this.controls.mouseButtons.middle=0,this.controls.mouseButtons.wheel=0}enableUserInput(){Object.keys(this._userInputButtons).length!==0&&(this.controls.mouseButtons.left=this._userInputButtons.left,this.controls.mouseButtons.right=this._userInputButtons.right,this.controls.mouseButtons.middle=this._userInputButtons.middle,this.controls.mouseButtons.wheel=this._userInputButtons.wheel)}newOrthoCamera(){const e=window.innerWidth/window.innerHeight;return new S(this._frustumSize*e/-2,this._frustumSize*e/2,this._frustumSize/2,this._frustumSize/-2,.1,1e3)}setOrthoCameraAspect(){if(!this.currentWorld||!this.currentWorld.renderer)return;const e=this.currentWorld.renderer.getSize(),s=e.x/e.y;this.threeOrtho.left=-this._frustumSize*s/2,this.threeOrtho.right=this._frustumSize*s/2,this.threeOrtho.top=this._frustumSize/2,this.threeOrtho.bottom=-this._frustumSize/2,this.threeOrtho.updateProjectionMatrix()}}const H=new B,Y=new I({color:"#6528D7"}),O=new M(H,Y);O.position.set(0,.5,0);const Z=document.getElementById("container"),l=new F,$=l.get(U),i=$.create();i.scene=new k(l);i.renderer=new E(l,Z);i.camera=new G(l);l.init();i.scene.setup();i.camera.controls.setLookAt(3,3,3,0,0,0);i.scene.three.add(O);i.meshes.add(O);const K=l.get(L),X=K.create(i);i.camera.projection.onChanged.add(()=>{const n=i.camera.projection.current;X.fade=n==="Perspective"});A.registerComponents();const J=T.create(()=>j`
    <bim-panel active label="Orthoperspective Camera Tutorial" 
      style="position: fixed; top: 5px; right: 5px">
      <bim-panel-section style="padding-top: 10px;">
         
          <bim-dropdown required label="Navigation mode" 
            @change="${({target:n})=>{const t=n.value[0],{current:e}=i.camera.projection;if(e==="Orthographic"&&t==="FirstPerson"){alert("First person is not compatible with ortho!"),n.value[0]=i.camera.mode.id;return}i.camera.set(t)}}">
          <bim-option checked label="Orbit"></bim-option>
          <bim-option label="FirstPerson"></bim-option>
          <bim-option label="Plan"></bim-option>
        </bim-dropdown>
         
      
        <bim-dropdown required label="Camera projection" 
            @change="${({target:n})=>{const t=n.value[0],e=t==="Orthographic",s=i.camera.mode.id==="FirstPerson";if(e&&s){alert("First person is not compatible with ortho!"),n.value[0]=i.camera.projection.current;return}i.camera.projection.set(t)}}">
          <bim-option checked label="Perspective"></bim-option>
          <bim-option label="Orthographic"></bim-option>
        </bim-dropdown>

        <bim-checkbox 
          label="Allow user input" checked 
          @change="${({target:n})=>{i.camera.setUserInput(n.checked)}}">  
        </bim-checkbox>  
        
        <bim-button 
          label="Fit cube" 
          @click="${()=>{i.camera.fit([O])}}">  
        </bim-button>  

      </bim-panel-section>
    </bim-panel>
    `);document.body.append(J);const b=new y;b.showPanel(2);document.body.append(b.dom);b.dom.style.left="0px";i.renderer.onBeforeUpdate.add(()=>b.begin());i.renderer.onAfterUpdate.add(()=>b.end());
