var v=Object.defineProperty;var z=(n,t,e)=>t in n?v(n,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):n[t]=e;var o=(n,t,e)=>(z(n,typeof t!="symbol"?t+"":t,e),e);import{V as p,p as w,y as S,o as x,B as y,b as B,M as I}from"./web-ifc-api-BC8YMRiS.js";import{S as M}from"./stats.min-GTpOrGrX.js";import{p as A,a as T,m as j}from"./index-DyM33b1I.js";import{d as m,E as D,c as F,a as N,W as U,S as W,b as k}from"./index-B99Vyz6D.js";import{G as E}from"./index-vdN6D13n.js";import"./_commonjsHelpers-Cpj98o6Y.js";class L{constructor(t){o(this,"enabled",!1);o(this,"id","FirstPerson");this.camera=t}set(t){if(this.enabled=t,t){if(this.camera.projection.current!=="Perspective"){this.camera.set("Orbit");return}this.setupFirstPersonCamera()}}setupFirstPersonCamera(){const t=this.camera.controls,e=new p;t.distance--,t.getPosition(e),t.minDistance=1,t.maxDistance=1,t.distance=1,t.moveTo(e.x,e.y,e.z),t.truckSpeed=50,t.mouseButtons.wheel=m.ACTION.DOLLY,t.touches.two=m.ACTION.TOUCH_ZOOM_TRUCK}}class R{constructor(t){o(this,"enabled",!0);o(this,"id","Orbit");this.camera=t,this.activateOrbitControls()}set(t){this.enabled=t,t&&this.activateOrbitControls()}activateOrbitControls(){const t=this.camera.controls;t.minDistance=1,t.maxDistance=300;const e=new p;t.getPosition(e);const i=e.length();t.distance=i,t.truckSpeed=2;const{rotation:r}=this.camera.three,u=new p(0,0,-1).applyEuler(r),a=e.addScaledVector(u,i);t.moveTo(a.x,a.y,a.z)}}class q{constructor(t){o(this,"enabled",!1);o(this,"id","Plan");o(this,"mouseAction1");o(this,"mouseAction2");o(this,"mouseInitialized",!1);o(this,"defaultAzimuthSpeed");o(this,"defaultPolarSpeed");this.camera=t,this.defaultAzimuthSpeed=t.controls.azimuthRotateSpeed,this.defaultPolarSpeed=t.controls.polarRotateSpeed}set(t){this.enabled=t;const e=this.camera.controls;e.azimuthRotateSpeed=t?0:this.defaultAzimuthSpeed,e.polarRotateSpeed=t?0:this.defaultPolarSpeed,this.mouseInitialized||(this.mouseAction1=e.touches.one,this.mouseAction2=e.touches.two,this.mouseInitialized=!0),t?(e.mouseButtons.left=m.ACTION.TRUCK,e.touches.one=m.ACTION.TOUCH_TRUCK,e.touches.two=m.ACTION.TOUCH_ZOOM):(e.mouseButtons.left=m.ACTION.ROTATE,e.touches.one=this.mouseAction1,e.touches.two=this.mouseAction2)}}class H{constructor(t){o(this,"onChanged",new D);o(this,"current","Perspective");o(this,"camera");o(this,"_component");o(this,"_previousDistance",-1);o(this,"matchOrthoDistanceEnabled",!1);this._component=t,this.camera=t.three}async set(t){this.current!==t&&(t==="Orthographic"?this.setOrthoCamera():await this.setPerspectiveCamera(),this.onChanged.trigger(this.camera))}async toggle(){const e=this.current==="Perspective"?"Orthographic":"Perspective";await this.set(e)}setOrthoCamera(){if(this._component.mode===null||this._component.mode.id==="FirstPerson")return;this._previousDistance=this._component.controls.distance,this._component.controls.distance=200;const t=this.getPerspectiveDims();if(!t)return;const{width:e,height:i}=t;this.setupOrthoCamera(i,e),this.camera=this._component.threeOrtho,this.current="Orthographic"}getPerspectiveDims(){const t=this._component.currentWorld;if(!t||!t.renderer)return null;const e=new p;this._component.threePersp.getWorldDirection(e);const i=new p;this._component.controls.getTarget(i);const u=i.clone().sub(this._component.threePersp.position).dot(e),a=t.renderer.getSize(),c=a.x/a.y,d=this._component.threePersp,l=u*2*Math.atan(d.fov*(Math.PI/180)/2);return{width:l*c,height:l}}setupOrthoCamera(t,e){this._component.controls.mouseButtons.wheel=m.ACTION.ZOOM,this._component.controls.mouseButtons.middle=m.ACTION.ZOOM;const i=this._component.threePersp,r=this._component.threeOrtho;r.zoom=1,r.left=e/-2,r.right=e/2,r.top=t/2,r.bottom=t/-2,r.updateProjectionMatrix(),r.position.copy(i.position),r.quaternion.copy(i.quaternion),this._component.controls.camera=r}getDistance(){const t=this._component.threePersp,e=this._component.threeOrtho;return(e.top-e.bottom)/e.zoom/(2*Math.atan(t.fov*(Math.PI/180)/2))}async setPerspectiveCamera(){this._component.controls.mouseButtons.wheel=m.ACTION.DOLLY,this._component.controls.mouseButtons.middle=m.ACTION.DOLLY;const t=this._component.threePersp,e=this._component.threeOrtho;t.position.copy(e.position),t.quaternion.copy(e.quaternion),this._component.controls.mouseButtons.wheel=m.ACTION.DOLLY,this.matchOrthoDistanceEnabled?this._component.controls.distance=this.getDistance():this._component.controls.distance=this._previousDistance,await this._component.controls.zoomTo(1),t.updateProjectionMatrix(),this._component.controls.camera=t,this.camera=t,this.current="Perspective"}}class V extends F{constructor(e){super(e);o(this,"_mode",null);o(this,"projection");o(this,"threeOrtho");o(this,"threePersp");o(this,"_userInputButtons",{});o(this,"_frustumSize",50);o(this,"_navigationModes",new Map);o(this,"previousSize",null);this.threePersp=this.three,this.threeOrtho=this.newOrthoCamera(),this.projection=new H(this),this.onAspectUpdated.add(()=>{this.setOrthoPerspCameraAspect()}),this.projection.onChanged.add(i=>{this.three=i,this.updateAspect()}),this.onWorldChanged.add(()=>{this._navigationModes.clear(),this._navigationModes.set("Orbit",new R(this)),this._navigationModes.set("FirstPerson",new L(this)),this._navigationModes.set("Plan",new q(this)),this._mode=this._navigationModes.get("Orbit"),this.mode.set(!0,{preventTargetAdjustment:!0}),this.currentWorld&&this.currentWorld.renderer&&(this.previousSize=this.currentWorld.renderer.getSize().clone())})}get mode(){if(!this._mode)throw new Error("Mode not found, camera not initialized");return this._mode}dispose(){super.dispose(),this.threeOrtho.removeFromParent()}set(e){if(this.mode!==null&&this.mode.id!==e){if(this.mode.set(!1),!this._navigationModes.has(e))throw new Error("The specified mode does not exist!");this._mode=this._navigationModes.get(e),this.mode.set(!0)}}async fit(e,i=1.5){if(!this.enabled)return;const r=Number.MAX_VALUE,u=Number.MIN_VALUE,a=new p(r,r,r),c=new p(u,u,u);for(const C of e){const h=new w().setFromObject(C);h.min.x<a.x&&(a.x=h.min.x),h.min.y<a.y&&(a.y=h.min.y),h.min.z<a.z&&(a.z=h.min.z),h.max.x>c.x&&(c.x=h.max.x),h.max.y>c.y&&(c.y=h.max.y),h.max.z>c.z&&(c.z=h.max.z)}const d=new w(a,c),l=new p;d.getSize(l);const g=new p;d.getCenter(g);const _=Math.max(l.x,l.y,l.z)*i,P=new S(g,_);await this.controls.fitToSphere(P,!0)}setUserInput(e){e?this.enableUserInput():this.disableUserInput()}disableUserInput(){this._userInputButtons.left=this.controls.mouseButtons.left,this._userInputButtons.right=this.controls.mouseButtons.right,this._userInputButtons.middle=this.controls.mouseButtons.middle,this._userInputButtons.wheel=this.controls.mouseButtons.wheel,this.controls.mouseButtons.left=0,this.controls.mouseButtons.right=0,this.controls.mouseButtons.middle=0,this.controls.mouseButtons.wheel=0}enableUserInput(){Object.keys(this._userInputButtons).length!==0&&(this.controls.mouseButtons.left=this._userInputButtons.left,this.controls.mouseButtons.right=this._userInputButtons.right,this.controls.mouseButtons.middle=this._userInputButtons.middle,this.controls.mouseButtons.wheel=this._userInputButtons.wheel)}newOrthoCamera(){const e=window.innerWidth/window.innerHeight;return new x(this._frustumSize*e/-2,this._frustumSize*e/2,this._frustumSize/2,this._frustumSize/-2,.1,1e3)}setOrthoPerspCameraAspect(){if(!this.currentWorld||!this.currentWorld.renderer||!this.previousSize)return;const e=this.currentWorld.renderer.getSize(),i=this.threeOrtho.top,r=this.threeOrtho.right,u=e.y/this.previousSize.y,a=e.x/this.previousSize.x,c=i*u,d=r*a;this.threeOrtho.left=-d,this.threeOrtho.right=d,this.threeOrtho.top=c,this.threeOrtho.bottom=-c,this.threeOrtho.updateProjectionMatrix(),this.previousSize.copy(e)}}const G=document.getElementById("container"),b=new N,Y=b.get(U),s=Y.create();s.scene=new W(b);s.renderer=new k(b,G);s.camera=new V(b);s.scene.setup();async function Z(){await s.camera.controls.setLookAt(3,3,3,0,0,0),await s.camera.projection.set("Orthographic")}Z();b.init();const $=new y,K=new B({color:"#6528D7"}),O=new I($,K);O.position.set(0,.5,0);s.scene.three.add(O);s.meshes.add(O);const X=b.get(E),J=X.create(s);s.camera.projection.onChanged.add(()=>{const n=s.camera.projection.current;J.fade=n==="Perspective"});A.init();const Q=T.create(()=>j`
    <bim-panel active label="Orthoperspective Camera Tutorial" 
      style="position: fixed; top: 5px; right: 5px">
      <bim-panel-section style="padding-top: 10px;">
         
          <bim-dropdown required label="Navigation mode" 
            @change="${({target:n})=>{const t=n.value[0],{current:e}=s.camera.projection;if(e==="Orthographic"&&t==="FirstPerson"){alert("First person is not compatible with ortho!"),n.value[0]=s.camera.mode.id;return}s.camera.set(t)}}">

          <bim-option checked label="Orbit"></bim-option>
          <bim-option label="FirstPerson"></bim-option>
          <bim-option label="Plan"></bim-option>
        </bim-dropdown>
         
      
        <bim-dropdown required label="Camera projection" 
            @change="${({target:n})=>{const t=n.value[0],e=t==="Orthographic",i=s.camera.mode.id==="FirstPerson";if(e&&i){alert("First person is not compatible with ortho!"),n.value[0]=s.camera.projection.current;return}s.camera.projection.set(t)}}">
          <bim-option checked label="Perspective"></bim-option>
          <bim-option label="Orthographic"></bim-option>
        </bim-dropdown>

        <bim-checkbox 
          label="Allow user input" checked 
          @change="${({target:n})=>{s.camera.setUserInput(n.checked)}}">  
        </bim-checkbox>  
        
        <bim-button 
          label="Fit cube" 
          @click="${()=>{s.camera.fit([O])}}">  
        </bim-button>  

      </bim-panel-section>
    </bim-panel>
    `);document.body.append(Q);const f=new M;f.showPanel(2);document.body.append(f.dom);f.dom.style.left="0px";s.renderer.onBeforeUpdate.add(()=>f.begin());s.renderer.onAfterUpdate.add(()=>f.end());
