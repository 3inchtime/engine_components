var M=Object.defineProperty;var N=(m,u,e)=>u in m?M(m,u,{enumerable:!0,configurable:!0,writable:!0,value:e}):m[u]=e;var o=(m,u,e)=>(N(m,typeof u!="symbol"?u+"":u,e),e);import{C as b}from"./web-ifc-api-BffFJDIm.js";import{J as H,D as g,u as E,H as z,O as x}from"./index-D43g96vP.js";const v=class v extends H{constructor(e){super(e);o(this,"onDisposed",new g);o(this,"onBeforeUpdate",new g);o(this,"onAfterUpdate",new g);o(this,"onSetup",new g);o(this,"isSetup",!1);o(this,"enabled",!0);o(this,"events",{});o(this,"multiple","ctrlKey");o(this,"zoomFactor",1.5);o(this,"zoomToSelection",!1);o(this,"backupColor",null);o(this,"selection",{});o(this,"config",{selectName:"select",hoverName:"hover",selectionColor:new b("#BCF124"),hoverColor:new b("#6528D7"),autoHighlightOnClick:!0,world:null});o(this,"colors",new Map);o(this,"_mouseState",{down:!1,moved:!1});o(this,"clearHover",()=>{this.selection[this.config.hoverName]={}});o(this,"onMouseDown",()=>{this.enabled&&(this._mouseState.down=!0)});o(this,"onMouseUp",async e=>{const t=this.config.world;if(!t)throw new Error("No world found!");if(!t.renderer)throw new Error("This world doesn't have a renderer!");if(this.enabled&&e.target===t.renderer.three.domElement){if(this._mouseState.down=!1,this._mouseState.moved||e.button!==0){this._mouseState.moved=!1;return}if(this._mouseState.moved=!1,this.config.autoHighlightOnClick){const s=this.multiple==="none"?!0:!e[this.multiple];await this.highlight(this.config.selectName,s,this.zoomToSelection)}}});o(this,"onMouseMove",async()=>{if(!this.enabled)return;if(this._mouseState.moved){this.clear(this.config.hoverName);return}this._mouseState.moved=this._mouseState.down;const e=this.selection[this.config.selectName];await this.highlight(this.config.hoverName,!0,!1,e)});this.components.add(v.uuid,this)}async dispose(){this.setupEvents(!1),this.onBeforeUpdate.reset(),this.onAfterUpdate.reset(),this.selection={};for(const e in this.events)this.events[e].onClear.reset(),this.events[e].onHighlight.reset();this.onSetup.reset(),this.events={},this.onDisposed.trigger(v.uuid),this.onDisposed.reset()}add(e,t){if(this.selection[e]||this.colors.has(e))throw new Error("A selection with that name already exists!");this.colors.set(e,t),this.selection[e]={},this.events[e]={onHighlight:new g,onClear:new g}}async highlight(e,t=!0,s=this.zoomToSelection,d={}){if(!this.enabled)return null;if(!this.config.world)throw new Error("No world found in config!");const a=this.config.world;if(!this.selection[e])throw new Error(`Selection ${e} does not exist.`);const n=this.components.get(E).meshes,h=this.components.get(z).get(a).castRay(n);if(!h||!h.face)return this.clear(e),null;const l=h.object,f=l.geometry,S=h.instanceId;if(!f||S===void 0)return null;const w=l.fragment.getItemID(S);if(w===null)throw new Error("Item ID not found!");const C=l.fragment.group;if(!C)throw new Error("Fragment must belong to a FragmentsGroup!");const p=C.getFragmentMap([w]);return await this.highlightByID(e,p,t,s,d),{id:w,fragments:p}}async highlightByID(e,t,s=!0,d=this.zoomToSelection,a={}){if(!this.enabled)return;s&&this.clear(e);const c=this.components.get(E),n=this.colors.get(e);if(!n)throw new Error("Color for selection not found!");const r={};for(const i in t){const h=t[i],l=a[i];for(const f of h)(!l||!l.has(f))&&(r[i]||(r[i]=new Set),r[i].add(f))}for(const i in r){const h=c.list.get(i);if(!h)continue;this.selection[e][i]||(this.selection[e][i]=new Set);const l=t[i];for(const f of l)this.selection[e][i].add(f),h.setColor(n,[f])}this.events[e].onHighlight.trigger(this.selection[e]),d&&await this.zoomSelection(e)}clear(e){const t=e?[e]:Object.keys(this.selection);for(const s of t){const d=this.components.get(E),a=this.selection[s];for(const c in this.selection[s]){const n=d.list.get(c);if(!n)continue;const r=a[c];r&&(this.backupColor?n.setColor(this.backupColor):n.resetColor(r))}this.events[s].onClear.trigger(null),this.selection[s]={}}}setup(e){this.config={...this.config,...e},this.add(this.config.selectName,this.config.selectionColor),this.add(this.config.hoverName,this.config.hoverColor),this.setupEvents(!0),this.enabled=!0,this.isSetup=!0,this.onSetup.trigger(this)}async zoomSelection(e){if(!this.config.world)throw new Error("No world found in config!");const t=this.config.world;if(!t.camera.hasCameraControls())return;const s=this.components.get(x),d=this.components.get(E);s.reset();const a=this.selection[e];if(!Object.keys(a).length)return;for(const p in a){const D=d.list.get(p);if(!D)continue;const I=a[p];s.addMesh(D.mesh,I)}const c=s.getSphere(),n=1/0,r=-1/0,{x:i,y:h,z:l}=c.center,f=c.radius===n||i===n||h===n||l===n,S=c.radius===r||i===r||h===r||l===r,w=c.radius===0;if(f||S||w)return;c.radius*=this.zoomFactor,await t.camera.controls.fitToSphere(c,!0)}setupEvents(e){if(!this.config.world)throw new Error("No world found while setting up events!");if(this.config.world.isDisposing)return;if(!this.config.world.renderer)throw new Error("The given world doesn't have a renderer!");const t=this.config.world.renderer.three.domElement,s=this.events[this.config.selectName].onHighlight;s.remove(this.clearHover),t.removeEventListener("mousedown",this.onMouseDown),t.removeEventListener("mouseup",this.onMouseUp),t.removeEventListener("mousemove",this.onMouseMove),e&&(s.add(this.clearHover),t.addEventListener("mousedown",this.onMouseDown),t.addEventListener("mouseup",this.onMouseUp),t.addEventListener("mousemove",this.onMouseMove))}};o(v,"uuid","cb8a76f2-654a-4b50-80c6-66fd83cafd77");let y=v;export{y as H};
