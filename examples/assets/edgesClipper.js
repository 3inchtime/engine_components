var we=Object.defineProperty;var _e=(g,t,e)=>t in g?we(g,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):g[t]=e;var a=(g,t,e)=>(_e(g,typeof t!="symbol"?t+"":t,e),e);import{b as j,f as ee,V as z,g as R,h as xe,L as Me,i as be,D as Se,j as De,I as Pe,k as K,l as ve,A as Ve,C as te,d as Ee,e as Ie,M as X}from"./unzipit.module-DoMll51G.js";import{S as Ce}from"./stats.min-GTpOrGrX.js";import{g as Fe}from"./lil-gui.module.min-Bc0DeA9g.js";import{e as Le,D as A,z as Ae,F as Ue,u as ze}from"./N8AO-DNqyA7wK.js";import{F as Te}from"./serializer-mvlfGVOZ.js";import{P as W}from"./index-DfGhfuKi.js";import"./_commonjsHelpers-Cpj98o6Y.js";import"./stream-serializer-CIKXTIZE.js";class Be{constructor(t,e,s,i){a(this,"mesh",new j(new ee));a(this,"world");a(this,"styleName");a(this,"_precission",1e4);a(this,"_tempVector",new z);a(this,"_plane");a(this,"_geometry");a(this,"_plane2DCoordinateSystem",new R);a(this,"_planeAxis");this.world=t,this.mesh.material=i,this.mesh.frustumCulled=!1,this._plane=e;const{x:n,y:l,z:o}=e.normal;Math.abs(n)===1?this._planeAxis="x":Math.abs(l)===1?this._planeAxis="y":Math.abs(o)===1&&(this._planeAxis="z"),this._geometry=s,this.mesh.geometry.attributes.position=s.attributes.position;const d=e.normal.clone().multiplyScalar(.01);this.mesh.position.copy(d),this.visible=!0}get visible(){return this.mesh.parent!==null}set visible(t){const e=this.getStyle();t?(this.world.scene.three.add(this.mesh),e&&e.meshes.add(this.mesh)):(this.mesh.removeFromParent(),e&&e.meshes.delete(this.mesh))}set geometry(t){this._geometry=t,this.mesh.geometry.attributes.position=t.attributes.position}dispose(){const t=this.getStyle();t&&t.meshes.delete(this.mesh),this.mesh.geometry.dispose(),this.mesh.removeFromParent(),this.mesh.geometry=null,this.mesh=null,this._plane=null,this._geometry=null}update(t){const e=this._geometry.attributes.position.array;if(!e)return;this.updatePlane2DCoordinateSystem();const s=[];let i=0;for(let n=0;n<t.length;n++){const l=t[n],o=[];for(let u=i;u<l;u+=2)o.push(u*3);const d=this.computeFill(o,e);for(const u of d)s.push(u);i=l}this.mesh.geometry.setIndex(s)}computeFill(t,e){const s=new Map,i={},n=new Map;let l=0;const o=new Map,d=new Map,u=new Set,p=this._precission;for(let M=0;M<t.length;M++){const x=t[M];let b=0,S=0,y=0,P=0;const v=e[x],L=e[x+1],fe=e[x+2],me=e[x+3],ge=e[x+4],ye=e[x+5];if(this._tempVector.set(v,L,fe),this._tempVector.applyMatrix4(this._plane2DCoordinateSystem),b=Math.trunc(this._tempVector.x*p)/p,S=Math.trunc(this._tempVector.y*p)/p,this._tempVector.set(me,ge,ye),this._tempVector.applyMatrix4(this._plane2DCoordinateSystem),y=Math.trunc(this._tempVector.x*p)/p,P=Math.trunc(this._tempVector.y*p)/p,b===y&&S===P)continue;const Z=`${b}|${S}`,G=`${y}|${P}`;s.has(Z)||s.set(Z,x/3),s.has(G)||s.set(G,x/3+1);const f=s.get(Z),m=s.get(G);i[f]=[b,S],i[m]=[y,P];const B=d.has(f),N=o.has(f),O=d.has(m),k=o.has(m);if(!B&&!N&&!O&&!k)d.set(f,l),o.set(m,l),u.add(l),n.set(l,[f,m]),l++;else if(B&&k){const r=d.get(f),c=o.get(m);if(r!==c){const h=n.get(c),V=n.get(r);if(!h||!V)continue;n.delete(r),u.delete(r),o.set(V[V.length-1],c),o.delete(h[h.length-1]);for(const $ of V)h.push($)}else u.delete(c);d.delete(f),o.delete(m)}else if(N&&O){const r=d.get(m),c=o.get(f);if(r!==c){const h=n.get(c),V=n.get(r);if(!h||!V)continue;n.delete(r),u.delete(r),o.set(V[V.length-1],c),o.delete(h[h.length-1]);for(const $ of V)h.push($)}else u.delete(c);d.delete(m),o.delete(f)}else if(B&&O){const r=d.get(m),c=d.get(f),D=n.get(c),h=n.get(r);if(!D||!h)continue;n.delete(r),u.delete(r),d.delete(D[0]),d.delete(h[0]),o.delete(h[h.length-1]),d.set(h[h.length-1],c),h.reverse(),D.splice(0,0,...h)}else if(N&&k){const r=o.get(m),c=o.get(f),D=n.get(c),h=n.get(r);if(!D||!h)continue;n.delete(r),u.delete(r),o.delete(D[D.length-1]),o.delete(h[h.length-1]),d.delete(h[0]),o.set(h[0],c),h.reverse(),D.push(...h)}else if(B){const r=d.get(f),c=n.get(r);if(!c)continue;c.unshift(m),d.delete(f),d.set(m,r)}else if(N){const r=o.get(f),c=n.get(r);if(!c)continue;c.push(m),o.delete(f),o.set(m,r)}else if(O){const r=d.get(m),c=n.get(r);if(!c)continue;c.unshift(f),d.delete(m),d.set(f,r)}else if(k){const r=o.get(m),c=n.get(r);if(!c)continue;c.push(f),o.delete(m),o.set(f,r)}}const F=[];for(const[M,x]of n){if(u.has(M))continue;const b=[],S=new Map;let y=0;for(const v of x){const L=i[v];b.push(L[0],L[1]),S.set(y++,v)}const P=Le(b);for(const v of P){const L=S.get(v);if(L===void 0)throw new Error("Map error!");F.push(L)}}return F}updatePlane2DCoordinateSystem(){this._plane2DCoordinateSystem=new R;const t=new z(1,0,0),e=new z(0,1,0),s=this._plane.normal,i=new z;this._plane.coplanarPoint(i),this._planeAxis==="x"?t.crossVectors(e,s):this._planeAxis==="y"?e.crossVectors(s,t):this._planeAxis==="z"||(t.crossVectors(e,s).normalize(),e.crossVectors(s,t)),this._plane2DCoordinateSystem.fromArray([t.x,t.y,t.z,0,e.x,e.y,e.z,0,s.x,s.y,s.z,0,i.x,i.y,i.z,1]),this._plane2DCoordinateSystem.invert()}getStyle(){if(!this.world.renderer)return null;const t=this.world.renderer instanceof W;return this.styleName&&t?this.world.renderer.postproduction.customEffects.outlinedMeshes[this.styleName]:null}}class Ne{constructor(t,e,s,i){a(this,"onDisposed",new A);a(this,"onAfterUpdate",new A);a(this,"onBeforeUpdate",new A);a(this,"enabled",!0);a(this,"fillNeedsUpdate",!1);a(this,"components");a(this,"world");a(this,"_edges",{});a(this,"_styles");a(this,"_visible",!0);a(this,"_inverseMatrix",new R);a(this,"_localPlane",new xe);a(this,"_tempLine",new Me);a(this,"_tempVector",new z);a(this,"_plane");this.components=t,this.world=e,this._plane=s,this._styles=i}get visible(){return this._visible}get fillVisible(){for(const t in this._edges){const e=this._edges[t];if(e.fill)return e.fill.visible}return!1}set fillVisible(t){for(const e in this._edges){const s=this._edges[e];s.fill&&(s.fill.visible=t)}}async setVisible(t){this._visible=t;const e=Object.keys(this._edges);for(const s of e)this.updateEdgesVisibility(s,t);t&&await this.update()}async update(){const t=this._styles.get();await this.updateDeletedEdges(t);for(const e in t)this.drawEdges(e);this.fillNeedsUpdate=!1}get(){return this._edges}dispose(){const t=Object.keys(this._edges);for(const e of t)this.disposeEdge(e);this.onDisposed.trigger(),this.onDisposed.reset()}newEdgesMesh(t){const s=this._styles.get()[t].lineMaterial,i=new ee,n=new Float32Array(3e5),l=new be(n,3,!1);l.setUsage(Se),i.setAttribute("position",l);const o=new De(i,s);return o.frustumCulled=!1,o}newFillMesh(t,e){const i=this._styles.get()[t],n=i.fillMaterial;if(n){const l=new Be(this.world,this._plane,e,n);return this.newFillOutline(t,l,i),l}}newFillOutline(t,e,s){if(!s.outlineMaterial||!this.world.renderer)return;const i=this.world.renderer;if(i instanceof W){const l=i.postproduction.customEffects.outlinedMeshes;l[t]||(l[t]={meshes:new Set,material:s.outlineMaterial}),e.styleName=t}}drawEdges(t){const e=this._styles.get()[t];this._edges[t]||this.initializeStyle(t);const s=this._edges[t];let i=0;const n=s.mesh.geometry.attributes.position;n.array.fill(0);const l=[];let o=0;for(const p of e.meshes)if(p.geometry){if(!p.geometry.boundsTree)throw new Error("Bounds tree not found for clipping edges subset.");if(p instanceof Pe){if(p.count===0)continue;const F=p;for(let M=0;M<F.count;M++){const x=F instanceof Te,b=F,S=e.fragments[b.fragment.id];if(x&&S){const v=b.fragment.getItemID(M);if(v===null||!S.has(v))continue}const y=new j(p.geometry);y.matrix.copy(p.matrix);const P=new R;F.getMatrixAt(M,P),y.applyMatrix4(P),y.applyMatrix4(p.matrix),y.updateMatrix(),y.updateMatrixWorld(),this._inverseMatrix.copy(y.matrixWorld).invert(),this._localPlane.copy(this._plane).applyMatrix4(this._inverseMatrix),i=this.shapecast(y,n,i),i!==o&&(l.push(i),o=i)}}else this._inverseMatrix.copy(p.matrixWorld).invert(),this._localPlane.copy(this._plane).applyMatrix4(this._inverseMatrix),i=this.shapecast(p,n,i),i!==o&&(l.push(i),o=i)}s.mesh.geometry.setDrawRange(0,i),s.mesh.position.copy(this._plane.normal).multiplyScalar(1e-4),n.needsUpdate=!0;const u=s.mesh.geometry.attributes.position;Number.isNaN(u.array[0])||(s.mesh.parent||this.world.scene.three.add(s.mesh),this.fillNeedsUpdate&&s.fill&&(s.fill.geometry=s.mesh.geometry,s.fill.update(l)))}initializeStyle(t){const e=this.newEdgesMesh(t),s=e.geometry,i=this.newFillMesh(t,s);this._edges[t]={mesh:e,name:t,fill:i}}shapecast(t,e,s){return t.geometry.boundsTree.shapecast({intersectsBounds:i=>this._localPlane.intersectsBox(i),intersectsTriangle:i=>{let n=0;if(this._tempLine.start.copy(i.a),this._tempLine.end.copy(i.b),this._localPlane.intersectLine(this._tempLine,this._tempVector)){const l=this._tempVector.applyMatrix4(t.matrixWorld);e.setXYZ(s,l.x,l.y,l.z),n++,s++}if(this._tempLine.start.copy(i.b),this._tempLine.end.copy(i.c),this._localPlane.intersectLine(this._tempLine,this._tempVector)){const l=this._tempVector.applyMatrix4(t.matrixWorld);e.setXYZ(s,l.x,l.y,l.z),n++,s++}if(this._tempLine.start.copy(i.c),this._tempLine.end.copy(i.a),this._localPlane.intersectLine(this._tempLine,this._tempVector)){const l=this._tempVector.applyMatrix4(t.matrixWorld);e.setXYZ(s,l.x,l.y,l.z),n++,s++}n!==2&&(s-=n)}}),s}updateEdgesVisibility(t,e){const s=this._edges[t];s.fill&&(s.fill.visible=e),s.mesh.visible=e,e?this.world.scene.three.add(s.mesh):s.mesh.removeFromParent()}async updateDeletedEdges(t){const e=Object.keys(this._edges);for(const s of e)t[s]===void 0&&(this.disposeEdge(s),this.disposeOutline(s))}disposeOutline(t){if(!this.world.renderer)return;const e=this.world.renderer;if(e instanceof W){const s=e.postproduction.customEffects.outlinedMeshes;delete s[t]}}disposeEdge(t){const e=this.components.get(Ae),s=this._edges[t];s.fill&&s.fill.dispose(),e.destroy(s.mesh,!1),delete this._edges[t]}}class Oe extends Ue{constructor(e,s,i,n,l,o){super(e,s,i,n,l,5,!1);a(this,"edges");a(this,"edgesMaxUpdateRate",50);a(this,"lastUpdate",-1);a(this,"updateTimeout",-1);a(this,"updateFill",async()=>{this.edges.fillNeedsUpdate=!0,await this.edges.update(),this._visible&&(this.edges.fillVisible=!0)});a(this,"update",async()=>{if(!this.enabled)return;this.three.setFromNormalAndCoplanarPoint(this.normal,this._helper.position);const e=Date.now();this.lastUpdate+this.edgesMaxUpdateRate<e?(this.lastUpdate=e,await this.edges.update()):this.updateTimeout===-1&&(this.updateTimeout=window.setTimeout(()=>{this.update(),this.updateTimeout=-1},this.edgesMaxUpdateRate))});a(this,"hideFills",()=>{this.edges.fillVisible=!1});this.edges=new Ne(e,s,this.three,o),this.toggleControls(!0),this.edges.setVisible(!0),this.onDraggingEnded.add(this.updateFill),this.onDraggingStarted.add(this.hideFills)}set enabled(e){this._enabled=e,this.world.renderer&&this.world.renderer.setPlane(e,this.three)}get enabled(){return super.enabled}dispose(){super.dispose(),this.edges.dispose()}async setEnabled(e){super.enabled=e,e&&await this.update()}async setVisible(e){super.visible=e,this.toggleControls(e),await this.edges.setVisible(!0)}}class ke{constructor(){a(this,"onDisposed",new A);a(this,"enabled",!0);a(this,"_styles",{});a(this,"_defaultLineMaterial",new K({color:0,linewidth:.001}));a(this,"onAfterUpdate",new A);a(this,"onBeforeUpdate",new A)}get(){return this._styles}update(t){this.onBeforeUpdate.trigger(this._styles),this.onAfterUpdate.trigger(this._styles)}create(t,e,s,i,n,l){if(!s.renderer)throw new Error("The given world doesn't have a renderer!");i||(i=this._defaultLineMaterial);for(const u of e)u.geometry.boundsTree||u.geometry.computeBoundsTree();const o=s.renderer;i.clippingPlanes=o.clippingPlanes;const d={name:t,lineMaterial:i,meshes:e,fillMaterial:n,outlineMaterial:l,fragments:{}};return this._styles[t]=d,d}dispose(){const t=Object.keys(this._styles);for(const e of t)this.deleteStyle(e);this._styles={},this.onDisposed.trigger(),this.onDisposed.reset()}deleteStyle(t,e=!0){var i,n;const s=this._styles[t];s&&(s.meshes.clear(),e&&(s.lineMaterial.dispose(),(i=s.fillMaterial)==null||i.dispose(),(n=s.outlineMaterial)==null||n.dispose())),delete this._styles[t]}}class q extends ze{constructor(e){super(e);a(this,"styles");a(this,"fillsNeedUpdate",!1);this.components.list.set(q.uuid,this),this.PlaneType=Oe,this.styles=new ke}dispose(){super.dispose(),this.styles.dispose()}async updateEdges(e=!1){if(this.enabled)for(const s of this.list)e||this.fillsNeedUpdate?(await s.updateFill(),this.fillsNeedUpdate=!1):await s.update()}newPlaneInstance(e,s,i){return new this.PlaneType(this.components,e,s,i,this._material,this.styles)}}const se=document.getElementById("container"),w=new(void 0),ie=new(void 0)(w);ie.setup();w.scene=ie;const U=new W(w,se);w.renderer=U;const ne=new(void 0)(w);w.camera=ne;w.raycaster=new(void 0)(w);w.init();U.postproduction.enabled=!0;U.postproduction.customEffects.outlineEnabled=!0;ne.controls.setLookAt(10,10,10,0,0,0);const Y=w.scene.get(),J=new ve;J.position.set(5,10,3);J.intensity=.5;Y.add(J);const oe=new Ve;oe.intensity=.5;Y.add(oe);const Re=new(void 0)(w,new te(6710886));U.postproduction.customEffects.excludedMeshes.push(Re.get());const ae=new Ee(3,3,3),le=new Ie({color:"#6528D7"}),E=new j(ae,le);E.position.set(-2,1.5,0);Y.add(E);w.meshes.add(E);const I=new j(ae,le);I.position.set(2,1.5,0);Y.add(I);w.meshes.add(I);const _=new q(w);_.enabled=!0;const We=new X({color:"lightblue",side:2}),je=new K({color:"blue"}),re=new X({color:"blue",opacity:.2,side:2,transparent:!0});_.styles.create("Red lines",new Set([E]),je,We,re);const Xe=new X({color:"salmon",side:2}),Ye=new K({color:"red"}),de=new X({color:"red",opacity:.2,side:2,transparent:!0});_.styles.create("Blue lines",new Set([I]),Ye,Xe,de);se.ondblclick=()=>_.create();window.onkeydown=g=>{(g.code==="Delete"||g.code==="Backspace")&&_.delete(),g.code==="KeyP"&&console.log(_)};const T=new Ce;T.showPanel(2);document.body.append(T.dom);T.dom.style.left="0px";U.onBeforeUpdate.add(()=>T.begin());U.onAfterUpdate.add(()=>T.end());const ce=new Fe,he=ce.addFolder("Shortcuts"),pe={"Create clipping plane":"Double click","Delete clipping plane":"Delete"};he.add(pe,"Create clipping plane");he.add(pe,"Delete clipping plane");const C=ce.addFolder("Actions");C.add(_,"visible").name("Toggle clipping planes visible");C.add(_,"enabled").name("Toggle clipping planes enabled");const Ze={value:0},Q=new te;C.addColor(Ze,"value").name("Plane color").onChange(g=>{Q.setHex(g),"lineMaterial"in _.material&&(_.material.lineMaterial=Q)});C.add(_,"size").name("Plane Size").min(0).max(15);C.add(_.material,"opacity").name("Plane Opacity").min(0).max(1);const H={value:.2};C.add(H,"value").name("Lines width").step(.1).min(.1).max(1).onChange(()=>{re.opacity=H.value,de.opacity=H.value});const ue={"Delete all planes":()=>{_.deleteAll()},"Rotate cube":()=>{E.rotation.x=2*Math.PI*Math.random(),E.rotation.y=2*Math.PI*Math.random(),E.rotation.z=2*Math.PI*Math.random(),E.updateMatrix(),E.updateMatrixWorld(),I.rotation.x=2*Math.PI*Math.random(),I.rotation.y=2*Math.PI*Math.random(),I.rotation.z=2*Math.PI*Math.random(),I.updateMatrix(),I.updateMatrixWorld(),_.updateEdges()}};C.add(ue,"Rotate cube");C.add(ue,"Delete all planes");
