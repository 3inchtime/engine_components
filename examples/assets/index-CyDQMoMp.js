var Xn=Object.defineProperty;var jn=(e,n,t)=>n in e?Xn(e,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[n]=t;var I=(e,n,t)=>(jn(e,typeof n!="symbol"?n+"":n,t),t);import{e as Vn,V as U,f as yt,P as In,t as J,T as _t,w as Yn,a as nt,r as W,aJ as Zn,aa as Wn,aD as mn,M as $n,aE as Kn,a2 as Jn,c as xn}from"./web-ifc-api-DH5A5LIH.js";const Nn=0,Qn=1,Gn=2,wn=2,Zt=1.25,An=1,kt=6*4+4+4,jt=65535,On=Math.pow(2,-24),Wt=Symbol("SKIP_GENERATION");function te(e){return e.index?e.index.count:e.attributes.position.count}function ht(e){return te(e)/3}function ne(e,n=ArrayBuffer){return e>65535?new Uint32Array(new n(4*e)):new Uint16Array(new n(2*e))}function ee(e,n){if(!e.index){const t=e.attributes.position.count,s=n.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,i=ne(t,s);e.setIndex(new Vn(i,1));for(let a=0;a<t;a++)i[a]=a}}function qn(e){const n=ht(e),t=e.drawRange,s=t.start/3,i=(t.start+t.count)/3,a=Math.max(0,s),r=Math.min(n,i)-a;return[{offset:Math.floor(a),count:Math.floor(r)}]}function kn(e){if(!e.groups||!e.groups.length)return qn(e);const n=[],t=new Set,s=e.drawRange,i=s.start/3,a=(s.start+s.count)/3;for(const o of e.groups){const c=o.start/3,p=(o.start+o.count)/3;t.add(Math.max(i,c)),t.add(Math.min(a,p))}const r=Array.from(t.values()).sort((o,c)=>o-c);for(let o=0;o<r.length-1;o++){const c=r[o],p=r[o+1];n.push({offset:Math.floor(c),count:Math.floor(p-c)})}return n}function se(e){if(e.groups.length===0)return!1;const n=ht(e),t=kn(e).sort((a,r)=>a.offset-r.offset),s=t[t.length-1];s.count=Math.min(n-s.offset,s.count);let i=0;return t.forEach(({count:a})=>i+=a),n!==i}function D(e,n,t){return t.min.x=n[e],t.min.y=n[e+1],t.min.z=n[e+2],t.max.x=n[e+3],t.max.y=n[e+4],t.max.z=n[e+5],t}function ie(e){e[0]=e[1]=e[2]=1/0,e[3]=e[4]=e[5]=-1/0}function bn(e){let n=-1,t=-1/0;for(let s=0;s<3;s++){const i=e[s+3]-e[s];i>t&&(t=i,n=s)}return n}function Tn(e,n){n.set(e)}function Bn(e,n,t){let s,i;for(let a=0;a<3;a++){const r=a+3;s=e[a],i=n[a],t[a]=s<i?s:i,s=e[r],i=n[r],t[r]=s>i?s:i}}function St(e,n,t){for(let s=0;s<3;s++){const i=n[e+2*s],a=n[e+2*s+1],r=i-a,o=i+a;r<t[s]&&(t[s]=r),o>t[s+3]&&(t[s+3]=o)}}function At(e){const n=e[3]-e[0],t=e[4]-e[1],s=e[5]-e[2];return 2*(n*t+t*s+s*n)}function Kt(e,n,t,s,i=null){let a=1/0,r=1/0,o=1/0,c=-1/0,p=-1/0,f=-1/0,u=1/0,l=1/0,d=1/0,h=-1/0,B=-1/0,b=-1/0;const y=i!==null;for(let x=n*6,A=(n+t)*6;x<A;x+=6){const m=e[x+0],w=e[x+1],T=m-w,_=m+w;T<a&&(a=T),_>c&&(c=_),y&&m<u&&(u=m),y&&m>h&&(h=m);const g=e[x+2],M=e[x+3],S=g-M,F=g+M;S<r&&(r=S),F>p&&(p=F),y&&g<l&&(l=g),y&&g>B&&(B=g);const P=e[x+4],C=e[x+5],L=P-C,v=P+C;L<o&&(o=L),v>f&&(f=v),y&&P<d&&(d=P),y&&P>b&&(b=P)}s[0]=a,s[1]=r,s[2]=o,s[3]=c,s[4]=p,s[5]=f,y&&(i[0]=u,i[1]=l,i[2]=d,i[3]=h,i[4]=B,i[5]=b)}function re(e,n,t,s){let i=1/0,a=1/0,r=1/0,o=-1/0,c=-1/0,p=-1/0;for(let f=n*6,u=(n+t)*6;f<u;f+=6){const l=e[f+0];l<i&&(i=l),l>o&&(o=l);const d=e[f+2];d<a&&(a=d),d>c&&(c=d);const h=e[f+4];h<r&&(r=h),h>p&&(p=h)}s[0]=i,s[1]=a,s[2]=r,s[3]=o,s[4]=c,s[5]=p}function oe(e,n){ie(n);const t=e.attributes.position,s=e.index?e.index.array:null,i=ht(e),a=new Float32Array(i*6),r=t.normalized,o=t.array,c=t.offset||0;let p=3;t.isInterleavedBufferAttribute&&(p=t.data.stride);const f=["getX","getY","getZ"];for(let u=0;u<i;u++){const l=u*3,d=u*6;let h=l+0,B=l+1,b=l+2;s&&(h=s[h],B=s[B],b=s[b]),r||(h=h*p+c,B=B*p+c,b=b*p+c);for(let y=0;y<3;y++){let x,A,m;r?(x=t[f[y]](h),A=t[f[y]](B),m=t[f[y]](b)):(x=o[h+y],A=o[B+y],m=o[b+y]);let w=x;A<w&&(w=A),m<w&&(w=m);let T=x;A>T&&(T=A),m>T&&(T=m);const _=(T-w)/2,g=y*2;a[d+g+0]=w+_,a[d+g+1]=_+(Math.abs(w)+_)*On,w<n[y]&&(n[y]=w),T>n[y+3]&&(n[y+3]=T)}}return a}const K=32,ce=(e,n)=>e.candidate-n.candidate,G=new Array(K).fill().map(()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0})),Ct=new Float32Array(6);function ae(e,n,t,s,i,a){let r=-1,o=0;if(a===Nn)r=bn(n),r!==-1&&(o=(n[r]+n[r+3])/2);else if(a===Qn)r=bn(e),r!==-1&&(o=le(t,s,i,r));else if(a===Gn){const c=At(e);let p=Zt*i;const f=s*6,u=(s+i)*6;for(let l=0;l<3;l++){const d=n[l],b=(n[l+3]-d)/K;if(i<K/4){const y=[...G];y.length=i;let x=0;for(let m=f;m<u;m+=6,x++){const w=y[x];w.candidate=t[m+2*l],w.count=0;const{bounds:T,leftCacheBounds:_,rightCacheBounds:g}=w;for(let M=0;M<3;M++)g[M]=1/0,g[M+3]=-1/0,_[M]=1/0,_[M+3]=-1/0,T[M]=1/0,T[M+3]=-1/0;St(m,t,T)}y.sort(ce);let A=i;for(let m=0;m<A;m++){const w=y[m];for(;m+1<A&&y[m+1].candidate===w.candidate;)y.splice(m+1,1),A--}for(let m=f;m<u;m+=6){const w=t[m+2*l];for(let T=0;T<A;T++){const _=y[T];w>=_.candidate?St(m,t,_.rightCacheBounds):(St(m,t,_.leftCacheBounds),_.count++)}}for(let m=0;m<A;m++){const w=y[m],T=w.count,_=i-w.count,g=w.leftCacheBounds,M=w.rightCacheBounds;let S=0;T!==0&&(S=At(g)/c);let F=0;_!==0&&(F=At(M)/c);const P=An+Zt*(S*T+F*_);P<p&&(r=l,p=P,o=w.candidate)}}else{for(let A=0;A<K;A++){const m=G[A];m.count=0,m.candidate=d+b+A*b;const w=m.bounds;for(let T=0;T<3;T++)w[T]=1/0,w[T+3]=-1/0}for(let A=f;A<u;A+=6){let T=~~((t[A+2*l]-d)/b);T>=K&&(T=K-1);const _=G[T];_.count++,St(A,t,_.bounds)}const y=G[K-1];Tn(y.bounds,y.rightCacheBounds);for(let A=K-2;A>=0;A--){const m=G[A],w=G[A+1];Bn(m.bounds,w.rightCacheBounds,m.rightCacheBounds)}let x=0;for(let A=0;A<K-1;A++){const m=G[A],w=m.count,T=m.bounds,g=G[A+1].rightCacheBounds;w!==0&&(x===0?Tn(T,Ct):Bn(T,Ct,Ct)),x+=w;let M=0,S=0;x!==0&&(M=At(Ct)/c);const F=i-x;F!==0&&(S=At(g)/c);const P=An+Zt*(M*x+S*F);P<p&&(r=l,p=P,o=m.candidate)}}}}else console.warn(`MeshBVH: Invalid build strategy value ${a} used.`);return{axis:r,pos:o}}function le(e,n,t,s){let i=0;for(let a=n,r=n+t;a<r;a++)i+=e[a*6+s*2];return i/t}class Ft{constructor(){}}function fe(e,n,t,s,i,a){let r=s,o=s+i-1;const c=a.pos,p=a.axis*2;for(;;){for(;r<=o&&t[r*6+p]<c;)r++;for(;r<=o&&t[o*6+p]>=c;)o--;if(r<o){for(let f=0;f<3;f++){let u=n[r*3+f];n[r*3+f]=n[o*3+f],n[o*3+f]=u}for(let f=0;f<6;f++){let u=t[r*6+f];t[r*6+f]=t[o*6+f],t[o*6+f]=u}r++,o--}else return r}}function ue(e,n,t,s,i,a){let r=s,o=s+i-1;const c=a.pos,p=a.axis*2;for(;;){for(;r<=o&&t[r*6+p]<c;)r++;for(;r<=o&&t[o*6+p]>=c;)o--;if(r<o){let f=e[r];e[r]=e[o],e[o]=f;for(let u=0;u<6;u++){let l=t[r*6+u];t[r*6+u]=t[o*6+u],t[o*6+u]=l}r++,o--}else return r}}function pe(e,n){const t=(e.index?e.index.count:e.attributes.position.count)/3,s=t>2**16,i=s?4:2,a=n?new SharedArrayBuffer(t*i):new ArrayBuffer(t*i),r=s?new Uint32Array(a):new Uint16Array(a);for(let o=0,c=r.length;o<c;o++)r[o]=o;return r}function de(e,n){const t=e.geometry,s=t.index?t.index.array:null,i=n.maxDepth,a=n.verbose,r=n.maxLeafTris,o=n.strategy,c=n.onProgress,p=ht(t),f=e._indirectBuffer;let u=!1;const l=new Float32Array(6),d=new Float32Array(6),h=oe(t,l),B=n.indirect?ue:fe,b=[],y=n.indirect?qn(t):kn(t);if(y.length===1){const m=y[0],w=new Ft;w.boundingData=l,re(h,m.offset,m.count,d),A(w,m.offset,m.count,d),b.push(w)}else for(let m of y){const w=new Ft;w.boundingData=new Float32Array(6),Kt(h,m.offset,m.count,w.boundingData,d),A(w,m.offset,m.count,d),b.push(w)}return b;function x(m){c&&c(m/p)}function A(m,w,T,_=null,g=0){if(!u&&g>=i&&(u=!0,a&&(console.warn(`MeshBVH: Max depth of ${i} reached when generating BVH. Consider increasing maxDepth.`),console.warn(t))),T<=r||g>=i)return x(w+T),m.offset=w,m.count=T,m;const M=ae(m.boundingData,_,h,w,T,o);if(M.axis===-1)return x(w+T),m.offset=w,m.count=T,m;const S=B(f,s,h,w,T,M);if(S===w||S===w+T)x(w+T),m.offset=w,m.count=T;else{m.splitAxis=M.axis;const F=new Ft,P=w,C=S-w;m.left=F,F.boundingData=new Float32Array(6),Kt(h,P,C,F.boundingData,d),A(F,P,C,d,g+1);const L=new Ft,v=S,E=T-C;m.right=L,L.boundingData=new Float32Array(6),Kt(h,v,E,L.boundingData,d),A(L,v,E,d,g+1)}return m}}function ye(e,n){const t=e.geometry;n.indirect&&(e._indirectBuffer=pe(t,n.useSharedArrayBuffer),se(t)&&!n.verbose&&console.warn('MeshBVH: Provided geometry contains groups that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.')),e._indirectBuffer||ee(t,n);const s=de(e,n);let i,a,r;const o=[],c=n.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer;for(let u=0;u<s.length;u++){const l=s[u];let d=p(l);const h=new c(kt*d);i=new Float32Array(h),a=new Uint32Array(h),r=new Uint16Array(h),f(0,l),o.push(h)}e._roots=o;return;function p(u){return u.count?1:1+p(u.left)+p(u.right)}function f(u,l){const d=u/4,h=u/2,B=!!l.count,b=l.boundingData;for(let y=0;y<6;y++)i[d+y]=b[y];if(B){const y=l.offset,x=l.count;return a[d+6]=y,r[h+14]=x,r[h+15]=jt,u+kt}else{const y=l.left,x=l.right,A=l.splitAxis;let m;if(m=f(u+kt,y),m/4>Math.pow(2,32))throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return a[d+6]=m/4,m=f(m,x),a[d+7]=A,m}}}class Q{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(n,t){let s=1/0,i=-1/0;for(let a=0,r=n.length;a<r;a++){const c=n[a][t];s=c<s?c:s,i=c>i?c:i}this.min=s,this.max=i}setFromPoints(n,t){let s=1/0,i=-1/0;for(let a=0,r=t.length;a<r;a++){const o=t[a],c=n.dot(o);s=c<s?c:s,i=c>i?c:i}this.min=s,this.max=i}isSeparated(n){return this.min>n.max||n.min>this.max}}Q.prototype.setFromBox=function(){const e=new U;return function(t,s){const i=s.min,a=s.max;let r=1/0,o=-1/0;for(let c=0;c<=1;c++)for(let p=0;p<=1;p++)for(let f=0;f<=1;f++){e.x=i.x*c+a.x*(1-c),e.y=i.y*p+a.y*(1-p),e.z=i.z*f+a.z*(1-f);const u=t.dot(e);r=Math.min(u,r),o=Math.max(u,o)}this.min=r,this.max=o}}();const he=function(){const e=new U,n=new U,t=new U;return function(i,a,r){const o=i.start,c=e,p=a.start,f=n;t.subVectors(o,p),e.subVectors(i.end,i.start),n.subVectors(a.end,a.start);const u=t.dot(f),l=f.dot(c),d=f.dot(f),h=t.dot(c),b=c.dot(c)*d-l*l;let y,x;b!==0?y=(u*l-h*d)/b:y=0,x=(u+y*l)/d,r.x=y,r.y=x}}(),dn=function(){const e=new yt,n=new U,t=new U;return function(i,a,r,o){he(i,a,e);let c=e.x,p=e.y;if(c>=0&&c<=1&&p>=0&&p<=1){i.at(c,r),a.at(p,o);return}else if(c>=0&&c<=1){p<0?a.at(0,o):a.at(1,o),i.closestPointToPoint(o,!0,r);return}else if(p>=0&&p<=1){c<0?i.at(0,r):i.at(1,r),a.closestPointToPoint(r,!0,o);return}else{let f;c<0?f=i.start:f=i.end;let u;p<0?u=a.start:u=a.end;const l=n,d=t;if(i.closestPointToPoint(u,!0,n),a.closestPointToPoint(f,!0,t),l.distanceToSquared(u)<=d.distanceToSquared(f)){r.copy(l),o.copy(u);return}else{r.copy(f),o.copy(d);return}}}}(),me=function(){const e=new U,n=new U,t=new In,s=new J;return function(a,r){const{radius:o,center:c}=a,{a:p,b:f,c:u}=r;if(s.start=p,s.end=f,s.closestPointToPoint(c,!0,e).distanceTo(c)<=o||(s.start=p,s.end=u,s.closestPointToPoint(c,!0,e).distanceTo(c)<=o)||(s.start=f,s.end=u,s.closestPointToPoint(c,!0,e).distanceTo(c)<=o))return!0;const B=r.getPlane(t);if(Math.abs(B.distanceToPoint(c))<=o){const y=B.projectPoint(c,n);if(r.containsPoint(y))return!0}return!1}}(),xe=1e-15;function Jt(e){return Math.abs(e)<xe}class Z extends _t{constructor(...n){super(...n),this.isExtendedTriangle=!0,this.satAxes=new Array(4).fill().map(()=>new U),this.satBounds=new Array(4).fill().map(()=>new Q),this.points=[this.a,this.b,this.c],this.sphere=new Yn,this.plane=new In,this.needsUpdate=!0}intersectsSphere(n){return me(n,this)}update(){const n=this.a,t=this.b,s=this.c,i=this.points,a=this.satAxes,r=this.satBounds,o=a[0],c=r[0];this.getNormal(o),c.setFromPoints(o,i);const p=a[1],f=r[1];p.subVectors(n,t),f.setFromPoints(p,i);const u=a[2],l=r[2];u.subVectors(t,s),l.setFromPoints(u,i);const d=a[3],h=r[3];d.subVectors(s,n),h.setFromPoints(d,i),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(o,n),this.needsUpdate=!1}}Z.prototype.closestPointToSegment=function(){const e=new U,n=new U,t=new J;return function(i,a=null,r=null){const{start:o,end:c}=i,p=this.points;let f,u=1/0;for(let l=0;l<3;l++){const d=(l+1)%3;t.start.copy(p[l]),t.end.copy(p[d]),dn(t,i,e,n),f=e.distanceToSquared(n),f<u&&(u=f,a&&a.copy(e),r&&r.copy(n))}return this.closestPointToPoint(o,e),f=o.distanceToSquared(e),f<u&&(u=f,a&&a.copy(e),r&&r.copy(o)),this.closestPointToPoint(c,e),f=c.distanceToSquared(e),f<u&&(u=f,a&&a.copy(e),r&&r.copy(c)),Math.sqrt(u)}}();Z.prototype.intersectsTriangle=function(){const e=new Z,n=new Array(3),t=new Array(3),s=new Q,i=new Q,a=new U,r=new U,o=new U,c=new U,p=new U,f=new J,u=new J,l=new J,d=new U;function h(B,b,y){const x=B.points;let A=0,m=-1;for(let w=0;w<3;w++){const{start:T,end:_}=f;T.copy(x[w]),_.copy(x[(w+1)%3]),f.delta(r);const g=Jt(b.distanceToPoint(T));if(Jt(b.normal.dot(r))&&g){y.copy(f),A=2;break}const M=b.intersectLine(f,d);if(!M&&g&&d.copy(T),(M||g)&&!Jt(d.distanceTo(_))){if(A<=1)(A===1?y.start:y.end).copy(d),g&&(m=A);else if(A>=2){(m===1?y.start:y.end).copy(d),A=2;break}if(A++,A===2&&m===-1)break}}return A}return function(b,y=null,x=!1){this.needsUpdate&&this.update(),b.isExtendedTriangle?b.needsUpdate&&b.update():(e.copy(b),e.update(),b=e);const A=this.plane,m=b.plane;if(Math.abs(A.normal.dot(m.normal))>1-1e-10){const w=this.satBounds,T=this.satAxes;t[0]=b.a,t[1]=b.b,t[2]=b.c;for(let M=0;M<4;M++){const S=w[M],F=T[M];if(s.setFromPoints(F,t),S.isSeparated(s))return!1}const _=b.satBounds,g=b.satAxes;n[0]=this.a,n[1]=this.b,n[2]=this.c;for(let M=0;M<4;M++){const S=_[M],F=g[M];if(s.setFromPoints(F,n),S.isSeparated(s))return!1}for(let M=0;M<4;M++){const S=T[M];for(let F=0;F<4;F++){const P=g[F];if(a.crossVectors(S,P),s.setFromPoints(a,n),i.setFromPoints(a,t),s.isSeparated(i))return!1}}return y&&(x||console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),y.start.set(0,0,0),y.end.set(0,0,0)),!0}else{const w=h(this,m,u);if(w===1&&b.containsPoint(u.end))return y&&(y.start.copy(u.end),y.end.copy(u.end)),!0;if(w!==2)return!1;const T=h(b,A,l);if(T===1&&this.containsPoint(l.end))return y&&(y.start.copy(l.end),y.end.copy(l.end)),!0;if(T!==2)return!1;if(u.delta(o),l.delta(c),o.dot(c)<0){let C=l.start;l.start=l.end,l.end=C}const _=u.start.dot(o),g=u.end.dot(o),M=l.start.dot(o),S=l.end.dot(o),F=g<M,P=_<S;return _!==S&&M!==g&&F===P?!1:(y&&(p.subVectors(u.start,l.start),p.dot(o)>0?y.start.copy(u.start):y.start.copy(l.start),p.subVectors(u.end,l.end),p.dot(o)<0?y.end.copy(u.end):y.end.copy(l.end)),!0)}}}();Z.prototype.distanceToPoint=function(){const e=new U;return function(t){return this.closestPointToPoint(t,e),t.distanceTo(e)}}();Z.prototype.distanceToTriangle=function(){const e=new U,n=new U,t=["a","b","c"],s=new J,i=new J;return function(r,o=null,c=null){const p=o||c?s:null;if(this.intersectsTriangle(r,p))return(o||c)&&(o&&p.getCenter(o),c&&p.getCenter(c)),0;let f=1/0;for(let u=0;u<3;u++){let l;const d=t[u],h=r[d];this.closestPointToPoint(h,e),l=h.distanceToSquared(e),l<f&&(f=l,o&&o.copy(e),c&&c.copy(h));const B=this[d];r.closestPointToPoint(B,e),l=B.distanceToSquared(e),l<f&&(f=l,o&&o.copy(B),c&&c.copy(e))}for(let u=0;u<3;u++){const l=t[u],d=t[(u+1)%3];s.set(this[l],this[d]);for(let h=0;h<3;h++){const B=t[h],b=t[(h+1)%3];i.set(r[B],r[b]),dn(s,i,e,n);const y=e.distanceToSquared(n);y<f&&(f=y,o&&o.copy(e),c&&c.copy(n))}}return Math.sqrt(f)}}();class ${constructor(n,t,s){this.isOrientedBox=!0,this.min=new U,this.max=new U,this.matrix=new nt,this.invMatrix=new nt,this.points=new Array(8).fill().map(()=>new U),this.satAxes=new Array(3).fill().map(()=>new U),this.satBounds=new Array(3).fill().map(()=>new Q),this.alignedSatBounds=new Array(3).fill().map(()=>new Q),this.needsUpdate=!1,n&&this.min.copy(n),t&&this.max.copy(t),s&&this.matrix.copy(s)}set(n,t,s){this.min.copy(n),this.max.copy(t),this.matrix.copy(s),this.needsUpdate=!0}copy(n){this.min.copy(n.min),this.max.copy(n.max),this.matrix.copy(n.matrix),this.needsUpdate=!0}}$.prototype.update=function(){return function(){const n=this.matrix,t=this.min,s=this.max,i=this.points;for(let p=0;p<=1;p++)for(let f=0;f<=1;f++)for(let u=0;u<=1;u++){const l=1*p|2*f|4*u,d=i[l];d.x=p?s.x:t.x,d.y=f?s.y:t.y,d.z=u?s.z:t.z,d.applyMatrix4(n)}const a=this.satBounds,r=this.satAxes,o=i[0];for(let p=0;p<3;p++){const f=r[p],u=a[p],l=1<<p,d=i[l];f.subVectors(o,d),u.setFromPoints(f,i)}const c=this.alignedSatBounds;c[0].setFromPointsField(i,"x"),c[1].setFromPointsField(i,"y"),c[2].setFromPointsField(i,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1}}();$.prototype.intersectsBox=function(){const e=new Q;return function(t){this.needsUpdate&&this.update();const s=t.min,i=t.max,a=this.satBounds,r=this.satAxes,o=this.alignedSatBounds;if(e.min=s.x,e.max=i.x,o[0].isSeparated(e)||(e.min=s.y,e.max=i.y,o[1].isSeparated(e))||(e.min=s.z,e.max=i.z,o[2].isSeparated(e)))return!1;for(let c=0;c<3;c++){const p=r[c],f=a[c];if(e.setFromBox(p,t),f.isSeparated(e))return!1}return!0}}();$.prototype.intersectsTriangle=function(){const e=new Z,n=new Array(3),t=new Q,s=new Q,i=new U;return function(r){this.needsUpdate&&this.update(),r.isExtendedTriangle?r.needsUpdate&&r.update():(e.copy(r),e.update(),r=e);const o=this.satBounds,c=this.satAxes;n[0]=r.a,n[1]=r.b,n[2]=r.c;for(let l=0;l<3;l++){const d=o[l],h=c[l];if(t.setFromPoints(h,n),d.isSeparated(t))return!1}const p=r.satBounds,f=r.satAxes,u=this.points;for(let l=0;l<3;l++){const d=p[l],h=f[l];if(t.setFromPoints(h,u),d.isSeparated(t))return!1}for(let l=0;l<3;l++){const d=c[l];for(let h=0;h<4;h++){const B=f[h];if(i.crossVectors(d,B),t.setFromPoints(i,n),s.setFromPoints(i,u),t.isSeparated(s))return!1}}return!0}}();$.prototype.closestPointToPoint=function(){return function(n,t){return this.needsUpdate&&this.update(),t.copy(n).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),t}}();$.prototype.distanceToPoint=function(){const e=new U;return function(t){return this.closestPointToPoint(t,e),t.distanceTo(e)}}();$.prototype.distanceToBox=function(){const e=["x","y","z"],n=new Array(12).fill().map(()=>new J),t=new Array(12).fill().map(()=>new J),s=new U,i=new U;return function(r,o=0,c=null,p=null){if(this.needsUpdate&&this.update(),this.intersectsBox(r))return(c||p)&&(r.getCenter(i),this.closestPointToPoint(i,s),r.closestPointToPoint(s,i),c&&c.copy(s),p&&p.copy(i)),0;const f=o*o,u=r.min,l=r.max,d=this.points;let h=1/0;for(let b=0;b<8;b++){const y=d[b];i.copy(y).clamp(u,l);const x=y.distanceToSquared(i);if(x<h&&(h=x,c&&c.copy(y),p&&p.copy(i),x<f))return Math.sqrt(x)}let B=0;for(let b=0;b<3;b++)for(let y=0;y<=1;y++)for(let x=0;x<=1;x++){const A=(b+1)%3,m=(b+2)%3,w=y<<A|x<<m,T=1<<b|y<<A|x<<m,_=d[w],g=d[T];n[B].set(_,g);const S=e[b],F=e[A],P=e[m],C=t[B],L=C.start,v=C.end;L[S]=u[S],L[F]=y?u[F]:l[F],L[P]=x?u[P]:l[F],v[S]=l[S],v[F]=y?u[F]:l[F],v[P]=x?u[P]:l[F],B++}for(let b=0;b<=1;b++)for(let y=0;y<=1;y++)for(let x=0;x<=1;x++){i.x=b?l.x:u.x,i.y=y?l.y:u.y,i.z=x?l.z:u.z,this.closestPointToPoint(i,s);const A=i.distanceToSquared(s);if(A<h&&(h=A,c&&c.copy(s),p&&p.copy(i),A<f))return Math.sqrt(A)}for(let b=0;b<12;b++){const y=n[b];for(let x=0;x<12;x++){const A=t[x];dn(y,A,s,i);const m=s.distanceToSquared(i);if(m<h&&(h=m,c&&c.copy(s),p&&p.copy(i),m<f))return Math.sqrt(m)}}return Math.sqrt(h)}}();class yn{constructor(n){this._getNewPrimitive=n,this._primitives=[]}getPrimitive(){const n=this._primitives;return n.length===0?this._getNewPrimitive():n.pop()}releasePrimitive(n){this._primitives.push(n)}}class we extends yn{constructor(){super(()=>new Z)}}const k=new we;function N(e,n){return n[e+15]===65535}function q(e,n){return n[e+6]}function H(e,n){return n[e+14]}function X(e){return e+8}function j(e,n){return n[e+6]}function Hn(e,n){return n[e+7]}class Ae{constructor(){this.float32Array=null,this.uint16Array=null,this.uint32Array=null;const n=[];let t=null;this.setBuffer=s=>{t&&n.push(t),t=s,this.float32Array=new Float32Array(s),this.uint16Array=new Uint16Array(s),this.uint32Array=new Uint32Array(s)},this.clearBuffer=()=>{t=null,this.float32Array=null,this.uint16Array=null,this.uint32Array=null,n.length!==0&&this.setBuffer(n.pop())}}}const z=new Ae;let tt,dt;const st=[],Ut=new yn(()=>new W);function be(e,n,t,s,i,a){tt=Ut.getPrimitive(),dt=Ut.getPrimitive(),st.push(tt,dt),z.setBuffer(e._roots[n]);const r=rn(0,e.geometry,t,s,i,a);z.clearBuffer(),Ut.releasePrimitive(tt),Ut.releasePrimitive(dt),st.pop(),st.pop();const o=st.length;return o>0&&(dt=st[o-1],tt=st[o-2]),r}function rn(e,n,t,s,i=null,a=0,r=0){const{float32Array:o,uint16Array:c,uint32Array:p}=z;let f=e*2;if(N(f,c)){const l=q(e,p),d=H(f,c);return D(e,o,tt),s(l,d,!1,r,a+e,tt)}else{let S=function(P){const{uint16Array:C,uint32Array:L}=z;let v=P*2;for(;!N(v,C);)P=X(P),v=P*2;return q(P,L)},F=function(P){const{uint16Array:C,uint32Array:L}=z;let v=P*2;for(;!N(v,C);)P=j(P,L),v=P*2;return q(P,L)+H(v,C)};const l=X(e),d=j(e,p);let h=l,B=d,b,y,x,A;if(i&&(x=tt,A=dt,D(h,o,x),D(B,o,A),b=i(x),y=i(A),y<b)){h=d,B=l;const P=b;b=y,y=P,x=A}x||(x=tt,D(h,o,x));const m=N(h*2,c),w=t(x,m,b,r+1,a+h);let T;if(w===wn){const P=S(h),L=F(h)-P;T=s(P,L,!0,r+1,a+h,x)}else T=w&&rn(h,n,t,s,i,a,r+1);if(T)return!0;A=dt,D(B,o,A);const _=N(B*2,c),g=t(A,_,y,r+1,a+B);let M;if(g===wn){const P=S(B),L=F(B)-P;M=s(P,L,!0,r+1,a+B,A)}else M=g&&rn(B,n,t,s,i,a,r+1);return!!M}}const bt=new U,Qt=new U;function Te(e,n,t={},s=0,i=1/0){const a=s*s,r=i*i;let o=1/0,c=null;if(e.shapecast({boundsTraverseOrder:f=>(bt.copy(n).clamp(f.min,f.max),bt.distanceToSquared(n)),intersectsBounds:(f,u,l)=>l<o&&l<r,intersectsTriangle:(f,u)=>{f.closestPointToPoint(n,bt);const l=n.distanceToSquared(bt);return l<o&&(Qt.copy(bt),o=l,c=u),l<a}}),o===1/0)return null;const p=Math.sqrt(o);return t.point?t.point.copy(Qt):t.point=Qt.clone(),t.distance=p,t.faceIndex=c,t}const it=new U,rt=new U,ot=new U,Lt=new yt,vt=new yt,zt=new yt,gn=new U,Pn=new U,_n=new U,Dt=new U;function Be(e,n,t,s,i,a){let r;return a===Zn?r=e.intersectTriangle(s,t,n,!0,i):r=e.intersectTriangle(n,t,s,a!==Wn,i),r===null?null:{distance:e.origin.distanceTo(i),point:i.clone()}}function ge(e,n,t,s,i,a,r,o,c){it.fromBufferAttribute(n,a),rt.fromBufferAttribute(n,r),ot.fromBufferAttribute(n,o);const p=Be(e,it,rt,ot,Dt,c);if(p){s&&(Lt.fromBufferAttribute(s,a),vt.fromBufferAttribute(s,r),zt.fromBufferAttribute(s,o),p.uv=_t.getInterpolation(Dt,it,rt,ot,Lt,vt,zt,new yt)),i&&(Lt.fromBufferAttribute(i,a),vt.fromBufferAttribute(i,r),zt.fromBufferAttribute(i,o),p.uv1=_t.getInterpolation(Dt,it,rt,ot,Lt,vt,zt,new yt)),t&&(gn.fromBufferAttribute(t,a),Pn.fromBufferAttribute(t,r),_n.fromBufferAttribute(t,o),p.normal=_t.getInterpolation(Dt,it,rt,ot,gn,Pn,_n,new U),p.normal.dot(e.direction)>0&&p.normal.multiplyScalar(-1));const f={a,b:r,c:o,normal:new U,materialIndex:0};_t.getNormal(it,rt,ot,f.normal),p.face=f,p.faceIndex=a}return p}function Yt(e,n,t,s,i){const a=s*3;let r=a+0,o=a+1,c=a+2;const p=e.index;e.index&&(r=p.getX(r),o=p.getX(o),c=p.getX(c));const{position:f,normal:u,uv:l,uv1:d}=e.attributes,h=ge(t,f,u,l,d,r,o,c,n);return h?(h.faceIndex=s,i&&i.push(h),h):null}function V(e,n,t,s){const i=e.a,a=e.b,r=e.c;let o=n,c=n+1,p=n+2;t&&(o=t.getX(o),c=t.getX(c),p=t.getX(p)),i.x=s.getX(o),i.y=s.getY(o),i.z=s.getZ(o),a.x=s.getX(c),a.y=s.getY(c),a.z=s.getZ(c),r.x=s.getX(p),r.y=s.getY(p),r.z=s.getZ(p)}function Pe(e,n,t,s,i,a){const{geometry:r,_indirectBuffer:o}=e;for(let c=s,p=s+i;c<p;c++)Yt(r,n,t,c,a)}function _e(e,n,t,s,i){const{geometry:a,_indirectBuffer:r}=e;let o=1/0,c=null;for(let p=s,f=s+i;p<f;p++){let u;u=Yt(a,n,t,p),u&&u.distance<o&&(c=u,o=u.distance)}return c}function Me(e,n,t,s,i,a,r){const{geometry:o}=t,{index:c}=o,p=o.attributes.position;for(let f=e,u=n+e;f<u;f++){let l;if(l=f,V(r,l*3,c,p),r.needsUpdate=!0,s(r,l,i,a))return!0}return!1}function Se(e,n=null){n&&Array.isArray(n)&&(n=new Set(n));const t=e.geometry,s=t.index?t.index.array:null,i=t.attributes.position;let a,r,o,c,p=0;const f=e._roots;for(let l=0,d=f.length;l<d;l++)a=f[l],r=new Uint32Array(a),o=new Uint16Array(a),c=new Float32Array(a),u(0,p),p+=a.byteLength;function u(l,d,h=!1){const B=l*2;if(o[B+15]===jt){const y=r[l+6],x=o[B+14];let A=1/0,m=1/0,w=1/0,T=-1/0,_=-1/0,g=-1/0;for(let M=3*y,S=3*(y+x);M<S;M++){let F=s[M];const P=i.getX(F),C=i.getY(F),L=i.getZ(F);P<A&&(A=P),P>T&&(T=P),C<m&&(m=C),C>_&&(_=C),L<w&&(w=L),L>g&&(g=L)}return c[l+0]!==A||c[l+1]!==m||c[l+2]!==w||c[l+3]!==T||c[l+4]!==_||c[l+5]!==g?(c[l+0]=A,c[l+1]=m,c[l+2]=w,c[l+3]=T,c[l+4]=_,c[l+5]=g,!0):!1}else{const y=l+8,x=r[l+6],A=y+d,m=x+d;let w=h,T=!1,_=!1;n?w||(T=n.has(A),_=n.has(m),w=!T&&!_):(T=!0,_=!0);const g=w||T,M=w||_;let S=!1;g&&(S=u(y,d,w));let F=!1;M&&(F=u(x,d,w));const P=S||F;if(P)for(let C=0;C<3;C++){const L=y+C,v=x+C,E=c[L],mt=c[L+3],xt=c[v],wt=c[v+3];c[l+C]=E<xt?E:xt,c[l+C+3]=mt>wt?mt:wt}return P}}}const Mn=new W;function et(e,n,t,s){return D(e,n,Mn),t.intersectBox(Mn,s)}function Ce(e,n,t,s,i,a){const{geometry:r,_indirectBuffer:o}=e;for(let c=s,p=s+i;c<p;c++){let f=o?o[c]:c;Yt(r,n,t,f,a)}}function Fe(e,n,t,s,i){const{geometry:a,_indirectBuffer:r}=e;let o=1/0,c=null;for(let p=s,f=s+i;p<f;p++){let u;u=Yt(a,n,t,r?r[p]:p),u&&u.distance<o&&(c=u,o=u.distance)}return c}function Ue(e,n,t,s,i,a,r){const{geometry:o}=t,{index:c}=o,p=o.attributes.position;for(let f=e,u=n+e;f<u;f++){let l;if(l=t.resolveTriangleIndex(f),V(r,l*3,c,p),r.needsUpdate=!0,s(r,l,i,a))return!0}return!1}const Sn=new U;function Le(e,n,t,s,i){z.setBuffer(e._roots[n]),on(0,e,t,s,i),z.clearBuffer()}function on(e,n,t,s,i){const{float32Array:a,uint16Array:r,uint32Array:o}=z,c=e*2;if(N(c,r)){const f=q(e,o),u=H(c,r);Pe(n,t,s,f,u,i)}else{const f=X(e);et(f,a,s,Sn)&&on(f,n,t,s,i);const u=j(e,o);et(u,a,s,Sn)&&on(u,n,t,s,i)}}const Cn=new U,ve=["x","y","z"];function ze(e,n,t,s){z.setBuffer(e._roots[n]);const i=cn(0,e,t,s);return z.clearBuffer(),i}function cn(e,n,t,s){const{float32Array:i,uint16Array:a,uint32Array:r}=z;let o=e*2;if(N(o,a)){const p=q(e,r),f=H(o,a);return _e(n,t,s,p,f)}else{const p=Hn(e,r),f=ve[p],l=s.direction[f]>=0;let d,h;l?(d=X(e),h=j(e,r)):(d=j(e,r),h=X(e));const b=et(d,i,s,Cn)?cn(d,n,t,s):null;if(b){const A=b.point[f];if(l?A<=i[h+p]:A>=i[h+p+3])return b}const x=et(h,i,s,Cn)?cn(h,n,t,s):null;return b&&x?b.distance<=x.distance?b:x:b||x||null}}const Et=new W,ct=new Z,at=new Z,Tt=new nt,Fn=new $,Rt=new $;function De(e,n,t,s){z.setBuffer(e._roots[n]);const i=an(0,e,t,s);return z.clearBuffer(),i}function an(e,n,t,s,i=null){const{float32Array:a,uint16Array:r,uint32Array:o}=z;let c=e*2;if(i===null&&(t.boundingBox||t.computeBoundingBox(),Fn.set(t.boundingBox.min,t.boundingBox.max,s),i=Fn),N(c,r)){const f=n.geometry,u=f.index,l=f.attributes.position,d=t.index,h=t.attributes.position,B=q(e,o),b=H(c,r);if(Tt.copy(s).invert(),t.boundsTree)return D(e,a,Rt),Rt.matrix.copy(Tt),Rt.needsUpdate=!0,t.boundsTree.shapecast({intersectsBounds:x=>Rt.intersectsBox(x),intersectsTriangle:x=>{x.a.applyMatrix4(s),x.b.applyMatrix4(s),x.c.applyMatrix4(s),x.needsUpdate=!0;for(let A=B*3,m=(b+B)*3;A<m;A+=3)if(V(at,A,u,l),at.needsUpdate=!0,x.intersectsTriangle(at))return!0;return!1}});for(let y=B*3,x=(b+B)*3;y<x;y+=3){V(ct,y,u,l),ct.a.applyMatrix4(Tt),ct.b.applyMatrix4(Tt),ct.c.applyMatrix4(Tt),ct.needsUpdate=!0;for(let A=0,m=d.count;A<m;A+=3)if(V(at,A,d,h),at.needsUpdate=!0,ct.intersectsTriangle(at))return!0}}else{const f=e+8,u=o[e+6];return D(f,a,Et),!!(i.intersectsBox(Et)&&an(f,n,t,s,i)||(D(u,a,Et),i.intersectsBox(Et)&&an(u,n,t,s,i)))}}const Vt=new nt,Gt=new $,Bt=new $,Ee=new U,Re=new U,Ve=new U,Ie=new U;function $e(e,n,t,s={},i={},a=0,r=1/0){n.boundingBox||n.computeBoundingBox(),Gt.set(n.boundingBox.min,n.boundingBox.max,t),Gt.needsUpdate=!0;const o=e.geometry,c=o.attributes.position,p=o.index,f=n.attributes.position,u=n.index,l=k.getPrimitive(),d=k.getPrimitive();let h=Ee,B=Re,b=null,y=null;i&&(b=Ve,y=Ie);let x=1/0,A=null,m=null;return Vt.copy(t).invert(),Bt.matrix.copy(Vt),e.shapecast({boundsTraverseOrder:w=>Gt.distanceToBox(w),intersectsBounds:(w,T,_)=>_<x&&_<r?(T&&(Bt.min.copy(w.min),Bt.max.copy(w.max),Bt.needsUpdate=!0),!0):!1,intersectsRange:(w,T)=>{if(n.boundsTree)return n.boundsTree.shapecast({boundsTraverseOrder:g=>Bt.distanceToBox(g),intersectsBounds:(g,M,S)=>S<x&&S<r,intersectsRange:(g,M)=>{for(let S=g,F=g+M;S<F;S++){V(d,3*S,u,f),d.a.applyMatrix4(t),d.b.applyMatrix4(t),d.c.applyMatrix4(t),d.needsUpdate=!0;for(let P=w,C=w+T;P<C;P++){V(l,3*P,p,c),l.needsUpdate=!0;const L=l.distanceToTriangle(d,h,b);if(L<x&&(B.copy(h),y&&y.copy(b),x=L,A=P,m=S),L<a)return!0}}}});{const _=ht(n);for(let g=0,M=_;g<M;g++){V(d,3*g,u,f),d.a.applyMatrix4(t),d.b.applyMatrix4(t),d.c.applyMatrix4(t),d.needsUpdate=!0;for(let S=w,F=w+T;S<F;S++){V(l,3*S,p,c),l.needsUpdate=!0;const P=l.distanceToTriangle(d,h,b);if(P<x&&(B.copy(h),y&&y.copy(b),x=P,A=S,m=g),P<a)return!0}}}}}),k.releasePrimitive(l),k.releasePrimitive(d),x===1/0?null:(s.point?s.point.copy(B):s.point=B.clone(),s.distance=x,s.faceIndex=A,i&&(i.point?i.point.copy(y):i.point=y.clone(),i.point.applyMatrix4(Vt),B.applyMatrix4(Vt),i.distance=B.sub(i.point).length(),i.faceIndex=m),s)}function Ne(e,n=null){n&&Array.isArray(n)&&(n=new Set(n));const t=e.geometry,s=t.index?t.index.array:null,i=t.attributes.position;let a,r,o,c,p=0;const f=e._roots;for(let l=0,d=f.length;l<d;l++)a=f[l],r=new Uint32Array(a),o=new Uint16Array(a),c=new Float32Array(a),u(0,p),p+=a.byteLength;function u(l,d,h=!1){const B=l*2;if(o[B+15]===jt){const y=r[l+6],x=o[B+14];let A=1/0,m=1/0,w=1/0,T=-1/0,_=-1/0,g=-1/0;for(let M=y,S=y+x;M<S;M++){const F=3*e.resolveTriangleIndex(M);for(let P=0;P<3;P++){let C=F+P;C=s?s[C]:C;const L=i.getX(C),v=i.getY(C),E=i.getZ(C);L<A&&(A=L),L>T&&(T=L),v<m&&(m=v),v>_&&(_=v),E<w&&(w=E),E>g&&(g=E)}}return c[l+0]!==A||c[l+1]!==m||c[l+2]!==w||c[l+3]!==T||c[l+4]!==_||c[l+5]!==g?(c[l+0]=A,c[l+1]=m,c[l+2]=w,c[l+3]=T,c[l+4]=_,c[l+5]=g,!0):!1}else{const y=l+8,x=r[l+6],A=y+d,m=x+d;let w=h,T=!1,_=!1;n?w||(T=n.has(A),_=n.has(m),w=!T&&!_):(T=!0,_=!0);const g=w||T,M=w||_;let S=!1;g&&(S=u(y,d,w));let F=!1;M&&(F=u(x,d,w));const P=S||F;if(P)for(let C=0;C<3;C++){const L=y+C,v=x+C,E=c[L],mt=c[L+3],xt=c[v],wt=c[v+3];c[l+C]=E<xt?E:xt,c[l+C+3]=mt>wt?mt:wt}return P}}}const Un=new U;function qe(e,n,t,s,i){z.setBuffer(e._roots[n]),ln(0,e,t,s,i),z.clearBuffer()}function ln(e,n,t,s,i){const{float32Array:a,uint16Array:r,uint32Array:o}=z,c=e*2;if(N(c,r)){const f=q(e,o),u=H(c,r);Ce(n,t,s,f,u,i)}else{const f=X(e);et(f,a,s,Un)&&ln(f,n,t,s,i);const u=j(e,o);et(u,a,s,Un)&&ln(u,n,t,s,i)}}const Ln=new U,ke=["x","y","z"];function He(e,n,t,s){z.setBuffer(e._roots[n]);const i=fn(0,e,t,s);return z.clearBuffer(),i}function fn(e,n,t,s){const{float32Array:i,uint16Array:a,uint32Array:r}=z;let o=e*2;if(N(o,a)){const p=q(e,r),f=H(o,a);return Fe(n,t,s,p,f)}else{const p=Hn(e,r),f=ke[p],l=s.direction[f]>=0;let d,h;l?(d=X(e),h=j(e,r)):(d=j(e,r),h=X(e));const b=et(d,i,s,Ln)?fn(d,n,t,s):null;if(b){const A=b.point[f];if(l?A<=i[h+p]:A>=i[h+p+3])return b}const x=et(h,i,s,Ln)?fn(h,n,t,s):null;return b&&x?b.distance<=x.distance?b:x:b||x||null}}const It=new W,lt=new Z,ft=new Z,gt=new nt,vn=new $,$t=new $;function Xe(e,n,t,s){z.setBuffer(e._roots[n]);const i=un(0,e,t,s);return z.clearBuffer(),i}function un(e,n,t,s,i=null){const{float32Array:a,uint16Array:r,uint32Array:o}=z;let c=e*2;if(i===null&&(t.boundingBox||t.computeBoundingBox(),vn.set(t.boundingBox.min,t.boundingBox.max,s),i=vn),N(c,r)){const f=n.geometry,u=f.index,l=f.attributes.position,d=t.index,h=t.attributes.position,B=q(e,o),b=H(c,r);if(gt.copy(s).invert(),t.boundsTree)return D(e,a,$t),$t.matrix.copy(gt),$t.needsUpdate=!0,t.boundsTree.shapecast({intersectsBounds:x=>$t.intersectsBox(x),intersectsTriangle:x=>{x.a.applyMatrix4(s),x.b.applyMatrix4(s),x.c.applyMatrix4(s),x.needsUpdate=!0;for(let A=B,m=b+B;A<m;A++)if(V(ft,3*n.resolveTriangleIndex(A),u,l),ft.needsUpdate=!0,x.intersectsTriangle(ft))return!0;return!1}});for(let y=B,x=b+B;y<x;y++){const A=n.resolveTriangleIndex(y);V(lt,3*A,u,l),lt.a.applyMatrix4(gt),lt.b.applyMatrix4(gt),lt.c.applyMatrix4(gt),lt.needsUpdate=!0;for(let m=0,w=d.count;m<w;m+=3)if(V(ft,m,d,h),ft.needsUpdate=!0,lt.intersectsTriangle(ft))return!0}}else{const f=e+8,u=o[e+6];return D(f,a,It),!!(i.intersectsBox(It)&&un(f,n,t,s,i)||(D(u,a,It),i.intersectsBox(It)&&un(u,n,t,s,i)))}}const Nt=new nt,Ot=new $,Pt=new $,je=new U,Ye=new U,Ze=new U,We=new U;function Ke(e,n,t,s={},i={},a=0,r=1/0){n.boundingBox||n.computeBoundingBox(),Ot.set(n.boundingBox.min,n.boundingBox.max,t),Ot.needsUpdate=!0;const o=e.geometry,c=o.attributes.position,p=o.index,f=n.attributes.position,u=n.index,l=k.getPrimitive(),d=k.getPrimitive();let h=je,B=Ye,b=null,y=null;i&&(b=Ze,y=We);let x=1/0,A=null,m=null;return Nt.copy(t).invert(),Pt.matrix.copy(Nt),e.shapecast({boundsTraverseOrder:w=>Ot.distanceToBox(w),intersectsBounds:(w,T,_)=>_<x&&_<r?(T&&(Pt.min.copy(w.min),Pt.max.copy(w.max),Pt.needsUpdate=!0),!0):!1,intersectsRange:(w,T)=>{if(n.boundsTree){const _=n.boundsTree;return _.shapecast({boundsTraverseOrder:g=>Pt.distanceToBox(g),intersectsBounds:(g,M,S)=>S<x&&S<r,intersectsRange:(g,M)=>{for(let S=g,F=g+M;S<F;S++){const P=_.resolveTriangleIndex(S);V(d,3*P,u,f),d.a.applyMatrix4(t),d.b.applyMatrix4(t),d.c.applyMatrix4(t),d.needsUpdate=!0;for(let C=w,L=w+T;C<L;C++){const v=e.resolveTriangleIndex(C);V(l,3*v,p,c),l.needsUpdate=!0;const E=l.distanceToTriangle(d,h,b);if(E<x&&(B.copy(h),y&&y.copy(b),x=E,A=C,m=S),E<a)return!0}}}})}else{const _=ht(n);for(let g=0,M=_;g<M;g++){V(d,3*g,u,f),d.a.applyMatrix4(t),d.b.applyMatrix4(t),d.c.applyMatrix4(t),d.needsUpdate=!0;for(let S=w,F=w+T;S<F;S++){const P=e.resolveTriangleIndex(S);V(l,3*P,p,c),l.needsUpdate=!0;const C=l.distanceToTriangle(d,h,b);if(C<x&&(B.copy(h),y&&y.copy(b),x=C,A=S,m=g),C<a)return!0}}}}}),k.releasePrimitive(l),k.releasePrimitive(d),x===1/0?null:(s.point?s.point.copy(B):s.point=B.clone(),s.distance=x,s.faceIndex=A,i&&(i.point?i.point.copy(y):i.point=y.clone(),i.point.applyMatrix4(Nt),B.applyMatrix4(Nt),i.distance=B.sub(i.point).length(),i.faceIndex=m),s)}function Je(){return typeof SharedArrayBuffer<"u"}const Mt=new z.constructor,Ht=new z.constructor,O=new yn(()=>new W),ut=new W,pt=new W,tn=new W,nn=new W;let en=!1;function Qe(e,n,t,s){if(en)throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");en=!0;const i=e._roots,a=n._roots;let r,o=0,c=0;const p=new nt().copy(t).invert();for(let f=0,u=i.length;f<u;f++){Mt.setBuffer(i[f]),c=0;const l=O.getPrimitive();D(0,Mt.float32Array,l),l.applyMatrix4(p);for(let d=0,h=a.length;d<h&&(Ht.setBuffer(a[f]),r=Y(0,0,t,p,s,o,c,0,0,l),Ht.clearBuffer(),c+=a[d].length,!r);d++);if(O.releasePrimitive(l),Mt.clearBuffer(),o+=i[f].length,r)break}return en=!1,r}function Y(e,n,t,s,i,a=0,r=0,o=0,c=0,p=null,f=!1){let u,l;f?(u=Ht,l=Mt):(u=Mt,l=Ht);const d=u.float32Array,h=u.uint32Array,B=u.uint16Array,b=l.float32Array,y=l.uint32Array,x=l.uint16Array,A=e*2,m=n*2,w=N(A,B),T=N(m,x);let _=!1;if(T&&w)f?_=i(q(n,y),H(n*2,x),q(e,h),H(e*2,B),c,r+n,o,a+e):_=i(q(e,h),H(e*2,B),q(n,y),H(n*2,x),o,a+e,c,r+n);else if(T){const g=O.getPrimitive();D(n,b,g),g.applyMatrix4(t);const M=X(e),S=j(e,h);D(M,d,ut),D(S,d,pt);const F=g.intersectsBox(ut),P=g.intersectsBox(pt);_=F&&Y(n,M,s,t,i,r,a,c,o+1,g,!f)||P&&Y(n,S,s,t,i,r,a,c,o+1,g,!f),O.releasePrimitive(g)}else{const g=X(n),M=j(n,y);D(g,b,tn),D(M,b,nn);const S=p.intersectsBox(tn),F=p.intersectsBox(nn);if(S&&F)_=Y(e,g,t,s,i,a,r,o,c+1,p,f)||Y(e,M,t,s,i,a,r,o,c+1,p,f);else if(S)if(w)_=Y(e,g,t,s,i,a,r,o,c+1,p,f);else{const P=O.getPrimitive();P.copy(tn).applyMatrix4(t);const C=X(e),L=j(e,h);D(C,d,ut),D(L,d,pt);const v=P.intersectsBox(ut),E=P.intersectsBox(pt);_=v&&Y(g,C,s,t,i,r,a,c,o+1,P,!f)||E&&Y(g,L,s,t,i,r,a,c,o+1,P,!f),O.releasePrimitive(P)}else if(F)if(w)_=Y(e,M,t,s,i,a,r,o,c+1,p,f);else{const P=O.getPrimitive();P.copy(nn).applyMatrix4(t);const C=X(e),L=j(e,h);D(C,d,ut),D(L,d,pt);const v=P.intersectsBox(ut),E=P.intersectsBox(pt);_=v&&Y(M,C,s,t,i,r,a,c,o+1,P,!f)||E&&Y(M,L,s,t,i,r,a,c,o+1,P,!f),O.releasePrimitive(P)}}return _}const qt=new $,zn=new W;class hn{static serialize(n,t={}){t={cloneBuffers:!0,...t};const s=n.geometry,i=n._roots,a=n._indirectBuffer,r=s.getIndex();let o;return t.cloneBuffers?o={roots:i.map(c=>c.slice()),index:r.array.slice(),indirectBuffer:a?a.slice():null}:o={roots:i,index:r.array,indirectBuffer:a},o}static deserialize(n,t,s={}){s={setIndex:!0,indirect:!!n.indirectBuffer,...s};const{index:i,roots:a,indirectBuffer:r}=n,o=new hn(t,{...s,[Wt]:!0});if(o._roots=a,o._indirectBuffer=r||null,s.setIndex){const c=t.getIndex();if(c===null){const p=new Vn(n.index,1,!1);t.setIndex(p)}else c.array!==i&&(c.array.set(i),c.needsUpdate=!0)}return o}get indirect(){return!!this._indirectBuffer}constructor(n,t={}){if(n.isBufferGeometry){if(n.index&&n.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.")}else throw new Error("MeshBVH: Only BufferGeometries are supported.");if(t=Object.assign({strategy:Nn,maxDepth:40,maxLeafTris:10,verbose:!0,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,indirect:!1,[Wt]:!1},t),t.useSharedArrayBuffer&&!Je())throw new Error("MeshBVH: SharedArrayBuffer is not available.");this.geometry=n,this._roots=null,this._indirectBuffer=null,t[Wt]||(ye(this,t),!n.boundingBox&&t.setBoundingBox&&(n.boundingBox=this.getBoundingBox(new W)));const{_indirectBuffer:s}=this;this.resolveTriangleIndex=t.indirect?i=>s[i]:i=>i}refit(n=null){return(this.indirect?Ne:Se)(this,n)}traverse(n,t=0){const s=this._roots[t],i=new Uint32Array(s),a=new Uint16Array(s);r(0);function r(o,c=0){const p=o*2,f=a[p+15]===jt;if(f){const u=i[o+6],l=a[p+14];n(c,f,new Float32Array(s,o*4,6),u,l)}else{const u=o+kt/4,l=i[o+6],d=i[o+7];n(c,f,new Float32Array(s,o*4,6),d)||(r(u,c+1),r(l,c+1))}}}raycast(n,t=mn){const s=this._roots,i=this.geometry,a=[],r=t.isMaterial,o=Array.isArray(t),c=i.groups,p=r?t.side:t,f=this.indirect?qe:Le;for(let u=0,l=s.length;u<l;u++){const d=o?t[c[u].materialIndex].side:p,h=a.length;if(f(this,u,d,n,a),o){const B=c[u].materialIndex;for(let b=h,y=a.length;b<y;b++)a[b].face.materialIndex=B}}return a}raycastFirst(n,t=mn){const s=this._roots,i=this.geometry,a=t.isMaterial,r=Array.isArray(t);let o=null;const c=i.groups,p=a?t.side:t,f=this.indirect?He:ze;for(let u=0,l=s.length;u<l;u++){const d=r?t[c[u].materialIndex].side:p,h=f(this,u,d,n);h!=null&&(o==null||h.distance<o.distance)&&(o=h,r&&(h.face.materialIndex=c[u].materialIndex))}return o}intersectsGeometry(n,t){let s=!1;const i=this._roots,a=this.indirect?Xe:De;for(let r=0,o=i.length;r<o&&(s=a(this,r,n,t),!s);r++);return s}shapecast(n){const t=k.getPrimitive(),s=this.indirect?Ue:Me;let{boundsTraverseOrder:i,intersectsBounds:a,intersectsRange:r,intersectsTriangle:o}=n;if(r&&o){const u=r;r=(l,d,h,B,b)=>u(l,d,h,B,b)?!0:s(l,d,this,o,h,B,t)}else r||(o?r=(u,l,d,h)=>s(u,l,this,o,d,h,t):r=(u,l,d)=>d);let c=!1,p=0;const f=this._roots;for(let u=0,l=f.length;u<l;u++){const d=f[u];if(c=be(this,u,a,r,i,p),c)break;p+=d.byteLength}return k.releasePrimitive(t),c}bvhcast(n,t,s){let{intersectsRanges:i,intersectsTriangles:a}=s;const r=k.getPrimitive(),o=this.geometry.index,c=this.geometry.attributes.position,p=this.indirect?h=>{const B=this.resolveTriangleIndex(h);V(r,B*3,o,c)}:h=>{V(r,h*3,o,c)},f=k.getPrimitive(),u=n.geometry.index,l=n.geometry.attributes.position,d=n.indirect?h=>{const B=n.resolveTriangleIndex(h);V(f,B*3,u,l)}:h=>{V(f,h*3,u,l)};if(a){const h=(B,b,y,x,A,m,w,T)=>{for(let _=y,g=y+x;_<g;_++){d(_),f.a.applyMatrix4(t),f.b.applyMatrix4(t),f.c.applyMatrix4(t),f.needsUpdate=!0;for(let M=B,S=B+b;M<S;M++)if(p(M),r.needsUpdate=!0,a(r,f,M,_,A,m,w,T))return!0}return!1};if(i){const B=i;i=function(b,y,x,A,m,w,T,_){return B(b,y,x,A,m,w,T,_)?!0:h(b,y,x,A,m,w,T,_)}}else i=h}return Qe(this,n,t,i)}intersectsBox(n,t){return qt.set(n.min,n.max,t),qt.needsUpdate=!0,this.shapecast({intersectsBounds:s=>qt.intersectsBox(s),intersectsTriangle:s=>qt.intersectsTriangle(s)})}intersectsSphere(n){return this.shapecast({intersectsBounds:t=>n.intersectsBox(t),intersectsTriangle:t=>t.intersectsSphere(n)})}closestPointToGeometry(n,t,s={},i={},a=0,r=1/0){return(this.indirect?Ke:$e)(this,n,t,s,i,a,r)}closestPointToPoint(n,t={},s=0,i=1/0){return Te(this,n,t,s,i)}getBoundingBox(n){return n.makeEmpty(),this._roots.forEach(s=>{D(0,new Float32Array(s),zn),n.union(zn)}),n}}function Dn(e,n,t){return e===null||(e.point.applyMatrix4(n.matrixWorld),e.distance=e.point.distanceTo(t.ray.origin),e.object=n,e.distance<t.near||e.distance>t.far)?null:e}const sn=new Kn,En=new nt,Ge=$n.prototype.raycast;function Oe(e,n){if(this.geometry.boundsTree){if(this.material===void 0)return;En.copy(this.matrixWorld).invert(),sn.copy(e.ray).applyMatrix4(En);const t=this.geometry.boundsTree;if(e.firstHitOnly===!0){const s=Dn(t.raycastFirst(sn,this.material),this,e);s&&n.push(s)}else{const s=t.raycast(sn,this.material);for(let i=0,a=s.length;i<a;i++){const r=Dn(s[i],this,e);r&&n.push(r)}}}else Ge.call(this,e,n)}function ts(e){return this.boundsTree=new hn(this,e),this.boundsTree}function ns(){this.boundsTree=null}class es{constructor(){I(this,"trigger",n=>{const t=this.handlers.slice(0);for(const s of t)s(n)});I(this,"handlers",[])}add(n){this.handlers.push(n)}remove(n){this.handlers=this.handlers.filter(t=>t!==n)}reset(){this.handlers.length=0}}class ss{constructor(n){I(this,"isDisposeable",()=>"dispose"in this&&"onDisposed"in this);I(this,"isResizeable",()=>"resize"in this&&"getSize"in this);I(this,"isUpdateable",()=>"onAfterUpdate"in this&&"onBeforeUpdate"in this&&"update"in this);I(this,"isHideable",()=>"visible"in this);I(this,"isConfigurable",()=>"setup"in this&&"config"in this&&"onSetup"in this);this.components=n}}class os extends ss{}const R=class R{static create(){const n=Math.random()*4294967295|0,t=Math.random()*4294967295|0,s=Math.random()*4294967295|0,i=Math.random()*4294967295|0;return`${R._lut[n&255]+R._lut[n>>8&255]+R._lut[n>>16&255]+R._lut[n>>24&255]}-${R._lut[t&255]}${R._lut[t>>8&255]}-${R._lut[t>>16&15|64]}${R._lut[t>>24&255]}-${R._lut[s&63|128]}${R._lut[s>>8&255]}-${R._lut[s>>16&255]}${R._lut[s>>24&255]}${R._lut[i&255]}${R._lut[i>>8&255]}${R._lut[i>>16&255]}${R._lut[i>>24&255]}`.toLowerCase()}static validate(n){if(!R._pattern.test(n))throw new Error(`${n} is not a valid UUID v4.

- If you're the tool creator, you can take one from https://www.uuidgenerator.net/.

- If you're using a platform tool, verify the uuid isn't misspelled or contact the tool creator.`)}};I(R,"_pattern",/^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-4[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$/),I(R,"_lut",["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"]);let pn=R;const Xt=class Xt{constructor(){I(this,"onDisposed",new es);I(this,"list",new Map);I(this,"enabled",!1);I(this,"_clock");I(this,"update",()=>{if(!this.enabled)return;const n=this._clock.getDelta();for(const[t,s]of this.list)s.enabled&&s.isUpdateable()&&s.update(n);requestAnimationFrame(this.update)});this._clock=new Jn,Xt.setupBVH()}add(n,t){if(this.list.has(n))throw new Error("You're trying to add a component that already exists in the components intance. Use Components.get() instead.");pn.validate(n),this.list.set(n,t)}get(n){const t=n.uuid;if(!this.list.has(t)){const s=new n(this);return this.list.has(t)||this.add(t,s),s}return this.list.get(t)}init(){this.enabled=!0,this._clock.start(),this.update()}dispose(){this.enabled=!1;for(const[n,t]of this.list)t.enabled=!1,t.isDisposeable()&&t.dispose();this._clock.stop(),this.onDisposed.trigger(),this.onDisposed.reset()}static setupBVH(){xn.prototype.computeBoundsTree=ts,xn.prototype.disposeBoundsTree=ns,$n.prototype.raycast=Oe}};I(Xt,"release","1.4.21");let Rn=Xt;export{ss as B,Rn as C,es as E,pn as U,os as a};
