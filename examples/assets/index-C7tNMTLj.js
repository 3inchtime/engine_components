var kt=Object.defineProperty;var Yt=(l,e,t)=>e in l?kt(l,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):l[e]=t;var h=(l,e,t)=>(Yt(l,typeof e!="symbol"?e+"":e,t),t);import{C as lt,V as Tt,n as Zt,a_ as Bt,a$ as Vt,ah as wt,f as Ot,o as Nt,at as Wt,au as Xt,v as Kt,Q as Gt,a as Qt,av as qt,p as jt,y as Jt,z as $t,h as te,m as ee,q as se,Z as ie,M as oe}from"./web-ifc-api-BffFJDIm.js";import{B as Mt,E as S,C as Ct,U as re}from"./index-BSAL1QGz.js";class vt extends Mt{constructor(t){super(t);h(this,"worlds",new Map);h(this,"onWorldChanged",new S);h(this,"currentWorld",null);this.onWorldChanged.add(({world:s,action:r})=>{r==="removed"&&this.worlds.delete(s.uuid)})}}class ne extends vt{constructor(){super(...arguments);h(this,"hasCameraControls",()=>"controls"in this)}}class ae extends vt{constructor(){super(...arguments);h(this,"onAfterUpdate",new S);h(this,"onBeforeUpdate",new S);h(this,"onDisposed",new S);h(this,"onResize",new S);h(this,"onClippingPlanesUpdated",new S);h(this,"clippingPlanes",[])}updateClippingPlanes(){this.onClippingPlanesUpdated.trigger()}setPlane(t,s,r){s.isLocal=r;const n=this.clippingPlanes.indexOf(s);t&&n===-1?this.clippingPlanes.push(s):!t&&n>-1&&this.clippingPlanes.splice(n,1),this.three.clippingPlanes=this.clippingPlanes.filter(a=>!a.isLocal)}}const tt=class tt extends Ct{constructor(t){super(t);h(this,"_disposedComponents",new Set);h(this,"enabled",!0);t.add(tt.uuid,this)}get(){return this._disposedComponents}destroy(t,s=!0,r=!0){t.removeFromParent();const n=t;n.dispose&&n.dispose(),this.disposeGeometryAndMaterials(t,s),r&&n.children&&n.children.length&&this.disposeChildren(n),t.children.length=0}disposeGeometry(t){const s=t;s.boundsTree&&s.disposeBoundsTree(),t.dispose()}disposeGeometryAndMaterials(t,s){const r=t;r.geometry&&this.disposeGeometry(r.geometry),s&&r.material&&tt.disposeMaterial(r),r.material=[],r.geometry=null}disposeChildren(t){for(const s of t.children)this.destroy(s)}static disposeMaterial(t){if(t.material)if(Array.isArray(t.material))for(const s of t.material)s.dispose();else t.material.dispose()}};h(tt,"uuid","76e9cd8e-ad8f-4753-9ef6-cbc60f7247fe");let et=tt;class he extends vt{constructor(t){super(t);h(this,"onDisposed",new S)}dispose(){const t=this.components.get(et);for(const s of this.three.children){const r=s;r.geometry&&t.destroy(r)}this.three.children=[],this.onDisposed.trigger(),this.onDisposed.reset()}}class le extends Mt{constructor(t){super(t);h(this,"meshes",new Set);h(this,"onAfterUpdate",new S);h(this,"onBeforeUpdate",new S);h(this,"isDisposing",!1);h(this,"enabled",!0);h(this,"uuid",re.create());h(this,"name");h(this,"onDisposed",new S);h(this,"_scene");h(this,"_camera");h(this,"_renderer",null)}get scene(){if(!this._scene)throw new Error("No scene initialized!");return this._scene}set scene(t){this._scene=t,t.worlds.set(this.uuid,this),t.currentWorld=this,t.onWorldChanged.trigger({world:this,action:"added"})}get camera(){if(!this._camera)throw new Error("No camera initialized!");return this._camera}set camera(t){this._camera=t,t.worlds.set(this.uuid,this),t.currentWorld=this,t.onWorldChanged.trigger({world:this,action:"added"})}get renderer(){return this._renderer}set renderer(t){this._renderer=t,t&&(t.worlds.set(this.uuid,this),t.currentWorld=this,t.onWorldChanged.trigger({world:this,action:"added"}))}update(t){this.enabled&&(!this._scene||!this._camera||(this.scene.currentWorld=this,this.camera.currentWorld=this,this.renderer&&(this.renderer.currentWorld=this),this.onBeforeUpdate.trigger(),this.scene.isUpdateable()&&this.scene.update(t),this.camera.isUpdateable()&&this.camera.update(t),this.renderer&&this.renderer.update(t),this.onAfterUpdate.trigger()))}dispose(t=!0){if(this.enabled=!1,this.isDisposing=!0,this.scene.onWorldChanged.trigger({world:this,action:"removed"}),this.camera.onWorldChanged.trigger({world:this,action:"removed"}),this.renderer&&this.renderer.onWorldChanged.trigger({world:this,action:"removed"}),t){const s=this.components.get(et);this.scene.dispose(),this.camera.isDisposeable()&&this.camera.dispose(),this.renderer&&this.renderer.dispose();for(const r of this.meshes)s.destroy(r);this.meshes.clear()}this._scene=null,this._camera=null,this._renderer=null,this.onDisposed.trigger()}}class Ee extends he{constructor(t){super(t);h(this,"isSetup",!1);h(this,"three");h(this,"onSetup",new S);h(this,"config",{directionalLight:{color:new lt("white"),intensity:1.5,position:new Tt(5,10,3)},ambientLight:{color:new lt("white"),intensity:1}});this.three=new Zt,this.three.background=new lt(2107698)}setup(t){this.config={...this.config,...t};const s=new Bt(this.config.directionalLight.color,this.config.directionalLight.intensity);s.position.copy(this.config.directionalLight.position);const r=new Vt(this.config.ambientLight.color,this.config.ambientLight.intensity);this.three.add(s,r),this.isSetup=!0,this.onSetup.trigger(this)}}class ye extends ae{constructor(t,s,r){super(t);h(this,"enabled",!0);h(this,"container");h(this,"three");h(this,"_canvas");h(this,"_parameters");h(this,"_resizeObserver",null);h(this,"onContainerUpdated",new S);h(this,"_resizing",!1);h(this,"resize",t=>{if(this._resizing)return;this._resizing=!0,this.onContainerUpdated.trigger();const s=t?t.x:this.container.clientWidth,r=t?t.y:this.container.clientHeight;this.three.setSize(s,r),this.onResize.trigger(new Ot(s,r)),this._resizing=!1});h(this,"resizeEvent",()=>{this.resize()});h(this,"onContextLost",t=>{t.preventDefault(),this.enabled=!1});h(this,"onContextBack",()=>{this.three.setRenderTarget(null),this.three.dispose(),this.three=new wt({canvas:this._canvas,antialias:!0,alpha:!0,...this._parameters}),this.enabled=!0});this.container=s,this._parameters=r,this.three=new wt({antialias:!0,alpha:!0,...r}),this.three.setPixelRatio(Math.min(window.devicePixelRatio,2)),this.setupRenderer(),this.setupEvents(!0),this.resize(),this._canvas=this.three.domElement;const n=this.three.getContext(),{canvas:a}=n;a.addEventListener("webglcontextlost",this.onContextLost,!1),a.addEventListener("webglcontextrestored",this.onContextBack,!1)}update(){if(!this.enabled||!this.currentWorld)return;this.onBeforeUpdate.trigger(this);const t=this.currentWorld.scene.three,s=this.currentWorld.camera.three;this.three.render(t,s),this.onAfterUpdate.trigger(this)}dispose(){this.enabled=!1,this.setupEvents(!1),this.three.domElement.remove(),this.three.dispose(),this.onResize.reset(),this.onAfterUpdate.reset(),this.onBeforeUpdate.reset(),this.onDisposed.trigger(),this.onDisposed.reset()}getSize(){return new Ot(this.three.domElement.clientWidth,this.three.domElement.clientHeight)}setupEvents(t){const s=this.three.domElement.parentElement;if(!s)throw new Error("This renderer needs to have an HTML container!");this._resizeObserver&&(this._resizeObserver.disconnect(),this._resizeObserver=null),window.removeEventListener("resize",this.resizeEvent),t&&(this._resizeObserver=new ResizeObserver(this.resizeEvent),this._resizeObserver.observe(s),window.addEventListener("resize",this.resizeEvent))}setupRenderer(){this.three.localClippingEnabled=!0,this.container&&this.container.appendChild(this.three.domElement),this.onContainerUpdated.trigger()}}/*!
 * camera-controls
 * https://github.com/yomotsu/camera-controls
 * (c) 2017 @yomotsu
 * Released under the MIT License.
 */const p={LEFT:1,RIGHT:2,MIDDLE:4},i=Object.freeze({NONE:0,ROTATE:1,TRUCK:2,OFFSET:4,DOLLY:8,ZOOM:16,TOUCH_ROTATE:32,TOUCH_TRUCK:64,TOUCH_OFFSET:128,TOUCH_DOLLY:256,TOUCH_ZOOM:512,TOUCH_DOLLY_TRUCK:1024,TOUCH_DOLLY_OFFSET:2048,TOUCH_DOLLY_ROTATE:4096,TOUCH_ZOOM_TRUCK:8192,TOUCH_ZOOM_OFFSET:16384,TOUCH_ZOOM_ROTATE:32768}),W={NONE:0,IN:1,OUT:-1};function V(l){return l.isPerspectiveCamera}function B(l){return l.isOrthographicCamera}const X=Math.PI*2,Ut=Math.PI/2,bt=1e-5,Q=Math.PI/180;function k(l,e,t){return Math.max(e,Math.min(t,l))}function L(l,e=bt){return Math.abs(l)<e}function x(l,e,t=bt){return L(l-e,t)}function Dt(l,e){return Math.round(l/e)*e}function q(l){return isFinite(l)?l:l<0?-Number.MAX_VALUE:Number.MAX_VALUE}function j(l){return Math.abs(l)<Number.MAX_VALUE?l:l*(1/0)}function rt(l,e,t,s,r=1/0,n){s=Math.max(1e-4,s);const a=2/s,c=a*n,m=1/(1+c+.48*c*c+.235*c*c*c);let u=l-e;const C=e,g=r*s;u=k(u,-g,g),e=l-u;const D=(t.value+a*u)*n;t.value=(t.value-a*D)*m;let E=e+(u+D)*m;return C-l>0==E>C&&(E=C,t.value=(E-C)/n),E}function xt(l,e,t,s,r=1/0,n,a){s=Math.max(1e-4,s);const c=2/s,m=c*n,u=1/(1+m+.48*m*m+.235*m*m*m);let C=e.x,g=e.y,D=e.z,E=l.x-C,A=l.y-g,v=l.z-D;const P=C,F=g,z=D,M=r*s,o=M*M,d=E*E+A*A+v*v;if(d>o){const mt=Math.sqrt(d);E=E/mt*M,A=A/mt*M,v=v/mt*M}C=l.x-E,g=l.y-A,D=l.z-v;const T=(t.x+c*E)*n,f=(t.y+c*A)*n,U=(t.z+c*v)*n;t.x=(t.x-c*T)*u,t.y=(t.y-c*f)*u,t.z=(t.z-c*U)*u,a.x=C+(E+T)*u,a.y=g+(A+f)*u,a.z=D+(v+U)*u;const O=P-l.x,R=F-l.y,I=z-l.z,it=a.x-P,ot=a.y-F,Ht=a.z-z;return O*it+R*ot+I*Ht>0&&(a.x=P,a.y=F,a.z=z,t.x=(a.x-P)/n,t.y=(a.y-F)/n,t.z=(a.z-z)/n),a}function pt(l,e){e.set(0,0),l.forEach(t=>{e.x+=t.clientX,e.y+=t.clientY}),e.x/=l.length,e.y/=l.length}function ut(l,e){return B(l)?(console.warn(`${e} is not supported in OrthographicCamera`),!0):!1}class ce{constructor(){this._listeners={}}addEventListener(e,t){const s=this._listeners;s[e]===void 0&&(s[e]=[]),s[e].indexOf(t)===-1&&s[e].push(t)}hasEventListener(e,t){const s=this._listeners;return s[e]!==void 0&&s[e].indexOf(t)!==-1}removeEventListener(e,t){const r=this._listeners[e];if(r!==void 0){const n=r.indexOf(t);n!==-1&&r.splice(n,1)}}removeAllEventListeners(e){if(!e){this._listeners={};return}Array.isArray(this._listeners[e])&&(this._listeners[e].length=0)}dispatchEvent(e){const s=this._listeners[e.type];if(s!==void 0){e.target=this;const r=s.slice(0);for(let n=0,a=r.length;n<a;n++)r[n].call(this,e)}}}const de="2.7.3",nt=1/8,It=typeof window<"u",_e=It&&/Mac/.test(navigator.platform),me=!(It&&"PointerEvent"in window);let _,Lt,at,ft,b,y,w,K,J,Y,Z,N,At,zt,H,$,G,St,gt,Pt,Et,yt,ht;class st extends ce{static install(e){_=e.THREE,Lt=Object.freeze(new _.Vector3(0,0,0)),at=Object.freeze(new _.Vector3(0,1,0)),ft=Object.freeze(new _.Vector3(0,0,1)),b=new _.Vector2,y=new _.Vector3,w=new _.Vector3,K=new _.Vector3,J=new _.Vector3,Y=new _.Vector3,Z=new _.Vector3,N=new _.Vector3,At=new _.Vector3,zt=new _.Vector3,H=new _.Spherical,$=new _.Spherical,G=new _.Box3,St=new _.Box3,gt=new _.Sphere,Pt=new _.Quaternion,Et=new _.Quaternion,yt=new _.Matrix4,ht=new _.Raycaster}static get ACTION(){return i}constructor(e,t){super(),this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-1/0,this.maxAzimuthAngle=1/0,this.minDistance=Number.EPSILON,this.maxDistance=1/0,this.infinityDolly=!1,this.minZoom=.01,this.maxZoom=1/0,this.smoothTime=.25,this.draggingSmoothTime=.125,this.maxSpeed=1/0,this.azimuthRotateSpeed=1,this.polarRotateSpeed=1,this.dollySpeed=1,this.dollyDragInverted=!1,this.truckSpeed=2,this.dollyToCursor=!1,this.dragToOffset=!1,this.verticalDragToForward=!1,this.boundaryFriction=0,this.restThreshold=.01,this.colliderMeshes=[],this.cancel=()=>{},this._enabled=!0,this._state=i.NONE,this._viewport=null,this._changedDolly=0,this._changedZoom=0,this._hasRested=!0,this._boundaryEnclosesCamera=!1,this._needsUpdate=!0,this._updatedLastTime=!1,this._elementRect=new DOMRect,this._isDragging=!1,this._dragNeedsUpdate=!0,this._activePointers=[],this._lockedPointer=null,this._interactiveArea=new DOMRect(0,0,1,1),this._isUserControllingRotate=!1,this._isUserControllingDolly=!1,this._isUserControllingTruck=!1,this._isUserControllingOffset=!1,this._isUserControllingZoom=!1,this._lastDollyDirection=W.NONE,this._thetaVelocity={value:0},this._phiVelocity={value:0},this._radiusVelocity={value:0},this._targetVelocity=new _.Vector3,this._focalOffsetVelocity=new _.Vector3,this._zoomVelocity={value:0},this._truckInternal=(o,d,T)=>{let f,U;if(V(this._camera)){const O=y.copy(this._camera.position).sub(this._target),R=this._camera.getEffectiveFOV()*Q,I=O.length()*Math.tan(R*.5);f=this.truckSpeed*o*I/this._elementRect.height,U=this.truckSpeed*d*I/this._elementRect.height}else if(B(this._camera)){const O=this._camera;f=o*(O.right-O.left)/O.zoom/this._elementRect.width,U=d*(O.top-O.bottom)/O.zoom/this._elementRect.height}else return;this.verticalDragToForward?(T?this.setFocalOffset(this._focalOffsetEnd.x+f,this._focalOffsetEnd.y,this._focalOffsetEnd.z,!0):this.truck(f,0,!0),this.forward(-U,!0)):T?this.setFocalOffset(this._focalOffsetEnd.x+f,this._focalOffsetEnd.y+U,this._focalOffsetEnd.z,!0):this.truck(f,U,!0)},this._rotateInternal=(o,d)=>{const T=X*this.azimuthRotateSpeed*o/this._elementRect.height,f=X*this.polarRotateSpeed*d/this._elementRect.height;this.rotate(T,f,!0)},this._dollyInternal=(o,d,T)=>{const f=Math.pow(.95,-o*this.dollySpeed),U=this._sphericalEnd.radius,O=this._sphericalEnd.radius*f,R=k(O,this.minDistance,this.maxDistance),I=R-O;this.infinityDolly&&this.dollyToCursor?this._dollyToNoClamp(O,!0):this.infinityDolly&&!this.dollyToCursor?(this.dollyInFixed(I,!0),this._dollyToNoClamp(R,!0)):this._dollyToNoClamp(R,!0),this.dollyToCursor&&(this._changedDolly+=(this.infinityDolly?O:R)-U,this._dollyControlCoord.set(d,T)),this._lastDollyDirection=Math.sign(-o)},this._zoomInternal=(o,d,T)=>{const f=Math.pow(.95,o*this.dollySpeed),U=this._zoom,O=this._zoom*f;this.zoomTo(O,!0),this.dollyToCursor&&(this._changedZoom+=O-U,this._dollyControlCoord.set(d,T))},typeof _>"u"&&console.error("camera-controls: `THREE` is undefined. You must first run `CameraControls.install( { THREE: THREE } )`. Check the docs for further information."),this._camera=e,this._yAxisUpSpace=new _.Quaternion().setFromUnitVectors(this._camera.up,at),this._yAxisUpSpaceInverse=this._yAxisUpSpace.clone().invert(),this._state=i.NONE,this._target=new _.Vector3,this._targetEnd=this._target.clone(),this._focalOffset=new _.Vector3,this._focalOffsetEnd=this._focalOffset.clone(),this._spherical=new _.Spherical().setFromVector3(y.copy(this._camera.position).applyQuaternion(this._yAxisUpSpace)),this._sphericalEnd=this._spherical.clone(),this._lastDistance=this._spherical.radius,this._zoom=this._camera.zoom,this._zoomEnd=this._zoom,this._lastZoom=this._zoom,this._nearPlaneCorners=[new _.Vector3,new _.Vector3,new _.Vector3,new _.Vector3],this._updateNearPlaneCorners(),this._boundary=new _.Box3(new _.Vector3(-1/0,-1/0,-1/0),new _.Vector3(1/0,1/0,1/0)),this._cameraUp0=this._camera.up.clone(),this._target0=this._target.clone(),this._position0=this._camera.position.clone(),this._zoom0=this._zoom,this._focalOffset0=this._focalOffset.clone(),this._dollyControlCoord=new _.Vector2,this.mouseButtons={left:i.ROTATE,middle:i.DOLLY,right:i.TRUCK,wheel:V(this._camera)?i.DOLLY:B(this._camera)?i.ZOOM:i.NONE},this.touches={one:i.TOUCH_ROTATE,two:V(this._camera)?i.TOUCH_DOLLY_TRUCK:B(this._camera)?i.TOUCH_ZOOM_TRUCK:i.NONE,three:i.TOUCH_TRUCK};const s=new _.Vector2,r=new _.Vector2,n=new _.Vector2,a=o=>{if(!this._enabled||!this._domElement)return;if(this._interactiveArea.left!==0||this._interactiveArea.top!==0||this._interactiveArea.width!==1||this._interactiveArea.height!==1){const f=this._domElement.getBoundingClientRect(),U=o.clientX/f.width,O=o.clientY/f.height;if(U<this._interactiveArea.left||U>this._interactiveArea.right||O<this._interactiveArea.top||O>this._interactiveArea.bottom)return}const d=o.pointerType!=="mouse"?null:(o.buttons&p.LEFT)===p.LEFT?p.LEFT:(o.buttons&p.MIDDLE)===p.MIDDLE?p.MIDDLE:(o.buttons&p.RIGHT)===p.RIGHT?p.RIGHT:null;if(d!==null){const f=this._findPointerByMouseButton(d);f&&this._disposePointer(f)}if((o.buttons&p.LEFT)===p.LEFT&&this._lockedPointer)return;const T={pointerId:o.pointerId,clientX:o.clientX,clientY:o.clientY,deltaX:0,deltaY:0,mouseButton:d};this._activePointers.push(T),this._domElement.ownerDocument.removeEventListener("pointermove",m,{passive:!1}),this._domElement.ownerDocument.removeEventListener("pointerup",C),this._domElement.ownerDocument.addEventListener("pointermove",m,{passive:!1}),this._domElement.ownerDocument.addEventListener("pointerup",C),this._isDragging=!0,v(o)},c=o=>{if(!this._enabled||!this._domElement||this._lockedPointer)return;if(this._interactiveArea.left!==0||this._interactiveArea.top!==0||this._interactiveArea.width!==1||this._interactiveArea.height!==1){const f=this._domElement.getBoundingClientRect(),U=o.clientX/f.width,O=o.clientY/f.height;if(U<this._interactiveArea.left||U>this._interactiveArea.right||O<this._interactiveArea.top||O>this._interactiveArea.bottom)return}const d=(o.buttons&p.LEFT)===p.LEFT?p.LEFT:(o.buttons&p.MIDDLE)===p.MIDDLE?p.MIDDLE:(o.buttons&p.RIGHT)===p.RIGHT?p.RIGHT:null;if(d!==null){const f=this._findPointerByMouseButton(d);f&&this._disposePointer(f)}const T={pointerId:1,clientX:o.clientX,clientY:o.clientY,deltaX:0,deltaY:0,mouseButton:(o.buttons&p.LEFT)===p.LEFT?p.LEFT:(o.buttons&p.MIDDLE)===p.LEFT?p.MIDDLE:(o.buttons&p.RIGHT)===p.LEFT?p.RIGHT:null};this._activePointers.push(T),this._domElement.ownerDocument.removeEventListener("mousemove",u),this._domElement.ownerDocument.removeEventListener("mouseup",g),this._domElement.ownerDocument.addEventListener("mousemove",u),this._domElement.ownerDocument.addEventListener("mouseup",g),this._isDragging=!0,v(o)},m=o=>{o.cancelable&&o.preventDefault();const d=o.pointerId,T=this._lockedPointer||this._findPointerById(d);if(T){if(T.clientX=o.clientX,T.clientY=o.clientY,T.deltaX=o.movementX,T.deltaY=o.movementY,this._state=0,o.pointerType==="touch")switch(this._activePointers.length){case 1:this._state=this.touches.one;break;case 2:this._state=this.touches.two;break;case 3:this._state=this.touches.three;break}else(!this._isDragging&&this._lockedPointer||this._isDragging&&(o.buttons&p.LEFT)===p.LEFT)&&(this._state=this._state|this.mouseButtons.left),this._isDragging&&(o.buttons&p.MIDDLE)===p.MIDDLE&&(this._state=this._state|this.mouseButtons.middle),this._isDragging&&(o.buttons&p.RIGHT)===p.RIGHT&&(this._state=this._state|this.mouseButtons.right);P()}},u=o=>{const d=this._lockedPointer||this._findPointerById(1);d&&(d.clientX=o.clientX,d.clientY=o.clientY,d.deltaX=o.movementX,d.deltaY=o.movementY,this._state=0,(this._lockedPointer||(o.buttons&p.LEFT)===p.LEFT)&&(this._state=this._state|this.mouseButtons.left),(o.buttons&p.MIDDLE)===p.MIDDLE&&(this._state=this._state|this.mouseButtons.middle),(o.buttons&p.RIGHT)===p.RIGHT&&(this._state=this._state|this.mouseButtons.right),P())},C=o=>{const d=this._findPointerById(o.pointerId);if(!(d&&d===this._lockedPointer)){if(d&&this._disposePointer(d),o.pointerType==="touch")switch(this._activePointers.length){case 0:this._state=i.NONE;break;case 1:this._state=this.touches.one;break;case 2:this._state=this.touches.two;break;case 3:this._state=this.touches.three;break}else this._state=i.NONE;F()}},g=()=>{const o=this._findPointerById(1);o&&o===this._lockedPointer||(o&&this._disposePointer(o),this._state=i.NONE,F())};let D=-1;const E=o=>{if(!this._domElement||!this._enabled||this.mouseButtons.wheel===i.NONE)return;if(this._interactiveArea.left!==0||this._interactiveArea.top!==0||this._interactiveArea.width!==1||this._interactiveArea.height!==1){const O=this._domElement.getBoundingClientRect(),R=o.clientX/O.width,I=o.clientY/O.height;if(R<this._interactiveArea.left||R>this._interactiveArea.right||I<this._interactiveArea.top||I>this._interactiveArea.bottom)return}if(o.preventDefault(),this.dollyToCursor||this.mouseButtons.wheel===i.ROTATE||this.mouseButtons.wheel===i.TRUCK){const O=performance.now();D-O<1e3&&this._getClientRect(this._elementRect),D=O}const d=_e?-1:-3,T=o.deltaMode===1?o.deltaY/d:o.deltaY/(d*10),f=this.dollyToCursor?(o.clientX-this._elementRect.x)/this._elementRect.width*2-1:0,U=this.dollyToCursor?(o.clientY-this._elementRect.y)/this._elementRect.height*-2+1:0;switch(this.mouseButtons.wheel){case i.ROTATE:{this._rotateInternal(o.deltaX,o.deltaY),this._isUserControllingRotate=!0;break}case i.TRUCK:{this._truckInternal(o.deltaX,o.deltaY,!1),this._isUserControllingTruck=!0;break}case i.OFFSET:{this._truckInternal(o.deltaX,o.deltaY,!0),this._isUserControllingOffset=!0;break}case i.DOLLY:{this._dollyInternal(-T,f,U),this._isUserControllingDolly=!0;break}case i.ZOOM:{this._zoomInternal(-T,f,U),this._isUserControllingZoom=!0;break}}this.dispatchEvent({type:"control"})},A=o=>{if(!(!this._domElement||!this._enabled)){if(this.mouseButtons.right===st.ACTION.NONE){const d=o instanceof PointerEvent?o.pointerId:(o instanceof MouseEvent,0),T=this._findPointerById(d);T&&this._disposePointer(T),this._domElement.ownerDocument.removeEventListener("pointermove",m,{passive:!1}),this._domElement.ownerDocument.removeEventListener("pointerup",C),this._domElement.ownerDocument.removeEventListener("mousemove",u),this._domElement.ownerDocument.removeEventListener("mouseup",g);return}o.preventDefault()}},v=o=>{if(!this._enabled)return;if(pt(this._activePointers,b),this._getClientRect(this._elementRect),s.copy(b),r.copy(b),this._activePointers.length>=2){const T=b.x-this._activePointers[1].clientX,f=b.y-this._activePointers[1].clientY,U=Math.sqrt(T*T+f*f);n.set(0,U);const O=(this._activePointers[0].clientX+this._activePointers[1].clientX)*.5,R=(this._activePointers[0].clientY+this._activePointers[1].clientY)*.5;r.set(O,R)}if(this._state=0,!o)this._lockedPointer&&(this._state=this._state|this.mouseButtons.left);else if("pointerType"in o&&o.pointerType==="touch")switch(this._activePointers.length){case 1:this._state=this.touches.one;break;case 2:this._state=this.touches.two;break;case 3:this._state=this.touches.three;break}else!this._lockedPointer&&(o.buttons&p.LEFT)===p.LEFT&&(this._state=this._state|this.mouseButtons.left),(o.buttons&p.MIDDLE)===p.MIDDLE&&(this._state=this._state|this.mouseButtons.middle),(o.buttons&p.RIGHT)===p.RIGHT&&(this._state=this._state|this.mouseButtons.right);((this._state&i.ROTATE)===i.ROTATE||(this._state&i.TOUCH_ROTATE)===i.TOUCH_ROTATE||(this._state&i.TOUCH_DOLLY_ROTATE)===i.TOUCH_DOLLY_ROTATE||(this._state&i.TOUCH_ZOOM_ROTATE)===i.TOUCH_ZOOM_ROTATE)&&(this._sphericalEnd.theta=this._spherical.theta,this._sphericalEnd.phi=this._spherical.phi,this._thetaVelocity.value=0,this._phiVelocity.value=0),((this._state&i.TRUCK)===i.TRUCK||(this._state&i.TOUCH_TRUCK)===i.TOUCH_TRUCK||(this._state&i.TOUCH_DOLLY_TRUCK)===i.TOUCH_DOLLY_TRUCK||(this._state&i.TOUCH_ZOOM_TRUCK)===i.TOUCH_ZOOM_TRUCK)&&(this._targetEnd.copy(this._target),this._targetVelocity.set(0,0,0)),((this._state&i.DOLLY)===i.DOLLY||(this._state&i.TOUCH_DOLLY)===i.TOUCH_DOLLY||(this._state&i.TOUCH_DOLLY_TRUCK)===i.TOUCH_DOLLY_TRUCK||(this._state&i.TOUCH_DOLLY_OFFSET)===i.TOUCH_DOLLY_OFFSET||(this._state&i.TOUCH_DOLLY_ROTATE)===i.TOUCH_DOLLY_ROTATE)&&(this._sphericalEnd.radius=this._spherical.radius,this._radiusVelocity.value=0),((this._state&i.ZOOM)===i.ZOOM||(this._state&i.TOUCH_ZOOM)===i.TOUCH_ZOOM||(this._state&i.TOUCH_ZOOM_TRUCK)===i.TOUCH_ZOOM_TRUCK||(this._state&i.TOUCH_ZOOM_OFFSET)===i.TOUCH_ZOOM_OFFSET||(this._state&i.TOUCH_ZOOM_ROTATE)===i.TOUCH_ZOOM_ROTATE)&&(this._zoomEnd=this._zoom,this._zoomVelocity.value=0),((this._state&i.OFFSET)===i.OFFSET||(this._state&i.TOUCH_OFFSET)===i.TOUCH_OFFSET||(this._state&i.TOUCH_DOLLY_OFFSET)===i.TOUCH_DOLLY_OFFSET||(this._state&i.TOUCH_ZOOM_OFFSET)===i.TOUCH_ZOOM_OFFSET)&&(this._focalOffsetEnd.copy(this._focalOffset),this._focalOffsetVelocity.set(0,0,0)),this.dispatchEvent({type:"controlstart"})},P=()=>{if(!this._enabled||!this._dragNeedsUpdate)return;this._dragNeedsUpdate=!1,pt(this._activePointers,b);const d=this._domElement&&document.pointerLockElement===this._domElement?this._lockedPointer||this._activePointers[0]:null,T=d?-d.deltaX:r.x-b.x,f=d?-d.deltaY:r.y-b.y;if(r.copy(b),((this._state&i.ROTATE)===i.ROTATE||(this._state&i.TOUCH_ROTATE)===i.TOUCH_ROTATE||(this._state&i.TOUCH_DOLLY_ROTATE)===i.TOUCH_DOLLY_ROTATE||(this._state&i.TOUCH_ZOOM_ROTATE)===i.TOUCH_ZOOM_ROTATE)&&(this._rotateInternal(T,f),this._isUserControllingRotate=!0),(this._state&i.DOLLY)===i.DOLLY||(this._state&i.ZOOM)===i.ZOOM){const U=this.dollyToCursor?(s.x-this._elementRect.x)/this._elementRect.width*2-1:0,O=this.dollyToCursor?(s.y-this._elementRect.y)/this._elementRect.height*-2+1:0,R=this.dollyDragInverted?-1:1;(this._state&i.DOLLY)===i.DOLLY?(this._dollyInternal(R*f*nt,U,O),this._isUserControllingDolly=!0):(this._zoomInternal(R*f*nt,U,O),this._isUserControllingZoom=!0)}if((this._state&i.TOUCH_DOLLY)===i.TOUCH_DOLLY||(this._state&i.TOUCH_ZOOM)===i.TOUCH_ZOOM||(this._state&i.TOUCH_DOLLY_TRUCK)===i.TOUCH_DOLLY_TRUCK||(this._state&i.TOUCH_ZOOM_TRUCK)===i.TOUCH_ZOOM_TRUCK||(this._state&i.TOUCH_DOLLY_OFFSET)===i.TOUCH_DOLLY_OFFSET||(this._state&i.TOUCH_ZOOM_OFFSET)===i.TOUCH_ZOOM_OFFSET||(this._state&i.TOUCH_DOLLY_ROTATE)===i.TOUCH_DOLLY_ROTATE||(this._state&i.TOUCH_ZOOM_ROTATE)===i.TOUCH_ZOOM_ROTATE){const U=b.x-this._activePointers[1].clientX,O=b.y-this._activePointers[1].clientY,R=Math.sqrt(U*U+O*O),I=n.y-R;n.set(0,R);const it=this.dollyToCursor?(r.x-this._elementRect.x)/this._elementRect.width*2-1:0,ot=this.dollyToCursor?(r.y-this._elementRect.y)/this._elementRect.height*-2+1:0;(this._state&i.TOUCH_DOLLY)===i.TOUCH_DOLLY||(this._state&i.TOUCH_DOLLY_ROTATE)===i.TOUCH_DOLLY_ROTATE||(this._state&i.TOUCH_DOLLY_TRUCK)===i.TOUCH_DOLLY_TRUCK||(this._state&i.TOUCH_DOLLY_OFFSET)===i.TOUCH_DOLLY_OFFSET?(this._dollyInternal(I*nt,it,ot),this._isUserControllingDolly=!0):(this._zoomInternal(I*nt,it,ot),this._isUserControllingZoom=!0)}((this._state&i.TRUCK)===i.TRUCK||(this._state&i.TOUCH_TRUCK)===i.TOUCH_TRUCK||(this._state&i.TOUCH_DOLLY_TRUCK)===i.TOUCH_DOLLY_TRUCK||(this._state&i.TOUCH_ZOOM_TRUCK)===i.TOUCH_ZOOM_TRUCK)&&(this._truckInternal(T,f,!1),this._isUserControllingTruck=!0),((this._state&i.OFFSET)===i.OFFSET||(this._state&i.TOUCH_OFFSET)===i.TOUCH_OFFSET||(this._state&i.TOUCH_DOLLY_OFFSET)===i.TOUCH_DOLLY_OFFSET||(this._state&i.TOUCH_ZOOM_OFFSET)===i.TOUCH_ZOOM_OFFSET)&&(this._truckInternal(T,f,!0),this._isUserControllingOffset=!0),this.dispatchEvent({type:"control"})},F=()=>{pt(this._activePointers,b),r.copy(b),this._dragNeedsUpdate=!1,(this._activePointers.length===0||this._activePointers.length===1&&this._activePointers[0]===this._lockedPointer)&&(this._isDragging=!1),this._activePointers.length===0&&this._domElement&&(this._domElement.ownerDocument.removeEventListener("pointermove",m,{passive:!1}),this._domElement.ownerDocument.removeEventListener("mousemove",u),this._domElement.ownerDocument.removeEventListener("pointerup",C),this._domElement.ownerDocument.removeEventListener("mouseup",g),this.dispatchEvent({type:"controlend"}))};this.lockPointer=()=>{!this._enabled||!this._domElement||(this.cancel(),this._lockedPointer={pointerId:-1,clientX:0,clientY:0,deltaX:0,deltaY:0,mouseButton:null},this._activePointers.push(this._lockedPointer),this._domElement.ownerDocument.removeEventListener("pointermove",m,{passive:!1}),this._domElement.ownerDocument.removeEventListener("pointerup",C),this._domElement.requestPointerLock(),this._domElement.ownerDocument.addEventListener("pointerlockchange",z),this._domElement.ownerDocument.addEventListener("pointerlockerror",M),this._domElement.ownerDocument.addEventListener("pointermove",m,{passive:!1}),this._domElement.ownerDocument.addEventListener("pointerup",C),v())},this.unlockPointer=()=>{this._lockedPointer!==null&&(this._disposePointer(this._lockedPointer),this._lockedPointer=null),document.exitPointerLock(),this.cancel(),this._domElement&&(this._domElement.ownerDocument.removeEventListener("pointerlockchange",z),this._domElement.ownerDocument.removeEventListener("pointerlockerror",M))};const z=()=>{this._domElement&&this._domElement.ownerDocument.pointerLockElement===this._domElement||this.unlockPointer()},M=()=>{this.unlockPointer()};this._addAllEventListeners=o=>{this._domElement=o,this._domElement.style.touchAction="none",this._domElement.style.userSelect="none",this._domElement.style.webkitUserSelect="none",this._domElement.addEventListener("pointerdown",a),me&&this._domElement.addEventListener("mousedown",c),this._domElement.addEventListener("pointercancel",C),this._domElement.addEventListener("wheel",E,{passive:!1}),this._domElement.addEventListener("contextmenu",A)},this._removeAllEventListeners=()=>{this._domElement&&(this._domElement.style.touchAction="",this._domElement.style.userSelect="",this._domElement.style.webkitUserSelect="",this._domElement.removeEventListener("pointerdown",a),this._domElement.removeEventListener("mousedown",c),this._domElement.removeEventListener("pointercancel",C),this._domElement.removeEventListener("wheel",E,{passive:!1}),this._domElement.removeEventListener("contextmenu",A),this._domElement.ownerDocument.removeEventListener("pointermove",m,{passive:!1}),this._domElement.ownerDocument.removeEventListener("mousemove",u),this._domElement.ownerDocument.removeEventListener("pointerup",C),this._domElement.ownerDocument.removeEventListener("mouseup",g),this._domElement.ownerDocument.removeEventListener("pointerlockchange",z),this._domElement.ownerDocument.removeEventListener("pointerlockerror",M))},this.cancel=()=>{this._state!==i.NONE&&(this._state=i.NONE,this._activePointers.length=0,F())},t&&this.connect(t),this.update(0)}get camera(){return this._camera}set camera(e){this._camera=e,this.updateCameraUp(),this._camera.updateProjectionMatrix(),this._updateNearPlaneCorners(),this._needsUpdate=!0}get enabled(){return this._enabled}set enabled(e){this._enabled=e,this._domElement&&(e?(this._domElement.style.touchAction="none",this._domElement.style.userSelect="none",this._domElement.style.webkitUserSelect="none"):(this.cancel(),this._domElement.style.touchAction="",this._domElement.style.userSelect="",this._domElement.style.webkitUserSelect=""))}get active(){return!this._hasRested}get currentAction(){return this._state}get distance(){return this._spherical.radius}set distance(e){this._spherical.radius===e&&this._sphericalEnd.radius===e||(this._spherical.radius=e,this._sphericalEnd.radius=e,this._needsUpdate=!0)}get azimuthAngle(){return this._spherical.theta}set azimuthAngle(e){this._spherical.theta===e&&this._sphericalEnd.theta===e||(this._spherical.theta=e,this._sphericalEnd.theta=e,this._needsUpdate=!0)}get polarAngle(){return this._spherical.phi}set polarAngle(e){this._spherical.phi===e&&this._sphericalEnd.phi===e||(this._spherical.phi=e,this._sphericalEnd.phi=e,this._needsUpdate=!0)}get boundaryEnclosesCamera(){return this._boundaryEnclosesCamera}set boundaryEnclosesCamera(e){this._boundaryEnclosesCamera=e,this._needsUpdate=!0}set interactiveArea(e){this._interactiveArea.width=k(e.width,0,1),this._interactiveArea.height=k(e.height,0,1),this._interactiveArea.x=k(e.x,0,1-this._interactiveArea.width),this._interactiveArea.y=k(e.y,0,1-this._interactiveArea.height)}addEventListener(e,t){super.addEventListener(e,t)}removeEventListener(e,t){super.removeEventListener(e,t)}rotate(e,t,s=!1){return this.rotateTo(this._sphericalEnd.theta+e,this._sphericalEnd.phi+t,s)}rotateAzimuthTo(e,t=!1){return this.rotateTo(e,this._sphericalEnd.phi,t)}rotatePolarTo(e,t=!1){return this.rotateTo(this._sphericalEnd.theta,e,t)}rotateTo(e,t,s=!1){this._isUserControllingRotate=!1;const r=k(e,this.minAzimuthAngle,this.maxAzimuthAngle),n=k(t,this.minPolarAngle,this.maxPolarAngle);this._sphericalEnd.theta=r,this._sphericalEnd.phi=n,this._sphericalEnd.makeSafe(),this._needsUpdate=!0,s||(this._spherical.theta=this._sphericalEnd.theta,this._spherical.phi=this._sphericalEnd.phi);const a=!s||x(this._spherical.theta,this._sphericalEnd.theta,this.restThreshold)&&x(this._spherical.phi,this._sphericalEnd.phi,this.restThreshold);return this._createOnRestPromise(a)}dolly(e,t=!1){return this.dollyTo(this._sphericalEnd.radius-e,t)}dollyTo(e,t=!1){return this._isUserControllingDolly=!1,this._lastDollyDirection=W.NONE,this._changedDolly=0,this._dollyToNoClamp(k(e,this.minDistance,this.maxDistance),t)}_dollyToNoClamp(e,t=!1){const s=this._sphericalEnd.radius;if(this.colliderMeshes.length>=1){const a=this._collisionTest(),c=x(a,this._spherical.radius);if(!(s>e)&&c)return Promise.resolve();this._sphericalEnd.radius=Math.min(e,a)}else this._sphericalEnd.radius=e;this._needsUpdate=!0,t||(this._spherical.radius=this._sphericalEnd.radius);const n=!t||x(this._spherical.radius,this._sphericalEnd.radius,this.restThreshold);return this._createOnRestPromise(n)}dollyInFixed(e,t=!1){this._targetEnd.add(this._getCameraDirection(J).multiplyScalar(e)),t||this._target.copy(this._targetEnd);const s=!t||x(this._target.x,this._targetEnd.x,this.restThreshold)&&x(this._target.y,this._targetEnd.y,this.restThreshold)&&x(this._target.z,this._targetEnd.z,this.restThreshold);return this._createOnRestPromise(s)}zoom(e,t=!1){return this.zoomTo(this._zoomEnd+e,t)}zoomTo(e,t=!1){this._isUserControllingZoom=!1,this._zoomEnd=k(e,this.minZoom,this.maxZoom),this._needsUpdate=!0,t||(this._zoom=this._zoomEnd);const s=!t||x(this._zoom,this._zoomEnd,this.restThreshold);return this._changedZoom=0,this._createOnRestPromise(s)}pan(e,t,s=!1){return console.warn("`pan` has been renamed to `truck`"),this.truck(e,t,s)}truck(e,t,s=!1){this._camera.updateMatrix(),Y.setFromMatrixColumn(this._camera.matrix,0),Z.setFromMatrixColumn(this._camera.matrix,1),Y.multiplyScalar(e),Z.multiplyScalar(-t);const r=y.copy(Y).add(Z),n=w.copy(this._targetEnd).add(r);return this.moveTo(n.x,n.y,n.z,s)}forward(e,t=!1){y.setFromMatrixColumn(this._camera.matrix,0),y.crossVectors(this._camera.up,y),y.multiplyScalar(e);const s=w.copy(this._targetEnd).add(y);return this.moveTo(s.x,s.y,s.z,t)}elevate(e,t=!1){return y.copy(this._camera.up).multiplyScalar(e),this.moveTo(this._targetEnd.x+y.x,this._targetEnd.y+y.y,this._targetEnd.z+y.z,t)}moveTo(e,t,s,r=!1){this._isUserControllingTruck=!1;const n=y.set(e,t,s).sub(this._targetEnd);this._encloseToBoundary(this._targetEnd,n,this.boundaryFriction),this._needsUpdate=!0,r||this._target.copy(this._targetEnd);const a=!r||x(this._target.x,this._targetEnd.x,this.restThreshold)&&x(this._target.y,this._targetEnd.y,this.restThreshold)&&x(this._target.z,this._targetEnd.z,this.restThreshold);return this._createOnRestPromise(a)}lookInDirectionOf(e,t,s,r=!1){const c=y.set(e,t,s).sub(this._targetEnd).normalize().multiplyScalar(-this._sphericalEnd.radius);return this.setPosition(c.x,c.y,c.z,r)}fitToBox(e,t,{cover:s=!1,paddingLeft:r=0,paddingRight:n=0,paddingBottom:a=0,paddingTop:c=0}={}){const m=[],u=e.isBox3?G.copy(e):G.setFromObject(e);u.isEmpty()&&(console.warn("camera-controls: fitTo() cannot be used with an empty box. Aborting"),Promise.resolve());const C=Dt(this._sphericalEnd.theta,Ut),g=Dt(this._sphericalEnd.phi,Ut);m.push(this.rotateTo(C,g,t));const D=y.setFromSpherical(this._sphericalEnd).normalize(),E=Pt.setFromUnitVectors(D,ft),A=x(Math.abs(D.y),1);A&&E.multiply(Et.setFromAxisAngle(at,C)),E.multiply(this._yAxisUpSpaceInverse);const v=St.makeEmpty();w.copy(u.min).applyQuaternion(E),v.expandByPoint(w),w.copy(u.min).setX(u.max.x).applyQuaternion(E),v.expandByPoint(w),w.copy(u.min).setY(u.max.y).applyQuaternion(E),v.expandByPoint(w),w.copy(u.max).setZ(u.min.z).applyQuaternion(E),v.expandByPoint(w),w.copy(u.min).setZ(u.max.z).applyQuaternion(E),v.expandByPoint(w),w.copy(u.max).setY(u.min.y).applyQuaternion(E),v.expandByPoint(w),w.copy(u.max).setX(u.min.x).applyQuaternion(E),v.expandByPoint(w),w.copy(u.max).applyQuaternion(E),v.expandByPoint(w),v.min.x-=r,v.min.y-=a,v.max.x+=n,v.max.y+=c,E.setFromUnitVectors(ft,D),A&&E.premultiply(Et.invert()),E.premultiply(this._yAxisUpSpace);const P=v.getSize(y),F=v.getCenter(w).applyQuaternion(E);if(V(this._camera)){const z=this.getDistanceToFitBox(P.x,P.y,P.z,s);m.push(this.moveTo(F.x,F.y,F.z,t)),m.push(this.dollyTo(z,t)),m.push(this.setFocalOffset(0,0,0,t))}else if(B(this._camera)){const z=this._camera,M=z.right-z.left,o=z.top-z.bottom,d=s?Math.max(M/P.x,o/P.y):Math.min(M/P.x,o/P.y);m.push(this.moveTo(F.x,F.y,F.z,t)),m.push(this.zoomTo(d,t)),m.push(this.setFocalOffset(0,0,0,t))}return Promise.all(m)}fitToSphere(e,t){const s=[],n=e instanceof _.Sphere?gt.copy(e):st.createBoundingSphere(e,gt);if(s.push(this.moveTo(n.center.x,n.center.y,n.center.z,t)),V(this._camera)){const a=this.getDistanceToFitSphere(n.radius);s.push(this.dollyTo(a,t))}else if(B(this._camera)){const a=this._camera.right-this._camera.left,c=this._camera.top-this._camera.bottom,m=2*n.radius,u=Math.min(a/m,c/m);s.push(this.zoomTo(u,t))}return s.push(this.setFocalOffset(0,0,0,t)),Promise.all(s)}setLookAt(e,t,s,r,n,a,c=!1){this._isUserControllingRotate=!1,this._isUserControllingDolly=!1,this._isUserControllingTruck=!1,this._lastDollyDirection=W.NONE,this._changedDolly=0;const m=w.set(r,n,a),u=y.set(e,t,s);this._targetEnd.copy(m),this._sphericalEnd.setFromVector3(u.sub(m).applyQuaternion(this._yAxisUpSpace)),this.normalizeRotations(),this._needsUpdate=!0,c||(this._target.copy(this._targetEnd),this._spherical.copy(this._sphericalEnd));const C=!c||x(this._target.x,this._targetEnd.x,this.restThreshold)&&x(this._target.y,this._targetEnd.y,this.restThreshold)&&x(this._target.z,this._targetEnd.z,this.restThreshold)&&x(this._spherical.theta,this._sphericalEnd.theta,this.restThreshold)&&x(this._spherical.phi,this._sphericalEnd.phi,this.restThreshold)&&x(this._spherical.radius,this._sphericalEnd.radius,this.restThreshold);return this._createOnRestPromise(C)}lerpLookAt(e,t,s,r,n,a,c,m,u,C,g,D,E,A=!1){this._isUserControllingRotate=!1,this._isUserControllingDolly=!1,this._isUserControllingTruck=!1,this._lastDollyDirection=W.NONE,this._changedDolly=0;const v=y.set(r,n,a),P=w.set(e,t,s);H.setFromVector3(P.sub(v).applyQuaternion(this._yAxisUpSpace));const F=K.set(C,g,D),z=w.set(c,m,u);$.setFromVector3(z.sub(F).applyQuaternion(this._yAxisUpSpace)),this._targetEnd.copy(v.lerp(F,E));const M=$.theta-H.theta,o=$.phi-H.phi,d=$.radius-H.radius;this._sphericalEnd.set(H.radius+d*E,H.phi+o*E,H.theta+M*E),this.normalizeRotations(),this._needsUpdate=!0,A||(this._target.copy(this._targetEnd),this._spherical.copy(this._sphericalEnd));const T=!A||x(this._target.x,this._targetEnd.x,this.restThreshold)&&x(this._target.y,this._targetEnd.y,this.restThreshold)&&x(this._target.z,this._targetEnd.z,this.restThreshold)&&x(this._spherical.theta,this._sphericalEnd.theta,this.restThreshold)&&x(this._spherical.phi,this._sphericalEnd.phi,this.restThreshold)&&x(this._spherical.radius,this._sphericalEnd.radius,this.restThreshold);return this._createOnRestPromise(T)}setPosition(e,t,s,r=!1){return this.setLookAt(e,t,s,this._targetEnd.x,this._targetEnd.y,this._targetEnd.z,r)}setTarget(e,t,s,r=!1){const n=this.getPosition(y),a=this.setLookAt(n.x,n.y,n.z,e,t,s,r);return this._sphericalEnd.phi=k(this._sphericalEnd.phi,this.minPolarAngle,this.maxPolarAngle),a}setFocalOffset(e,t,s,r=!1){this._isUserControllingOffset=!1,this._focalOffsetEnd.set(e,t,s),this._needsUpdate=!0,r||this._focalOffset.copy(this._focalOffsetEnd);const n=!r||x(this._focalOffset.x,this._focalOffsetEnd.x,this.restThreshold)&&x(this._focalOffset.y,this._focalOffsetEnd.y,this.restThreshold)&&x(this._focalOffset.z,this._focalOffsetEnd.z,this.restThreshold);return this._createOnRestPromise(n)}setOrbitPoint(e,t,s){this._camera.updateMatrixWorld(),Y.setFromMatrixColumn(this._camera.matrixWorldInverse,0),Z.setFromMatrixColumn(this._camera.matrixWorldInverse,1),N.setFromMatrixColumn(this._camera.matrixWorldInverse,2);const r=y.set(e,t,s),n=r.distanceTo(this._camera.position),a=r.sub(this._camera.position);Y.multiplyScalar(a.x),Z.multiplyScalar(a.y),N.multiplyScalar(a.z),y.copy(Y).add(Z).add(N),y.z=y.z+n,this.dollyTo(n,!1),this.setFocalOffset(-y.x,y.y,-y.z,!1),this.moveTo(e,t,s,!1)}setBoundary(e){if(!e){this._boundary.min.set(-1/0,-1/0,-1/0),this._boundary.max.set(1/0,1/0,1/0),this._needsUpdate=!0;return}this._boundary.copy(e),this._boundary.clampPoint(this._targetEnd,this._targetEnd),this._needsUpdate=!0}setViewport(e,t,s,r){if(e===null){this._viewport=null;return}this._viewport=this._viewport||new _.Vector4,typeof e=="number"?this._viewport.set(e,t,s,r):this._viewport.copy(e)}getDistanceToFitBox(e,t,s,r=!1){if(ut(this._camera,"getDistanceToFitBox"))return this._spherical.radius;const n=e/t,a=this._camera.getEffectiveFOV()*Q,c=this._camera.aspect;return((r?n>c:n<c)?t:e/c)*.5/Math.tan(a*.5)+s*.5}getDistanceToFitSphere(e){if(ut(this._camera,"getDistanceToFitSphere"))return this._spherical.radius;const t=this._camera.getEffectiveFOV()*Q,s=Math.atan(Math.tan(t*.5)*this._camera.aspect)*2,r=1<this._camera.aspect?t:s;return e/Math.sin(r*.5)}getTarget(e,t=!0){return(e&&e.isVector3?e:new _.Vector3).copy(t?this._targetEnd:this._target)}getPosition(e,t=!0){return(e&&e.isVector3?e:new _.Vector3).setFromSpherical(t?this._sphericalEnd:this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(t?this._targetEnd:this._target)}getSpherical(e,t=!0){return(e&&e instanceof _.Spherical?e:new _.Spherical).copy(t?this._sphericalEnd:this._spherical)}getFocalOffset(e,t=!0){return(e&&e.isVector3?e:new _.Vector3).copy(t?this._focalOffsetEnd:this._focalOffset)}normalizeRotations(){this._sphericalEnd.theta=this._sphericalEnd.theta%X,this._sphericalEnd.theta<0&&(this._sphericalEnd.theta+=X),this._spherical.theta+=X*Math.round((this._sphericalEnd.theta-this._spherical.theta)/X)}reset(e=!1){if(!x(this._camera.up.x,this._cameraUp0.x)||!x(this._camera.up.y,this._cameraUp0.y)||!x(this._camera.up.z,this._cameraUp0.z)){this._camera.up.copy(this._cameraUp0);const s=this.getPosition(y);this.updateCameraUp(),this.setPosition(s.x,s.y,s.z)}const t=[this.setLookAt(this._position0.x,this._position0.y,this._position0.z,this._target0.x,this._target0.y,this._target0.z,e),this.setFocalOffset(this._focalOffset0.x,this._focalOffset0.y,this._focalOffset0.z,e),this.zoomTo(this._zoom0,e)];return Promise.all(t)}saveState(){this._cameraUp0.copy(this._camera.up),this.getTarget(this._target0),this.getPosition(this._position0),this._zoom0=this._zoom,this._focalOffset0.copy(this._focalOffset)}updateCameraUp(){this._yAxisUpSpace.setFromUnitVectors(this._camera.up,at),this._yAxisUpSpaceInverse.copy(this._yAxisUpSpace).invert()}applyCameraUp(){const e=y.subVectors(this._target,this._camera.position).normalize(),t=w.crossVectors(e,this._camera.up);this._camera.up.crossVectors(t,e).normalize(),this._camera.updateMatrixWorld();const s=this.getPosition(y);this.updateCameraUp(),this.setPosition(s.x,s.y,s.z)}update(e){const t=this._sphericalEnd.theta-this._spherical.theta,s=this._sphericalEnd.phi-this._spherical.phi,r=this._sphericalEnd.radius-this._spherical.radius,n=At.subVectors(this._targetEnd,this._target),a=zt.subVectors(this._focalOffsetEnd,this._focalOffset),c=this._zoomEnd-this._zoom;if(L(t))this._thetaVelocity.value=0,this._spherical.theta=this._sphericalEnd.theta;else{const g=this._isUserControllingRotate?this.draggingSmoothTime:this.smoothTime;this._spherical.theta=rt(this._spherical.theta,this._sphericalEnd.theta,this._thetaVelocity,g,1/0,e),this._needsUpdate=!0}if(L(s))this._phiVelocity.value=0,this._spherical.phi=this._sphericalEnd.phi;else{const g=this._isUserControllingRotate?this.draggingSmoothTime:this.smoothTime;this._spherical.phi=rt(this._spherical.phi,this._sphericalEnd.phi,this._phiVelocity,g,1/0,e),this._needsUpdate=!0}if(L(r))this._radiusVelocity.value=0,this._spherical.radius=this._sphericalEnd.radius;else{const g=this._isUserControllingDolly?this.draggingSmoothTime:this.smoothTime;this._spherical.radius=rt(this._spherical.radius,this._sphericalEnd.radius,this._radiusVelocity,g,this.maxSpeed,e),this._needsUpdate=!0}if(L(n.x)&&L(n.y)&&L(n.z))this._targetVelocity.set(0,0,0),this._target.copy(this._targetEnd);else{const g=this._isUserControllingTruck?this.draggingSmoothTime:this.smoothTime;xt(this._target,this._targetEnd,this._targetVelocity,g,this.maxSpeed,e,this._target),this._needsUpdate=!0}if(L(a.x)&&L(a.y)&&L(a.z))this._focalOffsetVelocity.set(0,0,0),this._focalOffset.copy(this._focalOffsetEnd);else{const g=this._isUserControllingOffset?this.draggingSmoothTime:this.smoothTime;xt(this._focalOffset,this._focalOffsetEnd,this._focalOffsetVelocity,g,this.maxSpeed,e,this._focalOffset),this._needsUpdate=!0}if(L(c))this._zoomVelocity.value=0,this._zoom=this._zoomEnd;else{const g=this._isUserControllingZoom?this.draggingSmoothTime:this.smoothTime;this._zoom=rt(this._zoom,this._zoomEnd,this._zoomVelocity,g,1/0,e)}if(this.dollyToCursor){if(V(this._camera)&&this._changedDolly!==0){const g=this._spherical.radius-this._lastDistance,D=this._camera,E=this._getCameraDirection(J),A=y.copy(E).cross(D.up).normalize();A.lengthSq()===0&&(A.x=1);const v=w.crossVectors(A,E),P=this._sphericalEnd.radius*Math.tan(D.getEffectiveFOV()*Q*.5),z=(this._sphericalEnd.radius-g-this._sphericalEnd.radius)/this._sphericalEnd.radius,M=K.copy(this._targetEnd).add(A.multiplyScalar(this._dollyControlCoord.x*P*D.aspect)).add(v.multiplyScalar(this._dollyControlCoord.y*P)),o=y.copy(this._targetEnd).lerp(M,z),d=this._lastDollyDirection===W.IN&&this._spherical.radius<=this.minDistance,T=this._lastDollyDirection===W.OUT&&this.maxDistance<=this._spherical.radius;if(this.infinityDolly&&(d||T)){this._sphericalEnd.radius-=g,this._spherical.radius-=g;const U=w.copy(E).multiplyScalar(-g);o.add(U)}this._boundary.clampPoint(o,o);const f=w.subVectors(o,this._targetEnd);this._targetEnd.copy(o),this._target.add(f),this._changedDolly-=g,L(this._changedDolly)&&(this._changedDolly=0)}else if(B(this._camera)&&this._changedZoom!==0){const g=this._zoom-this._lastZoom,D=this._camera,E=y.set(this._dollyControlCoord.x,this._dollyControlCoord.y,(D.near+D.far)/(D.near-D.far)).unproject(D),A=w.set(0,0,-1).applyQuaternion(D.quaternion),v=K.copy(E).add(A.multiplyScalar(-E.dot(D.up))),F=-(this._zoom-g-this._zoom)/this._zoom,z=this._getCameraDirection(J),M=this._targetEnd.dot(z),o=y.copy(this._targetEnd).lerp(v,F),d=o.dot(z),T=z.multiplyScalar(d-M);o.sub(T),this._boundary.clampPoint(o,o);const f=w.subVectors(o,this._targetEnd);this._targetEnd.copy(o),this._target.add(f),this._changedZoom-=g,L(this._changedZoom)&&(this._changedZoom=0)}}this._camera.zoom!==this._zoom&&(this._camera.zoom=this._zoom,this._camera.updateProjectionMatrix(),this._updateNearPlaneCorners(),this._needsUpdate=!0),this._dragNeedsUpdate=!0;const m=this._collisionTest();this._spherical.radius=Math.min(this._spherical.radius,m),this._spherical.makeSafe(),this._camera.position.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(this._target),this._camera.lookAt(this._target),(!L(this._focalOffset.x)||!L(this._focalOffset.y)||!L(this._focalOffset.z))&&(this._camera.updateMatrixWorld(),Y.setFromMatrixColumn(this._camera.matrix,0),Z.setFromMatrixColumn(this._camera.matrix,1),N.setFromMatrixColumn(this._camera.matrix,2),Y.multiplyScalar(this._focalOffset.x),Z.multiplyScalar(-this._focalOffset.y),N.multiplyScalar(this._focalOffset.z),y.copy(Y).add(Z).add(N),this._camera.position.add(y)),this._boundaryEnclosesCamera&&this._encloseToBoundary(this._camera.position.copy(this._target),y.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse),1);const C=this._needsUpdate;return C&&!this._updatedLastTime?(this._hasRested=!1,this.dispatchEvent({type:"wake"}),this.dispatchEvent({type:"update"})):C?(this.dispatchEvent({type:"update"}),L(t,this.restThreshold)&&L(s,this.restThreshold)&&L(r,this.restThreshold)&&L(n.x,this.restThreshold)&&L(n.y,this.restThreshold)&&L(n.z,this.restThreshold)&&L(a.x,this.restThreshold)&&L(a.y,this.restThreshold)&&L(a.z,this.restThreshold)&&L(c,this.restThreshold)&&!this._hasRested&&(this._hasRested=!0,this.dispatchEvent({type:"rest"}))):!C&&this._updatedLastTime&&this.dispatchEvent({type:"sleep"}),this._lastDistance=this._spherical.radius,this._lastZoom=this._zoom,this._updatedLastTime=C,this._needsUpdate=!1,C}toJSON(){return JSON.stringify({enabled:this._enabled,minDistance:this.minDistance,maxDistance:q(this.maxDistance),minZoom:this.minZoom,maxZoom:q(this.maxZoom),minPolarAngle:this.minPolarAngle,maxPolarAngle:q(this.maxPolarAngle),minAzimuthAngle:q(this.minAzimuthAngle),maxAzimuthAngle:q(this.maxAzimuthAngle),smoothTime:this.smoothTime,draggingSmoothTime:this.draggingSmoothTime,dollySpeed:this.dollySpeed,truckSpeed:this.truckSpeed,dollyToCursor:this.dollyToCursor,verticalDragToForward:this.verticalDragToForward,target:this._targetEnd.toArray(),position:y.setFromSpherical(this._sphericalEnd).add(this._targetEnd).toArray(),zoom:this._zoomEnd,focalOffset:this._focalOffsetEnd.toArray(),target0:this._target0.toArray(),position0:this._position0.toArray(),zoom0:this._zoom0,focalOffset0:this._focalOffset0.toArray()})}fromJSON(e,t=!1){const s=JSON.parse(e);this.enabled=s.enabled,this.minDistance=s.minDistance,this.maxDistance=j(s.maxDistance),this.minZoom=s.minZoom,this.maxZoom=j(s.maxZoom),this.minPolarAngle=s.minPolarAngle,this.maxPolarAngle=j(s.maxPolarAngle),this.minAzimuthAngle=j(s.minAzimuthAngle),this.maxAzimuthAngle=j(s.maxAzimuthAngle),this.smoothTime=s.smoothTime,this.draggingSmoothTime=s.draggingSmoothTime,this.dollySpeed=s.dollySpeed,this.truckSpeed=s.truckSpeed,this.dollyToCursor=s.dollyToCursor,this.verticalDragToForward=s.verticalDragToForward,this._target0.fromArray(s.target0),this._position0.fromArray(s.position0),this._zoom0=s.zoom0,this._focalOffset0.fromArray(s.focalOffset0),this.moveTo(s.target[0],s.target[1],s.target[2],t),H.setFromVector3(y.fromArray(s.position).sub(this._targetEnd).applyQuaternion(this._yAxisUpSpace)),this.rotateTo(H.theta,H.phi,t),this.dollyTo(H.radius,t),this.zoomTo(s.zoom,t),this.setFocalOffset(s.focalOffset[0],s.focalOffset[1],s.focalOffset[2],t),this._needsUpdate=!0}connect(e){if(this._domElement){console.warn("camera-controls is already connected.");return}e.setAttribute("data-camera-controls-version",de),this._addAllEventListeners(e),this._getClientRect(this._elementRect)}disconnect(){this.cancel(),this._removeAllEventListeners(),this._domElement&&(this._domElement.removeAttribute("data-camera-controls-version"),this._domElement=void 0)}dispose(){this.removeAllEventListeners(),this.disconnect()}_getTargetDirection(e){return e.setFromSpherical(this._spherical).divideScalar(this._spherical.radius).applyQuaternion(this._yAxisUpSpaceInverse)}_getCameraDirection(e){return this._getTargetDirection(e).negate()}_findPointerById(e){return this._activePointers.find(t=>t.pointerId===e)}_findPointerByMouseButton(e){return this._activePointers.find(t=>t.mouseButton===e)}_disposePointer(e){this._activePointers.splice(this._activePointers.indexOf(e),1)}_encloseToBoundary(e,t,s){const r=t.lengthSq();if(r===0)return e;const n=w.copy(t).add(e),c=this._boundary.clampPoint(n,K).sub(n),m=c.lengthSq();if(m===0)return e.add(t);if(m===r)return e;if(s===0)return e.add(t).add(c);{const u=1+s*m/t.dot(c);return e.add(w.copy(t).multiplyScalar(u)).add(c.multiplyScalar(1-s))}}_updateNearPlaneCorners(){if(V(this._camera)){const e=this._camera,t=e.near,s=e.getEffectiveFOV()*Q,r=Math.tan(s*.5)*t,n=r*e.aspect;this._nearPlaneCorners[0].set(-n,-r,0),this._nearPlaneCorners[1].set(n,-r,0),this._nearPlaneCorners[2].set(n,r,0),this._nearPlaneCorners[3].set(-n,r,0)}else if(B(this._camera)){const e=this._camera,t=1/e.zoom,s=e.left*t,r=e.right*t,n=e.top*t,a=e.bottom*t;this._nearPlaneCorners[0].set(s,n,0),this._nearPlaneCorners[1].set(r,n,0),this._nearPlaneCorners[2].set(r,a,0),this._nearPlaneCorners[3].set(s,a,0)}}_collisionTest(){let e=1/0;if(!(this.colliderMeshes.length>=1)||ut(this._camera,"_collisionTest"))return e;const s=this._getTargetDirection(J);yt.lookAt(Lt,s,this._camera.up);for(let r=0;r<4;r++){const n=w.copy(this._nearPlaneCorners[r]);n.applyMatrix4(yt);const a=K.addVectors(this._target,n);ht.set(a,s),ht.far=this._spherical.radius+1;const c=ht.intersectObjects(this.colliderMeshes);c.length!==0&&c[0].distance<e&&(e=c[0].distance)}return e}_getClientRect(e){if(!this._domElement)return;const t=this._domElement.getBoundingClientRect();return e.x=t.left,e.y=t.top,this._viewport?(e.x+=this._viewport.x,e.y+=t.height-this._viewport.w-this._viewport.y,e.width=this._viewport.z,e.height=this._viewport.w):(e.width=t.width,e.height=t.height),e}_createOnRestPromise(e){return e?Promise.resolve():(this._hasRested=!1,this.dispatchEvent({type:"transitionstart"}),new Promise(t=>{const s=()=>{this.removeEventListener("rest",s),t()};this.addEventListener("rest",s)}))}_addAllEventListeners(e){}_removeAllEventListeners(){}get dampingFactor(){return console.warn(".dampingFactor has been deprecated. use smoothTime (in seconds) instead."),0}set dampingFactor(e){console.warn(".dampingFactor has been deprecated. use smoothTime (in seconds) instead.")}get draggingDampingFactor(){return console.warn(".draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead."),0}set draggingDampingFactor(e){console.warn(".draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead.")}static createBoundingSphere(e,t=new _.Sphere){const s=t,r=s.center;G.makeEmpty(),e.traverseVisible(a=>{a.isMesh&&G.expandByObject(a)}),G.getCenter(r);let n=0;return e.traverseVisible(a=>{if(!a.isMesh)return;const c=a,m=c.geometry.clone();m.applyMatrix4(c.matrixWorld);const C=m.attributes.position;for(let g=0,D=C.count;g<D;g++)y.fromBufferAttribute(C,g),n=Math.max(n,r.distanceToSquared(y))}),s.radius=Math.sqrt(n),s}}class ct extends ne{constructor(t){super(t);h(this,"onBeforeUpdate",new S);h(this,"onAfterUpdate",new S);h(this,"onAspectUpdated",new S);h(this,"onDisposed",new S);h(this,"three");h(this,"_allControls",new Map);h(this,"updateAspect",()=>{var t;if(!(!this.currentWorld||!this.currentWorld.renderer)){if(this.three instanceof Nt){this.onAspectUpdated.trigger();return}if((t=this.currentWorld.renderer)!=null&&t.isResizeable()){const s=this.currentWorld.renderer.getSize();this.three.aspect=s.width/s.height,this.three.updateProjectionMatrix(),this.onAspectUpdated.trigger()}}});this.three=this.setupCamera(),this.setupEvents(!0),this.onWorldChanged.add(({action:s,world:r})=>{if(s==="added"){const n=this.newCameraControls();this._allControls.set(r.uuid,n)}if(s==="removed"){const n=this._allControls.get(r.uuid);n&&(n.dispose(),this._allControls.delete(r.uuid))}})}get controls(){if(!this.currentWorld)throw new Error("This camera needs a world to work!");const t=this._allControls.get(this.currentWorld.uuid);if(!t)throw new Error("Controls not found!");return t}get enabled(){return this.currentWorld===null?!1:this.controls.enabled}set enabled(t){this.controls.enabled=t}dispose(){this.setupEvents(!1),this.onAspectUpdated.reset(),this.onBeforeUpdate.reset(),this.onAfterUpdate.reset(),this.three.removeFromParent(),this.onDisposed.trigger(),this.onDisposed.reset();for(const[t,s]of this._allControls)s.dispose()}update(t){this.enabled&&(this.onBeforeUpdate.trigger(this),this.controls.update(t),this.onAfterUpdate.trigger(this))}setupCamera(){const t=window.innerWidth/window.innerHeight,s=new Wt(60,t,1,1e3);return s.position.set(50,50,50),s.lookAt(new Tt(0,0,0)),s}newCameraControls(){if(!this.currentWorld)throw new Error("This camera needs a world to work!");if(!this.currentWorld.renderer)throw new Error("This camera needs a renderer to work!");st.install({THREE:ct.getSubsetOfThree()});const{domElement:t}=this.currentWorld.renderer.three,s=new st(this.three,t);return s.smoothTime=.2,s.dollyToCursor=!0,s.infinityDolly=!0,s}setupEvents(t){t?window.addEventListener("resize",this.updateAspect):window.removeEventListener("resize",this.updateAspect)}static getSubsetOfThree(){return{MOUSE:Xt,Vector2:Ot,Vector3:Tt,Vector4:Kt,Quaternion:Gt,Matrix4:Qt,Spherical:qt,Box3:jt,Sphere:Jt,Raycaster:$t,MathUtils:te}}}const dt=class dt extends Ct{constructor(t){super(t);h(this,"onAfterUpdate",new S);h(this,"onBeforeUpdate",new S);h(this,"onDisposed",new S);h(this,"onWorldCreated",new S);h(this,"onWorldDeleted",new S);h(this,"list",new Map);h(this,"enabled",!0);t.add(dt.uuid,this)}create(){const t=new le(this.components),s=t.uuid;if(this.list.has(s))throw new Error("There is already a world with this name!");return this.list.set(s,t),this.onWorldCreated.trigger(t),t}delete(t){const s=t.uuid;this.list.delete(t.uuid),t.dispose(),this.onWorldDeleted.trigger(s)}dispose(){this.enabled=!1;for(const[t,s]of this.list)s.dispose();this.list.clear(),this.onDisposed.trigger()}update(t){if(this.enabled)for(const[s,r]of this.list)r.update(t)}};h(dt,"uuid","fdb61dc4-2ec1-4966-b83d-54ea795fad4a");let Ft=dt;class pe{constructor(e,t,s){h(this,"onDisposed",new S);h(this,"world");h(this,"components");h(this,"three");h(this,"_fade",3);h(this,"updateZoom",()=>{this.world.camera instanceof ct&&(this.material.uniforms.uZoom.value=this.world.camera.three.zoom)});this.world=t;const{color:r,size1:n,size2:a,distance:c}=s;this.components=e;const m=new ee(2,2,1,1),u=new se({side:ie,uniforms:{uSize1:{value:n},uSize2:{value:a},uColor:{value:r},uDistance:{value:c},uFade:{value:this._fade},uZoom:{value:1}},transparent:!0,vertexShader:`
            
            varying vec3 worldPosition;
            
            uniform float uDistance;
            
            void main() {
            
                    vec3 pos = position.xzy * uDistance;
                    pos.xz += cameraPosition.xz;
                    
                    worldPosition = pos;
                    
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
            
            }
            `,fragmentShader:`
            
            varying vec3 worldPosition;
            
            uniform float uZoom;
            uniform float uFade;
            uniform float uSize1;
            uniform float uSize2;
            uniform vec3 uColor;
            uniform float uDistance;
                
                
                
                float getGrid(float size) {
                
                    vec2 r = worldPosition.xz / size;
                    
                    
                    vec2 grid = abs(fract(r - 0.5) - 0.5) / fwidth(r);
                    float line = min(grid.x, grid.y);
                    
                
                    return 1.0 - min(line, 1.0);
                }
                
            void main() {
            
                    
                    float d = 1.0 - min(distance(cameraPosition.xz, worldPosition.xz) / uDistance, 1.0);
                    
                    float g1 = getGrid(uSize1);
                    float g2 = getGrid(uSize2);
                    
                    // Ortho camera fades the grid away when zooming out
                    float minZoom = step(0.2, uZoom);
                    float zoomFactor = pow(min(uZoom, 1.), 2.) * minZoom;
                    
                    gl_FragColor = vec4(uColor.rgb, mix(g2, g1, g1) * pow(d, uFade));
                    gl_FragColor.a = mix(0.5 * gl_FragColor.a, gl_FragColor.a, g2) * zoomFactor;
                    
                    if ( gl_FragColor.a <= 0.0 ) discard;
                    
            
            }
            
            `,extensions:{derivatives:!0}});this.three=new oe(m,u),this.three.frustumCulled=!1,t.scene.three.add(this.three),this.setupEvents(!0)}get visible(){return this.three.visible}set visible(e){e?this.world.scene.three.add(this.three):this.three.removeFromParent()}get material(){return this.three.material}get fade(){return this._fade===3}set fade(e){this._fade=e?3:0,this.material.uniforms.uFade.value=this._fade}[Symbol.dispose](){throw new Error("Method not implemented.")}dispose(){this.setupEvents(!1),this.components.get(et).destroy(this.three),this.onDisposed.trigger(),this.onDisposed.reset(),this.world=null,this.components=null}setupEvents(e){if(this.world.isDisposing||!(this.world.camera instanceof ct))return;const t=this.world.camera.controls;e?t.addEventListener("update",this.updateZoom):t.removeEventListener("update",this.updateZoom)}}const _t=class _t extends Ct{constructor(t){super(t);h(this,"list",new Map);h(this,"onDisposed",new S);h(this,"config",{color:new lt(12303291),size1:1,size2:10,distance:500});h(this,"enabled",!0);t.add(_t.uuid,this)}create(t){if(this.list.has(t.uuid))throw new Error("This world already has a grid!");const s=new pe(this.components,t,this.config);return this.list.set(t.uuid,s),t.onDisposed.add(()=>{this.delete(t)}),s}delete(t){const s=this.list.get(t.uuid);s&&s.dispose(),this.list.delete(t.uuid)}dispose(){for(const[t,s]of this.list)s.dispose();this.list.clear(),this.onDisposed.trigger(),this.onDisposed.reset()}};h(_t,"uuid","d1e814d5-b81c-4452-87a2-f039375e0489");let Rt=_t;export{et as D,Rt as G,Ee as S,Ft as W,ye as a,ct as b};
