var y=Object.defineProperty;var A=(d,t,e)=>t in d?y(d,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):d[t]=e;var l=(d,t,e)=>(A(d,typeof t!="symbol"?t+"":t,e),e);import{av as R,f as L,a9 as C,E as I,aj as S,ak as F,L as G,h as D,al as O}from"./unzipit.module-RGQJWpcx.js";import{C as T,A as E}from"./serializer-1xMmy3Qo.js";class U{constructor(){l(this,"factor",1);l(this,"complement",1)}apply(t){const s=this.getScaleMatrix().multiply(t);t.copy(s)}setUp(t){var o;this.factor=1;const e=this.getLengthUnits(t);if(!e)return;const s=e==null,n=e.Name===void 0||e.Name===null;s||n||(e.Name.value==="FOOT"?this.factor=.3048:((o=e.Prefix)==null?void 0:o.value)==="MILLI"&&(this.complement=.001))}getLengthUnits(t){try{const s=t.GetLineIDsWithType(0,R).get(0),n=t.GetLine(0,s);for(const o of n.Units){if(!o||o.value===null||o.value===void 0)continue;const f=t.GetLine(0,o.value);if(f.UnitType&&f.UnitType.value==="LENGTHUNIT")return f}return null}catch{return console.log("Could not get units"),null}}getScaleMatrix(){const t=this.factor;return new L().fromArray([t,0,0,0,0,t,0,0,0,0,t,0,0,0,0,1])}}class j{constructor(){l(this,"itemsByFloor",{});l(this,"_units",new U)}setUp(t){this._units.setUp(t),this.cleanUp();try{const e=t.GetLineIDsWithType(0,C),s=new Set,n=t.GetLineIDsWithType(0,I);for(let r=0;r<n.size();r++)s.add(n.get(r));const o=t.GetLineIDsWithType(0,S),f=o.size();for(let r=0;r<f;r++){const g=o.get(r),i=t.GetLine(0,g);if(!i||!i.RelatingObject||!i.RelatedObjects)continue;const a=i.RelatingObject.value,h=i.RelatedObjects;for(const c of h){const u=c.value;s.has(u)&&(this.itemsByFloor[u]=a)}}const m={},p=e.size();for(let r=0;r<p;r++){const g=e.get(r),i=t.GetLine(0,g);if(!i||!i.RelatingStructure||!i.RelatedElements)continue;const a=i.RelatingStructure.value,h=i.RelatedElements;if(s.has(a))for(const c of h){m[a]||(m[a]=[]);const u=c.value;m[a].push(u)}else for(const c of h){const u=c.value;this.itemsByFloor[u]=a}}for(const r in m){const g=this.itemsByFloor[r];if(g!==void 0){const i=m[r];for(const a of i)this.itemsByFloor[a]=g}}for(let r=0;r<f;r++){const g=o.get(r),i=t.GetLine(0,g);if(!i||!i.RelatingObject||!i.RelatedObjects)continue;const a=i.RelatingObject.value,h=i.RelatedObjects;for(const c of h){const u=c.value,v=this.itemsByFloor[a];v!==void 0&&(this.itemsByFloor[u]=v)}}}catch{console.log("Could not get floors.")}}cleanUp(){this.itemsByFloor={}}}class z{constructor(){l(this,"includeProperties",!0);l(this,"optionalCategories",[I]);l(this,"coordinate",!0);l(this,"wasm",{path:"",absolute:!1,logLevel:F.LOG_LEVEL_OFF});l(this,"excludedCategories",new Set);l(this,"saveLocations",!1);l(this,"webIfc",{COORDINATE_TO_ORIGIN:!0,OPTIMIZE_PROFILES:!0});l(this,"autoSetWasm",!0);l(this,"customLocateFileHandler",null)}}class x{constructor(){l(this,"defLineMat",new G({color:16777215}))}read(t){const e=t.GetAllAlignments(0),s=t.GetAllCrossSections2D(0),n=t.GetAllCrossSections3D(0),o={IfcAlignment:e,IfcCrossSection2D:s,IfcCrossSection3D:n};return this.get(o)}get(t){if(t.IfcAlignment){const e=new Map;for(const s of t.IfcAlignment){const n=new E;n.absolute=this.getCurves(s.curve3D,n),n.horizontal=this.getCurves(s.horizontal,n),n.vertical=this.getCurves(s.vertical,n),e.set(e.size,n)}return{alignments:e,coordinationMatrix:new L}}}getCurves(t,e){const s=[];let n=0;for(const o of t){const f={};if(o.data)for(const a of o.data){const[h,c]=a.split(": "),u=parseFloat(c);f[h]=u||c}const{points:m}=o,p=new Float32Array(m.length*3);for(let a=0;a<m.length;a++){const{x:h,y:c,z:u}=m[a];p[a*3]=h,p[a*3+1]=c,p[a*3+2]=u||0}const r=new D(p,3),g=new O;g.setAttribute("position",r);const i=new T(n,f,e,g,this.defLineMat);s.push(i.curve),n++}return s}}class P{get(t,e){let s="";const n=t.GetHeaderLine(0,e)||"";if(!n)return s;for(const o of n.arguments)if(o!=null)if(Array.isArray(o))for(const f of o)s+=`${f.value}|`;else s+=`${o.value}|`;return s}}export{x as C,z as I,j as S,P as a};
