var Q=Object.defineProperty;var q=(P,m,n)=>m in P?Q(P,m,{enumerable:!0,configurable:!0,writable:!0,value:n}):P[m]=n;var p=(P,m,n)=>(q(P,typeof m!="symbol"?m+"":m,n),n);import{V as d,E as J,h as W,c as f,g as y,L as Z,Q as tt,r as _,q as et}from"./web-ifc-api-eJ7dR4yy.js";import{J as T,U as V,A as nt}from"./import-wrapper-prod-Dt8pgrvp.js";import{a as ot}from"./index-B5ZryrG5.js";import{M as b}from"./index-CcoJVEnC.js";import{M}from"./mark-cmFzwbfb.js";const st=["Station","Radius","Length","InitialKP","FinalKP","KP","Slope","Height","InitialKPV","FinalKPV"],A=class A extends T{constructor(n){super(n);p(this,"enabled",!0);p(this,"world",null);p(this,"list",new Map);p(this,"_markerKey",0);p(this,"type","horizontal");p(this,"divisionLength",100);n.add(A.uuid,this)}addKPStation(n,i,t){const e=this.components.get(b),s=document.createElement("div"),o=document.createElement("div");s.appendChild(o),o.innerHTML=i,o.style.color=e.color,o.style.borderBottom="1px dotted white",o.style.width="160px",o.style.textAlign="left";const a=new M(n,s),r=new d;r.x=t.geometry.attributes.position.getX(t.geometry.attributes.position.count-1),r.y=t.geometry.attributes.position.getY(t.geometry.attributes.position.count-1),r.z=t.geometry.attributes.position.getZ(t.geometry.attributes.position.count-1);const l=new d;l.x=t.geometry.attributes.position.getX(t.geometry.attributes.position.count-2),l.y=t.geometry.attributes.position.getY(t.geometry.attributes.position.count-2),l.z=t.geometry.attributes.position.getZ(t.geometry.attributes.position.count-2);const c=new d;c.x=(r.x+l.x)/2,c.y=(r.y+l.y)/2,c.z=(r.z+l.z)/2,a.three.position.copy(c);const h=new d;h.subVectors(r,l).normalize();const u=new tt;u.setFromUnitVectors(new d(0,1,0),h);const g=new J().setFromQuaternion(u).z,w=W.radToDeg(g);o.style.transform=`rotate(${-w-90}deg) translate(-35%, -50%)`;const v=this._markerKey.toString();e.list.set(v,{label:a,key:v,merged:!1,static:!1}),this._markerKey++,this.save(v,"KP")}addVerticalMarker(n,i,t,e,s){const o=this.components.get(b),a=document.createElement("span");a.innerHTML=i,a.style.color=o.color;const r=new M(n,a,s);if(e==="Height"){const c=document.createElement("span");c.innerHTML=i,c.style.color=o.color;const{position:h}=t.geometry.attributes,g=(h.array.length/3-1)*3,w=h.array.slice(g,g+3);r.three.position.set(w[0],w[1]+10,w[2])}else if(e==="InitialKPV"){const{position:c}=t.geometry.attributes,h=c.getX(0),u=c.getY(0),g=c.getZ(0);r.three.position.set(h-20,u,g)}else if(e==="FinalKPV"){const{position:c}=t.geometry.attributes,h=c.getX(t.geometry.attributes.position.count-1),u=c.getY(t.geometry.attributes.position.count-1),g=c.getZ(t.geometry.attributes.position.count-1);r.three.position.set(h+20,u,g)}else if(e==="Slope"){a.style.color="grey";const{position:c}=t.geometry.attributes,h=new d;h.x=c.getX(0),h.y=c.getY(0),h.z=c.getZ(0);const u=new d;u.x=c.getX(c.count-1),u.y=c.getY(c.count-1),u.z=c.getZ(c.count-1);const g=new d;g.addVectors(h,u).multiplyScalar(.5),r.three.position.set(g.x,g.y-10,g.z)}const l=this._markerKey.toString();return o.list.set(l,{label:r,key:l,type:e,merged:!1,static:!1}),this._markerKey++,this.save(l,e),r}addCivilMarker(n,i,t,e){const s=this.components.get(b),o=document.createElement("span");o.innerHTML=i,o.style.color=s.color;const a=new M(n,o);if(e==="InitialKP"){const l=t.geometry.attributes.position.getX(0),c=t.geometry.attributes.position.getY(0),h=t.geometry.attributes.position.getZ(0);a.three.position.set(l+2,c+2,h)}else if(e==="FinalKP"){const l=t.geometry.attributes.position.getX(t.geometry.attributes.position.count-1),c=t.geometry.attributes.position.getY(t.geometry.attributes.position.count-1),h=t.geometry.attributes.position.getZ(t.geometry.attributes.position.count-1);a.three.position.set(l+2,c-2,h)}else if(e==="Length"){const l=new d;l.x=t.geometry.attributes.position.getX(0),l.y=t.geometry.attributes.position.getY(0),l.z=t.geometry.attributes.position.getZ(0);const c=new d;c.x=t.geometry.attributes.position.getX(t.geometry.attributes.position.count-1),c.y=t.geometry.attributes.position.getY(t.geometry.attributes.position.count-1),c.z=t.geometry.attributes.position.getZ(t.geometry.attributes.position.count-1);const h=l.distanceTo(c);a.three.element.innerText=h.toFixed(2);const u=c.clone().add(l).divideScalar(2);a.three.position.copy(u)}const r=this._markerKey.toString();return s.list.set(r,{label:a,key:r,type:e,merged:!1,static:!1}),this._markerKey++,this.save(r,e),a}showKPStations(n){if(!this.world)throw new Error("A world is needed for this component to work!");if(this.type==="horizontal"){const i=this.generateStartAndEndKP(n);for(const[,e]of i)this.addKPStation(this.world,e.value,e.normal);const t=this.generateConstantKP(n);for(const[,e]of t)this.addKPStation(this.world,e.value,e.normal)}}showCurveLength(n,i){if(!this.world)throw new Error("A world is needed for this component to work!");const t=this.components.get(b),e=n.length,s=`${i.toFixed(2)} m`,o=Math.round(e/2),a=n[o],r=t.create(this.world,s,a,!0);this.save(r,"Length")}showLineLength(n,i){if(!this.world)throw new Error("A world is needed for this component to work!");const t=this.components.get(b),e=new d;e.x=n.geometry.getAttribute("position").getX(0),e.y=n.geometry.getAttribute("position").getY(0),e.z=n.geometry.getAttribute("position").getZ(0);const s=new d;s.x=n.geometry.getAttribute("position").getX(1),s.y=n.geometry.getAttribute("position").getY(1),s.z=n.geometry.getAttribute("position").getZ(1);const o=`${i.toFixed(2)} m`,a=new d;a.addVectors(e,s).multiplyScalar(.5);const r=t.create(this.world,o,a,!0);this.save(r,"Length")}showCurveRadius(n,i){if(!this.world)throw new Error("A world is needed for this component to work!");const t=this.components.get(b),e=new d;e.x=n.geometry.getAttribute("position").getX(0),e.y=n.geometry.getAttribute("position").getY(0),e.z=n.geometry.getAttribute("position").getZ(0);const s=new d;s.x=n.geometry.getAttribute("position").getX(1),s.y=n.geometry.getAttribute("position").getY(1),s.z=n.geometry.getAttribute("position").getZ(1);const o=`R = ${i.toFixed(2)} m`,a=new d;a.addVectors(e,s).multiplyScalar(.5);const r=t.create(this.world,o,a,!0);this.save(r,"Radius")}deleteByType(n=st){const i=this.components.get(b);for(const t of n){const e=this.list.get(t);if(e){for(const s of e)i.delete(s);this.list.delete(t)}}}generateStartAndEndKP(n){const{alignment:i}=n.curve,t=new Map;for(const e of i.horizontal){const s=e.getLength();if(t.size>0){const o=e.index-1,r=t.get(o).distance+s,l=e.mesh.geometry.getAttribute("position"),c=l.count-1,h=new d;h.x=l.getX(c),h.y=l.getY(c),h.z=l.getZ(c);const u=this.createNormalLine(e.mesh);t.set(e.index,{value:this.getShortendKPValue(r),distance:r,point:h,normal:u})}else{const o=e.mesh.geometry.getAttribute("position"),a=o.count-1,r=new d;r.x=o.getX(a),r.y=o.getY(a),r.z=o.getZ(a);const l=this.createNormalLine(e.mesh);t.set(e.index,{value:this.getShortendKPValue(s),distance:s,point:r,normal:l})}}return t}createNormalLine(n){const i=n.geometry.attributes.position.count-1,t=i-1,e=new d;e.x=n.geometry.attributes.position.getX(i),e.y=n.geometry.attributes.position.getY(i),e.z=n.geometry.attributes.position.getZ(i);const s=new d;s.x=n.geometry.attributes.position.getX(t),s.y=n.geometry.attributes.position.getY(t),s.z=n.geometry.attributes.position.getZ(t);const a=new d().subVectors(e,s).clone().applyAxisAngle(new d(0,0,1),Math.PI*.5).normalize(),r=new f().setFromPoints([a.clone().setLength(10).add(e),a.clone().setLength(-10).add(e)]);return new y(r)}generateConstantKP(n){const{alignment:i}=n.curve,t=new Map,e=i.getLength("horizontal"),s=Math.floor(e/this.divisionLength);for(let o=0;o<s;o++){const a=o/s,r=i.getPointAt(a,"horizontal"),l=e*a,c=this.getNormal(i,r);t.set(o,{value:this.getShortendKPValue(l),distance:l,point:r,normal:c})}return t}getNormal(n,i){const t=[],e={start:new d,end:new d};for(let l=0;l<n.horizontal.length;l++){const h=n.horizontal[l].mesh.geometry.attributes.position,u=h.count;for(let g=0;g<u;g++){const w=h.getX(g),v=h.getY(g),L=h.getZ(g);t.push(new d(w,v,L))}}for(let l=0;l<t.length-1;l++){const c=t[l],h=t[l+1],u=c.distanceTo(i),g=h.distanceTo(i),w=c.distanceTo(h);Math.abs(u+g-w)<1e-5&&(e.start=c,e.end=h)}const o=new d().subVectors(e.end,e.start).clone().applyAxisAngle(new d(0,0,1),Math.PI*.5).normalize(),a=new f().setFromPoints([o.clone().setLength(10).add(i),o.clone().setLength(-10).add(i)]);return new y(a,new Z({color:16711680}))}getShortendKPValue(n){const i=n.toFixed(2),[t,e]=i.toString().split("."),s=e||"00";if(parseInt(t,10)>1e3&&parseInt(t,10)<1e4){const[o,...a]=t;return`${o}+${a.join("")}.${s}`}if(parseInt(t,10)>1e4){const[o,a,...r]=t;return`${o}${a}+${r.join("")}.${s}`}return`0+${t.padStart(3,"0")}.${s}`}save(n,i){this.list.has(i)||this.list.set(i,new Set),this.list.get(i).add(n)}};p(A,"uuid","0af12c32-81ee-4100-a030-e9ae546f6170");let k=A;class it extends T{constructor(n){super(n);p(this,"enabled",!0);p(this,"highlighter");p(this,"onHighlight",new V);p(this,"onMarkerChange",new V);p(this,"mouseMarkers");p(this,"onMarkerHidden",new V);p(this,"_curves",[]);p(this,"_previousAlignment",null);p(this,"_world",null);p(this,"onMouseMove",n=>{var o,a,r;if(!this.world)throw new Error("No world was given for this navigator!");if(!this.world.renderer)return;const t=this.world.renderer.three.domElement.parentElement,e=this.world.camera.three,s=(o=this.highlighter)==null?void 0:o.castRay(n,e,t,this._curves);if(s){const{object:l}=s;(a=this.highlighter)==null||a.hover(l),this.updateMarker(s,"hover");return}this.mouseMarkers&&(this.mouseMarkers.hover.visible=!1),(r=this.highlighter)==null||r.unHover(),this.onMarkerHidden.trigger({type:"hover"})});p(this,"onClick",n=>{var o,a;if(!this.world)throw new Error("No world was given for this navigator!");if(!this.world.renderer)return;const t=this.world.renderer.three.domElement.parentElement,e=this.world.camera.three,s=(o=this.highlighter)==null?void 0:o.castRay(n,e,t,this._curves);if(s){const r=s,l=r.object;if((a=this.highlighter)==null||a.select(l),this.updateMarker(r,"select"),this.onHighlight.trigger({mesh:l,point:r.point}),this._previousAlignment!==l.curve.alignment){const c=this.components.get(k);c.deleteByType(["KP"]),c.showKPStations(l),this._previousAlignment=l.curve.alignment}}});p(this,"onControlsUpdated",()=>{if(!this.world)throw new Error("No world was given for this navigator!");if(!(this.world.camera.three instanceof et)||!this.highlighter)return;const{zoom:n,left:i,right:t,top:e,bottom:s}=this.world.camera.three,o=i-t,a=e-s,l=Math.max(o,a)/n,c=40,{caster:h}=this.highlighter;h.params.Line.threshold=l/c})}get world(){return this._world}set world(n){var t,e,s;if(n===this._world||(this._world&&this.setupEvents(!1),this._world=n,(t=this.highlighter)==null||t.dispose(),(e=this.mouseMarkers)==null||e.hover.dispose(),(s=this.mouseMarkers)==null||s.select.dispose(),!n))return;const i=n.scene.three;this.highlighter=new ot(i,"absolute"),this.mouseMarkers={select:this.newMouseMarker("#ffffff",n),hover:this.newMouseMarker("#575757",n)},this.setupEvents(!0)}async draw(n,i){if(!n.civilData)throw new Error("The provided model doesn't have civil data!");if(!this.world)throw new Error("No world was given for this navigator!");const{alignments:t}=n.civilData,e=i||t.values(),s=this.world.scene.three,o=new _;o.makeEmpty(),o.min.set(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),o.max.set(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE);for(const c of e){if(!c)throw new Error("Alignment not found!");for(const h of c[this.view])if(s.add(h.mesh),this._curves.push(h.mesh),!o.isEmpty())o.expandByObject(h.mesh);else{h.mesh.geometry.computeBoundingBox();const u=h.mesh.geometry.boundingBox;u instanceof _&&o.copy(u).applyMatrix4(h.mesh.matrixWorld)}}const a=new _,r=new d,l=new d;o.getCenter(l),o.getSize(r),r.multiplyScalar(1.2),a.setFromCenterAndSize(l,r),this.world.camera.hasCameraControls()&&await this.world.camera.controls.fitToBox(a,!1)}async dispose(){var n;(n=this.highlighter)==null||n.dispose(),this.clear(),this.onHighlight.reset(),this._curves=[]}clear(){var n,i;(n=this.highlighter)==null||n.unSelect(),(i=this.highlighter)==null||i.unHover();for(const t of this._curves)t.removeFromParent();this._curves=[]}setMarker(n,i,t){if(!this._curves.length)return;const e=n.getCurveAt(i,this.view),s=n.getPointAt(i,this.view),{index:o}=e.curve.getSegmentAt(e.percentage);this.setMouseMarker(s,e.curve.mesh,o,t)}setDefSegments(n){const i=[],t=[],e=(s,o)=>{const a=o[1]-s[1],r=o[0]-s[0];return a/r};for(let s=0;s<n.length;s++){const o=n[s];let a,r,l,c;for(let g=0;g<Object.keys(o).length/3;g++)if(o[g*3]!==void 0&&o[g*3+1]!==void 0){a=o[g*3],r=o[g*3+1];break}for(let g=Object.keys(o).length/3-1;g>=0;g--)if(o[g*3]!==void 0&&o[g*3+1]!==void 0){l=o[g*3],c=o[g*3+1];break}const u=(e([a,r],[l,c])*100).toFixed(2);t.push({slope:u})}for(const s of n)for(let o=0;o<s.length-3;o+=3){const a=s[o],r=s[o+1],l=s[o+2],c=s[o+3],h=s[o+4],u=s[o+5];i.push({start:new d(a,r,l),end:new d(c,h,u)})}return{defSegments:i,slope:t}}hideMarker(n){this.mouseMarkers&&(this.mouseMarkers[n].visible=!1)}setupEvents(n){if(!this.world)throw new Error("No world was given for this navigator!");if(!this.world.renderer)return;const t=this.world.renderer.three.domElement.parentElement;n?(t.addEventListener("mousemove",this.onMouseMove),t.addEventListener("click",this.onClick),this.world.camera.hasCameraControls()&&this.world.camera.controls.addEventListener("update",this.onControlsUpdated)):(t.removeEventListener("mousemove",this.onMouseMove),t.removeEventListener("click",this.onClick),this.world.camera.hasCameraControls()&&this.world.camera.controls.removeEventListener("update",this.onControlsUpdated))}newMouseMarker(n,i){if(!this.world)throw new Error("No world was given for this navigator!");const t=i.scene.three,e=document.createElement("div"),s=document.createElement("div");e.appendChild(s),s.style.backgroundColor=n,s.style.width="3rem",s.style.height="3px";const o=new M(this.world,e,t);return o.visible=!1,o}setMouseMarker(n,i,t,e){if(t===void 0||!this.mouseMarkers)return;this.mouseMarkers[e].visible=!0;const s=this.mouseMarkers[e].three;s.position.copy(n);const o=i,{startPoint:a,endPoint:r}=o.curve.getSegment(t),l=Math.atan2(r.y-a.y,r.x-a.x),c=s.element.children[0],h=90-l/Math.PI*180;c.style.transform=`rotate(${h}deg)`}updateMarker(n,i){const{point:t,index:e,object:s}=n,o=s,a=o.curve,r=o.curve.alignment,l=r.getPercentageAt(t,this.view),c=t.clone();this.setMouseMarker(c,o,e,i),l!==null&&this.onMarkerChange.trigger({alignment:r,percentage:l,type:i,curve:a})}}class rt{constructor(m,n){p(this,"components");p(this,"_scene");p(this,"offset",10);p(this,"markupLines",[]);p(this,"currentCurveMesh");p(this,"markupMaterial",new Z({color:6842472}));this.components=m,this._scene=n}showCurveInfo(m){switch(this.disposeMarkups(),this.currentCurveMesh=m,m.curve.data.TYPE){case"LINE":this.showLineInfo(m,this.offset);break;case"CIRCULARARC":this.showCircularArcInfo(m,this.offset);break;case"CLOTHOID":this.showClothoidInfo(m,this.offset);break;default:console.log("Unknown curve type:",m.curve.data.TYPE);break}}updateOffset(m,n,i){const e=Math.max(m.height,m.width)/(n*150);e!==this.offset&&(this.offset=e,i&&this.currentCurveMesh&&this.showCurveInfo(this.currentCurveMesh))}dispose(){for(const m of this.markupLines)m.removeFromParent();this.disposeMarkups(),this.markupMaterial.dispose()}disposeMarkups(){for(const m of this.markupLines)m.geometry.dispose(),m.removeFromParent();this.markupLines=[]}unSelect(){this.disposeMarkups()}calculateTangent(m,n){const t=n*3,e=Math.max(0,t-3),s=Math.min(m.length-3,t+3),o=new d().fromArray(m,e);return new d().fromArray(m,s).clone().sub(o).normalize()}calculateParallelCurve(m,n,i){const t=[];for(let e=0;e<n;e++){const o=this.calculateTangent(m,e).clone().applyAxisAngle(new d(0,0,1),Math.PI/2);o.normalize();const a=o.clone().multiplyScalar(i),r=e*3,l=new d().fromArray(m,r).add(a);t.push(l)}return t}calculateDimensionLines(m,n){const i=[],t=m.geometry.attributes.position.array,e=n.geometry.attributes.position.array;if(t.length<6&&e.length<6)throw new Error("Line must have at least two vertices");const s=new d(t[0],t[1],t[2]),o=new d(e[0],e[1],e[2]),a=[],r=t.length-3,l=new d(t[r],t[r+1],t[r+2]),c=e.length-3,h=new d(e[c],e[c+1],e[c+2]);return i.push(s,o),a.push(l,h),{startDimensionPoints:i,endDimensionPoints:a}}offsetDimensionLine(m,n){const t=new d().copy(m[m.length-1]).sub(m[0]).normalize().clone().multiplyScalar(n);return m.map(s=>s.clone().add(t))}showLineInfo(m,n){const i=this.components.get(k);i.deleteByType(["Length","Radius"]);const t=m.geometry.attributes.position.array,e=this.calculateParallelCurve(t,t.length/3,n),s=new f().setFromPoints(e),o=new y(s,this.markupMaterial);i.showLineLength(o,m.curve.getLength()),this._scene.add(o),this.markupLines.push(o);const{startDimensionPoints:a,endDimensionPoints:r}=this.calculateDimensionLines(m,o),l=this.offsetDimensionLine(a,n*.1),c=this.offsetDimensionLine(r,n*.1),h=new f().setFromPoints(l),u=new f().setFromPoints(c),g=new y(h,this.markupMaterial);this._scene.add(g),this.markupLines.push(g);const w=new y(u,this.markupMaterial);this._scene.add(w),this.markupLines.push(w)}showClothoidInfo(m,n){const i=this.components.get(k);i.deleteByType(["Length","Radius"]);const t=m.geometry.attributes.position.array,e=this.calculateParallelCurve(t,t.length/3,n),s=new f().setFromPoints(e);i.showCurveLength(e,m.curve.getLength());const o=new y(s,this.markupMaterial);this._scene.add(o),this.markupLines.push(o);const{startDimensionPoints:a,endDimensionPoints:r}=this.calculateDimensionLines(m,o),l=this.offsetDimensionLine(a,n*.1),c=this.offsetDimensionLine(r,n*.1),h=new f().setFromPoints(l),u=new f().setFromPoints(c),g=new y(h,this.markupMaterial);this._scene.add(g),this.markupLines.push(g);const w=new y(u,this.markupMaterial);this._scene.add(w),this.markupLines.push(w)}showCircularArcInfo(m,n){const i=this.components.get(k);i.deleteByType(["Length","Radius"]);const t=m.curve.data.RADIUS,e=m.geometry.attributes.position.array,s=m.geometry.attributes.position.count,o=[],a=new d(e[0],e[1],e[2]),r=(s-1)*3,l=new d(e[r],e[r+1],e[r+2]),c=s/2*3,h=new d(e[c],e[c+1],e[c+2]),u=l.clone().sub(a).normalize(),g=new d(-u.y,u.x,0);g.multiplyScalar(t);const w=h.clone().add(g);o.push(h),o.push(w);const v=new f().setFromPoints(o),L=new y(v,this.markupMaterial);i.showCurveRadius(L,Math.abs(t)),this._scene.add(L),this.markupLines.push(L);const S=[];for(let x=0;x<s;x++){const F=this.calculateTangent(e,x),j=m.curve.data.RADIUS,z=new d(F.y,-F.x,0);z.normalize(),j<0&&z.negate();const D=z.clone().multiplyScalar(n),I=x*3,O=new d(e[I]+D.x,e[I+1]+D.y,e[I+2]+D.z);S.push(O)}const H=new f().setFromPoints(S);i.showCurveLength(S,m.curve.getLength());const E=new y(H,this.markupMaterial);this._scene.add(E),this.markupLines.push(E);const{startDimensionPoints:B,endDimensionPoints:N}=this.calculateDimensionLines(m,E),U=this.offsetDimensionLine(B,n*.1),R=this.offsetDimensionLine(N,n*.1),$=new f().setFromPoints(U),G=new f().setFromPoints(R),X=new y($,this.markupMaterial);this._scene.add(X),this.markupLines.push(X);const K=new y(G,this.markupMaterial);this._scene.add(K),this.markupLines.push(K)}}const C=class C extends it{constructor(n){super(n);p(this,"view","horizontal");p(this,"planHighlighter");this.components.add(C.uuid,this),this.onHighlight.add(({mesh:i})=>{!this.highlighter||!this.planHighlighter||(this.planHighlighter.showCurveInfo(i),this.fitCameraToAlignment(i))})}set world(n){var i;super.world=n,n&&((i=this.planHighlighter)==null||i.dispose(),this.planHighlighter=new rt(this.components,n.scene.three))}async fitCameraToAlignment(n){const i=this.components.get(nt),t=n.curve.alignment;for(const c of t.horizontal)i.addMesh(c.mesh);const e=i.get(),s=new d,{min:o,max:a}=e,r=1.2,l=new d((a.x-o.x)*r,(a.y-o.y)*r,(a.z-o.z)*r);e.getCenter(s),e.setFromCenterAndSize(s,l),i.reset(),this.world&&this.world.camera.hasCameraControls()&&await this.world.camera.controls.fitToBox(e,!0)}};p(C,"uuid","3096dea0-5bc2-41c7-abce-9089b6c9431b");let Y=C;export{Y as C,it as a,k as b};
