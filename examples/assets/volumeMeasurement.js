var _=Object.defineProperty;var j=(f,m,e)=>m in f?_(f,m,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[m]=e;var n=(f,m,e)=>(j(f,typeof m!="symbol"?m+"":m,e),e);import{M as W,a as I,I as B,V as F,C as T}from"./web-ifc-api-D3oDn2HF.js";import{S as P}from"./stats.min-DDrWCSVO.js";import{C as A,E as y,R as O,F as M,B as U,a as R,W as G,S as K,b as Z,G as $}from"./index-DPB0U-mi.js";import{n as q,M as J,P as Q}from"./import-wrapper-prod-C6LuifRs.js";const D=class D extends A{constructor(e){super(e);n(this,"label",null);n(this,"world");n(this,"onVolumeFound",new y);n(this,"_enabled",!1);n(this,"onDisposed",new y);n(this,"create",()=>{if(!this.enabled)return;if(!this.world)throw new Error("World is needed for Volume Measurement!");const o=this.components.get(O).get(this.world).castRay();if(!o||!o.object)return;const{object:l}=o;if(l instanceof W){const a=this.getVolumeOfMesh(l);this.onVolumeFound.trigger(a)}});n(this,"onMouseMove",()=>{});n(this,"onKeydown",e=>{});this.components.add(D.uuid,this)}set enabled(e){this._enabled=e,this.setupEvents(e),e||this.cancelCreation()}get enabled(){return this._enabled}async dispose(){var e;this.setupEvents(!1),(e=this.label)==null||e.dispose(),this.onDisposed.trigger(),this.onDisposed.reset(),this.components=null}delete(){}async deleteAll(){}endCreation(){}cancelCreation(){}get(){}getVolumeFromFragments(e){const t=this.components.get(M),o=new I,l=[];for(const a in e){const r=t.list.get(a);if(!r)continue;const s=e[a];let i=0;for(const d of s){const u=r.getInstancesIDs(d);u&&(i+=u.size)}const h=new B(r.mesh.geometry,void 0,i);let c=0;for(const d of s){const u=r.getInstancesIDs(d);if(u)for(const w of u)r.mesh.getMatrixAt(w,o),h.setMatrixAt(c++,o)}l.push(h)}return this.getVolumeFromMeshes(l)}getVolumeFromMeshes(e){if(!this.world)throw new Error("World is needed for Volume Measurement!");this.label||(this.label=this.newLabel(),this.label.three.removeFromParent());let t=0;for(const i of e)t+=this.getVolumeOfMesh(i);const o=this.world.scene.three,l=this.label.three;o.add(l);const a=this.components.get(U);for(const i of e)i.geometry.computeBoundingSphere(),a.addMesh(i);const r=a.getSphere();a.reset(),l.position.copy(r.center);const s=Math.trunc(t*100)/100;return l.element.textContent=s.toString(),t}newLabel(){if(!this.world)throw new Error("World is needed for Volume Measurement!");const e=q();return new J(this.world,e)}setupEvents(e){if(!this.world)throw new Error("The volume measurement needs a world to work!");if(this.world.isDisposing)return;if(!this.world.renderer)throw new Error("The world of the volume measurement needs a renderer!");const o=this.world.renderer.three.domElement.parentElement;e?(o.addEventListener("click",this.create),o.addEventListener("mousemove",this.onMouseMove),window.addEventListener("keydown",this.onKeydown)):(o.removeEventListener("click",this.create),o.removeEventListener("mousemove",this.onMouseMove),window.removeEventListener("keydown",this.onKeydown))}getVolumeOfMesh(e){let t=0;const o=new F,l=new F,a=new F,{index:r}=e.geometry,s=e.geometry.attributes.position.array;if(!r)return console.warn("Geometry must be indexed to compute its volume!"),0;const i=[];if(e instanceof B)for(let c=0;c<e.count;c++){const d=new I;e.getMatrixAt(c,d),i.push(d)}else i.push(new I().identity());const{matrixWorld:h}=e;for(let c=0;c<r.array.length-2;c+=3)for(const d of i){const u=d.multiply(h),w=r.array[c]*3,p=r.array[c+1]*3,b=r.array[c+2]*3;o.set(s[w],s[w+1],s[w+2]).applyMatrix4(u),l.set(s[p],s[p+1],s[p+2]).applyMatrix4(u),a.set(s[b],s[b+1],s[b+2]).applyMatrix4(u),t+=this.getSignedVolumeOfTriangle(o,l,a)}return Math.abs(t)}getSignedVolumeOfTriangle(e,t,o){const l=o.x*t.y*e.z,a=t.x*o.y*e.z,r=o.x*e.y*t.z,s=e.x*o.y*t.z,i=t.x*e.y*o.z,h=e.x*t.y*o.z;return 1/6*(-l+a+r-s-i+h)}};n(D,"uuid","811da532-7af3-4635-b592-1c06ae494af5");let k=D;const C=class C extends A{constructor(e){super(e);n(this,"onDisposed",new y);n(this,"onBeforeUpdate",new y);n(this,"onAfterUpdate",new y);n(this,"onSetup",new y);n(this,"isSetup",!1);n(this,"enabled",!0);n(this,"events",{});n(this,"multiple","ctrlKey");n(this,"zoomFactor",1.5);n(this,"zoomToSelection",!1);n(this,"backupColor",null);n(this,"selection",{});n(this,"config",{selectName:"select",hoverName:"hover",selectionColor:new T("#BCF124"),hoverColor:new T("#6528D7"),autoHighlightOnClick:!0,world:null});n(this,"colors",new Map);n(this,"_mouseState",{down:!1,moved:!1});n(this,"clearHover",()=>{this.selection[this.config.hoverName]={}});n(this,"onMouseDown",()=>{this.enabled&&(this._mouseState.down=!0)});n(this,"onMouseUp",async e=>{const t=this.config.world;if(!t)throw new Error("No world found!");if(!t.renderer)throw new Error("This world doesn't have a renderer!");if(this.enabled&&e.target===t.renderer.three.domElement){if(this._mouseState.down=!1,this._mouseState.moved||e.button!==0){this._mouseState.moved=!1;return}if(this._mouseState.moved=!1,this.config.autoHighlightOnClick){const o=this.multiple==="none"?!0:!e[this.multiple];await this.highlight(this.config.selectName,o,this.zoomToSelection)}}});n(this,"onMouseMove",async()=>{if(!this.enabled)return;if(this._mouseState.moved){this.clear(this.config.hoverName);return}this._mouseState.moved=this._mouseState.down;const e=this.selection[this.config.selectName];await this.highlight(this.config.hoverName,!0,!1,e)});this.components.add(C.uuid,this)}async dispose(){this.setupEvents(!1),this.onBeforeUpdate.reset(),this.onAfterUpdate.reset(),this.selection={};for(const e in this.events)this.events[e].onClear.reset(),this.events[e].onHighlight.reset();this.onSetup.reset(),this.events={},this.onDisposed.trigger(C.uuid),this.onDisposed.reset()}add(e,t){if(this.selection[e]||this.colors.has(e))throw new Error("A selection with that name already exists!");this.colors.set(e,t),this.selection[e]={},this.events[e]={onHighlight:new y,onClear:new y}}async highlight(e,t=!0,o=this.zoomToSelection,l={}){if(!this.enabled)return null;if(!this.config.world)throw new Error("No world found in config!");const a=this.config.world;if(!this.selection[e])throw new Error(`Selection ${e} does not exist.`);const s=this.components.get(M).meshes,c=this.components.get(O).get(a).castRay(s);if(!c||!c.face)return this.clear(e),null;const d=c.object,u=d.geometry,w=c.instanceId;if(!u||w===void 0)return null;const p=d.fragment.getItemID(w);if(p===null)throw new Error("Item ID not found!");const b=d.fragment.group;if(!b)throw new Error("Fragment must belong to a FragmentsGroup!");const S=b.getFragmentMap([p]);return await this.highlightByID(e,S,t,o,l),{id:p,fragments:S}}async highlightByID(e,t,o=!0,l=this.zoomToSelection,a={}){if(!this.enabled)return;o&&this.clear(e);const r=this.components.get(M),s=this.colors.get(e);if(!s)throw new Error("Color for selection not found!");const i={};for(const h in t){const c=t[h],d=a[h];for(const u of c)(!d||!d.has(u))&&(i[h]||(i[h]=new Set),i[h].add(u))}for(const h in i){const c=r.list.get(h);if(!c)continue;this.selection[e][h]||(this.selection[e][h]=new Set);const d=t[h];for(const u of d)this.selection[e][h].add(u),c.setColor(s,[u])}this.events[e].onHighlight.trigger(this.selection[e]),l&&await this.zoomSelection(e)}clear(e){const t=e?[e]:Object.keys(this.selection);for(const o of t){const l=this.components.get(M),a=this.selection[o];for(const r in this.selection[o]){const s=l.list.get(r);if(!s)continue;const i=a[r];i&&(this.backupColor?s.setColor(this.backupColor):s.resetColor(i))}this.events[o].onClear.trigger(null),this.selection[o]={}}}setup(e){this.config={...this.config,...e},this.add(this.config.selectName,this.config.selectionColor),this.add(this.config.hoverName,this.config.hoverColor),this.setupEvents(!0),this.enabled=!0,this.isSetup=!0,this.onSetup.trigger(this)}async zoomSelection(e){if(!this.config.world)throw new Error("No world found in config!");const t=this.config.world;if(!t.camera.hasCameraControls())return;const o=this.components.get(U),l=this.components.get(M);o.reset();const a=this.selection[e];if(!Object.keys(a).length)return;for(const S in a){const N=l.list.get(S);if(!N)continue;const H=a[S];o.addMesh(N.mesh,H)}const r=o.getSphere(),s=1/0,i=-1/0,{x:h,y:c,z:d}=r.center,u=r.radius===s||h===s||c===s||d===s,w=r.radius===i||h===i||c===i||d===i,p=r.radius===0;if(u||w||p)return;r.radius*=this.zoomFactor,await t.camera.controls.fitToSphere(r,!0)}setupEvents(e){if(!this.config.world)throw new Error("No world found while setting up events!");if(this.config.world.isDisposing)return;if(!this.config.world.renderer)throw new Error("The given world doesn't have a renderer!");const t=this.config.world.renderer.three.domElement,o=this.events[this.config.selectName].onHighlight;o.remove(this.clearHover),t.removeEventListener("mousedown",this.onMouseDown),t.removeEventListener("mouseup",this.onMouseUp),t.removeEventListener("mousemove",this.onMouseMove),e&&(o.add(this.clearHover),t.addEventListener("mousedown",this.onMouseDown),t.addEventListener("mouseup",this.onMouseUp),t.addEventListener("mousemove",this.onMouseMove))}};n(C,"uuid","cb8a76f2-654a-4b50-80c6-66fd83cafd77");let z=C;const L=document.getElementById("container"),v=new R,X=v.get(G),g=X.create();g.scene=new K(v);g.renderer=new Q(v,L);g.camera=new Z(v);v.init();g.camera.controls.setLookAt(5,5,5,0,0,0);g.scene.setup();const Y=v.get($);Y.create(g);const E=new k(v);E.world=g;E.enabled=!0;const ee=new M(v),te=await fetch("https://thatopen.github.io/engine_components/resources/small.frag"),oe=await te.arrayBuffer(),se=new Uint8Array(oe),ne=ee.load(se);g.scene.three.add(ne);const V=new z(v);V.setup({world:g});V.events.select.onHighlight.add(f=>{const m=E.getVolumeFromFragments(f);console.log(m)});V.events.select.onClear.add(()=>{var f;(f=E.label)==null||f.three.removeFromParent()});L.ondblclick=()=>E.create();L.oncontextmenu=()=>E.endCreation();window.onkeydown=f=>{f.code==="Delete"||f.code};const x=new P;x.showPanel(2);document.body.append(x.dom);x.dom.style.left="0px";g.renderer.onBeforeUpdate.add(()=>x.begin());g.renderer.onAfterUpdate.add(()=>x.end());
