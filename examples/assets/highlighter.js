var z=Object.defineProperty;var L=(f,l,e)=>l in f?z(f,l,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[l]=e;var o=(f,l,e)=>(L(f,typeof l!="symbol"?l+"":l,e),e);import{C as x,i as R,j as B,k as _}from"./web-ifc-api-eJ7dR4yy.js";import{S as k}from"./stats.min-GTpOrGrX.js";import{J as j,U as v,u as b,H as G,A as P,f as Z,p as J,s as K,i as $,k as q,N as Q}from"./import-wrapper-prod-Dt8pgrvp.js";import"./_commonjsHelpers-Cpj98o6Y.js";const S=class S extends j{constructor(e){super(e);o(this,"onDisposed",new v);o(this,"onBeforeUpdate",new v);o(this,"onAfterUpdate",new v);o(this,"onSetup",new v);o(this,"isSetup",!1);o(this,"enabled",!0);o(this,"events",{});o(this,"multiple","ctrlKey");o(this,"zoomFactor",1.5);o(this,"zoomToSelection",!1);o(this,"selection",{});o(this,"config",{selectName:"select",hoverName:"hover",selectionColor:new x("#BCF124"),hoverColor:new x("#6528D7"),autoHighlightOnClick:!0,world:null});o(this,"colors",new Map);o(this,"_mouseState",{down:!1,moved:!1});o(this,"clearHover",()=>{this.selection[this.config.hoverName]={}});o(this,"onMouseDown",()=>{this.enabled&&(this._mouseState.down=!0)});o(this,"onMouseUp",async e=>{const t=this.config.world;if(!t)throw new Error("No world found!");if(!t.renderer)throw new Error("This world doesn't have a renderer!");if(this.enabled&&e.target===t.renderer.three.domElement){if(this._mouseState.down=!1,this._mouseState.moved||e.button!==0){this._mouseState.moved=!1;return}if(this._mouseState.moved=!1,this.config.autoHighlightOnClick){const s=this.multiple==="none"?!0:!e[this.multiple];await this.highlight(this.config.selectName,s,this.zoomToSelection)}}});o(this,"onMouseMove",async()=>{if(!this.enabled)return;if(this._mouseState.moved){this.clear(this.config.hoverName);return}this._mouseState.moved=this._mouseState.down;const e=this.selection[this.config.selectName];await this.highlight(this.config.hoverName,!0,!1,e)});this.components.add(S.uuid,this)}async dispose(){this.setupEvents(!1),this.onBeforeUpdate.reset(),this.onAfterUpdate.reset(),this.selection={};for(const e in this.events)this.events[e].onClear.reset(),this.events[e].onHighlight.reset();this.onSetup.reset(),this.events={},this.onDisposed.trigger(S.uuid),this.onDisposed.reset()}add(e,t){if(this.selection[e]||this.colors.has(e))throw new Error("A selection with that name already exists!");this.colors.set(e,t),this.selection[e]={},this.events[e]={onHighlight:new v,onClear:new v}}async highlight(e,t=!0,s=this.zoomToSelection,u={}){if(!this.enabled)return null;if(!this.config.world)throw new Error("No world found in config!");const h=this.config.world;if(!this.selection[e])throw new Error(`Selection ${e} does not exist.`);const n=this.components.get(b).meshes,c=this.components.get(G).get(h).castRay(n);if(!c||!c.face)return this.clear(e),null;const w=c.object,D=w.geometry,y=c.instanceId;if(!D||y===void 0)return null;const E=w.fragment.getItemID(y);if(E===null)throw new Error("Item ID not found!");const M=w.fragment.group;if(!M)throw new Error("Fragment must belong to a FragmentsGroup!");const p=M.getFragmentMap([E]),g={};for(const m in p){const U=p[m],F=u[m];for(const T of U)(!F||!F.has(T))&&(g[m]||(g[m]=new Set),g[m].add(T))}return await this.highlightByID(e,g,t,s),{id:E,fragments:p}}async highlightByID(e,t,s=!0,u=this.zoomToSelection){if(!this.enabled)return;s&&this.clear(e);const h=this.components.get(b),i=this.colors.get(e);if(!i)throw new Error("Color for selection not found!");for(const n in t){const r=h.list.get(n);if(!r)continue;this.selection[e][n]||(this.selection[e][n]=new Set);const I=t[n];for(const c of I)this.selection[e][n].add(c),r.setColor(i,[c])}this.events[e].onHighlight.trigger(this.selection[e]),u&&await this.zoomSelection(e)}clear(e){const t=e?[e]:Object.keys(this.selection);for(const s of t){const u=this.components.get(b),h=this.selection[s];for(const i in this.selection[s]){const n=u.list.get(i);if(!n)continue;const r=h[i];r&&n.resetColor(r)}this.events[s].onClear.trigger(null),this.selection[s]={}}}setup(e){this.config={...this.config,...e},this.add(this.config.selectName,this.config.selectionColor),this.add(this.config.hoverName,this.config.hoverColor),this.setupEvents(!0),this.enabled=!0,this.isSetup=!0,this.onSetup.trigger(this)}async zoomSelection(e){if(!this.config.world)throw new Error("No world found in config!");const t=this.config.world;if(!t.camera.hasCameraControls())return;const s=this.components.get(P),u=this.components.get(b);s.reset();const h=this.selection[e];if(!Object.keys(h).length)return;for(const p in h){const g=u.list.get(p);if(!g)continue;const m=h[p];s.addMesh(g.mesh,m)}const i=s.getSphere(),n=1/0,r=-1/0,{x:I,y:c,z:w}=i.center,D=i.radius===n||I===n||c===n||w===n,y=i.radius===r||I===r||c===r||w===r,E=i.radius===0;if(D||y||E)return;i.radius*=this.zoomFactor,await t.camera.controls.fitToSphere(i,!0)}setupEvents(e){if(!this.config.world)throw new Error("No world found while setting up events!");if(!this.config.world.renderer)throw new Error("The given world doesn't have a renderer!");const t=this.config.world.renderer.three.domElement,s=this.events[this.config.selectName].onHighlight;s.remove(this.clearHover),t.removeEventListener("mousedown",this.onMouseDown),t.removeEventListener("mouseup",this.onMouseUp),t.removeEventListener("mousemove",this.onMouseMove),e&&(s.add(this.clearHover),t.addEventListener("mousedown",this.onMouseDown),t.addEventListener("mouseup",this.onMouseUp),t.addEventListener("mousemove",this.onMouseMove))}};o(S,"uuid","cb8a76f2-654a-4b50-80c6-66fd83cafd77");let O=S;const V=document.getElementById("container"),d=new Z,W=d.get(J),a=W.create();a.scene=new K(d);a.renderer=new $(d,V);a.camera=new q(d);d.init();a.camera.controls.setLookAt(12,6,8,0,0,-10);a.scene.setup();const X=d.get(Q);X.create(a);const C=d.get(void 0);await C.setup();const Y=[R,B,_];for(const f of Y)C.settings.excludedCategories.add(f);C.settings.webIfc.COORDINATE_TO_ORIGIN=!0;C.settings.webIfc.OPTIMIZE_PROFILES=!0;const ee=await fetch("../../../../../resources/small.ifc"),te=await ee.arrayBuffer(),oe=new Uint8Array(te),A=await C.load(oe);A.name="example";a.scene.three.add(A);const H=d.get(O);H.setup({world:a});H.zoomToSelection=!0;const N=new k;N.showPanel(2);document.body.append(N.dom);N.dom.style.left="0px";a.renderer.onBeforeUpdate.add(()=>N.begin());a.renderer.onAfterUpdate.add(()=>N.end());
