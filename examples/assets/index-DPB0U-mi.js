import{q as At,h as it,T as pe,ad as Ci,ae as So,a as W,V as O,f as gt,P as Re,l as Os,M as x,C as $t,s as Ti,a1 as yo,a2 as Po,af as gs,t as mi,$ as No,aY as wo,p as Lo,aJ as Rt,aZ as Mo,r as wn,a4 as Do,a3 as ei,aq as Ss,au as zt,v as Uo,c as Ge,d as Te,ai as We,aj as qt,B as nt,ak as xo,al as Ln,aA as Nt,am as Ri,an as Ai,ao as gi,ap as Fi,ar as _i,as as Mn,at as ys,av as Hi,aw as Dn,ax as Un,ay as Jt,az as bo,e as Ve,aB as vo,aC as Qe,aD as Bo,ab as Oi,aO as Si,aP as yi,aI as Pi,I as He,ah as Ni,n as Yo,ag as at,O as Fs,aN as Ds,aH as zo,aQ as Go,L as xn,aR as Vo,aS as Ho,aT as ko,aU as Wo,aV as Xo,aW as ki,aX as Zo,F as Wi,aK as je,g as Dt,aL as Qo,aM as _e,u as jo,a_ as qo,a$ as $o}from"./web-ifc-api-D3oDn2HF.js";var Ko=Object.defineProperty,Jo=(c,t,e)=>t in c?Ko(c,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):c[t]=e,E=(c,t,e)=>(Jo(c,typeof t!="symbol"?t+"":t,e),e);const bn=0,tr=1,er=2,Xi=2,Us=1.25,Zi=1,ms=6*4+4+4,Ps=65535,sr=Math.pow(2,-24),xs=Symbol("SKIP_GENERATION");function ir(c){return c.index?c.index.count:c.attributes.position.count}function Ae(c){return ir(c)/3}function nr(c,t=ArrayBuffer){return c>65535?new Uint32Array(new t(4*c)):new Uint16Array(new t(2*c))}function or(c,t){if(!c.index){const e=c.attributes.position.count,s=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,i=nr(e,s);c.setIndex(new Ve(i,1));for(let o=0;o<e;o++)i[o]=o}}function vn(c){const t=Ae(c),e=c.drawRange,s=e.start/3,i=(e.start+e.count)/3,o=Math.max(0,s),n=Math.min(t,i)-o;return[{offset:Math.floor(o),count:Math.floor(n)}]}function Bn(c){if(!c.groups||!c.groups.length)return vn(c);const t=[],e=new Set,s=c.drawRange,i=s.start/3,o=(s.start+s.count)/3;for(const r of c.groups){const a=r.start/3,l=(r.start+r.count)/3;e.add(Math.max(i,a)),e.add(Math.min(o,l))}const n=Array.from(e.values()).sort((r,a)=>r-a);for(let r=0;r<n.length-1;r++){const a=n[r],l=n[r+1];t.push({offset:Math.floor(a),count:Math.floor(l-a)})}return t}function rr(c){if(c.groups.length===0)return!1;const t=Ae(c),e=Bn(c).sort((o,n)=>o.offset-n.offset),s=e[e.length-1];s.count=Math.min(t-s.offset,s.count);let i=0;return e.forEach(({count:o})=>i+=o),t!==i}function q(c,t,e){return e.min.x=t[c],e.min.y=t[c+1],e.min.z=t[c+2],e.max.x=t[c+3],e.max.y=t[c+4],e.max.z=t[c+5],e}function ar(c){c[0]=c[1]=c[2]=1/0,c[3]=c[4]=c[5]=-1/0}function Qi(c){let t=-1,e=-1/0;for(let s=0;s<3;s++){const i=c[s+3]-c[s];i>e&&(e=i,t=s)}return t}function ji(c,t){t.set(c)}function qi(c,t,e){let s,i;for(let o=0;o<3;o++){const n=o+3;s=c[o],i=t[o],e[o]=s<i?s:i,s=c[n],i=t[n],e[n]=s>i?s:i}}function qe(c,t,e){for(let s=0;s<3;s++){const i=t[c+2*s],o=t[c+2*s+1],n=i-o,r=i+o;n<e[s]&&(e[s]=n),r>e[s+3]&&(e[s+3]=r)}}function Oe(c){const t=c[3]-c[0],e=c[4]-c[1],s=c[5]-c[2];return 2*(t*e+e*s+s*t)}function bs(c,t,e,s,i=null){let o=1/0,n=1/0,r=1/0,a=-1/0,l=-1/0,d=-1/0,u=1/0,h=1/0,f=1/0,p=-1/0,T=-1/0,m=-1/0;const C=i!==null;for(let R=t*6,g=(t+e)*6;R<g;R+=6){const I=c[R+0],A=c[R+1],F=I-A,_=I+A;F<o&&(o=F),_>a&&(a=_),C&&I<u&&(u=I),C&&I>p&&(p=I);const S=c[R+2],y=c[R+3],N=S-y,L=S+y;N<n&&(n=N),L>l&&(l=L),C&&S<h&&(h=S),C&&S>T&&(T=S);const w=c[R+4],D=c[R+5],U=w-D,b=w+D;U<r&&(r=U),b>d&&(d=b),C&&w<f&&(f=w),C&&w>m&&(m=w)}s[0]=o,s[1]=n,s[2]=r,s[3]=a,s[4]=l,s[5]=d,C&&(i[0]=u,i[1]=h,i[2]=f,i[3]=p,i[4]=T,i[5]=m)}function cr(c,t,e,s){let i=1/0,o=1/0,n=1/0,r=-1/0,a=-1/0,l=-1/0;for(let d=t*6,u=(t+e)*6;d<u;d+=6){const h=c[d+0];h<i&&(i=h),h>r&&(r=h);const f=c[d+2];f<o&&(o=f),f>a&&(a=f);const p=c[d+4];p<n&&(n=p),p>l&&(l=p)}s[0]=i,s[1]=o,s[2]=n,s[3]=r,s[4]=a,s[5]=l}function lr(c,t){ar(t);const e=c.attributes.position,s=c.index?c.index.array:null,i=Ae(c),o=new Float32Array(i*6),n=e.normalized,r=e.array,a=e.offset||0;let l=3;e.isInterleavedBufferAttribute&&(l=e.data.stride);const d=["getX","getY","getZ"];for(let u=0;u<i;u++){const h=u*3,f=u*6;let p=h+0,T=h+1,m=h+2;s&&(p=s[p],T=s[T],m=s[m]),n||(p=p*l+a,T=T*l+a,m=m*l+a);for(let C=0;C<3;C++){let R,g,I;n?(R=e[d[C]](p),g=e[d[C]](T),I=e[d[C]](m)):(R=r[p+C],g=r[T+C],I=r[m+C]);let A=R;g<A&&(A=g),I<A&&(A=I);let F=R;g>F&&(F=g),I>F&&(F=I);const _=(F-A)/2,S=C*2;o[f+S+0]=A+_,o[f+S+1]=_+(Math.abs(A)+_)*sr,A<t[C]&&(t[C]=A),F>t[C+3]&&(t[C+3]=F)}}return o}const wt=32,hr=(c,t)=>c.candidate-t.candidate,Ut=new Array(wt).fill().map(()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0})),$e=new Float32Array(6);function dr(c,t,e,s,i,o){let n=-1,r=0;if(o===bn)n=Qi(t),n!==-1&&(r=(t[n]+t[n+3])/2);else if(o===tr)n=Qi(c),n!==-1&&(r=ur(e,s,i,n));else if(o===er){const a=Oe(c);let l=Us*i;const d=s*6,u=(s+i)*6;for(let h=0;h<3;h++){const f=t[h],m=(t[h+3]-f)/wt;if(i<wt/4){const C=[...Ut];C.length=i;let R=0;for(let I=d;I<u;I+=6,R++){const A=C[R];A.candidate=e[I+2*h],A.count=0;const{bounds:F,leftCacheBounds:_,rightCacheBounds:S}=A;for(let y=0;y<3;y++)S[y]=1/0,S[y+3]=-1/0,_[y]=1/0,_[y+3]=-1/0,F[y]=1/0,F[y+3]=-1/0;qe(I,e,F)}C.sort(hr);let g=i;for(let I=0;I<g;I++){const A=C[I];for(;I+1<g&&C[I+1].candidate===A.candidate;)C.splice(I+1,1),g--}for(let I=d;I<u;I+=6){const A=e[I+2*h];for(let F=0;F<g;F++){const _=C[F];A>=_.candidate?qe(I,e,_.rightCacheBounds):(qe(I,e,_.leftCacheBounds),_.count++)}}for(let I=0;I<g;I++){const A=C[I],F=A.count,_=i-A.count,S=A.leftCacheBounds,y=A.rightCacheBounds;let N=0;F!==0&&(N=Oe(S)/a);let L=0;_!==0&&(L=Oe(y)/a);const w=Zi+Us*(N*F+L*_);w<l&&(n=h,l=w,r=A.candidate)}}else{for(let g=0;g<wt;g++){const I=Ut[g];I.count=0,I.candidate=f+m+g*m;const A=I.bounds;for(let F=0;F<3;F++)A[F]=1/0,A[F+3]=-1/0}for(let g=d;g<u;g+=6){let F=~~((e[g+2*h]-f)/m);F>=wt&&(F=wt-1);const _=Ut[F];_.count++,qe(g,e,_.bounds)}const C=Ut[wt-1];ji(C.bounds,C.rightCacheBounds);for(let g=wt-2;g>=0;g--){const I=Ut[g],A=Ut[g+1];qi(I.bounds,A.rightCacheBounds,I.rightCacheBounds)}let R=0;for(let g=0;g<wt-1;g++){const I=Ut[g],A=I.count,F=I.bounds,S=Ut[g+1].rightCacheBounds;A!==0&&(R===0?ji(F,$e):qi(F,$e,$e)),R+=A;let y=0,N=0;R!==0&&(y=Oe($e)/a);const L=i-R;L!==0&&(N=Oe(S)/a);const w=Zi+Us*(y*R+N*L);w<l&&(n=h,l=w,r=I.candidate)}}}}else console.warn(`MeshBVH: Invalid build strategy value ${o} used.`);return{axis:n,pos:r}}function ur(c,t,e,s){let i=0;for(let o=t,n=t+e;o<n;o++)i+=c[o*6+s*2];return i/e}class Ke{constructor(){}}function Er(c,t,e,s,i,o){let n=s,r=s+i-1;const a=o.pos,l=o.axis*2;for(;;){for(;n<=r&&e[n*6+l]<a;)n++;for(;n<=r&&e[r*6+l]>=a;)r--;if(n<r){for(let d=0;d<3;d++){let u=t[n*3+d];t[n*3+d]=t[r*3+d],t[r*3+d]=u}for(let d=0;d<6;d++){let u=e[n*6+d];e[n*6+d]=e[r*6+d],e[r*6+d]=u}n++,r--}else return n}}function fr(c,t,e,s,i,o){let n=s,r=s+i-1;const a=o.pos,l=o.axis*2;for(;;){for(;n<=r&&e[n*6+l]<a;)n++;for(;n<=r&&e[r*6+l]>=a;)r--;if(n<r){let d=c[n];c[n]=c[r],c[r]=d;for(let u=0;u<6;u++){let h=e[n*6+u];e[n*6+u]=e[r*6+u],e[r*6+u]=h}n++,r--}else return n}}function Ir(c,t){const e=(c.index?c.index.count:c.attributes.position.count)/3,s=e>2**16,i=s?4:2,o=t?new SharedArrayBuffer(e*i):new ArrayBuffer(e*i),n=s?new Uint32Array(o):new Uint16Array(o);for(let r=0,a=n.length;r<a;r++)n[r]=r;return n}function pr(c,t){const e=c.geometry,s=e.index?e.index.array:null,i=t.maxDepth,o=t.verbose,n=t.maxLeafTris,r=t.strategy,a=t.onProgress,l=Ae(e),d=c._indirectBuffer;let u=!1;const h=new Float32Array(6),f=new Float32Array(6),p=lr(e,h),T=t.indirect?fr:Er,m=[],C=t.indirect?vn(e):Bn(e);if(C.length===1){const I=C[0],A=new Ke;A.boundingData=h,cr(p,I.offset,I.count,f),g(A,I.offset,I.count,f),m.push(A)}else for(let I of C){const A=new Ke;A.boundingData=new Float32Array(6),bs(p,I.offset,I.count,A.boundingData,f),g(A,I.offset,I.count,f),m.push(A)}return m;function R(I){a&&a(I/l)}function g(I,A,F,_=null,S=0){if(!u&&S>=i&&(u=!0,o&&(console.warn(`MeshBVH: Max depth of ${i} reached when generating BVH. Consider increasing maxDepth.`),console.warn(e))),F<=n||S>=i)return R(A+F),I.offset=A,I.count=F,I;const y=dr(I.boundingData,_,p,A,F,r);if(y.axis===-1)return R(A+F),I.offset=A,I.count=F,I;const N=T(d,s,p,A,F,y);if(N===A||N===A+F)R(A+F),I.offset=A,I.count=F;else{I.splitAxis=y.axis;const L=new Ke,w=A,D=N-A;I.left=L,L.boundingData=new Float32Array(6),bs(p,w,D,L.boundingData,f),g(L,w,D,f,S+1);const U=new Ke,b=N,G=F-D;I.right=U,U.boundingData=new Float32Array(6),bs(p,b,G,U.boundingData,f),g(U,b,G,f,S+1)}return I}}function Cr(c,t){const e=c.geometry;t.indirect&&(c._indirectBuffer=Ir(e,t.useSharedArrayBuffer),rr(e)&&!t.verbose&&console.warn('MeshBVH: Provided geometry contains groups that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.')),c._indirectBuffer||or(e,t);const s=pr(c,t);let i,o,n;const r=[],a=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer;for(let u=0;u<s.length;u++){const h=s[u];let f=l(h);const p=new a(ms*f);i=new Float32Array(p),o=new Uint32Array(p),n=new Uint16Array(p),d(0,h),r.push(p)}c._roots=r;return;function l(u){return u.count?1:1+l(u.left)+l(u.right)}function d(u,h){const f=u/4,p=u/2,T=!!h.count,m=h.boundingData;for(let C=0;C<6;C++)i[f+C]=m[C];if(T){const C=h.offset,R=h.count;return o[f+6]=C,n[p+14]=R,n[p+15]=Ps,u+ms}else{const C=h.left,R=h.right,g=h.splitAxis;let I;if(I=d(u+ms,C),I/4>Math.pow(2,32))throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return o[f+6]=I/4,I=d(I,R),o[f+7]=g,I}}}class Mt{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(t,e){let s=1/0,i=-1/0;for(let o=0,n=t.length;o<n;o++){const a=t[o][e];s=a<s?a:s,i=a>i?a:i}this.min=s,this.max=i}setFromPoints(t,e){let s=1/0,i=-1/0;for(let o=0,n=e.length;o<n;o++){const r=e[o],a=t.dot(r);s=a<s?a:s,i=a>i?a:i}this.min=s,this.max=i}isSeparated(t){return this.min>t.max||t.min>this.max}}Mt.prototype.setFromBox=function(){const c=new O;return function(e,s){const i=s.min,o=s.max;let n=1/0,r=-1/0;for(let a=0;a<=1;a++)for(let l=0;l<=1;l++)for(let d=0;d<=1;d++){c.x=i.x*a+o.x*(1-a),c.y=i.y*l+o.y*(1-l),c.z=i.z*d+o.z*(1-d);const u=e.dot(c);n=Math.min(u,n),r=Math.max(u,r)}this.min=n,this.max=r}}();const Tr=function(){const c=new O,t=new O,e=new O;return function(i,o,n){const r=i.start,a=c,l=o.start,d=t;e.subVectors(r,l),c.subVectors(i.end,i.start),t.subVectors(o.end,o.start);const u=e.dot(d),h=d.dot(a),f=d.dot(d),p=e.dot(a),m=a.dot(a)*f-h*h;let C,R;m!==0?C=(u*h-p*f)/m:C=0,R=(u+C*h)/f,n.x=C,n.y=R}}(),wi=function(){const c=new gt,t=new O,e=new O;return function(i,o,n,r){Tr(i,o,c);let a=c.x,l=c.y;if(a>=0&&a<=1&&l>=0&&l<=1){i.at(a,n),o.at(l,r);return}else if(a>=0&&a<=1){l<0?o.at(0,r):o.at(1,r),i.closestPointToPoint(r,!0,n);return}else if(l>=0&&l<=1){a<0?i.at(0,n):i.at(1,n),o.closestPointToPoint(n,!0,r);return}else{let d;a<0?d=i.start:d=i.end;let u;l<0?u=o.start:u=o.end;const h=t,f=e;if(i.closestPointToPoint(u,!0,t),o.closestPointToPoint(d,!0,e),h.distanceToSquared(u)<=f.distanceToSquared(d)){n.copy(h),r.copy(u);return}else{n.copy(d),r.copy(f);return}}}}(),mr=function(){const c=new O,t=new O,e=new Re,s=new At;return function(o,n){const{radius:r,center:a}=o,{a:l,b:d,c:u}=n;if(s.start=l,s.end=d,s.closestPointToPoint(a,!0,c).distanceTo(a)<=r||(s.start=l,s.end=u,s.closestPointToPoint(a,!0,c).distanceTo(a)<=r)||(s.start=d,s.end=u,s.closestPointToPoint(a,!0,c).distanceTo(a)<=r))return!0;const T=n.getPlane(e);if(Math.abs(T.distanceToPoint(a))<=r){const C=T.projectPoint(a,t);if(n.containsPoint(C))return!0}return!1}}(),Rr=1e-15;function vs(c){return Math.abs(c)<Rr}class Ft extends pe{constructor(...t){super(...t),this.isExtendedTriangle=!0,this.satAxes=new Array(4).fill().map(()=>new O),this.satBounds=new Array(4).fill().map(()=>new Mt),this.points=[this.a,this.b,this.c],this.sphere=new Os,this.plane=new Re,this.needsUpdate=!0}intersectsSphere(t){return mr(t,this)}update(){const t=this.a,e=this.b,s=this.c,i=this.points,o=this.satAxes,n=this.satBounds,r=o[0],a=n[0];this.getNormal(r),a.setFromPoints(r,i);const l=o[1],d=n[1];l.subVectors(t,e),d.setFromPoints(l,i);const u=o[2],h=n[2];u.subVectors(e,s),h.setFromPoints(u,i);const f=o[3],p=n[3];f.subVectors(s,t),p.setFromPoints(f,i),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(r,t),this.needsUpdate=!1}}Ft.prototype.closestPointToSegment=function(){const c=new O,t=new O,e=new At;return function(i,o=null,n=null){const{start:r,end:a}=i,l=this.points;let d,u=1/0;for(let h=0;h<3;h++){const f=(h+1)%3;e.start.copy(l[h]),e.end.copy(l[f]),wi(e,i,c,t),d=c.distanceToSquared(t),d<u&&(u=d,o&&o.copy(c),n&&n.copy(t))}return this.closestPointToPoint(r,c),d=r.distanceToSquared(c),d<u&&(u=d,o&&o.copy(c),n&&n.copy(r)),this.closestPointToPoint(a,c),d=a.distanceToSquared(c),d<u&&(u=d,o&&o.copy(c),n&&n.copy(a)),Math.sqrt(u)}}();Ft.prototype.intersectsTriangle=function(){const c=new Ft,t=new Array(3),e=new Array(3),s=new Mt,i=new Mt,o=new O,n=new O,r=new O,a=new O,l=new O,d=new At,u=new At,h=new At,f=new O;function p(T,m,C){const R=T.points;let g=0,I=-1;for(let A=0;A<3;A++){const{start:F,end:_}=d;F.copy(R[A]),_.copy(R[(A+1)%3]),d.delta(n);const S=vs(m.distanceToPoint(F));if(vs(m.normal.dot(n))&&S){C.copy(d),g=2;break}const y=m.intersectLine(d,f);if(!y&&S&&f.copy(F),(y||S)&&!vs(f.distanceTo(_))){if(g<=1)(g===1?C.start:C.end).copy(f),S&&(I=g);else if(g>=2){(I===1?C.start:C.end).copy(f),g=2;break}if(g++,g===2&&I===-1)break}}return g}return function(m,C=null,R=!1){this.needsUpdate&&this.update(),m.isExtendedTriangle?m.needsUpdate&&m.update():(c.copy(m),c.update(),m=c);const g=this.plane,I=m.plane;if(Math.abs(g.normal.dot(I.normal))>1-1e-10){const A=this.satBounds,F=this.satAxes;e[0]=m.a,e[1]=m.b,e[2]=m.c;for(let y=0;y<4;y++){const N=A[y],L=F[y];if(s.setFromPoints(L,e),N.isSeparated(s))return!1}const _=m.satBounds,S=m.satAxes;t[0]=this.a,t[1]=this.b,t[2]=this.c;for(let y=0;y<4;y++){const N=_[y],L=S[y];if(s.setFromPoints(L,t),N.isSeparated(s))return!1}for(let y=0;y<4;y++){const N=F[y];for(let L=0;L<4;L++){const w=S[L];if(o.crossVectors(N,w),s.setFromPoints(o,t),i.setFromPoints(o,e),s.isSeparated(i))return!1}}return C&&(R||console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),C.start.set(0,0,0),C.end.set(0,0,0)),!0}else{const A=p(this,I,u);if(A===1&&m.containsPoint(u.end))return C&&(C.start.copy(u.end),C.end.copy(u.end)),!0;if(A!==2)return!1;const F=p(m,g,h);if(F===1&&this.containsPoint(h.end))return C&&(C.start.copy(h.end),C.end.copy(h.end)),!0;if(F!==2)return!1;if(u.delta(r),h.delta(a),r.dot(a)<0){let D=h.start;h.start=h.end,h.end=D}const _=u.start.dot(r),S=u.end.dot(r),y=h.start.dot(r),N=h.end.dot(r),L=S<y,w=_<N;return _!==N&&y!==S&&L===w?!1:(C&&(l.subVectors(u.start,h.start),l.dot(r)>0?C.start.copy(u.start):C.start.copy(h.start),l.subVectors(u.end,h.end),l.dot(r)<0?C.end.copy(u.end):C.end.copy(h.end)),!0)}}}();Ft.prototype.distanceToPoint=function(){const c=new O;return function(e){return this.closestPointToPoint(e,c),e.distanceTo(c)}}();Ft.prototype.distanceToTriangle=function(){const c=new O,t=new O,e=["a","b","c"],s=new At,i=new At;return function(n,r=null,a=null){const l=r||a?s:null;if(this.intersectsTriangle(n,l))return(r||a)&&(r&&l.getCenter(r),a&&l.getCenter(a)),0;let d=1/0;for(let u=0;u<3;u++){let h;const f=e[u],p=n[f];this.closestPointToPoint(p,c),h=p.distanceToSquared(c),h<d&&(d=h,r&&r.copy(c),a&&a.copy(p));const T=this[f];n.closestPointToPoint(T,c),h=T.distanceToSquared(c),h<d&&(d=h,r&&r.copy(T),a&&a.copy(c))}for(let u=0;u<3;u++){const h=e[u],f=e[(u+1)%3];s.set(this[h],this[f]);for(let p=0;p<3;p++){const T=e[p],m=e[(p+1)%3];i.set(n[T],n[m]),wi(s,i,c,t);const C=c.distanceToSquared(t);C<d&&(d=C,r&&r.copy(c),a&&a.copy(t))}}return Math.sqrt(d)}}();class ct{constructor(t,e,s){this.isOrientedBox=!0,this.min=new O,this.max=new O,this.matrix=new W,this.invMatrix=new W,this.points=new Array(8).fill().map(()=>new O),this.satAxes=new Array(3).fill().map(()=>new O),this.satBounds=new Array(3).fill().map(()=>new Mt),this.alignedSatBounds=new Array(3).fill().map(()=>new Mt),this.needsUpdate=!1,t&&this.min.copy(t),e&&this.max.copy(e),s&&this.matrix.copy(s)}set(t,e,s){this.min.copy(t),this.max.copy(e),this.matrix.copy(s),this.needsUpdate=!0}copy(t){this.min.copy(t.min),this.max.copy(t.max),this.matrix.copy(t.matrix),this.needsUpdate=!0}}ct.prototype.update=function(){return function(){const t=this.matrix,e=this.min,s=this.max,i=this.points;for(let l=0;l<=1;l++)for(let d=0;d<=1;d++)for(let u=0;u<=1;u++){const h=1*l|2*d|4*u,f=i[h];f.x=l?s.x:e.x,f.y=d?s.y:e.y,f.z=u?s.z:e.z,f.applyMatrix4(t)}const o=this.satBounds,n=this.satAxes,r=i[0];for(let l=0;l<3;l++){const d=n[l],u=o[l],h=1<<l,f=i[h];d.subVectors(r,f),u.setFromPoints(d,i)}const a=this.alignedSatBounds;a[0].setFromPointsField(i,"x"),a[1].setFromPointsField(i,"y"),a[2].setFromPointsField(i,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1}}();ct.prototype.intersectsBox=function(){const c=new Mt;return function(e){this.needsUpdate&&this.update();const s=e.min,i=e.max,o=this.satBounds,n=this.satAxes,r=this.alignedSatBounds;if(c.min=s.x,c.max=i.x,r[0].isSeparated(c)||(c.min=s.y,c.max=i.y,r[1].isSeparated(c))||(c.min=s.z,c.max=i.z,r[2].isSeparated(c)))return!1;for(let a=0;a<3;a++){const l=n[a],d=o[a];if(c.setFromBox(l,e),d.isSeparated(c))return!1}return!0}}();ct.prototype.intersectsTriangle=function(){const c=new Ft,t=new Array(3),e=new Mt,s=new Mt,i=new O;return function(n){this.needsUpdate&&this.update(),n.isExtendedTriangle?n.needsUpdate&&n.update():(c.copy(n),c.update(),n=c);const r=this.satBounds,a=this.satAxes;t[0]=n.a,t[1]=n.b,t[2]=n.c;for(let h=0;h<3;h++){const f=r[h],p=a[h];if(e.setFromPoints(p,t),f.isSeparated(e))return!1}const l=n.satBounds,d=n.satAxes,u=this.points;for(let h=0;h<3;h++){const f=l[h],p=d[h];if(e.setFromPoints(p,u),f.isSeparated(e))return!1}for(let h=0;h<3;h++){const f=a[h];for(let p=0;p<4;p++){const T=d[p];if(i.crossVectors(f,T),e.setFromPoints(i,t),s.setFromPoints(i,u),e.isSeparated(s))return!1}}return!0}}();ct.prototype.closestPointToPoint=function(){return function(t,e){return this.needsUpdate&&this.update(),e.copy(t).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),e}}();ct.prototype.distanceToPoint=function(){const c=new O;return function(e){return this.closestPointToPoint(e,c),e.distanceTo(c)}}();ct.prototype.distanceToBox=function(){const c=["x","y","z"],t=new Array(12).fill().map(()=>new At),e=new Array(12).fill().map(()=>new At),s=new O,i=new O;return function(n,r=0,a=null,l=null){if(this.needsUpdate&&this.update(),this.intersectsBox(n))return(a||l)&&(n.getCenter(i),this.closestPointToPoint(i,s),n.closestPointToPoint(s,i),a&&a.copy(s),l&&l.copy(i)),0;const d=r*r,u=n.min,h=n.max,f=this.points;let p=1/0;for(let m=0;m<8;m++){const C=f[m];i.copy(C).clamp(u,h);const R=C.distanceToSquared(i);if(R<p&&(p=R,a&&a.copy(C),l&&l.copy(i),R<d))return Math.sqrt(R)}let T=0;for(let m=0;m<3;m++)for(let C=0;C<=1;C++)for(let R=0;R<=1;R++){const g=(m+1)%3,I=(m+2)%3,A=C<<g|R<<I,F=1<<m|C<<g|R<<I,_=f[A],S=f[F];t[T].set(_,S);const N=c[m],L=c[g],w=c[I],D=e[T],U=D.start,b=D.end;U[N]=u[N],U[L]=C?u[L]:h[L],U[w]=R?u[w]:h[L],b[N]=h[N],b[L]=C?u[L]:h[L],b[w]=R?u[w]:h[L],T++}for(let m=0;m<=1;m++)for(let C=0;C<=1;C++)for(let R=0;R<=1;R++){i.x=m?h.x:u.x,i.y=C?h.y:u.y,i.z=R?h.z:u.z,this.closestPointToPoint(i,s);const g=i.distanceToSquared(s);if(g<p&&(p=g,a&&a.copy(s),l&&l.copy(i),g<d))return Math.sqrt(g)}for(let m=0;m<12;m++){const C=t[m];for(let R=0;R<12;R++){const g=e[R];wi(C,g,s,i);const I=s.distanceToSquared(i);if(I<p&&(p=I,a&&a.copy(s),l&&l.copy(i),I<d))return Math.sqrt(I)}}return Math.sqrt(p)}}();class Li{constructor(t){this._getNewPrimitive=t,this._primitives=[]}getPrimitive(){const t=this._primitives;return t.length===0?this._getNewPrimitive():t.pop()}releasePrimitive(t){this._primitives.push(t)}}class Ar extends Li{constructor(){super(()=>new Ft)}}const Et=new Ar;function ht(c,t){return t[c+15]===65535}function dt(c,t){return t[c+6]}function ft(c,t){return t[c+14]}function It(c){return c+8}function pt(c,t){return t[c+6]}function Yn(c,t){return t[c+7]}class gr{constructor(){this.float32Array=null,this.uint16Array=null,this.uint32Array=null;const t=[];let e=null;this.setBuffer=s=>{e&&t.push(e),e=s,this.float32Array=new Float32Array(s),this.uint16Array=new Uint16Array(s),this.uint32Array=new Uint32Array(s)},this.clearBuffer=()=>{e=null,this.float32Array=null,this.uint16Array=null,this.uint32Array=null,t.length!==0&&this.setBuffer(t.pop())}}}const X=new gr;let Bt,Ce;const ee=[],Je=new Li(()=>new it);function Fr(c,t,e,s,i,o){Bt=Je.getPrimitive(),Ce=Je.getPrimitive(),ee.push(Bt,Ce),X.setBuffer(c._roots[t]);const n=si(0,c.geometry,e,s,i,o);X.clearBuffer(),Je.releasePrimitive(Bt),Je.releasePrimitive(Ce),ee.pop(),ee.pop();const r=ee.length;return r>0&&(Ce=ee[r-1],Bt=ee[r-2]),n}function si(c,t,e,s,i=null,o=0,n=0){const{float32Array:r,uint16Array:a,uint32Array:l}=X;let d=c*2;if(ht(d,a)){const h=dt(c,l),f=ft(d,a);return q(c,r,Bt),s(h,f,!1,n,o+c,Bt)}else{let h=function(w){const{uint16Array:D,uint32Array:U}=X;let b=w*2;for(;!ht(b,D);)w=It(w),b=w*2;return dt(w,U)},f=function(w){const{uint16Array:D,uint32Array:U}=X;let b=w*2;for(;!ht(b,D);)w=pt(w,U),b=w*2;return dt(w,U)+ft(b,D)};const p=It(c),T=pt(c,l);let m=p,C=T,R,g,I,A;if(i&&(I=Bt,A=Ce,q(m,r,I),q(C,r,A),R=i(I),g=i(A),g<R)){m=T,C=p;const w=R;R=g,g=w,I=A}I||(I=Bt,q(m,r,I));const F=ht(m*2,a),_=e(I,F,R,n+1,o+m);let S;if(_===Xi){const w=h(m),U=f(m)-w;S=s(w,U,!0,n+1,o+m,I)}else S=_&&si(m,t,e,s,i,o,n+1);if(S)return!0;A=Ce,q(C,r,A);const y=ht(C*2,a),N=e(A,y,g,n+1,o+C);let L;if(N===Xi){const w=h(C),U=f(C)-w;L=s(w,U,!0,n+1,o+C,A)}else L=N&&si(C,t,e,s,i,o,n+1);return!!L}}const Se=new O,Bs=new O;function _r(c,t,e={},s=0,i=1/0){const o=s*s,n=i*i;let r=1/0,a=null;if(c.shapecast({boundsTraverseOrder:d=>(Se.copy(t).clamp(d.min,d.max),Se.distanceToSquared(t)),intersectsBounds:(d,u,h)=>h<r&&h<n,intersectsTriangle:(d,u)=>{d.closestPointToPoint(t,Se);const h=t.distanceToSquared(Se);return h<r&&(Bs.copy(Se),r=h,a=u),h<o}}),r===1/0)return null;const l=Math.sqrt(r);return e.point?e.point.copy(Bs):e.point=Bs.clone(),e.distance=l,e.faceIndex=a,e}const se=new O,ie=new O,ne=new O,ts=new gt,es=new gt,ss=new gt,$i=new O,Ki=new O,Ji=new O,is=new O;function Or(c,t,e,s,i,o){let n;return o===$o?n=c.intersectTriangle(s,e,t,!0,i):n=c.intersectTriangle(t,e,s,o!==We,i),n===null?null:{distance:c.origin.distanceTo(i),point:i.clone()}}function Sr(c,t,e,s,i,o,n,r,a){se.fromBufferAttribute(t,o),ie.fromBufferAttribute(t,n),ne.fromBufferAttribute(t,r);const l=Or(c,se,ie,ne,is,a);if(l){s&&(ts.fromBufferAttribute(s,o),es.fromBufferAttribute(s,n),ss.fromBufferAttribute(s,r),l.uv=pe.getInterpolation(is,se,ie,ne,ts,es,ss,new gt)),i&&(ts.fromBufferAttribute(i,o),es.fromBufferAttribute(i,n),ss.fromBufferAttribute(i,r),l.uv1=pe.getInterpolation(is,se,ie,ne,ts,es,ss,new gt)),e&&($i.fromBufferAttribute(e,o),Ki.fromBufferAttribute(e,n),Ji.fromBufferAttribute(e,r),l.normal=pe.getInterpolation(is,se,ie,ne,$i,Ki,Ji,new O),l.normal.dot(c.direction)>0&&l.normal.multiplyScalar(-1));const d={a:o,b:n,c:r,normal:new O,materialIndex:0};pe.getNormal(se,ie,ne,d.normal),l.face=d,l.faceIndex=o}return l}function Ns(c,t,e,s,i){const o=s*3;let n=o+0,r=o+1,a=o+2;const l=c.index;c.index&&(n=l.getX(n),r=l.getX(r),a=l.getX(a));const{position:d,normal:u,uv:h,uv1:f}=c.attributes,p=Sr(e,d,u,h,f,n,r,a,t);return p?(p.faceIndex=s,i&&i.push(p),p):null}function J(c,t,e,s){const i=c.a,o=c.b,n=c.c;let r=t,a=t+1,l=t+2;e&&(r=e.getX(r),a=e.getX(a),l=e.getX(l)),i.x=s.getX(r),i.y=s.getY(r),i.z=s.getZ(r),o.x=s.getX(a),o.y=s.getY(a),o.z=s.getZ(a),n.x=s.getX(l),n.y=s.getY(l),n.z=s.getZ(l)}function yr(c,t,e,s,i,o){const{geometry:n,_indirectBuffer:r}=c;for(let a=s,l=s+i;a<l;a++)Ns(n,t,e,a,o)}function Pr(c,t,e,s,i){const{geometry:o,_indirectBuffer:n}=c;let r=1/0,a=null;for(let l=s,d=s+i;l<d;l++){let u;u=Ns(o,t,e,l),u&&u.distance<r&&(a=u,r=u.distance)}return a}function Nr(c,t,e,s,i,o,n){const{geometry:r}=e,{index:a}=r,l=r.attributes.position;for(let d=c,u=t+c;d<u;d++){let h;if(h=d,J(n,h*3,a,l),n.needsUpdate=!0,s(n,h,i,o))return!0}return!1}function wr(c,t=null){t&&Array.isArray(t)&&(t=new Set(t));const e=c.geometry,s=e.index?e.index.array:null,i=e.attributes.position;let o,n,r,a,l=0;const d=c._roots;for(let h=0,f=d.length;h<f;h++)o=d[h],n=new Uint32Array(o),r=new Uint16Array(o),a=new Float32Array(o),u(0,l),l+=o.byteLength;function u(h,f,p=!1){const T=h*2;if(r[T+15]===Ps){const C=n[h+6],R=r[T+14];let g=1/0,I=1/0,A=1/0,F=-1/0,_=-1/0,S=-1/0;for(let y=3*C,N=3*(C+R);y<N;y++){let L=s[y];const w=i.getX(L),D=i.getY(L),U=i.getZ(L);w<g&&(g=w),w>F&&(F=w),D<I&&(I=D),D>_&&(_=D),U<A&&(A=U),U>S&&(S=U)}return a[h+0]!==g||a[h+1]!==I||a[h+2]!==A||a[h+3]!==F||a[h+4]!==_||a[h+5]!==S?(a[h+0]=g,a[h+1]=I,a[h+2]=A,a[h+3]=F,a[h+4]=_,a[h+5]=S,!0):!1}else{const C=h+8,R=n[h+6],g=C+f,I=R+f;let A=p,F=!1,_=!1;t?A||(F=t.has(g),_=t.has(I),A=!F&&!_):(F=!0,_=!0);const S=A||F,y=A||_;let N=!1;S&&(N=u(C,f,A));let L=!1;y&&(L=u(R,f,A));const w=N||L;if(w)for(let D=0;D<3;D++){const U=C+D,b=R+D,G=a[U],j=a[U+3],tt=a[b],Z=a[b+3];a[h+D]=G<tt?G:tt,a[h+D+3]=j>Z?j:Z}return w}}}const tn=new it;function Gt(c,t,e,s){return q(c,t,tn),e.intersectBox(tn,s)}function Lr(c,t,e,s,i,o){const{geometry:n,_indirectBuffer:r}=c;for(let a=s,l=s+i;a<l;a++){let d=r?r[a]:a;Ns(n,t,e,d,o)}}function Mr(c,t,e,s,i){const{geometry:o,_indirectBuffer:n}=c;let r=1/0,a=null;for(let l=s,d=s+i;l<d;l++){let u;u=Ns(o,t,e,n?n[l]:l),u&&u.distance<r&&(a=u,r=u.distance)}return a}function Dr(c,t,e,s,i,o,n){const{geometry:r}=e,{index:a}=r,l=r.attributes.position;for(let d=c,u=t+c;d<u;d++){let h;if(h=e.resolveTriangleIndex(d),J(n,h*3,a,l),n.needsUpdate=!0,s(n,h,i,o))return!0}return!1}const en=new O;function Ur(c,t,e,s,i){X.setBuffer(c._roots[t]),ii(0,c,e,s,i),X.clearBuffer()}function ii(c,t,e,s,i){const{float32Array:o,uint16Array:n,uint32Array:r}=X,a=c*2;if(ht(a,n)){const d=dt(c,r),u=ft(a,n);yr(t,e,s,d,u,i)}else{const d=It(c);Gt(d,o,s,en)&&ii(d,t,e,s,i);const u=pt(c,r);Gt(u,o,s,en)&&ii(u,t,e,s,i)}}const sn=new O,xr=["x","y","z"];function br(c,t,e,s){X.setBuffer(c._roots[t]);const i=ni(0,c,e,s);return X.clearBuffer(),i}function ni(c,t,e,s){const{float32Array:i,uint16Array:o,uint32Array:n}=X;let r=c*2;if(ht(r,o)){const l=dt(c,n),d=ft(r,o);return Pr(t,e,s,l,d)}else{const l=Yn(c,n),d=xr[l],h=s.direction[d]>=0;let f,p;h?(f=It(c),p=pt(c,n)):(f=pt(c,n),p=It(c));const m=Gt(f,i,s,sn)?ni(f,t,e,s):null;if(m){const g=m.point[d];if(h?g<=i[p+l]:g>=i[p+l+3])return m}const R=Gt(p,i,s,sn)?ni(p,t,e,s):null;return m&&R?m.distance<=R.distance?m:R:m||R||null}}const ns=new it,oe=new Ft,re=new Ft,ye=new W,nn=new ct,os=new ct;function vr(c,t,e,s){X.setBuffer(c._roots[t]);const i=oi(0,c,e,s);return X.clearBuffer(),i}function oi(c,t,e,s,i=null){const{float32Array:o,uint16Array:n,uint32Array:r}=X;let a=c*2;if(i===null&&(e.boundingBox||e.computeBoundingBox(),nn.set(e.boundingBox.min,e.boundingBox.max,s),i=nn),ht(a,n)){const d=t.geometry,u=d.index,h=d.attributes.position,f=e.index,p=e.attributes.position,T=dt(c,r),m=ft(a,n);if(ye.copy(s).invert(),e.boundsTree)return q(c,o,os),os.matrix.copy(ye),os.needsUpdate=!0,e.boundsTree.shapecast({intersectsBounds:R=>os.intersectsBox(R),intersectsTriangle:R=>{R.a.applyMatrix4(s),R.b.applyMatrix4(s),R.c.applyMatrix4(s),R.needsUpdate=!0;for(let g=T*3,I=(m+T)*3;g<I;g+=3)if(J(re,g,u,h),re.needsUpdate=!0,R.intersectsTriangle(re))return!0;return!1}});for(let C=T*3,R=(m+T)*3;C<R;C+=3){J(oe,C,u,h),oe.a.applyMatrix4(ye),oe.b.applyMatrix4(ye),oe.c.applyMatrix4(ye),oe.needsUpdate=!0;for(let g=0,I=f.count;g<I;g+=3)if(J(re,g,f,p),re.needsUpdate=!0,oe.intersectsTriangle(re))return!0}}else{const d=c+8,u=r[c+6];return q(d,o,ns),!!(i.intersectsBox(ns)&&oi(d,t,e,s,i)||(q(u,o,ns),i.intersectsBox(ns)&&oi(u,t,e,s,i)))}}const rs=new W,Ys=new ct,Pe=new ct,Br=new O,Yr=new O,zr=new O,Gr=new O;function Vr(c,t,e,s={},i={},o=0,n=1/0){t.boundingBox||t.computeBoundingBox(),Ys.set(t.boundingBox.min,t.boundingBox.max,e),Ys.needsUpdate=!0;const r=c.geometry,a=r.attributes.position,l=r.index,d=t.attributes.position,u=t.index,h=Et.getPrimitive(),f=Et.getPrimitive();let p=Br,T=Yr,m=null,C=null;i&&(m=zr,C=Gr);let R=1/0,g=null,I=null;return rs.copy(e).invert(),Pe.matrix.copy(rs),c.shapecast({boundsTraverseOrder:A=>Ys.distanceToBox(A),intersectsBounds:(A,F,_)=>_<R&&_<n?(F&&(Pe.min.copy(A.min),Pe.max.copy(A.max),Pe.needsUpdate=!0),!0):!1,intersectsRange:(A,F)=>{if(t.boundsTree)return t.boundsTree.shapecast({boundsTraverseOrder:S=>Pe.distanceToBox(S),intersectsBounds:(S,y,N)=>N<R&&N<n,intersectsRange:(S,y)=>{for(let N=S,L=S+y;N<L;N++){J(f,3*N,u,d),f.a.applyMatrix4(e),f.b.applyMatrix4(e),f.c.applyMatrix4(e),f.needsUpdate=!0;for(let w=A,D=A+F;w<D;w++){J(h,3*w,l,a),h.needsUpdate=!0;const U=h.distanceToTriangle(f,p,m);if(U<R&&(T.copy(p),C&&C.copy(m),R=U,g=w,I=N),U<o)return!0}}}});{const _=Ae(t);for(let S=0,y=_;S<y;S++){J(f,3*S,u,d),f.a.applyMatrix4(e),f.b.applyMatrix4(e),f.c.applyMatrix4(e),f.needsUpdate=!0;for(let N=A,L=A+F;N<L;N++){J(h,3*N,l,a),h.needsUpdate=!0;const w=h.distanceToTriangle(f,p,m);if(w<R&&(T.copy(p),C&&C.copy(m),R=w,g=N,I=S),w<o)return!0}}}}}),Et.releasePrimitive(h),Et.releasePrimitive(f),R===1/0?null:(s.point?s.point.copy(T):s.point=T.clone(),s.distance=R,s.faceIndex=g,i&&(i.point?i.point.copy(C):i.point=C.clone(),i.point.applyMatrix4(rs),T.applyMatrix4(rs),i.distance=T.sub(i.point).length(),i.faceIndex=I),s)}function Hr(c,t=null){t&&Array.isArray(t)&&(t=new Set(t));const e=c.geometry,s=e.index?e.index.array:null,i=e.attributes.position;let o,n,r,a,l=0;const d=c._roots;for(let h=0,f=d.length;h<f;h++)o=d[h],n=new Uint32Array(o),r=new Uint16Array(o),a=new Float32Array(o),u(0,l),l+=o.byteLength;function u(h,f,p=!1){const T=h*2;if(r[T+15]===Ps){const C=n[h+6],R=r[T+14];let g=1/0,I=1/0,A=1/0,F=-1/0,_=-1/0,S=-1/0;for(let y=C,N=C+R;y<N;y++){const L=3*c.resolveTriangleIndex(y);for(let w=0;w<3;w++){let D=L+w;D=s?s[D]:D;const U=i.getX(D),b=i.getY(D),G=i.getZ(D);U<g&&(g=U),U>F&&(F=U),b<I&&(I=b),b>_&&(_=b),G<A&&(A=G),G>S&&(S=G)}}return a[h+0]!==g||a[h+1]!==I||a[h+2]!==A||a[h+3]!==F||a[h+4]!==_||a[h+5]!==S?(a[h+0]=g,a[h+1]=I,a[h+2]=A,a[h+3]=F,a[h+4]=_,a[h+5]=S,!0):!1}else{const C=h+8,R=n[h+6],g=C+f,I=R+f;let A=p,F=!1,_=!1;t?A||(F=t.has(g),_=t.has(I),A=!F&&!_):(F=!0,_=!0);const S=A||F,y=A||_;let N=!1;S&&(N=u(C,f,A));let L=!1;y&&(L=u(R,f,A));const w=N||L;if(w)for(let D=0;D<3;D++){const U=C+D,b=R+D,G=a[U],j=a[U+3],tt=a[b],Z=a[b+3];a[h+D]=G<tt?G:tt,a[h+D+3]=j>Z?j:Z}return w}}}const on=new O;function kr(c,t,e,s,i){X.setBuffer(c._roots[t]),ri(0,c,e,s,i),X.clearBuffer()}function ri(c,t,e,s,i){const{float32Array:o,uint16Array:n,uint32Array:r}=X,a=c*2;if(ht(a,n)){const d=dt(c,r),u=ft(a,n);Lr(t,e,s,d,u,i)}else{const d=It(c);Gt(d,o,s,on)&&ri(d,t,e,s,i);const u=pt(c,r);Gt(u,o,s,on)&&ri(u,t,e,s,i)}}const rn=new O,Wr=["x","y","z"];function Xr(c,t,e,s){X.setBuffer(c._roots[t]);const i=ai(0,c,e,s);return X.clearBuffer(),i}function ai(c,t,e,s){const{float32Array:i,uint16Array:o,uint32Array:n}=X;let r=c*2;if(ht(r,o)){const l=dt(c,n),d=ft(r,o);return Mr(t,e,s,l,d)}else{const l=Yn(c,n),d=Wr[l],h=s.direction[d]>=0;let f,p;h?(f=It(c),p=pt(c,n)):(f=pt(c,n),p=It(c));const m=Gt(f,i,s,rn)?ai(f,t,e,s):null;if(m){const g=m.point[d];if(h?g<=i[p+l]:g>=i[p+l+3])return m}const R=Gt(p,i,s,rn)?ai(p,t,e,s):null;return m&&R?m.distance<=R.distance?m:R:m||R||null}}const as=new it,ae=new Ft,ce=new Ft,Ne=new W,an=new ct,cs=new ct;function Zr(c,t,e,s){X.setBuffer(c._roots[t]);const i=ci(0,c,e,s);return X.clearBuffer(),i}function ci(c,t,e,s,i=null){const{float32Array:o,uint16Array:n,uint32Array:r}=X;let a=c*2;if(i===null&&(e.boundingBox||e.computeBoundingBox(),an.set(e.boundingBox.min,e.boundingBox.max,s),i=an),ht(a,n)){const d=t.geometry,u=d.index,h=d.attributes.position,f=e.index,p=e.attributes.position,T=dt(c,r),m=ft(a,n);if(Ne.copy(s).invert(),e.boundsTree)return q(c,o,cs),cs.matrix.copy(Ne),cs.needsUpdate=!0,e.boundsTree.shapecast({intersectsBounds:R=>cs.intersectsBox(R),intersectsTriangle:R=>{R.a.applyMatrix4(s),R.b.applyMatrix4(s),R.c.applyMatrix4(s),R.needsUpdate=!0;for(let g=T,I=m+T;g<I;g++)if(J(ce,3*t.resolveTriangleIndex(g),u,h),ce.needsUpdate=!0,R.intersectsTriangle(ce))return!0;return!1}});for(let C=T,R=m+T;C<R;C++){const g=t.resolveTriangleIndex(C);J(ae,3*g,u,h),ae.a.applyMatrix4(Ne),ae.b.applyMatrix4(Ne),ae.c.applyMatrix4(Ne),ae.needsUpdate=!0;for(let I=0,A=f.count;I<A;I+=3)if(J(ce,I,f,p),ce.needsUpdate=!0,ae.intersectsTriangle(ce))return!0}}else{const d=c+8,u=r[c+6];return q(d,o,as),!!(i.intersectsBox(as)&&ci(d,t,e,s,i)||(q(u,o,as),i.intersectsBox(as)&&ci(u,t,e,s,i)))}}const ls=new W,zs=new ct,we=new ct,Qr=new O,jr=new O,qr=new O,$r=new O;function Kr(c,t,e,s={},i={},o=0,n=1/0){t.boundingBox||t.computeBoundingBox(),zs.set(t.boundingBox.min,t.boundingBox.max,e),zs.needsUpdate=!0;const r=c.geometry,a=r.attributes.position,l=r.index,d=t.attributes.position,u=t.index,h=Et.getPrimitive(),f=Et.getPrimitive();let p=Qr,T=jr,m=null,C=null;i&&(m=qr,C=$r);let R=1/0,g=null,I=null;return ls.copy(e).invert(),we.matrix.copy(ls),c.shapecast({boundsTraverseOrder:A=>zs.distanceToBox(A),intersectsBounds:(A,F,_)=>_<R&&_<n?(F&&(we.min.copy(A.min),we.max.copy(A.max),we.needsUpdate=!0),!0):!1,intersectsRange:(A,F)=>{if(t.boundsTree){const _=t.boundsTree;return _.shapecast({boundsTraverseOrder:S=>we.distanceToBox(S),intersectsBounds:(S,y,N)=>N<R&&N<n,intersectsRange:(S,y)=>{for(let N=S,L=S+y;N<L;N++){const w=_.resolveTriangleIndex(N);J(f,3*w,u,d),f.a.applyMatrix4(e),f.b.applyMatrix4(e),f.c.applyMatrix4(e),f.needsUpdate=!0;for(let D=A,U=A+F;D<U;D++){const b=c.resolveTriangleIndex(D);J(h,3*b,l,a),h.needsUpdate=!0;const G=h.distanceToTriangle(f,p,m);if(G<R&&(T.copy(p),C&&C.copy(m),R=G,g=D,I=N),G<o)return!0}}}})}else{const _=Ae(t);for(let S=0,y=_;S<y;S++){J(f,3*S,u,d),f.a.applyMatrix4(e),f.b.applyMatrix4(e),f.c.applyMatrix4(e),f.needsUpdate=!0;for(let N=A,L=A+F;N<L;N++){const w=c.resolveTriangleIndex(N);J(h,3*w,l,a),h.needsUpdate=!0;const D=h.distanceToTriangle(f,p,m);if(D<R&&(T.copy(p),C&&C.copy(m),R=D,g=N,I=S),D<o)return!0}}}}}),Et.releasePrimitive(h),Et.releasePrimitive(f),R===1/0?null:(s.point?s.point.copy(T):s.point=T.clone(),s.distance=R,s.faceIndex=g,i&&(i.point?i.point.copy(C):i.point=C.clone(),i.point.applyMatrix4(ls),T.applyMatrix4(ls),i.distance=T.sub(i.point).length(),i.faceIndex=I),s)}function Jr(){return typeof SharedArrayBuffer<"u"}const ze=new X.constructor,_s=new X.constructor,vt=new Li(()=>new it),le=new it,he=new it,Gs=new it,Vs=new it;let Hs=!1;function ta(c,t,e,s){if(Hs)throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");Hs=!0;const i=c._roots,o=t._roots;let n,r=0,a=0;const l=new W().copy(e).invert();for(let d=0,u=i.length;d<u;d++){ze.setBuffer(i[d]),a=0;const h=vt.getPrimitive();q(0,ze.float32Array,h),h.applyMatrix4(l);for(let f=0,p=o.length;f<p&&(_s.setBuffer(o[d]),n=Ct(0,0,e,l,s,r,a,0,0,h),_s.clearBuffer(),a+=o[f].length,!n);f++);if(vt.releasePrimitive(h),ze.clearBuffer(),r+=i[d].length,n)break}return Hs=!1,n}function Ct(c,t,e,s,i,o=0,n=0,r=0,a=0,l=null,d=!1){let u,h;d?(u=_s,h=ze):(u=ze,h=_s);const f=u.float32Array,p=u.uint32Array,T=u.uint16Array,m=h.float32Array,C=h.uint32Array,R=h.uint16Array,g=c*2,I=t*2,A=ht(g,T),F=ht(I,R);let _=!1;if(F&&A)d?_=i(dt(t,C),ft(t*2,R),dt(c,p),ft(c*2,T),a,n+t,r,o+c):_=i(dt(c,p),ft(c*2,T),dt(t,C),ft(t*2,R),r,o+c,a,n+t);else if(F){const S=vt.getPrimitive();q(t,m,S),S.applyMatrix4(e);const y=It(c),N=pt(c,p);q(y,f,le),q(N,f,he);const L=S.intersectsBox(le),w=S.intersectsBox(he);_=L&&Ct(t,y,s,e,i,n,o,a,r+1,S,!d)||w&&Ct(t,N,s,e,i,n,o,a,r+1,S,!d),vt.releasePrimitive(S)}else{const S=It(t),y=pt(t,C);q(S,m,Gs),q(y,m,Vs);const N=l.intersectsBox(Gs),L=l.intersectsBox(Vs);if(N&&L)_=Ct(c,S,e,s,i,o,n,r,a+1,l,d)||Ct(c,y,e,s,i,o,n,r,a+1,l,d);else if(N)if(A)_=Ct(c,S,e,s,i,o,n,r,a+1,l,d);else{const w=vt.getPrimitive();w.copy(Gs).applyMatrix4(e);const D=It(c),U=pt(c,p);q(D,f,le),q(U,f,he);const b=w.intersectsBox(le),G=w.intersectsBox(he);_=b&&Ct(S,D,s,e,i,n,o,a,r+1,w,!d)||G&&Ct(S,U,s,e,i,n,o,a,r+1,w,!d),vt.releasePrimitive(w)}else if(L)if(A)_=Ct(c,y,e,s,i,o,n,r,a+1,l,d);else{const w=vt.getPrimitive();w.copy(Vs).applyMatrix4(e);const D=It(c),U=pt(c,p);q(D,f,le),q(U,f,he);const b=w.intersectsBox(le),G=w.intersectsBox(he);_=b&&Ct(y,D,s,e,i,n,o,a,r+1,w,!d)||G&&Ct(y,U,s,e,i,n,o,a,r+1,w,!d),vt.releasePrimitive(w)}}return _}const hs=new ct,cn=new it;class Mi{static serialize(t,e={}){e={cloneBuffers:!0,...e};const s=t.geometry,i=t._roots,o=t._indirectBuffer,n=s.getIndex();let r;return e.cloneBuffers?r={roots:i.map(a=>a.slice()),index:n.array.slice(),indirectBuffer:o?o.slice():null}:r={roots:i,index:n.array,indirectBuffer:o},r}static deserialize(t,e,s={}){s={setIndex:!0,indirect:!!t.indirectBuffer,...s};const{index:i,roots:o,indirectBuffer:n}=t,r=new Mi(e,{...s,[xs]:!0});if(r._roots=o,r._indirectBuffer=n||null,s.setIndex){const a=e.getIndex();if(a===null){const l=new Ve(t.index,1,!1);e.setIndex(l)}else a.array!==i&&(a.array.set(i),a.needsUpdate=!0)}return r}get indirect(){return!!this._indirectBuffer}constructor(t,e={}){if(t.isBufferGeometry){if(t.index&&t.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.")}else throw new Error("MeshBVH: Only BufferGeometries are supported.");if(e=Object.assign({strategy:bn,maxDepth:40,maxLeafTris:10,verbose:!0,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,indirect:!1,[xs]:!1},e),e.useSharedArrayBuffer&&!Jr())throw new Error("MeshBVH: SharedArrayBuffer is not available.");this.geometry=t,this._roots=null,this._indirectBuffer=null,e[xs]||(Cr(this,e),!t.boundingBox&&e.setBoundingBox&&(t.boundingBox=this.getBoundingBox(new it)));const{_indirectBuffer:s}=this;this.resolveTriangleIndex=e.indirect?i=>s[i]:i=>i}refit(t=null){return(this.indirect?Hr:wr)(this,t)}traverse(t,e=0){const s=this._roots[e],i=new Uint32Array(s),o=new Uint16Array(s);n(0);function n(r,a=0){const l=r*2,d=o[l+15]===Ps;if(d){const u=i[r+6],h=o[l+14];t(a,d,new Float32Array(s,r*4,6),u,h)}else{const u=r+ms/4,h=i[r+6],f=i[r+7];t(a,d,new Float32Array(s,r*4,6),f)||(n(u,a+1),n(h,a+1))}}}raycast(t,e=ki){const s=this._roots,i=this.geometry,o=[],n=e.isMaterial,r=Array.isArray(e),a=i.groups,l=n?e.side:e,d=this.indirect?kr:Ur;for(let u=0,h=s.length;u<h;u++){const f=r?e[a[u].materialIndex].side:l,p=o.length;if(d(this,u,f,t,o),r){const T=a[u].materialIndex;for(let m=p,C=o.length;m<C;m++)o[m].face.materialIndex=T}}return o}raycastFirst(t,e=ki){const s=this._roots,i=this.geometry,o=e.isMaterial,n=Array.isArray(e);let r=null;const a=i.groups,l=o?e.side:e,d=this.indirect?Xr:br;for(let u=0,h=s.length;u<h;u++){const f=n?e[a[u].materialIndex].side:l,p=d(this,u,f,t);p!=null&&(r==null||p.distance<r.distance)&&(r=p,n&&(p.face.materialIndex=a[u].materialIndex))}return r}intersectsGeometry(t,e){let s=!1;const i=this._roots,o=this.indirect?Zr:vr;for(let n=0,r=i.length;n<r&&(s=o(this,n,t,e),!s);n++);return s}shapecast(t){const e=Et.getPrimitive(),s=this.indirect?Dr:Nr;let{boundsTraverseOrder:i,intersectsBounds:o,intersectsRange:n,intersectsTriangle:r}=t;if(n&&r){const u=n;n=(h,f,p,T,m)=>u(h,f,p,T,m)?!0:s(h,f,this,r,p,T,e)}else n||(r?n=(u,h,f,p)=>s(u,h,this,r,f,p,e):n=(u,h,f)=>f);let a=!1,l=0;const d=this._roots;for(let u=0,h=d.length;u<h;u++){const f=d[u];if(a=Fr(this,u,o,n,i,l),a)break;l+=f.byteLength}return Et.releasePrimitive(e),a}bvhcast(t,e,s){let{intersectsRanges:i,intersectsTriangles:o}=s;const n=Et.getPrimitive(),r=this.geometry.index,a=this.geometry.attributes.position,l=this.indirect?p=>{const T=this.resolveTriangleIndex(p);J(n,T*3,r,a)}:p=>{J(n,p*3,r,a)},d=Et.getPrimitive(),u=t.geometry.index,h=t.geometry.attributes.position,f=t.indirect?p=>{const T=t.resolveTriangleIndex(p);J(d,T*3,u,h)}:p=>{J(d,p*3,u,h)};if(o){const p=(T,m,C,R,g,I,A,F)=>{for(let _=C,S=C+R;_<S;_++){f(_),d.a.applyMatrix4(e),d.b.applyMatrix4(e),d.c.applyMatrix4(e),d.needsUpdate=!0;for(let y=T,N=T+m;y<N;y++)if(l(y),n.needsUpdate=!0,o(n,d,y,_,g,I,A,F))return!0}return!1};if(i){const T=i;i=function(m,C,R,g,I,A,F,_){return T(m,C,R,g,I,A,F,_)?!0:p(m,C,R,g,I,A,F,_)}}else i=p}return ta(this,t,e,i)}intersectsBox(t,e){return hs.set(t.min,t.max,e),hs.needsUpdate=!0,this.shapecast({intersectsBounds:s=>hs.intersectsBox(s),intersectsTriangle:s=>hs.intersectsTriangle(s)})}intersectsSphere(t){return this.shapecast({intersectsBounds:e=>t.intersectsBox(e),intersectsTriangle:e=>e.intersectsSphere(t)})}closestPointToGeometry(t,e,s={},i={},o=0,n=1/0){return(this.indirect?Kr:Vr)(this,t,e,s,i,o,n)}closestPointToPoint(t,e={},s=0,i=1/0){return _r(this,t,e,s,i)}getBoundingBox(t){return t.makeEmpty(),this._roots.forEach(s=>{q(0,new Float32Array(s),cn),t.union(cn)}),t}}function ln(c,t,e){return c===null||(c.point.applyMatrix4(t.matrixWorld),c.distance=c.point.distanceTo(e.ray.origin),c.object=t,c.distance<e.near||c.distance>e.far)?null:c}const ks=new Zo,hn=new W,ea=x.prototype.raycast;function sa(c,t){if(this.geometry.boundsTree){if(this.material===void 0)return;hn.copy(this.matrixWorld).invert(),ks.copy(c.ray).applyMatrix4(hn);const e=this.geometry.boundsTree;if(c.firstHitOnly===!0){const s=ln(e.raycastFirst(ks,this.material),this,c);s&&t.push(s)}else{const s=e.raycast(ks,this.material);for(let i=0,o=s.length;i<o;i++){const n=ln(s[i],this,c);n&&t.push(n)}}}else ea.call(this,c,t)}function ia(c){return this.boundsTree=new Mi(this,c),this.boundsTree}function na(){this.boundsTree=null}class M{constructor(){E(this,"trigger",t=>{const e=this.handlers.slice(0);for(const s of e)s(t)}),E(this,"handlers",[])}add(t){this.handlers.push(t)}remove(t){this.handlers=this.handlers.filter(e=>e!==t)}reset(){this.handlers.length=0}}class Kt{constructor(){E(this,"trigger",async t=>{const e=this.handlers.slice(0);for(const s of e)await s(t)}),E(this,"handlers",[])}add(t){this.handlers.push(t)}remove(t){this.handlers=this.handlers.filter(e=>e!==t)}reset(){this.handlers.length=0}}class Di{constructor(t){E(this,"isDisposeable",()=>"dispose"in this&&"onDisposed"in this),E(this,"isResizeable",()=>"resize"in this&&"getSize"in this),E(this,"isUpdateable",()=>"onAfterUpdate"in this&&"onBeforeUpdate"in this&&"update"in this),E(this,"isHideable",()=>"visible"in this),E(this,"isConfigurable",()=>"setup"in this&&"config"in this&&"onSetup"in this),this.components=t}}class $ extends Di{}class Ui extends Di{constructor(t){super(t),E(this,"worlds",new Map),E(this,"onWorldChanged",new M),E(this,"currentWorld",null),this.onWorldChanged.add(({world:e,action:s})=>{s==="removed"&&this.worlds.delete(e.uuid)})}}class oa extends Ui{constructor(){super(...arguments),E(this,"hasCameraControls",()=>"controls"in this)}}class ra extends Ui{constructor(){super(...arguments),E(this,"onAfterUpdate",new M),E(this,"onBeforeUpdate",new M),E(this,"onDisposed",new M),E(this,"onResize",new M),E(this,"onClippingPlanesUpdated",new M),E(this,"clippingPlanes",[])}updateClippingPlanes(){this.onClippingPlanesUpdated.trigger()}setPlane(t,e,s){e.isLocal=s;const i=this.clippingPlanes.indexOf(e);t&&i===-1?this.clippingPlanes.push(e):!t&&i>-1&&this.clippingPlanes.splice(i,1),this.three.clippingPlanes=this.clippingPlanes.filter(o=>!o.isLocal)}}const zn=class li extends ${constructor(t){super(t),E(this,"_disposedComponents",new Set),E(this,"enabled",!0),t.add(li.uuid,this)}get(){return this._disposedComponents}destroy(t,e=!0,s=!0){t.removeFromParent();const i=t;i.dispose&&i.dispose(),this.disposeGeometryAndMaterials(t,e),s&&i.children&&i.children.length&&this.disposeChildren(i),t.children.length=0}disposeGeometry(t){const e=t;e.boundsTree&&e.disposeBoundsTree(),t.dispose()}disposeGeometryAndMaterials(t,e){const s=t;s.geometry&&this.disposeGeometry(s.geometry),e&&s.material&&li.disposeMaterial(s),s.material=[],s.geometry=null}disposeChildren(t){for(const e of t.children)this.destroy(e)}static disposeMaterial(t){if(t.material)if(Array.isArray(t.material))for(const e of t.material)e.dispose();else t.material.dispose()}};E(zn,"uuid","76e9cd8e-ad8f-4753-9ef6-cbc60f7247fe");let me=zn;class aa extends Ui{constructor(t){super(t),E(this,"onDisposed",new M)}dispose(){const t=this.components.get(me);for(const e of this.three.children){const s=e;s.geometry&&t.destroy(s)}this.three.children=[],this.onDisposed.trigger(),this.onDisposed.reset()}}const Rs=0,ca=1,la=new O,dn=new At,Ws=new Re,un=new O,ds=new pe;class ha{constructor(){this.tolerance=-1,this.faces=[],this.newFaces=[],this.assigned=new En,this.unassigned=new En,this.vertices=[]}setFromPoints(t){if(t.length>=4){this.makeEmpty();for(let e=0,s=t.length;e<s;e++)this.vertices.push(new da(t[e]));this.compute()}return this}setFromObject(t){const e=[];return t.updateMatrixWorld(!0),t.traverse(function(s){const i=s.geometry;if(i!==void 0){const o=i.attributes.position;if(o!==void 0)for(let n=0,r=o.count;n<r;n++){const a=new O;a.fromBufferAttribute(o,n).applyMatrix4(s.matrixWorld),e.push(a)}}}),this.setFromPoints(e)}containsPoint(t){const e=this.faces;for(let s=0,i=e.length;s<i;s++)if(e[s].distanceToPoint(t)>this.tolerance)return!1;return!0}intersectRay(t,e){const s=this.faces;let i=-1/0,o=1/0;for(let n=0,r=s.length;n<r;n++){const a=s[n],l=a.distanceToPoint(t.origin),d=a.normal.dot(t.direction);if(l>0&&d>=0)return null;const u=d!==0?-l/d:0;if(!(u<=0)&&(d>0?o=Math.min(u,o):i=Math.max(u,i),i>o))return null}return i!==-1/0?t.at(i,e):t.at(o,e),e}intersectsRay(t){return this.intersectRay(t,la)!==null}makeEmpty(){return this.faces=[],this.vertices=[],this}addVertexToFace(t,e){return t.face=e,e.outside===null?this.assigned.append(t):this.assigned.insertBefore(e.outside,t),e.outside=t,this}removeVertexFromFace(t,e){return t===e.outside&&(t.next!==null&&t.next.face===e?e.outside=t.next:e.outside=null),this.assigned.remove(t),this}removeAllVerticesFromFace(t){if(t.outside!==null){const e=t.outside;let s=t.outside;for(;s.next!==null&&s.next.face===t;)s=s.next;return this.assigned.removeSubList(e,s),e.prev=s.next=null,t.outside=null,e}}deleteFaceVertices(t,e){const s=this.removeAllVerticesFromFace(t);if(s!==void 0)if(e===void 0)this.unassigned.appendChain(s);else{let i=s;do{const o=i.next;e.distanceToPoint(i.point)>this.tolerance?this.addVertexToFace(i,e):this.unassigned.append(i),i=o}while(i!==null)}return this}resolveUnassignedPoints(t){if(this.unassigned.isEmpty()===!1){let e=this.unassigned.first();do{const s=e.next;let i=this.tolerance,o=null;for(let n=0;n<t.length;n++){const r=t[n];if(r.mark===Rs){const a=r.distanceToPoint(e.point);if(a>i&&(i=a,o=r),i>1e3*this.tolerance)break}}o!==null&&this.addVertexToFace(e,o),e=s}while(e!==null)}return this}computeExtremes(){const t=new O,e=new O,s=[],i=[];for(let o=0;o<3;o++)s[o]=i[o]=this.vertices[0];t.copy(this.vertices[0].point),e.copy(this.vertices[0].point);for(let o=0,n=this.vertices.length;o<n;o++){const r=this.vertices[o],a=r.point;for(let l=0;l<3;l++)a.getComponent(l)<t.getComponent(l)&&(t.setComponent(l,a.getComponent(l)),s[l]=r);for(let l=0;l<3;l++)a.getComponent(l)>e.getComponent(l)&&(e.setComponent(l,a.getComponent(l)),i[l]=r)}return this.tolerance=3*Number.EPSILON*(Math.max(Math.abs(t.x),Math.abs(e.x))+Math.max(Math.abs(t.y),Math.abs(e.y))+Math.max(Math.abs(t.z),Math.abs(e.z))),{min:s,max:i}}computeInitialHull(){const t=this.vertices,e=this.computeExtremes(),s=e.min,i=e.max;let o=0,n=0;for(let h=0;h<3;h++){const f=i[h].point.getComponent(h)-s[h].point.getComponent(h);f>o&&(o=f,n=h)}const r=s[n],a=i[n];let l,d;o=0,dn.set(r.point,a.point);for(let h=0,f=this.vertices.length;h<f;h++){const p=t[h];if(p!==r&&p!==a){dn.closestPointToPoint(p.point,!0,un);const T=un.distanceToSquared(p.point);T>o&&(o=T,l=p)}}o=-1,Ws.setFromCoplanarPoints(r.point,a.point,l.point);for(let h=0,f=this.vertices.length;h<f;h++){const p=t[h];if(p!==r&&p!==a&&p!==l){const T=Math.abs(Ws.distanceToPoint(p.point));T>o&&(o=T,d=p)}}const u=[];if(Ws.distanceToPoint(d.point)<0){u.push(mt.create(r,a,l),mt.create(d,a,r),mt.create(d,l,a),mt.create(d,r,l));for(let h=0;h<3;h++){const f=(h+1)%3;u[h+1].getEdge(2).setTwin(u[0].getEdge(f)),u[h+1].getEdge(1).setTwin(u[f+1].getEdge(0))}}else{u.push(mt.create(r,l,a),mt.create(d,r,a),mt.create(d,a,l),mt.create(d,l,r));for(let h=0;h<3;h++){const f=(h+1)%3;u[h+1].getEdge(2).setTwin(u[0].getEdge((3-h)%3)),u[h+1].getEdge(0).setTwin(u[f+1].getEdge(1))}}for(let h=0;h<4;h++)this.faces.push(u[h]);for(let h=0,f=t.length;h<f;h++){const p=t[h];if(p!==r&&p!==a&&p!==l&&p!==d){o=this.tolerance;let T=null;for(let m=0;m<4;m++){const C=this.faces[m].distanceToPoint(p.point);C>o&&(o=C,T=this.faces[m])}T!==null&&this.addVertexToFace(p,T)}}return this}reindexFaces(){const t=[];for(let e=0;e<this.faces.length;e++){const s=this.faces[e];s.mark===Rs&&t.push(s)}return this.faces=t,this}nextVertexToAdd(){if(this.assigned.isEmpty()===!1){let t,e=0;const s=this.assigned.first().face;let i=s.outside;do{const o=s.distanceToPoint(i.point);o>e&&(e=o,t=i),i=i.next}while(i!==null&&i.face===s);return t}}computeHorizon(t,e,s,i){this.deleteFaceVertices(s),s.mark=ca;let o;e===null?o=e=s.getEdge(0):o=e.next;do{const n=o.twin,r=n.face;r.mark===Rs&&(r.distanceToPoint(t)>this.tolerance?this.computeHorizon(t,n,r,i):i.push(o)),o=o.next}while(o!==e);return this}addAdjoiningFace(t,e){const s=mt.create(t,e.tail(),e.head());return this.faces.push(s),s.getEdge(-1).setTwin(e.twin),s.getEdge(0)}addNewFaces(t,e){this.newFaces=[];let s=null,i=null;for(let o=0;o<e.length;o++){const n=e[o],r=this.addAdjoiningFace(t,n);s===null?s=r:r.next.setTwin(i),this.newFaces.push(r.face),i=r}return s.next.setTwin(i),this}addVertexToHull(t){const e=[];return this.unassigned.clear(),this.removeVertexFromFace(t,t.face),this.computeHorizon(t.point,null,t.face,e),this.addNewFaces(t,e),this.resolveUnassignedPoints(this.newFaces),this}cleanup(){return this.assigned.clear(),this.unassigned.clear(),this.newFaces=[],this}compute(){let t;for(this.computeInitialHull();(t=this.nextVertexToAdd())!==void 0;)this.addVertexToHull(t);return this.reindexFaces(),this.cleanup(),this}}class mt{constructor(){this.normal=new O,this.midpoint=new O,this.area=0,this.constant=0,this.outside=null,this.mark=Rs,this.edge=null}static create(t,e,s){const i=new mt,o=new Xs(t,i),n=new Xs(e,i),r=new Xs(s,i);return o.next=r.prev=n,n.next=o.prev=r,r.next=n.prev=o,i.edge=o,i.compute()}getEdge(t){let e=this.edge;for(;t>0;)e=e.next,t--;for(;t<0;)e=e.prev,t++;return e}compute(){const t=this.edge.tail(),e=this.edge.head(),s=this.edge.next.head();return ds.set(t.point,e.point,s.point),ds.getNormal(this.normal),ds.getMidpoint(this.midpoint),this.area=ds.getArea(),this.constant=this.normal.dot(this.midpoint),this}distanceToPoint(t){return this.normal.dot(t)-this.constant}}class Xs{constructor(t,e){this.vertex=t,this.prev=null,this.next=null,this.twin=null,this.face=e}head(){return this.vertex}tail(){return this.prev?this.prev.vertex:null}length(){const t=this.head(),e=this.tail();return e!==null?e.point.distanceTo(t.point):-1}lengthSquared(){const t=this.head(),e=this.tail();return e!==null?e.point.distanceToSquared(t.point):-1}setTwin(t){return this.twin=t,t.twin=this,this}}class da{constructor(t){this.point=t,this.prev=null,this.next=null,this.face=null}}class En{constructor(){this.head=null,this.tail=null}first(){return this.head}last(){return this.tail}clear(){return this.head=this.tail=null,this}insertBefore(t,e){return e.prev=t.prev,e.next=t,e.prev===null?this.head=e:e.prev.next=e,t.prev=e,this}insertAfter(t,e){return e.prev=t,e.next=t.next,e.next===null?this.tail=e:e.next.prev=e,t.next=e,this}append(t){return this.head===null?this.head=t:this.tail.next=t,t.prev=this.tail,t.next=null,this.tail=t,this}appendChain(t){for(this.head===null?this.head=t:this.tail.next=t,t.prev=this.tail;t.next!==null;)t=t.next;return this.tail=t,this}remove(t){return t.prev===null?this.head=t.next:t.prev.next=t.next,t.next===null?this.tail=t.prev:t.next.prev=t.prev,this}removeSubList(t,e){return t.prev===null?this.head=e.next:t.prev.next=e.next,e.next===null?this.tail=t.prev:e.next.prev=t.prev,this}isEmpty(){return this.head===null}}const hi=[2,2,1],di=[1,0,0];function yt(c,t){return c*3+t}function ua(c){const t=c.elements;let e=0;for(let s=0;s<9;s++)e+=t[s]*t[s];return Math.sqrt(e)}function Ea(c){const t=c.elements;let e=0;for(let s=0;s<3;s++){const i=t[yt(hi[s],di[s])];e+=2*i*i}return Math.sqrt(e)}function fa(c,t){let e=0,s=1;const i=c.elements;for(let l=0;l<3;l++){const d=Math.abs(i[yt(hi[l],di[l])]);d>e&&(e=d,s=l)}let o=1,n=0;const r=di[s],a=hi[s];if(Math.abs(i[yt(a,r)])>Number.EPSILON){const l=i[yt(a,a)],d=i[yt(r,r)],u=i[yt(a,r)],h=(l-d)/2/u;let f;h<0?f=-1/(-h+Math.sqrt(1+h*h)):f=1/(h+Math.sqrt(1+h*h)),o=1/Math.sqrt(1+f*f),n=f*o}return t.identity(),t.elements[yt(r,r)]=o,t.elements[yt(a,a)]=o,t.elements[yt(a,r)]=n,t.elements[yt(r,a)]=-n,t}function Ia(c,t){let e=0,s=0;const i=10;t.unitary.identity(),t.diagonal.copy(c);const o=t.unitary,n=t.diagonal,r=new qt,a=new qt,l=Number.EPSILON*ua(n);for(;s<i&&Ea(n)>l;)fa(n,r),a.copy(r).transpose(),n.multiply(r),n.premultiply(a),o.multiply(r),++e>2&&(s++,e=0);return t}function pa(c){const t=[];for(let et=0;et<c.length-2;et+=3){const Wt=c[et],K=c[et+1],te=c[et+2];t.push(new O(Wt,K,te))}const e=new ha;e.setFromPoints(t);const s={unitary:new qt,diagonal:new qt},i=e.faces,o=[],n=[];for(let et=0,Wt=i.length;et<Wt;et++){const K=i[et];let te=K.edge;o.length=0;do o.push(te),te=te.next;while(te!==K.edge);const _o=o.length-2;for(let Ze=1,Oo=_o;Ze<=Oo;Ze++){const ws=o[0].vertex,Ls=o[Ze+0].vertex,Ms=o[Ze+1].vertex;n.push(ws.point.x,ws.point.y,ws.point.z),n.push(Ls.point.x,Ls.point.y,Ls.point.z),n.push(Ms.point.x,Ms.point.y,Ms.point.z)}}const r=new O,a=new O,l=new O,d=new O,u=new O,h=new O,f=new O,p=new O;let T=0,m=0,C=0,R=0,g=0,I=0,A=0;for(let et=0,Wt=n.length;et<Wt;et+=9){r.fromArray(n,et),a.fromArray(n,et+3),l.fromArray(n,et+6),f.set(0,0,0),f.add(r).add(a).add(l).divideScalar(3),d.subVectors(a,r),u.subVectors(l,r);const K=h.crossVectors(d,u).length()/2;p.add(h.copy(f).multiplyScalar(K)),T+=K,m+=(9*f.x*f.x+r.x*r.x+a.x*a.x+l.x*l.x)*(K/12),C+=(9*f.x*f.y+r.x*r.y+a.x*a.y+l.x*l.y)*(K/12),R+=(9*f.x*f.z+r.x*r.z+a.x*a.z+l.x*l.z)*(K/12),g+=(9*f.y*f.y+r.y*r.y+a.y*a.y+l.y*l.y)*(K/12),I+=(9*f.y*f.z+r.y*r.z+a.y*a.z+l.y*l.z)*(K/12),A+=(9*f.z*f.z+r.z*r.z+a.z*a.z+l.z*l.z)*(K/12)}p.divideScalar(T),m/=T,C/=T,R/=T,g/=T,I/=T,A/=T,m-=p.x*p.x,C-=p.x*p.y,R-=p.x*p.z,g-=p.y*p.y,I-=p.y*p.z,A-=p.z*p.z;const F=new qt;F.elements[0]=m,F.elements[1]=C,F.elements[2]=R,F.elements[3]=C,F.elements[4]=g,F.elements[5]=I,F.elements[6]=R,F.elements[7]=I,F.elements[8]=A,Ia(F,s);const _=s.unitary,S=new O,y=new O,N=new O;_.extractBasis(S,y,N);let L=-1/0,w=-1/0,D=-1/0,U=1/0,b=1/0,G=1/0;for(let et=0,Wt=t.length;et<Wt;et++){const K=t[et];L=Math.max(S.dot(K),L),w=Math.max(y.dot(K),w),D=Math.max(N.dot(K),D),U=Math.min(S.dot(K),U),b=Math.min(y.dot(K),b),G=Math.min(N.dot(K),G)}S.multiplyScalar(.5*(U+L)),y.multiplyScalar(.5*(b+w)),N.multiplyScalar(.5*(G+D));const j=new O,tt=new O,Z=new qt;j.add(S).add(y).add(N),tt.x=L-U,tt.y=w-b,tt.z=D-G,tt.multiplyScalar(.5),Z.copy(_);const{x:Vt,y:Ht,z:kt}=tt,Xe=new W;Xe.makeScale(Vt*2,Ht*2,kt*2);const ge=new W;ge.makeTranslation(-Vt,-Ht,-kt);const Gi=new W;Gi.makeTranslation(j.x,j.y,j.z);const Vi=new W;Vi.setFromMatrix3(Z);const Fe=new W;return Fe.multiply(Gi),Fe.multiply(Vi),Fe.multiply(ge),Fe.multiply(Xe),{center:j,halfSizes:tt,rotation:Z,transformation:Fe}}function Ca(c,t,e){const s=[c[0]-t[0],c[1]-t[1],c[2]-t[2]];return e[0]*s[0]+e[1]*s[1]+e[2]*s[2]>0}class fn{static isTransparent(t){return t.transparent&&t.opacity<1}}const xi=class st{static create(){const t=Math.random()*4294967295|0,e=Math.random()*4294967295|0,s=Math.random()*4294967295|0,i=Math.random()*4294967295|0;return`${st._lut[t&255]+st._lut[t>>8&255]+st._lut[t>>16&255]+st._lut[t>>24&255]}-${st._lut[e&255]}${st._lut[e>>8&255]}-${st._lut[e>>16&15|64]}${st._lut[e>>24&255]}-${st._lut[s&63|128]}${st._lut[s>>8&255]}-${st._lut[s>>16&255]}${st._lut[s>>24&255]}${st._lut[i&255]}${st._lut[i>>8&255]}${st._lut[i>>16&255]}${st._lut[i>>24&255]}`.toLowerCase()}static validate(t){if(!st._pattern.test(t))throw new Error(`${t} is not a valid UUID v4.

- If you're the tool creator, you can take one from https://www.uuidgenerator.net/.

- If you're using a platform tool, verify the uuid isn't misspelled or contact the tool creator.`)}};E(xi,"_pattern",/^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-4[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$/);E(xi,"_lut",["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"]);let bi=xi;class ic extends ${constructor(t,e){super(t),E(this,"onVertexFound",new M),E(this,"onVertexLost",new M),E(this,"components"),E(this,"_pickedPoint",null),E(this,"_config"),E(this,"_enabled",!1),E(this,"_workingPlane",null),this.components=t,this.config={snapDistance:.25,showOnlyVertex:!1,...e},this.enabled=!1}set enabled(t){this._enabled=t,t||(this._pickedPoint=null)}get enabled(){return this._enabled}set workingPlane(t){this._workingPlane=t}get workingPlane(){return this._workingPlane}set config(t){this._config={...this._config,...t}}get config(){return this._config}dispose(){this.onVertexFound.reset(),this.onVertexLost.reset(),this.components=null}get(t){if(!this.enabled)return this._pickedPoint;const i=this.components.get(ui).get(t).castRay();if(!i)return this._pickedPoint!==null&&(this.onVertexLost.trigger(),this._pickedPoint=null),this._pickedPoint;const o=this.getClosestVertex(i);return o?(this.workingPlane?Math.abs(this.workingPlane.distanceToPoint(o))<.001:!0)?((this._pickedPoint===null||!this._pickedPoint.equals(o))&&(this._pickedPoint=o.clone(),this.onVertexFound.trigger(this._pickedPoint)),this._pickedPoint):(this._pickedPoint=null,this._pickedPoint):(this._pickedPoint!==null&&(this.onVertexLost.trigger(),this._pickedPoint=null),this._pickedPoint)}getClosestVertex(t){let e=new O,s=!1,i=Number.MAX_SAFE_INTEGER;const o=this.getVertices(t);return o==null||o.forEach(n=>{if(!n)return;const r=t.point.distanceTo(n);r>i||r>this._config.snapDistance||(s=!0,e=n,i=t.point.distanceTo(n))}),s?e:this.config.showOnlyVertex?null:t.point}getVertices(t){const e=t.object;if(!t.face||!e)return null;const s=e.geometry;return[this.getVertex(t.face.a,s),this.getVertex(t.face.b,s),this.getVertex(t.face.c,s)].map(i=>i==null?void 0:i.applyMatrix4(e.matrixWorld))}getVertex(t,e){if(t===void 0)return null;const s=e.attributes.position;return new O(s.getX(t),s.getY(t),s.getZ(t))}}const Gn=class Vn{constructor(){E(this,"onDisposed",new M),E(this,"list",new Map),E(this,"enabled",!1),E(this,"_clock"),E(this,"update",()=>{if(!this.enabled)return;const t=this._clock.getDelta();for(const[e,s]of this.list)s.enabled&&s.isUpdateable()&&s.update(t);requestAnimationFrame(this.update)}),this._clock=new Uo,Vn.setupBVH()}add(t,e){if(this.list.has(t))throw new Error("You're trying to add a component that already exists in the components intance. Use Components.get() instead.");bi.validate(t),this.list.set(t,e)}get(t){const e=t.uuid;if(!this.list.has(e)){const s=new t(this);return this.list.has(e)||this.add(e,s),s}return this.list.get(e)}init(){this.enabled=!0,this._clock.start(),this.update()}dispose(){this.enabled=!1;for(const[t,e]of this.list)e.enabled=!1,e.isDisposeable()&&e.dispose();this._clock.stop(),this.onDisposed.trigger(),this.onDisposed.reset()}static setupBVH(){Ge.prototype.computeBoundsTree=ia,Ge.prototype.disposeBoundsTree=na,x.prototype.raycast=sa}};E(Gn,"release","1.4.21");let Ta=Gn;class ma{constructor(t){E(this,"_event"),E(this,"_position",new gt),E(this,"onDisposed",new M),E(this,"updateMouseInfo",e=>{this._event=e}),this.dom=t,this.setupEvents(!0)}get position(){if(this._event){const t=this.dom.getBoundingClientRect();this._position.x=this.getPositionX(t,this._event),this._position.y=this.getPositionY(t,this._event)}return this._position}dispose(){this.setupEvents(!1),this.onDisposed.trigger(),this.onDisposed.reset()}getPositionY(t,e){return-((e.clientY-t.top)/(t.bottom-t.top))*2+1}getPositionX(t,e){return(e.clientX-t.left)/(t.right-t.left)*2-1}setupEvents(t){t?this.dom.addEventListener("mousemove",this.updateMouseInfo):this.dom.removeEventListener("mousemove",this.updateMouseInfo)}}class Ra{constructor(t,e){E(this,"enabled",!0),E(this,"components"),E(this,"onDisposed",new M),E(this,"mouse"),E(this,"three",new Ci),E(this,"world");const s=e.renderer;if(!s)throw new Error("A renderer is needed for the raycaster to work!");this.world=e,this.mouse=new ma(s.three.domElement),this.components=t}dispose(){this.mouse.dispose(),this.onDisposed.trigger(),this.onDisposed.reset()}castRay(t=Array.from(this.world.meshes)){if(!this.world)throw new Error("A world is needed to cast rays!");const e=this.world.camera.three;return this.three.setFromCamera(this.mouse.position,e),this.intersect(t)}castRayFromVector(t,e,s=Array.from(this.world.meshes)){return this.three.set(t,e),this.intersect(s)}intersect(t=Array.from(this.world.meshes)){const e=this.three.intersectObjects(t),s=this.filterClippingPlanes(e);return s.length>0?s[0]:null}filterClippingPlanes(t){if(!this.world.renderer)throw new Error("Renderer not found!");const e=this.world.renderer.three;if(!e.clippingPlanes)return t;const s=e.clippingPlanes;return t.length<=0||!s||(s==null?void 0:s.length)<=0?t:t.filter(i=>s.every(o=>o.distanceToPoint(i.point)>0))}}const Hn=class kn extends ${constructor(t){super(t),E(this,"enabled",!0),E(this,"list",new Map),E(this,"onDisposed",new M),t.add(kn.uuid,this)}get(t){if(this.list.has(t.uuid))return this.list.get(t.uuid);const e=new Ra(this.components,t);return this.list.set(t.uuid,e),t.onDisposed.add(()=>{this.delete(t)}),e}delete(t){const e=this.list.get(t.uuid);e&&e.dispose(),this.list.delete(t.uuid)}dispose(){for(const[t,e]of this.list)e.dispose();this.list.clear(),this.onDisposed.trigger()}};E(Hn,"uuid","d5d8bdf0-db25-4952-b951-b643af207ace");let ui=Hn;class Aa extends Di{constructor(t){super(t),E(this,"meshes",new Set),E(this,"onAfterUpdate",new M),E(this,"onBeforeUpdate",new M),E(this,"isDisposing",!1),E(this,"enabled",!0),E(this,"uuid",bi.create()),E(this,"name"),E(this,"onDisposed",new M),E(this,"_scene"),E(this,"_camera"),E(this,"_renderer",null)}get scene(){if(!this._scene)throw new Error("No scene initialized!");return this._scene}set scene(t){this._scene=t,t.worlds.set(this.uuid,this),t.currentWorld=this,t.onWorldChanged.trigger({world:this,action:"added"})}get camera(){if(!this._camera)throw new Error("No camera initialized!");return this._camera}set camera(t){this._camera=t,t.worlds.set(this.uuid,this),t.currentWorld=this,t.onWorldChanged.trigger({world:this,action:"added"})}get renderer(){return this._renderer}set renderer(t){this._renderer=t,t&&(t.worlds.set(this.uuid,this),t.currentWorld=this,t.onWorldChanged.trigger({world:this,action:"added"}))}update(t){this.enabled&&(!this._scene||!this._camera||(this.scene.currentWorld=this,this.camera.currentWorld=this,this.renderer&&(this.renderer.currentWorld=this),this.onBeforeUpdate.trigger(),this.scene.isUpdateable()&&this.scene.update(t),this.camera.isUpdateable()&&this.camera.update(t),this.renderer&&this.renderer.update(t),this.onAfterUpdate.trigger()))}dispose(t=!0){if(this.enabled=!1,this.isDisposing=!0,this.scene.onWorldChanged.trigger({world:this,action:"removed"}),this.camera.onWorldChanged.trigger({world:this,action:"removed"}),this.renderer&&this.renderer.onWorldChanged.trigger({world:this,action:"removed"}),t){const e=this.components.get(me);this.scene.dispose(),this.camera.isDisposeable()&&this.camera.dispose(),this.renderer&&this.renderer.dispose();for(const s of this.meshes)e.destroy(s);this.meshes.clear()}this._scene=null,this._camera=null,this._renderer=null,this.onDisposed.trigger()}}class nc extends aa{constructor(t){super(t),E(this,"isSetup",!1),E(this,"three"),E(this,"onSetup",new M),E(this,"config",{directionalLight:{color:new $t("white"),intensity:1.5,position:new O(5,10,3)},ambientLight:{color:new $t("white"),intensity:1}}),this.three=new Ti,this.three.background=new $t(2107698)}setup(t){this.config={...this.config,...t};const e=new yo(this.config.directionalLight.color,this.config.directionalLight.intensity);e.position.copy(this.config.directionalLight.position);const s=new Po(this.config.ambientLight.color,this.config.ambientLight.intensity);this.three.add(e,s),this.isSetup=!0,this.onSetup.trigger(this)}}class oc extends ra{constructor(t,e,s){super(t),E(this,"enabled",!0),E(this,"container"),E(this,"three"),E(this,"_canvas"),E(this,"_parameters"),E(this,"_resizeObserver",null),E(this,"onContainerUpdated",new M),E(this,"_resizing",!1),E(this,"resize",n=>{if(this._resizing)return;this._resizing=!0,this.onContainerUpdated.trigger();const r=n?n.x:this.container.clientWidth,a=n?n.y:this.container.clientHeight;this.three.setSize(r,a),this.onResize.trigger(new gt(r,a)),this._resizing=!1}),E(this,"resizeEvent",()=>{this.resize()}),E(this,"onContextLost",n=>{n.preventDefault(),this.enabled=!1}),E(this,"onContextBack",()=>{this.three.setRenderTarget(null),this.three.dispose(),this.three=new gs({canvas:this._canvas,antialias:!0,alpha:!0,...this._parameters}),this.enabled=!0}),this.container=e,this._parameters=s,this.three=new gs({antialias:!0,alpha:!0,...s}),this.three.setPixelRatio(Math.min(window.devicePixelRatio,2)),this.setupRenderer(),this.setupEvents(!0),this.resize(),this._canvas=this.three.domElement;const i=this.three.getContext(),{canvas:o}=i;o.addEventListener("webglcontextlost",this.onContextLost,!1),o.addEventListener("webglcontextrestored",this.onContextBack,!1)}update(){if(!this.enabled||!this.currentWorld)return;this.onBeforeUpdate.trigger(this);const t=this.currentWorld.scene.three,e=this.currentWorld.camera.three;this.three.render(t,e),this.onAfterUpdate.trigger(this)}dispose(){this.enabled=!1,this.setupEvents(!1),this.three.domElement.remove(),this.three.dispose(),this.onResize.reset(),this.onAfterUpdate.reset(),this.onBeforeUpdate.reset(),this.onDisposed.trigger(),this.onDisposed.reset()}getSize(){return new gt(this.three.domElement.clientWidth,this.three.domElement.clientHeight)}setupEvents(t){const e=this.three.domElement.parentElement;if(!e)throw new Error("This renderer needs to have an HTML container!");this._resizeObserver&&(this._resizeObserver.disconnect(),this._resizeObserver=null),window.removeEventListener("resize",this.resizeEvent),t&&(this._resizeObserver=new ResizeObserver(this.resizeEvent),this._resizeObserver.observe(e),window.addEventListener("resize",this.resizeEvent))}setupRenderer(){this.three.localClippingEnabled=!0,this.container&&this.container.appendChild(this.three.domElement),this.onContainerUpdated.trigger()}}/*!
 * camera-controls
 * https://github.com/yomotsu/camera-controls
 * (c) 2017 @yomotsu
 * Released under the MIT License.
 */const B={LEFT:1,RIGHT:2,MIDDLE:4},P=Object.freeze({NONE:0,ROTATE:1,TRUCK:2,OFFSET:4,DOLLY:8,ZOOM:16,TOUCH_ROTATE:32,TOUCH_TRUCK:64,TOUCH_OFFSET:128,TOUCH_DOLLY:256,TOUCH_ZOOM:512,TOUCH_DOLLY_TRUCK:1024,TOUCH_DOLLY_OFFSET:2048,TOUCH_DOLLY_ROTATE:4096,TOUCH_ZOOM_TRUCK:8192,TOUCH_ZOOM_OFFSET:16384,TOUCH_ZOOM_ROTATE:32768}),de={NONE:0,IN:1,OUT:-1};function Xt(c){return c.isPerspectiveCamera}function bt(c){return c.isOrthographicCamera}const ue=Math.PI*2,In=Math.PI/2,Wn=1e-5,Le=Math.PI/180;function Tt(c,t,e){return Math.max(t,Math.min(e,c))}function k(c,t=Wn){return Math.abs(c)<t}function V(c,t,e=Wn){return k(c-t,e)}function pn(c,t){return Math.round(c/t)*t}function Me(c){return isFinite(c)?c:c<0?-Number.MAX_VALUE:Number.MAX_VALUE}function De(c){return Math.abs(c)<Number.MAX_VALUE?c:c*(1/0)}function us(c,t,e,s,i=1/0,o){s=Math.max(1e-4,s);const n=2/s,r=n*o,a=1/(1+r+.48*r*r+.235*r*r*r);let l=c-t;const d=t,u=i*s;l=Tt(l,-u,u),t=c-l;const h=(e.value+n*l)*o;e.value=(e.value-n*h)*a;let f=t+(l+h)*a;return d-c>0==f>d&&(f=d,e.value=(f-d)/o),f}function Cn(c,t,e,s,i=1/0,o,n){s=Math.max(1e-4,s);const r=2/s,a=r*o,l=1/(1+a+.48*a*a+.235*a*a*a);let d=t.x,u=t.y,h=t.z,f=c.x-d,p=c.y-u,T=c.z-h;const m=d,C=u,R=h,g=i*s,I=g*g,A=f*f+p*p+T*T;if(A>I){const b=Math.sqrt(A);f=f/b*g,p=p/b*g,T=T/b*g}d=c.x-f,u=c.y-p,h=c.z-T;const F=(e.x+r*f)*o,_=(e.y+r*p)*o,S=(e.z+r*T)*o;e.x=(e.x-r*F)*l,e.y=(e.y-r*_)*l,e.z=(e.z-r*S)*l,n.x=d+(f+F)*l,n.y=u+(p+_)*l,n.z=h+(T+S)*l;const y=m-c.x,N=C-c.y,L=R-c.z,w=n.x-m,D=n.y-C,U=n.z-R;return y*w+N*D+L*U>0&&(n.x=m,n.y=C,n.z=R,e.x=(n.x-m)/o,e.y=(n.y-C)/o,e.z=(n.z-R)/o),n}function Zs(c,t){t.set(0,0),c.forEach(e=>{t.x+=e.clientX,t.y+=e.clientY}),t.x/=c.length,t.y/=c.length}function Qs(c,t){return bt(c)?(console.warn(`${t} is not supported in OrthographicCamera`),!0):!1}class ga{constructor(){this._listeners={}}addEventListener(t,e){const s=this._listeners;s[t]===void 0&&(s[t]=[]),s[t].indexOf(e)===-1&&s[t].push(e)}hasEventListener(t,e){const s=this._listeners;return s[t]!==void 0&&s[t].indexOf(e)!==-1}removeEventListener(t,e){const i=this._listeners[t];if(i!==void 0){const o=i.indexOf(e);o!==-1&&i.splice(o,1)}}removeAllEventListeners(t){if(!t){this._listeners={};return}Array.isArray(this._listeners[t])&&(this._listeners[t].length=0)}dispatchEvent(t){const s=this._listeners[t.type];if(s!==void 0){t.target=this;const i=s.slice(0);for(let o=0,n=i.length;o<n;o++)i[o].call(this,t)}}}const Fa="2.7.3",Es=1/8,Xn=typeof window<"u",_a=Xn&&/Mac/.test(navigator.platform),Oa=!(Xn&&"PointerEvent"in window);let v,Tn,fs,js,lt,Y,z,Ee,Ue,_t,Ot,Zt,mn,Rn,ut,xe,fe,An,qs,gn,$s,Ks,Is;class rt extends ga{static install(t){v=t.THREE,Tn=Object.freeze(new v.Vector3(0,0,0)),fs=Object.freeze(new v.Vector3(0,1,0)),js=Object.freeze(new v.Vector3(0,0,1)),lt=new v.Vector2,Y=new v.Vector3,z=new v.Vector3,Ee=new v.Vector3,Ue=new v.Vector3,_t=new v.Vector3,Ot=new v.Vector3,Zt=new v.Vector3,mn=new v.Vector3,Rn=new v.Vector3,ut=new v.Spherical,xe=new v.Spherical,fe=new v.Box3,An=new v.Box3,qs=new v.Sphere,gn=new v.Quaternion,$s=new v.Quaternion,Ks=new v.Matrix4,Is=new v.Raycaster}static get ACTION(){return P}constructor(t,e){super(),this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-1/0,this.maxAzimuthAngle=1/0,this.minDistance=Number.EPSILON,this.maxDistance=1/0,this.infinityDolly=!1,this.minZoom=.01,this.maxZoom=1/0,this.smoothTime=.25,this.draggingSmoothTime=.125,this.maxSpeed=1/0,this.azimuthRotateSpeed=1,this.polarRotateSpeed=1,this.dollySpeed=1,this.dollyDragInverted=!1,this.truckSpeed=2,this.dollyToCursor=!1,this.dragToOffset=!1,this.verticalDragToForward=!1,this.boundaryFriction=0,this.restThreshold=.01,this.colliderMeshes=[],this.cancel=()=>{},this._enabled=!0,this._state=P.NONE,this._viewport=null,this._changedDolly=0,this._changedZoom=0,this._hasRested=!0,this._boundaryEnclosesCamera=!1,this._needsUpdate=!0,this._updatedLastTime=!1,this._elementRect=new DOMRect,this._isDragging=!1,this._dragNeedsUpdate=!0,this._activePointers=[],this._lockedPointer=null,this._interactiveArea=new DOMRect(0,0,1,1),this._isUserControllingRotate=!1,this._isUserControllingDolly=!1,this._isUserControllingTruck=!1,this._isUserControllingOffset=!1,this._isUserControllingZoom=!1,this._lastDollyDirection=de.NONE,this._thetaVelocity={value:0},this._phiVelocity={value:0},this._radiusVelocity={value:0},this._targetVelocity=new v.Vector3,this._focalOffsetVelocity=new v.Vector3,this._zoomVelocity={value:0},this._truckInternal=(I,A,F)=>{let _,S;if(Xt(this._camera)){const y=Y.copy(this._camera.position).sub(this._target),N=this._camera.getEffectiveFOV()*Le,L=y.length()*Math.tan(N*.5);_=this.truckSpeed*I*L/this._elementRect.height,S=this.truckSpeed*A*L/this._elementRect.height}else if(bt(this._camera)){const y=this._camera;_=I*(y.right-y.left)/y.zoom/this._elementRect.width,S=A*(y.top-y.bottom)/y.zoom/this._elementRect.height}else return;this.verticalDragToForward?(F?this.setFocalOffset(this._focalOffsetEnd.x+_,this._focalOffsetEnd.y,this._focalOffsetEnd.z,!0):this.truck(_,0,!0),this.forward(-S,!0)):F?this.setFocalOffset(this._focalOffsetEnd.x+_,this._focalOffsetEnd.y+S,this._focalOffsetEnd.z,!0):this.truck(_,S,!0)},this._rotateInternal=(I,A)=>{const F=ue*this.azimuthRotateSpeed*I/this._elementRect.height,_=ue*this.polarRotateSpeed*A/this._elementRect.height;this.rotate(F,_,!0)},this._dollyInternal=(I,A,F)=>{const _=Math.pow(.95,-I*this.dollySpeed),S=this._sphericalEnd.radius,y=this._sphericalEnd.radius*_,N=Tt(y,this.minDistance,this.maxDistance),L=N-y;this.infinityDolly&&this.dollyToCursor?this._dollyToNoClamp(y,!0):this.infinityDolly&&!this.dollyToCursor?(this.dollyInFixed(L,!0),this._dollyToNoClamp(N,!0)):this._dollyToNoClamp(N,!0),this.dollyToCursor&&(this._changedDolly+=(this.infinityDolly?y:N)-S,this._dollyControlCoord.set(A,F)),this._lastDollyDirection=Math.sign(-I)},this._zoomInternal=(I,A,F)=>{const _=Math.pow(.95,I*this.dollySpeed),S=this._zoom,y=this._zoom*_;this.zoomTo(y,!0),this.dollyToCursor&&(this._changedZoom+=y-S,this._dollyControlCoord.set(A,F))},typeof v>"u"&&console.error("camera-controls: `THREE` is undefined. You must first run `CameraControls.install( { THREE: THREE } )`. Check the docs for further information."),this._camera=t,this._yAxisUpSpace=new v.Quaternion().setFromUnitVectors(this._camera.up,fs),this._yAxisUpSpaceInverse=this._yAxisUpSpace.clone().invert(),this._state=P.NONE,this._target=new v.Vector3,this._targetEnd=this._target.clone(),this._focalOffset=new v.Vector3,this._focalOffsetEnd=this._focalOffset.clone(),this._spherical=new v.Spherical().setFromVector3(Y.copy(this._camera.position).applyQuaternion(this._yAxisUpSpace)),this._sphericalEnd=this._spherical.clone(),this._lastDistance=this._spherical.radius,this._zoom=this._camera.zoom,this._zoomEnd=this._zoom,this._lastZoom=this._zoom,this._nearPlaneCorners=[new v.Vector3,new v.Vector3,new v.Vector3,new v.Vector3],this._updateNearPlaneCorners(),this._boundary=new v.Box3(new v.Vector3(-1/0,-1/0,-1/0),new v.Vector3(1/0,1/0,1/0)),this._cameraUp0=this._camera.up.clone(),this._target0=this._target.clone(),this._position0=this._camera.position.clone(),this._zoom0=this._zoom,this._focalOffset0=this._focalOffset.clone(),this._dollyControlCoord=new v.Vector2,this.mouseButtons={left:P.ROTATE,middle:P.DOLLY,right:P.TRUCK,wheel:Xt(this._camera)?P.DOLLY:bt(this._camera)?P.ZOOM:P.NONE},this.touches={one:P.TOUCH_ROTATE,two:Xt(this._camera)?P.TOUCH_DOLLY_TRUCK:bt(this._camera)?P.TOUCH_ZOOM_TRUCK:P.NONE,three:P.TOUCH_TRUCK};const s=new v.Vector2,i=new v.Vector2,o=new v.Vector2,n=I=>{if(!this._enabled||!this._domElement)return;if(this._interactiveArea.left!==0||this._interactiveArea.top!==0||this._interactiveArea.width!==1||this._interactiveArea.height!==1){const _=this._domElement.getBoundingClientRect(),S=I.clientX/_.width,y=I.clientY/_.height;if(S<this._interactiveArea.left||S>this._interactiveArea.right||y<this._interactiveArea.top||y>this._interactiveArea.bottom)return}const A=I.pointerType!=="mouse"?null:(I.buttons&B.LEFT)===B.LEFT?B.LEFT:(I.buttons&B.MIDDLE)===B.MIDDLE?B.MIDDLE:(I.buttons&B.RIGHT)===B.RIGHT?B.RIGHT:null;if(A!==null){const _=this._findPointerByMouseButton(A);_&&this._disposePointer(_)}if((I.buttons&B.LEFT)===B.LEFT&&this._lockedPointer)return;const F={pointerId:I.pointerId,clientX:I.clientX,clientY:I.clientY,deltaX:0,deltaY:0,mouseButton:A};this._activePointers.push(F),this._domElement.ownerDocument.removeEventListener("pointermove",a,{passive:!1}),this._domElement.ownerDocument.removeEventListener("pointerup",d),this._domElement.ownerDocument.addEventListener("pointermove",a,{passive:!1}),this._domElement.ownerDocument.addEventListener("pointerup",d),this._isDragging=!0,T(I)},r=I=>{if(!this._enabled||!this._domElement||this._lockedPointer)return;if(this._interactiveArea.left!==0||this._interactiveArea.top!==0||this._interactiveArea.width!==1||this._interactiveArea.height!==1){const _=this._domElement.getBoundingClientRect(),S=I.clientX/_.width,y=I.clientY/_.height;if(S<this._interactiveArea.left||S>this._interactiveArea.right||y<this._interactiveArea.top||y>this._interactiveArea.bottom)return}const A=(I.buttons&B.LEFT)===B.LEFT?B.LEFT:(I.buttons&B.MIDDLE)===B.MIDDLE?B.MIDDLE:(I.buttons&B.RIGHT)===B.RIGHT?B.RIGHT:null;if(A!==null){const _=this._findPointerByMouseButton(A);_&&this._disposePointer(_)}const F={pointerId:1,clientX:I.clientX,clientY:I.clientY,deltaX:0,deltaY:0,mouseButton:(I.buttons&B.LEFT)===B.LEFT?B.LEFT:(I.buttons&B.MIDDLE)===B.LEFT?B.MIDDLE:(I.buttons&B.RIGHT)===B.LEFT?B.RIGHT:null};this._activePointers.push(F),this._domElement.ownerDocument.removeEventListener("mousemove",l),this._domElement.ownerDocument.removeEventListener("mouseup",u),this._domElement.ownerDocument.addEventListener("mousemove",l),this._domElement.ownerDocument.addEventListener("mouseup",u),this._isDragging=!0,T(I)},a=I=>{I.cancelable&&I.preventDefault();const A=I.pointerId,F=this._lockedPointer||this._findPointerById(A);if(F){if(F.clientX=I.clientX,F.clientY=I.clientY,F.deltaX=I.movementX,F.deltaY=I.movementY,this._state=0,I.pointerType==="touch")switch(this._activePointers.length){case 1:this._state=this.touches.one;break;case 2:this._state=this.touches.two;break;case 3:this._state=this.touches.three;break}else(!this._isDragging&&this._lockedPointer||this._isDragging&&(I.buttons&B.LEFT)===B.LEFT)&&(this._state=this._state|this.mouseButtons.left),this._isDragging&&(I.buttons&B.MIDDLE)===B.MIDDLE&&(this._state=this._state|this.mouseButtons.middle),this._isDragging&&(I.buttons&B.RIGHT)===B.RIGHT&&(this._state=this._state|this.mouseButtons.right);m()}},l=I=>{const A=this._lockedPointer||this._findPointerById(1);A&&(A.clientX=I.clientX,A.clientY=I.clientY,A.deltaX=I.movementX,A.deltaY=I.movementY,this._state=0,(this._lockedPointer||(I.buttons&B.LEFT)===B.LEFT)&&(this._state=this._state|this.mouseButtons.left),(I.buttons&B.MIDDLE)===B.MIDDLE&&(this._state=this._state|this.mouseButtons.middle),(I.buttons&B.RIGHT)===B.RIGHT&&(this._state=this._state|this.mouseButtons.right),m())},d=I=>{const A=this._findPointerById(I.pointerId);if(!(A&&A===this._lockedPointer)){if(A&&this._disposePointer(A),I.pointerType==="touch")switch(this._activePointers.length){case 0:this._state=P.NONE;break;case 1:this._state=this.touches.one;break;case 2:this._state=this.touches.two;break;case 3:this._state=this.touches.three;break}else this._state=P.NONE;C()}},u=()=>{const I=this._findPointerById(1);I&&I===this._lockedPointer||(I&&this._disposePointer(I),this._state=P.NONE,C())};let h=-1;const f=I=>{if(!this._domElement||!this._enabled||this.mouseButtons.wheel===P.NONE)return;if(this._interactiveArea.left!==0||this._interactiveArea.top!==0||this._interactiveArea.width!==1||this._interactiveArea.height!==1){const y=this._domElement.getBoundingClientRect(),N=I.clientX/y.width,L=I.clientY/y.height;if(N<this._interactiveArea.left||N>this._interactiveArea.right||L<this._interactiveArea.top||L>this._interactiveArea.bottom)return}if(I.preventDefault(),this.dollyToCursor||this.mouseButtons.wheel===P.ROTATE||this.mouseButtons.wheel===P.TRUCK){const y=performance.now();h-y<1e3&&this._getClientRect(this._elementRect),h=y}const A=_a?-1:-3,F=I.deltaMode===1?I.deltaY/A:I.deltaY/(A*10),_=this.dollyToCursor?(I.clientX-this._elementRect.x)/this._elementRect.width*2-1:0,S=this.dollyToCursor?(I.clientY-this._elementRect.y)/this._elementRect.height*-2+1:0;switch(this.mouseButtons.wheel){case P.ROTATE:{this._rotateInternal(I.deltaX,I.deltaY),this._isUserControllingRotate=!0;break}case P.TRUCK:{this._truckInternal(I.deltaX,I.deltaY,!1),this._isUserControllingTruck=!0;break}case P.OFFSET:{this._truckInternal(I.deltaX,I.deltaY,!0),this._isUserControllingOffset=!0;break}case P.DOLLY:{this._dollyInternal(-F,_,S),this._isUserControllingDolly=!0;break}case P.ZOOM:{this._zoomInternal(-F,_,S),this._isUserControllingZoom=!0;break}}this.dispatchEvent({type:"control"})},p=I=>{if(!(!this._domElement||!this._enabled)){if(this.mouseButtons.right===rt.ACTION.NONE){const A=I instanceof PointerEvent?I.pointerId:(I instanceof MouseEvent,0),F=this._findPointerById(A);F&&this._disposePointer(F),this._domElement.ownerDocument.removeEventListener("pointermove",a,{passive:!1}),this._domElement.ownerDocument.removeEventListener("pointerup",d),this._domElement.ownerDocument.removeEventListener("mousemove",l),this._domElement.ownerDocument.removeEventListener("mouseup",u);return}I.preventDefault()}},T=I=>{if(!this._enabled)return;if(Zs(this._activePointers,lt),this._getClientRect(this._elementRect),s.copy(lt),i.copy(lt),this._activePointers.length>=2){const F=lt.x-this._activePointers[1].clientX,_=lt.y-this._activePointers[1].clientY,S=Math.sqrt(F*F+_*_);o.set(0,S);const y=(this._activePointers[0].clientX+this._activePointers[1].clientX)*.5,N=(this._activePointers[0].clientY+this._activePointers[1].clientY)*.5;i.set(y,N)}if(this._state=0,!I)this._lockedPointer&&(this._state=this._state|this.mouseButtons.left);else if("pointerType"in I&&I.pointerType==="touch")switch(this._activePointers.length){case 1:this._state=this.touches.one;break;case 2:this._state=this.touches.two;break;case 3:this._state=this.touches.three;break}else!this._lockedPointer&&(I.buttons&B.LEFT)===B.LEFT&&(this._state=this._state|this.mouseButtons.left),(I.buttons&B.MIDDLE)===B.MIDDLE&&(this._state=this._state|this.mouseButtons.middle),(I.buttons&B.RIGHT)===B.RIGHT&&(this._state=this._state|this.mouseButtons.right);((this._state&P.ROTATE)===P.ROTATE||(this._state&P.TOUCH_ROTATE)===P.TOUCH_ROTATE||(this._state&P.TOUCH_DOLLY_ROTATE)===P.TOUCH_DOLLY_ROTATE||(this._state&P.TOUCH_ZOOM_ROTATE)===P.TOUCH_ZOOM_ROTATE)&&(this._sphericalEnd.theta=this._spherical.theta,this._sphericalEnd.phi=this._spherical.phi,this._thetaVelocity.value=0,this._phiVelocity.value=0),((this._state&P.TRUCK)===P.TRUCK||(this._state&P.TOUCH_TRUCK)===P.TOUCH_TRUCK||(this._state&P.TOUCH_DOLLY_TRUCK)===P.TOUCH_DOLLY_TRUCK||(this._state&P.TOUCH_ZOOM_TRUCK)===P.TOUCH_ZOOM_TRUCK)&&(this._targetEnd.copy(this._target),this._targetVelocity.set(0,0,0)),((this._state&P.DOLLY)===P.DOLLY||(this._state&P.TOUCH_DOLLY)===P.TOUCH_DOLLY||(this._state&P.TOUCH_DOLLY_TRUCK)===P.TOUCH_DOLLY_TRUCK||(this._state&P.TOUCH_DOLLY_OFFSET)===P.TOUCH_DOLLY_OFFSET||(this._state&P.TOUCH_DOLLY_ROTATE)===P.TOUCH_DOLLY_ROTATE)&&(this._sphericalEnd.radius=this._spherical.radius,this._radiusVelocity.value=0),((this._state&P.ZOOM)===P.ZOOM||(this._state&P.TOUCH_ZOOM)===P.TOUCH_ZOOM||(this._state&P.TOUCH_ZOOM_TRUCK)===P.TOUCH_ZOOM_TRUCK||(this._state&P.TOUCH_ZOOM_OFFSET)===P.TOUCH_ZOOM_OFFSET||(this._state&P.TOUCH_ZOOM_ROTATE)===P.TOUCH_ZOOM_ROTATE)&&(this._zoomEnd=this._zoom,this._zoomVelocity.value=0),((this._state&P.OFFSET)===P.OFFSET||(this._state&P.TOUCH_OFFSET)===P.TOUCH_OFFSET||(this._state&P.TOUCH_DOLLY_OFFSET)===P.TOUCH_DOLLY_OFFSET||(this._state&P.TOUCH_ZOOM_OFFSET)===P.TOUCH_ZOOM_OFFSET)&&(this._focalOffsetEnd.copy(this._focalOffset),this._focalOffsetVelocity.set(0,0,0)),this.dispatchEvent({type:"controlstart"})},m=()=>{if(!this._enabled||!this._dragNeedsUpdate)return;this._dragNeedsUpdate=!1,Zs(this._activePointers,lt);const A=this._domElement&&document.pointerLockElement===this._domElement?this._lockedPointer||this._activePointers[0]:null,F=A?-A.deltaX:i.x-lt.x,_=A?-A.deltaY:i.y-lt.y;if(i.copy(lt),((this._state&P.ROTATE)===P.ROTATE||(this._state&P.TOUCH_ROTATE)===P.TOUCH_ROTATE||(this._state&P.TOUCH_DOLLY_ROTATE)===P.TOUCH_DOLLY_ROTATE||(this._state&P.TOUCH_ZOOM_ROTATE)===P.TOUCH_ZOOM_ROTATE)&&(this._rotateInternal(F,_),this._isUserControllingRotate=!0),(this._state&P.DOLLY)===P.DOLLY||(this._state&P.ZOOM)===P.ZOOM){const S=this.dollyToCursor?(s.x-this._elementRect.x)/this._elementRect.width*2-1:0,y=this.dollyToCursor?(s.y-this._elementRect.y)/this._elementRect.height*-2+1:0,N=this.dollyDragInverted?-1:1;(this._state&P.DOLLY)===P.DOLLY?(this._dollyInternal(N*_*Es,S,y),this._isUserControllingDolly=!0):(this._zoomInternal(N*_*Es,S,y),this._isUserControllingZoom=!0)}if((this._state&P.TOUCH_DOLLY)===P.TOUCH_DOLLY||(this._state&P.TOUCH_ZOOM)===P.TOUCH_ZOOM||(this._state&P.TOUCH_DOLLY_TRUCK)===P.TOUCH_DOLLY_TRUCK||(this._state&P.TOUCH_ZOOM_TRUCK)===P.TOUCH_ZOOM_TRUCK||(this._state&P.TOUCH_DOLLY_OFFSET)===P.TOUCH_DOLLY_OFFSET||(this._state&P.TOUCH_ZOOM_OFFSET)===P.TOUCH_ZOOM_OFFSET||(this._state&P.TOUCH_DOLLY_ROTATE)===P.TOUCH_DOLLY_ROTATE||(this._state&P.TOUCH_ZOOM_ROTATE)===P.TOUCH_ZOOM_ROTATE){const S=lt.x-this._activePointers[1].clientX,y=lt.y-this._activePointers[1].clientY,N=Math.sqrt(S*S+y*y),L=o.y-N;o.set(0,N);const w=this.dollyToCursor?(i.x-this._elementRect.x)/this._elementRect.width*2-1:0,D=this.dollyToCursor?(i.y-this._elementRect.y)/this._elementRect.height*-2+1:0;(this._state&P.TOUCH_DOLLY)===P.TOUCH_DOLLY||(this._state&P.TOUCH_DOLLY_ROTATE)===P.TOUCH_DOLLY_ROTATE||(this._state&P.TOUCH_DOLLY_TRUCK)===P.TOUCH_DOLLY_TRUCK||(this._state&P.TOUCH_DOLLY_OFFSET)===P.TOUCH_DOLLY_OFFSET?(this._dollyInternal(L*Es,w,D),this._isUserControllingDolly=!0):(this._zoomInternal(L*Es,w,D),this._isUserControllingZoom=!0)}((this._state&P.TRUCK)===P.TRUCK||(this._state&P.TOUCH_TRUCK)===P.TOUCH_TRUCK||(this._state&P.TOUCH_DOLLY_TRUCK)===P.TOUCH_DOLLY_TRUCK||(this._state&P.TOUCH_ZOOM_TRUCK)===P.TOUCH_ZOOM_TRUCK)&&(this._truckInternal(F,_,!1),this._isUserControllingTruck=!0),((this._state&P.OFFSET)===P.OFFSET||(this._state&P.TOUCH_OFFSET)===P.TOUCH_OFFSET||(this._state&P.TOUCH_DOLLY_OFFSET)===P.TOUCH_DOLLY_OFFSET||(this._state&P.TOUCH_ZOOM_OFFSET)===P.TOUCH_ZOOM_OFFSET)&&(this._truckInternal(F,_,!0),this._isUserControllingOffset=!0),this.dispatchEvent({type:"control"})},C=()=>{Zs(this._activePointers,lt),i.copy(lt),this._dragNeedsUpdate=!1,(this._activePointers.length===0||this._activePointers.length===1&&this._activePointers[0]===this._lockedPointer)&&(this._isDragging=!1),this._activePointers.length===0&&this._domElement&&(this._domElement.ownerDocument.removeEventListener("pointermove",a,{passive:!1}),this._domElement.ownerDocument.removeEventListener("mousemove",l),this._domElement.ownerDocument.removeEventListener("pointerup",d),this._domElement.ownerDocument.removeEventListener("mouseup",u),this.dispatchEvent({type:"controlend"}))};this.lockPointer=()=>{!this._enabled||!this._domElement||(this.cancel(),this._lockedPointer={pointerId:-1,clientX:0,clientY:0,deltaX:0,deltaY:0,mouseButton:null},this._activePointers.push(this._lockedPointer),this._domElement.ownerDocument.removeEventListener("pointermove",a,{passive:!1}),this._domElement.ownerDocument.removeEventListener("pointerup",d),this._domElement.requestPointerLock(),this._domElement.ownerDocument.addEventListener("pointerlockchange",R),this._domElement.ownerDocument.addEventListener("pointerlockerror",g),this._domElement.ownerDocument.addEventListener("pointermove",a,{passive:!1}),this._domElement.ownerDocument.addEventListener("pointerup",d),T())},this.unlockPointer=()=>{this._lockedPointer!==null&&(this._disposePointer(this._lockedPointer),this._lockedPointer=null),document.exitPointerLock(),this.cancel(),this._domElement&&(this._domElement.ownerDocument.removeEventListener("pointerlockchange",R),this._domElement.ownerDocument.removeEventListener("pointerlockerror",g))};const R=()=>{this._domElement&&this._domElement.ownerDocument.pointerLockElement===this._domElement||this.unlockPointer()},g=()=>{this.unlockPointer()};this._addAllEventListeners=I=>{this._domElement=I,this._domElement.style.touchAction="none",this._domElement.style.userSelect="none",this._domElement.style.webkitUserSelect="none",this._domElement.addEventListener("pointerdown",n),Oa&&this._domElement.addEventListener("mousedown",r),this._domElement.addEventListener("pointercancel",d),this._domElement.addEventListener("wheel",f,{passive:!1}),this._domElement.addEventListener("contextmenu",p)},this._removeAllEventListeners=()=>{this._domElement&&(this._domElement.style.touchAction="",this._domElement.style.userSelect="",this._domElement.style.webkitUserSelect="",this._domElement.removeEventListener("pointerdown",n),this._domElement.removeEventListener("mousedown",r),this._domElement.removeEventListener("pointercancel",d),this._domElement.removeEventListener("wheel",f,{passive:!1}),this._domElement.removeEventListener("contextmenu",p),this._domElement.ownerDocument.removeEventListener("pointermove",a,{passive:!1}),this._domElement.ownerDocument.removeEventListener("mousemove",l),this._domElement.ownerDocument.removeEventListener("pointerup",d),this._domElement.ownerDocument.removeEventListener("mouseup",u),this._domElement.ownerDocument.removeEventListener("pointerlockchange",R),this._domElement.ownerDocument.removeEventListener("pointerlockerror",g))},this.cancel=()=>{this._state!==P.NONE&&(this._state=P.NONE,this._activePointers.length=0,C())},e&&this.connect(e),this.update(0)}get camera(){return this._camera}set camera(t){this._camera=t,this.updateCameraUp(),this._camera.updateProjectionMatrix(),this._updateNearPlaneCorners(),this._needsUpdate=!0}get enabled(){return this._enabled}set enabled(t){this._enabled=t,this._domElement&&(t?(this._domElement.style.touchAction="none",this._domElement.style.userSelect="none",this._domElement.style.webkitUserSelect="none"):(this.cancel(),this._domElement.style.touchAction="",this._domElement.style.userSelect="",this._domElement.style.webkitUserSelect=""))}get active(){return!this._hasRested}get currentAction(){return this._state}get distance(){return this._spherical.radius}set distance(t){this._spherical.radius===t&&this._sphericalEnd.radius===t||(this._spherical.radius=t,this._sphericalEnd.radius=t,this._needsUpdate=!0)}get azimuthAngle(){return this._spherical.theta}set azimuthAngle(t){this._spherical.theta===t&&this._sphericalEnd.theta===t||(this._spherical.theta=t,this._sphericalEnd.theta=t,this._needsUpdate=!0)}get polarAngle(){return this._spherical.phi}set polarAngle(t){this._spherical.phi===t&&this._sphericalEnd.phi===t||(this._spherical.phi=t,this._sphericalEnd.phi=t,this._needsUpdate=!0)}get boundaryEnclosesCamera(){return this._boundaryEnclosesCamera}set boundaryEnclosesCamera(t){this._boundaryEnclosesCamera=t,this._needsUpdate=!0}set interactiveArea(t){this._interactiveArea.width=Tt(t.width,0,1),this._interactiveArea.height=Tt(t.height,0,1),this._interactiveArea.x=Tt(t.x,0,1-this._interactiveArea.width),this._interactiveArea.y=Tt(t.y,0,1-this._interactiveArea.height)}addEventListener(t,e){super.addEventListener(t,e)}removeEventListener(t,e){super.removeEventListener(t,e)}rotate(t,e,s=!1){return this.rotateTo(this._sphericalEnd.theta+t,this._sphericalEnd.phi+e,s)}rotateAzimuthTo(t,e=!1){return this.rotateTo(t,this._sphericalEnd.phi,e)}rotatePolarTo(t,e=!1){return this.rotateTo(this._sphericalEnd.theta,t,e)}rotateTo(t,e,s=!1){this._isUserControllingRotate=!1;const i=Tt(t,this.minAzimuthAngle,this.maxAzimuthAngle),o=Tt(e,this.minPolarAngle,this.maxPolarAngle);this._sphericalEnd.theta=i,this._sphericalEnd.phi=o,this._sphericalEnd.makeSafe(),this._needsUpdate=!0,s||(this._spherical.theta=this._sphericalEnd.theta,this._spherical.phi=this._sphericalEnd.phi);const n=!s||V(this._spherical.theta,this._sphericalEnd.theta,this.restThreshold)&&V(this._spherical.phi,this._sphericalEnd.phi,this.restThreshold);return this._createOnRestPromise(n)}dolly(t,e=!1){return this.dollyTo(this._sphericalEnd.radius-t,e)}dollyTo(t,e=!1){return this._isUserControllingDolly=!1,this._lastDollyDirection=de.NONE,this._changedDolly=0,this._dollyToNoClamp(Tt(t,this.minDistance,this.maxDistance),e)}_dollyToNoClamp(t,e=!1){const s=this._sphericalEnd.radius;if(this.colliderMeshes.length>=1){const n=this._collisionTest(),r=V(n,this._spherical.radius);if(!(s>t)&&r)return Promise.resolve();this._sphericalEnd.radius=Math.min(t,n)}else this._sphericalEnd.radius=t;this._needsUpdate=!0,e||(this._spherical.radius=this._sphericalEnd.radius);const o=!e||V(this._spherical.radius,this._sphericalEnd.radius,this.restThreshold);return this._createOnRestPromise(o)}dollyInFixed(t,e=!1){this._targetEnd.add(this._getCameraDirection(Ue).multiplyScalar(t)),e||this._target.copy(this._targetEnd);const s=!e||V(this._target.x,this._targetEnd.x,this.restThreshold)&&V(this._target.y,this._targetEnd.y,this.restThreshold)&&V(this._target.z,this._targetEnd.z,this.restThreshold);return this._createOnRestPromise(s)}zoom(t,e=!1){return this.zoomTo(this._zoomEnd+t,e)}zoomTo(t,e=!1){this._isUserControllingZoom=!1,this._zoomEnd=Tt(t,this.minZoom,this.maxZoom),this._needsUpdate=!0,e||(this._zoom=this._zoomEnd);const s=!e||V(this._zoom,this._zoomEnd,this.restThreshold);return this._changedZoom=0,this._createOnRestPromise(s)}pan(t,e,s=!1){return console.warn("`pan` has been renamed to `truck`"),this.truck(t,e,s)}truck(t,e,s=!1){this._camera.updateMatrix(),_t.setFromMatrixColumn(this._camera.matrix,0),Ot.setFromMatrixColumn(this._camera.matrix,1),_t.multiplyScalar(t),Ot.multiplyScalar(-e);const i=Y.copy(_t).add(Ot),o=z.copy(this._targetEnd).add(i);return this.moveTo(o.x,o.y,o.z,s)}forward(t,e=!1){Y.setFromMatrixColumn(this._camera.matrix,0),Y.crossVectors(this._camera.up,Y),Y.multiplyScalar(t);const s=z.copy(this._targetEnd).add(Y);return this.moveTo(s.x,s.y,s.z,e)}elevate(t,e=!1){return Y.copy(this._camera.up).multiplyScalar(t),this.moveTo(this._targetEnd.x+Y.x,this._targetEnd.y+Y.y,this._targetEnd.z+Y.z,e)}moveTo(t,e,s,i=!1){this._isUserControllingTruck=!1;const o=Y.set(t,e,s).sub(this._targetEnd);this._encloseToBoundary(this._targetEnd,o,this.boundaryFriction),this._needsUpdate=!0,i||this._target.copy(this._targetEnd);const n=!i||V(this._target.x,this._targetEnd.x,this.restThreshold)&&V(this._target.y,this._targetEnd.y,this.restThreshold)&&V(this._target.z,this._targetEnd.z,this.restThreshold);return this._createOnRestPromise(n)}lookInDirectionOf(t,e,s,i=!1){const r=Y.set(t,e,s).sub(this._targetEnd).normalize().multiplyScalar(-this._sphericalEnd.radius);return this.setPosition(r.x,r.y,r.z,i)}fitToBox(t,e,{cover:s=!1,paddingLeft:i=0,paddingRight:o=0,paddingBottom:n=0,paddingTop:r=0}={}){const a=[],l=t.isBox3?fe.copy(t):fe.setFromObject(t);l.isEmpty()&&(console.warn("camera-controls: fitTo() cannot be used with an empty box. Aborting"),Promise.resolve());const d=pn(this._sphericalEnd.theta,In),u=pn(this._sphericalEnd.phi,In);a.push(this.rotateTo(d,u,e));const h=Y.setFromSpherical(this._sphericalEnd).normalize(),f=gn.setFromUnitVectors(h,js),p=V(Math.abs(h.y),1);p&&f.multiply($s.setFromAxisAngle(fs,d)),f.multiply(this._yAxisUpSpaceInverse);const T=An.makeEmpty();z.copy(l.min).applyQuaternion(f),T.expandByPoint(z),z.copy(l.min).setX(l.max.x).applyQuaternion(f),T.expandByPoint(z),z.copy(l.min).setY(l.max.y).applyQuaternion(f),T.expandByPoint(z),z.copy(l.max).setZ(l.min.z).applyQuaternion(f),T.expandByPoint(z),z.copy(l.min).setZ(l.max.z).applyQuaternion(f),T.expandByPoint(z),z.copy(l.max).setY(l.min.y).applyQuaternion(f),T.expandByPoint(z),z.copy(l.max).setX(l.min.x).applyQuaternion(f),T.expandByPoint(z),z.copy(l.max).applyQuaternion(f),T.expandByPoint(z),T.min.x-=i,T.min.y-=n,T.max.x+=o,T.max.y+=r,f.setFromUnitVectors(js,h),p&&f.premultiply($s.invert()),f.premultiply(this._yAxisUpSpace);const m=T.getSize(Y),C=T.getCenter(z).applyQuaternion(f);if(Xt(this._camera)){const R=this.getDistanceToFitBox(m.x,m.y,m.z,s);a.push(this.moveTo(C.x,C.y,C.z,e)),a.push(this.dollyTo(R,e)),a.push(this.setFocalOffset(0,0,0,e))}else if(bt(this._camera)){const R=this._camera,g=R.right-R.left,I=R.top-R.bottom,A=s?Math.max(g/m.x,I/m.y):Math.min(g/m.x,I/m.y);a.push(this.moveTo(C.x,C.y,C.z,e)),a.push(this.zoomTo(A,e)),a.push(this.setFocalOffset(0,0,0,e))}return Promise.all(a)}fitToSphere(t,e){const s=[],o=t instanceof v.Sphere?qs.copy(t):rt.createBoundingSphere(t,qs);if(s.push(this.moveTo(o.center.x,o.center.y,o.center.z,e)),Xt(this._camera)){const n=this.getDistanceToFitSphere(o.radius);s.push(this.dollyTo(n,e))}else if(bt(this._camera)){const n=this._camera.right-this._camera.left,r=this._camera.top-this._camera.bottom,a=2*o.radius,l=Math.min(n/a,r/a);s.push(this.zoomTo(l,e))}return s.push(this.setFocalOffset(0,0,0,e)),Promise.all(s)}setLookAt(t,e,s,i,o,n,r=!1){this._isUserControllingRotate=!1,this._isUserControllingDolly=!1,this._isUserControllingTruck=!1,this._lastDollyDirection=de.NONE,this._changedDolly=0;const a=z.set(i,o,n),l=Y.set(t,e,s);this._targetEnd.copy(a),this._sphericalEnd.setFromVector3(l.sub(a).applyQuaternion(this._yAxisUpSpace)),this.normalizeRotations(),this._needsUpdate=!0,r||(this._target.copy(this._targetEnd),this._spherical.copy(this._sphericalEnd));const d=!r||V(this._target.x,this._targetEnd.x,this.restThreshold)&&V(this._target.y,this._targetEnd.y,this.restThreshold)&&V(this._target.z,this._targetEnd.z,this.restThreshold)&&V(this._spherical.theta,this._sphericalEnd.theta,this.restThreshold)&&V(this._spherical.phi,this._sphericalEnd.phi,this.restThreshold)&&V(this._spherical.radius,this._sphericalEnd.radius,this.restThreshold);return this._createOnRestPromise(d)}lerpLookAt(t,e,s,i,o,n,r,a,l,d,u,h,f,p=!1){this._isUserControllingRotate=!1,this._isUserControllingDolly=!1,this._isUserControllingTruck=!1,this._lastDollyDirection=de.NONE,this._changedDolly=0;const T=Y.set(i,o,n),m=z.set(t,e,s);ut.setFromVector3(m.sub(T).applyQuaternion(this._yAxisUpSpace));const C=Ee.set(d,u,h),R=z.set(r,a,l);xe.setFromVector3(R.sub(C).applyQuaternion(this._yAxisUpSpace)),this._targetEnd.copy(T.lerp(C,f));const g=xe.theta-ut.theta,I=xe.phi-ut.phi,A=xe.radius-ut.radius;this._sphericalEnd.set(ut.radius+A*f,ut.phi+I*f,ut.theta+g*f),this.normalizeRotations(),this._needsUpdate=!0,p||(this._target.copy(this._targetEnd),this._spherical.copy(this._sphericalEnd));const F=!p||V(this._target.x,this._targetEnd.x,this.restThreshold)&&V(this._target.y,this._targetEnd.y,this.restThreshold)&&V(this._target.z,this._targetEnd.z,this.restThreshold)&&V(this._spherical.theta,this._sphericalEnd.theta,this.restThreshold)&&V(this._spherical.phi,this._sphericalEnd.phi,this.restThreshold)&&V(this._spherical.radius,this._sphericalEnd.radius,this.restThreshold);return this._createOnRestPromise(F)}setPosition(t,e,s,i=!1){return this.setLookAt(t,e,s,this._targetEnd.x,this._targetEnd.y,this._targetEnd.z,i)}setTarget(t,e,s,i=!1){const o=this.getPosition(Y),n=this.setLookAt(o.x,o.y,o.z,t,e,s,i);return this._sphericalEnd.phi=Tt(this._sphericalEnd.phi,this.minPolarAngle,this.maxPolarAngle),n}setFocalOffset(t,e,s,i=!1){this._isUserControllingOffset=!1,this._focalOffsetEnd.set(t,e,s),this._needsUpdate=!0,i||this._focalOffset.copy(this._focalOffsetEnd);const o=!i||V(this._focalOffset.x,this._focalOffsetEnd.x,this.restThreshold)&&V(this._focalOffset.y,this._focalOffsetEnd.y,this.restThreshold)&&V(this._focalOffset.z,this._focalOffsetEnd.z,this.restThreshold);return this._createOnRestPromise(o)}setOrbitPoint(t,e,s){this._camera.updateMatrixWorld(),_t.setFromMatrixColumn(this._camera.matrixWorldInverse,0),Ot.setFromMatrixColumn(this._camera.matrixWorldInverse,1),Zt.setFromMatrixColumn(this._camera.matrixWorldInverse,2);const i=Y.set(t,e,s),o=i.distanceTo(this._camera.position),n=i.sub(this._camera.position);_t.multiplyScalar(n.x),Ot.multiplyScalar(n.y),Zt.multiplyScalar(n.z),Y.copy(_t).add(Ot).add(Zt),Y.z=Y.z+o,this.dollyTo(o,!1),this.setFocalOffset(-Y.x,Y.y,-Y.z,!1),this.moveTo(t,e,s,!1)}setBoundary(t){if(!t){this._boundary.min.set(-1/0,-1/0,-1/0),this._boundary.max.set(1/0,1/0,1/0),this._needsUpdate=!0;return}this._boundary.copy(t),this._boundary.clampPoint(this._targetEnd,this._targetEnd),this._needsUpdate=!0}setViewport(t,e,s,i){if(t===null){this._viewport=null;return}this._viewport=this._viewport||new v.Vector4,typeof t=="number"?this._viewport.set(t,e,s,i):this._viewport.copy(t)}getDistanceToFitBox(t,e,s,i=!1){if(Qs(this._camera,"getDistanceToFitBox"))return this._spherical.radius;const o=t/e,n=this._camera.getEffectiveFOV()*Le,r=this._camera.aspect;return((i?o>r:o<r)?e:t/r)*.5/Math.tan(n*.5)+s*.5}getDistanceToFitSphere(t){if(Qs(this._camera,"getDistanceToFitSphere"))return this._spherical.radius;const e=this._camera.getEffectiveFOV()*Le,s=Math.atan(Math.tan(e*.5)*this._camera.aspect)*2,i=1<this._camera.aspect?e:s;return t/Math.sin(i*.5)}getTarget(t,e=!0){return(t&&t.isVector3?t:new v.Vector3).copy(e?this._targetEnd:this._target)}getPosition(t,e=!0){return(t&&t.isVector3?t:new v.Vector3).setFromSpherical(e?this._sphericalEnd:this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(e?this._targetEnd:this._target)}getSpherical(t,e=!0){return(t&&t instanceof v.Spherical?t:new v.Spherical).copy(e?this._sphericalEnd:this._spherical)}getFocalOffset(t,e=!0){return(t&&t.isVector3?t:new v.Vector3).copy(e?this._focalOffsetEnd:this._focalOffset)}normalizeRotations(){this._sphericalEnd.theta=this._sphericalEnd.theta%ue,this._sphericalEnd.theta<0&&(this._sphericalEnd.theta+=ue),this._spherical.theta+=ue*Math.round((this._sphericalEnd.theta-this._spherical.theta)/ue)}reset(t=!1){if(!V(this._camera.up.x,this._cameraUp0.x)||!V(this._camera.up.y,this._cameraUp0.y)||!V(this._camera.up.z,this._cameraUp0.z)){this._camera.up.copy(this._cameraUp0);const s=this.getPosition(Y);this.updateCameraUp(),this.setPosition(s.x,s.y,s.z)}const e=[this.setLookAt(this._position0.x,this._position0.y,this._position0.z,this._target0.x,this._target0.y,this._target0.z,t),this.setFocalOffset(this._focalOffset0.x,this._focalOffset0.y,this._focalOffset0.z,t),this.zoomTo(this._zoom0,t)];return Promise.all(e)}saveState(){this._cameraUp0.copy(this._camera.up),this.getTarget(this._target0),this.getPosition(this._position0),this._zoom0=this._zoom,this._focalOffset0.copy(this._focalOffset)}updateCameraUp(){this._yAxisUpSpace.setFromUnitVectors(this._camera.up,fs),this._yAxisUpSpaceInverse.copy(this._yAxisUpSpace).invert()}applyCameraUp(){const t=Y.subVectors(this._target,this._camera.position).normalize(),e=z.crossVectors(t,this._camera.up);this._camera.up.crossVectors(e,t).normalize(),this._camera.updateMatrixWorld();const s=this.getPosition(Y);this.updateCameraUp(),this.setPosition(s.x,s.y,s.z)}update(t){const e=this._sphericalEnd.theta-this._spherical.theta,s=this._sphericalEnd.phi-this._spherical.phi,i=this._sphericalEnd.radius-this._spherical.radius,o=mn.subVectors(this._targetEnd,this._target),n=Rn.subVectors(this._focalOffsetEnd,this._focalOffset),r=this._zoomEnd-this._zoom;if(k(e))this._thetaVelocity.value=0,this._spherical.theta=this._sphericalEnd.theta;else{const u=this._isUserControllingRotate?this.draggingSmoothTime:this.smoothTime;this._spherical.theta=us(this._spherical.theta,this._sphericalEnd.theta,this._thetaVelocity,u,1/0,t),this._needsUpdate=!0}if(k(s))this._phiVelocity.value=0,this._spherical.phi=this._sphericalEnd.phi;else{const u=this._isUserControllingRotate?this.draggingSmoothTime:this.smoothTime;this._spherical.phi=us(this._spherical.phi,this._sphericalEnd.phi,this._phiVelocity,u,1/0,t),this._needsUpdate=!0}if(k(i))this._radiusVelocity.value=0,this._spherical.radius=this._sphericalEnd.radius;else{const u=this._isUserControllingDolly?this.draggingSmoothTime:this.smoothTime;this._spherical.radius=us(this._spherical.radius,this._sphericalEnd.radius,this._radiusVelocity,u,this.maxSpeed,t),this._needsUpdate=!0}if(k(o.x)&&k(o.y)&&k(o.z))this._targetVelocity.set(0,0,0),this._target.copy(this._targetEnd);else{const u=this._isUserControllingTruck?this.draggingSmoothTime:this.smoothTime;Cn(this._target,this._targetEnd,this._targetVelocity,u,this.maxSpeed,t,this._target),this._needsUpdate=!0}if(k(n.x)&&k(n.y)&&k(n.z))this._focalOffsetVelocity.set(0,0,0),this._focalOffset.copy(this._focalOffsetEnd);else{const u=this._isUserControllingOffset?this.draggingSmoothTime:this.smoothTime;Cn(this._focalOffset,this._focalOffsetEnd,this._focalOffsetVelocity,u,this.maxSpeed,t,this._focalOffset),this._needsUpdate=!0}if(k(r))this._zoomVelocity.value=0,this._zoom=this._zoomEnd;else{const u=this._isUserControllingZoom?this.draggingSmoothTime:this.smoothTime;this._zoom=us(this._zoom,this._zoomEnd,this._zoomVelocity,u,1/0,t)}if(this.dollyToCursor){if(Xt(this._camera)&&this._changedDolly!==0){const u=this._spherical.radius-this._lastDistance,h=this._camera,f=this._getCameraDirection(Ue),p=Y.copy(f).cross(h.up).normalize();p.lengthSq()===0&&(p.x=1);const T=z.crossVectors(p,f),m=this._sphericalEnd.radius*Math.tan(h.getEffectiveFOV()*Le*.5),R=(this._sphericalEnd.radius-u-this._sphericalEnd.radius)/this._sphericalEnd.radius,g=Ee.copy(this._targetEnd).add(p.multiplyScalar(this._dollyControlCoord.x*m*h.aspect)).add(T.multiplyScalar(this._dollyControlCoord.y*m)),I=Y.copy(this._targetEnd).lerp(g,R),A=this._lastDollyDirection===de.IN&&this._spherical.radius<=this.minDistance,F=this._lastDollyDirection===de.OUT&&this.maxDistance<=this._spherical.radius;if(this.infinityDolly&&(A||F)){this._sphericalEnd.radius-=u,this._spherical.radius-=u;const S=z.copy(f).multiplyScalar(-u);I.add(S)}this._boundary.clampPoint(I,I);const _=z.subVectors(I,this._targetEnd);this._targetEnd.copy(I),this._target.add(_),this._changedDolly-=u,k(this._changedDolly)&&(this._changedDolly=0)}else if(bt(this._camera)&&this._changedZoom!==0){const u=this._zoom-this._lastZoom,h=this._camera,f=Y.set(this._dollyControlCoord.x,this._dollyControlCoord.y,(h.near+h.far)/(h.near-h.far)).unproject(h),p=z.set(0,0,-1).applyQuaternion(h.quaternion),T=Ee.copy(f).add(p.multiplyScalar(-f.dot(h.up))),C=-(this._zoom-u-this._zoom)/this._zoom,R=this._getCameraDirection(Ue),g=this._targetEnd.dot(R),I=Y.copy(this._targetEnd).lerp(T,C),A=I.dot(R),F=R.multiplyScalar(A-g);I.sub(F),this._boundary.clampPoint(I,I);const _=z.subVectors(I,this._targetEnd);this._targetEnd.copy(I),this._target.add(_),this._changedZoom-=u,k(this._changedZoom)&&(this._changedZoom=0)}}this._camera.zoom!==this._zoom&&(this._camera.zoom=this._zoom,this._camera.updateProjectionMatrix(),this._updateNearPlaneCorners(),this._needsUpdate=!0),this._dragNeedsUpdate=!0;const a=this._collisionTest();this._spherical.radius=Math.min(this._spherical.radius,a),this._spherical.makeSafe(),this._camera.position.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(this._target),this._camera.lookAt(this._target),(!k(this._focalOffset.x)||!k(this._focalOffset.y)||!k(this._focalOffset.z))&&(this._camera.updateMatrixWorld(),_t.setFromMatrixColumn(this._camera.matrix,0),Ot.setFromMatrixColumn(this._camera.matrix,1),Zt.setFromMatrixColumn(this._camera.matrix,2),_t.multiplyScalar(this._focalOffset.x),Ot.multiplyScalar(-this._focalOffset.y),Zt.multiplyScalar(this._focalOffset.z),Y.copy(_t).add(Ot).add(Zt),this._camera.position.add(Y)),this._boundaryEnclosesCamera&&this._encloseToBoundary(this._camera.position.copy(this._target),Y.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse),1);const d=this._needsUpdate;return d&&!this._updatedLastTime?(this._hasRested=!1,this.dispatchEvent({type:"wake"}),this.dispatchEvent({type:"update"})):d?(this.dispatchEvent({type:"update"}),k(e,this.restThreshold)&&k(s,this.restThreshold)&&k(i,this.restThreshold)&&k(o.x,this.restThreshold)&&k(o.y,this.restThreshold)&&k(o.z,this.restThreshold)&&k(n.x,this.restThreshold)&&k(n.y,this.restThreshold)&&k(n.z,this.restThreshold)&&k(r,this.restThreshold)&&!this._hasRested&&(this._hasRested=!0,this.dispatchEvent({type:"rest"}))):!d&&this._updatedLastTime&&this.dispatchEvent({type:"sleep"}),this._lastDistance=this._spherical.radius,this._lastZoom=this._zoom,this._updatedLastTime=d,this._needsUpdate=!1,d}toJSON(){return JSON.stringify({enabled:this._enabled,minDistance:this.minDistance,maxDistance:Me(this.maxDistance),minZoom:this.minZoom,maxZoom:Me(this.maxZoom),minPolarAngle:this.minPolarAngle,maxPolarAngle:Me(this.maxPolarAngle),minAzimuthAngle:Me(this.minAzimuthAngle),maxAzimuthAngle:Me(this.maxAzimuthAngle),smoothTime:this.smoothTime,draggingSmoothTime:this.draggingSmoothTime,dollySpeed:this.dollySpeed,truckSpeed:this.truckSpeed,dollyToCursor:this.dollyToCursor,verticalDragToForward:this.verticalDragToForward,target:this._targetEnd.toArray(),position:Y.setFromSpherical(this._sphericalEnd).add(this._targetEnd).toArray(),zoom:this._zoomEnd,focalOffset:this._focalOffsetEnd.toArray(),target0:this._target0.toArray(),position0:this._position0.toArray(),zoom0:this._zoom0,focalOffset0:this._focalOffset0.toArray()})}fromJSON(t,e=!1){const s=JSON.parse(t);this.enabled=s.enabled,this.minDistance=s.minDistance,this.maxDistance=De(s.maxDistance),this.minZoom=s.minZoom,this.maxZoom=De(s.maxZoom),this.minPolarAngle=s.minPolarAngle,this.maxPolarAngle=De(s.maxPolarAngle),this.minAzimuthAngle=De(s.minAzimuthAngle),this.maxAzimuthAngle=De(s.maxAzimuthAngle),this.smoothTime=s.smoothTime,this.draggingSmoothTime=s.draggingSmoothTime,this.dollySpeed=s.dollySpeed,this.truckSpeed=s.truckSpeed,this.dollyToCursor=s.dollyToCursor,this.verticalDragToForward=s.verticalDragToForward,this._target0.fromArray(s.target0),this._position0.fromArray(s.position0),this._zoom0=s.zoom0,this._focalOffset0.fromArray(s.focalOffset0),this.moveTo(s.target[0],s.target[1],s.target[2],e),ut.setFromVector3(Y.fromArray(s.position).sub(this._targetEnd).applyQuaternion(this._yAxisUpSpace)),this.rotateTo(ut.theta,ut.phi,e),this.dollyTo(ut.radius,e),this.zoomTo(s.zoom,e),this.setFocalOffset(s.focalOffset[0],s.focalOffset[1],s.focalOffset[2],e),this._needsUpdate=!0}connect(t){if(this._domElement){console.warn("camera-controls is already connected.");return}t.setAttribute("data-camera-controls-version",Fa),this._addAllEventListeners(t),this._getClientRect(this._elementRect)}disconnect(){this.cancel(),this._removeAllEventListeners(),this._domElement&&(this._domElement.removeAttribute("data-camera-controls-version"),this._domElement=void 0)}dispose(){this.removeAllEventListeners(),this.disconnect()}_getTargetDirection(t){return t.setFromSpherical(this._spherical).divideScalar(this._spherical.radius).applyQuaternion(this._yAxisUpSpaceInverse)}_getCameraDirection(t){return this._getTargetDirection(t).negate()}_findPointerById(t){return this._activePointers.find(e=>e.pointerId===t)}_findPointerByMouseButton(t){return this._activePointers.find(e=>e.mouseButton===t)}_disposePointer(t){this._activePointers.splice(this._activePointers.indexOf(t),1)}_encloseToBoundary(t,e,s){const i=e.lengthSq();if(i===0)return t;const o=z.copy(e).add(t),r=this._boundary.clampPoint(o,Ee).sub(o),a=r.lengthSq();if(a===0)return t.add(e);if(a===i)return t;if(s===0)return t.add(e).add(r);{const l=1+s*a/e.dot(r);return t.add(z.copy(e).multiplyScalar(l)).add(r.multiplyScalar(1-s))}}_updateNearPlaneCorners(){if(Xt(this._camera)){const t=this._camera,e=t.near,s=t.getEffectiveFOV()*Le,i=Math.tan(s*.5)*e,o=i*t.aspect;this._nearPlaneCorners[0].set(-o,-i,0),this._nearPlaneCorners[1].set(o,-i,0),this._nearPlaneCorners[2].set(o,i,0),this._nearPlaneCorners[3].set(-o,i,0)}else if(bt(this._camera)){const t=this._camera,e=1/t.zoom,s=t.left*e,i=t.right*e,o=t.top*e,n=t.bottom*e;this._nearPlaneCorners[0].set(s,o,0),this._nearPlaneCorners[1].set(i,o,0),this._nearPlaneCorners[2].set(i,n,0),this._nearPlaneCorners[3].set(s,n,0)}}_collisionTest(){let t=1/0;if(!(this.colliderMeshes.length>=1)||Qs(this._camera,"_collisionTest"))return t;const s=this._getTargetDirection(Ue);Ks.lookAt(Tn,s,this._camera.up);for(let i=0;i<4;i++){const o=z.copy(this._nearPlaneCorners[i]);o.applyMatrix4(Ks);const n=Ee.addVectors(this._target,o);Is.set(n,s),Is.far=this._spherical.radius+1;const r=Is.intersectObjects(this.colliderMeshes);r.length!==0&&r[0].distance<t&&(t=r[0].distance)}return t}_getClientRect(t){if(!this._domElement)return;const e=this._domElement.getBoundingClientRect();return t.x=e.left,t.y=e.top,this._viewport?(t.x+=this._viewport.x,t.y+=e.height-this._viewport.w-this._viewport.y,t.width=this._viewport.z,t.height=this._viewport.w):(t.width=e.width,t.height=e.height),t}_createOnRestPromise(t){return t?Promise.resolve():(this._hasRested=!1,this.dispatchEvent({type:"transitionstart"}),new Promise(e=>{const s=()=>{this.removeEventListener("rest",s),e()};this.addEventListener("rest",s)}))}_addAllEventListeners(t){}_removeAllEventListeners(){}get dampingFactor(){return console.warn(".dampingFactor has been deprecated. use smoothTime (in seconds) instead."),0}set dampingFactor(t){console.warn(".dampingFactor has been deprecated. use smoothTime (in seconds) instead.")}get draggingDampingFactor(){return console.warn(".draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead."),0}set draggingDampingFactor(t){console.warn(".draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead.")}static createBoundingSphere(t,e=new v.Sphere){const s=e,i=s.center;fe.makeEmpty(),t.traverseVisible(n=>{n.isMesh&&fe.expandByObject(n)}),fe.getCenter(i);let o=0;return t.traverseVisible(n=>{if(!n.isMesh)return;const r=n,a=r.geometry.clone();a.applyMatrix4(r.matrixWorld);const d=a.attributes.position;for(let u=0,h=d.count;u<h;u++)Y.fromBufferAttribute(d,u),o=Math.max(o,i.distanceToSquared(Y))}),s.radius=Math.sqrt(o),s}}class ke extends oa{constructor(t){super(t),E(this,"onBeforeUpdate",new M),E(this,"onAfterUpdate",new M),E(this,"onAspectUpdated",new M),E(this,"onDisposed",new M),E(this,"three"),E(this,"_allControls",new Map),E(this,"updateAspect",()=>{var e;if(!(!this.currentWorld||!this.currentWorld.renderer)){if(this.three instanceof mi){this.onAspectUpdated.trigger();return}if((e=this.currentWorld.renderer)!=null&&e.isResizeable()){const s=this.currentWorld.renderer.getSize();this.three.aspect=s.width/s.height,this.three.updateProjectionMatrix(),this.onAspectUpdated.trigger()}}}),this.three=this.setupCamera(),this.setupEvents(!0),this.onWorldChanged.add(({action:e,world:s})=>{if(e==="added"){const i=this.newCameraControls();this._allControls.set(s.uuid,i)}if(e==="removed"){const i=this._allControls.get(s.uuid);i&&(i.dispose(),this._allControls.delete(s.uuid))}})}get controls(){if(!this.currentWorld)throw new Error("This camera needs a world to work!");const t=this._allControls.get(this.currentWorld.uuid);if(!t)throw new Error("Controls not found!");return t}get enabled(){return this.currentWorld===null?!1:this.controls.enabled}set enabled(t){this.controls.enabled=t}dispose(){this.setupEvents(!1),this.onAspectUpdated.reset(),this.onBeforeUpdate.reset(),this.onAfterUpdate.reset(),this.three.removeFromParent(),this.onDisposed.trigger(),this.onDisposed.reset();for(const[t,e]of this._allControls)e.dispose()}update(t){this.enabled&&(this.onBeforeUpdate.trigger(this),this.controls.update(t),this.onAfterUpdate.trigger(this))}setupCamera(){const t=window.innerWidth/window.innerHeight,e=new No(60,t,1,1e3);return e.position.set(50,50,50),e.lookAt(new O(0,0,0)),e}newCameraControls(){if(!this.currentWorld)throw new Error("This camera needs a world to work!");if(!this.currentWorld.renderer)throw new Error("This camera needs a renderer to work!");rt.install({THREE:ke.getSubsetOfThree()});const{domElement:t}=this.currentWorld.renderer.three,e=new rt(this.three,t);return e.smoothTime=.2,e.dollyToCursor=!0,e.infinityDolly=!0,e}setupEvents(t){t?window.addEventListener("resize",this.updateAspect):window.removeEventListener("resize",this.updateAspect)}static getSubsetOfThree(){return{MOUSE:wo,Vector2:gt,Vector3:O,Vector4:Lo,Quaternion:Rt,Matrix4:W,Spherical:Mo,Box3:it,Sphere:Os,Raycaster:Ci,MathUtils:wn}}}const Zn=class Qn extends ${constructor(t){super(t),E(this,"onAfterUpdate",new M),E(this,"onBeforeUpdate",new M),E(this,"onDisposed",new M),E(this,"onWorldCreated",new M),E(this,"onWorldDeleted",new M),E(this,"list",new Map),E(this,"enabled",!0),t.add(Qn.uuid,this)}create(){const t=new Aa(this.components),e=t.uuid;if(this.list.has(e))throw new Error("There is already a world with this name!");return this.list.set(e,t),this.onWorldCreated.trigger(t),t}delete(t){const e=t.uuid;this.list.delete(t.uuid),t.dispose(),this.onWorldDeleted.trigger(e)}dispose(){this.enabled=!1;for(const[t,e]of this.list)e.dispose();this.list.clear(),this.onDisposed.trigger()}update(t){if(this.enabled)for(const[e,s]of this.list)s.update(t)}};E(Zn,"uuid","fdb61dc4-2ec1-4966-b83d-54ea795fad4a");let Sa=Zn;class ya{constructor(t,e,s){E(this,"onDisposed",new M),E(this,"world"),E(this,"components"),E(this,"three"),E(this,"_fade",3),E(this,"updateZoom",()=>{this.world.camera instanceof ke&&(this.material.uniforms.uZoom.value=this.world.camera.three.zoom)}),this.world=e;const{color:i,size1:o,size2:n,distance:r}=s;this.components=t;const a=new Ni(2,2,1,1),l=new Yo({side:We,uniforms:{uSize1:{value:o},uSize2:{value:n},uColor:{value:i},uDistance:{value:r},uFade:{value:this._fade},uZoom:{value:1}},transparent:!0,vertexShader:`
            
            varying vec3 worldPosition;
            
            uniform float uDistance;
            
            void main() {
            
                    vec3 pos = position.xzy * uDistance;
                    pos.xz += cameraPosition.xz;
                    
                    worldPosition = pos;
                    
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
            
            }
            `,fragmentShader:`
            
            varying vec3 worldPosition;
            
            uniform float uZoom;
            uniform float uFade;
            uniform float uSize1;
            uniform float uSize2;
            uniform vec3 uColor;
            uniform float uDistance;
                
                
                
                float getGrid(float size) {
                
                    vec2 r = worldPosition.xz / size;
                    
                    
                    vec2 grid = abs(fract(r - 0.5) - 0.5) / fwidth(r);
                    float line = min(grid.x, grid.y);
                    
                
                    return 1.0 - min(line, 1.0);
                }
                
            void main() {
            
                    
                    float d = 1.0 - min(distance(cameraPosition.xz, worldPosition.xz) / uDistance, 1.0);
                    
                    float g1 = getGrid(uSize1);
                    float g2 = getGrid(uSize2);
                    
                    // Ortho camera fades the grid away when zooming out
                    float minZoom = step(0.2, uZoom);
                    float zoomFactor = pow(min(uZoom, 1.), 2.) * minZoom;
                    
                    gl_FragColor = vec4(uColor.rgb, mix(g2, g1, g1) * pow(d, uFade));
                    gl_FragColor.a = mix(0.5 * gl_FragColor.a, gl_FragColor.a, g2) * zoomFactor;
                    
                    if ( gl_FragColor.a <= 0.0 ) discard;
                    
            
            }
            
            `,extensions:{derivatives:!0}});this.three=new x(a,l),this.three.frustumCulled=!1,e.scene.three.add(this.three),this.setupEvents(!0)}get visible(){return this.three.visible}set visible(t){t?this.world.scene.three.add(this.three):this.three.removeFromParent()}get material(){return this.three.material}get fade(){return this._fade===3}set fade(t){this._fade=t?3:0,this.material.uniforms.uFade.value=this._fade}dispose(){this.setupEvents(!1),this.components.get(me).destroy(this.three),this.onDisposed.trigger(),this.onDisposed.reset(),this.world=null,this.components=null}setupEvents(t){if(this.world.isDisposing||!(this.world.camera instanceof ke))return;const e=this.world.camera.controls;t?e.addEventListener("update",this.updateZoom):e.removeEventListener("update",this.updateZoom)}}const jn=class qn extends ${constructor(t){super(t),E(this,"list",new Map),E(this,"onDisposed",new M),E(this,"config",{color:new $t(12303291),size1:1,size2:10,distance:500}),E(this,"enabled",!0),t.add(qn.uuid,this)}create(t){if(this.list.has(t.uuid))throw new Error("This world already has a grid!");const e=new ya(this.components,t,this.config);return this.list.set(t.uuid,e),t.onDisposed.add(()=>{this.delete(t)}),e}delete(t){const e=this.list.get(t.uuid);e&&e.dispose(),this.list.delete(t.uuid)}dispose(){for(const[t,e]of this.list)e.dispose();this.list.clear(),this.onDisposed.trigger(),this.onDisposed.reset()}};E(jn,"uuid","d1e814d5-b81c-4452-87a2-f039375e0489");let rc=jn;const Qt=new Ci,ot=new O,xt=new O,Q=new Rt,Fn={X:new O(1,0,0),Y:new O(0,1,0),Z:new O(0,0,1)},Js={type:"change"},_n={type:"mouseDown"},On={type:"mouseUp",mode:null},Sn={type:"objectChange"};class Pa extends Fs{constructor(t,e){super(),e===void 0&&(console.warn('THREE.TransformControls: The second parameter "domElement" is now mandatory.'),e=document),this.isTransformControls=!0,this.visible=!1,this.domElement=e,this.domElement.style.touchAction="none";const s=new Ua;this._gizmo=s,this.add(s);const i=new xa;this._plane=i,this.add(i);const o=this;function n(R,g){let I=g;Object.defineProperty(o,R,{get:function(){return I!==void 0?I:g},set:function(A){I!==A&&(I=A,i[R]=A,s[R]=A,o.dispatchEvent({type:R+"-changed",value:A}),o.dispatchEvent(Js))}}),o[R]=g,i[R]=g,s[R]=g}n("camera",t),n("object",void 0),n("enabled",!0),n("axis",null),n("mode","translate"),n("translationSnap",null),n("rotationSnap",null),n("scaleSnap",null),n("space","world"),n("size",1),n("dragging",!1),n("showX",!0),n("showY",!0),n("showZ",!0);const r=new O,a=new O,l=new Rt,d=new Rt,u=new O,h=new Rt,f=new O,p=new O,T=new O,m=0,C=new O;n("worldPosition",r),n("worldPositionStart",a),n("worldQuaternion",l),n("worldQuaternionStart",d),n("cameraPosition",u),n("cameraQuaternion",h),n("pointStart",f),n("pointEnd",p),n("rotationAxis",T),n("rotationAngle",m),n("eye",C),this._offset=new O,this._startNorm=new O,this._endNorm=new O,this._cameraScale=new O,this._parentPosition=new O,this._parentQuaternion=new Rt,this._parentQuaternionInv=new Rt,this._parentScale=new O,this._worldScaleStart=new O,this._worldQuaternionInv=new Rt,this._worldScale=new O,this._positionStart=new O,this._quaternionStart=new Rt,this._scaleStart=new O,this._getPointer=Na.bind(this),this._onPointerDown=La.bind(this),this._onPointerHover=wa.bind(this),this._onPointerMove=Ma.bind(this),this._onPointerUp=Da.bind(this),this.domElement.addEventListener("pointerdown",this._onPointerDown),this.domElement.addEventListener("pointermove",this._onPointerHover),this.domElement.addEventListener("pointerup",this._onPointerUp)}updateMatrixWorld(){this.object!==void 0&&(this.object.updateMatrixWorld(),this.object.parent===null?console.error("TransformControls: The attached 3D object must be a part of the scene graph."):this.object.parent.matrixWorld.decompose(this._parentPosition,this._parentQuaternion,this._parentScale),this.object.matrixWorld.decompose(this.worldPosition,this.worldQuaternion,this._worldScale),this._parentQuaternionInv.copy(this._parentQuaternion).invert(),this._worldQuaternionInv.copy(this.worldQuaternion).invert()),this.camera.updateMatrixWorld(),this.camera.matrixWorld.decompose(this.cameraPosition,this.cameraQuaternion,this._cameraScale),this.camera.isOrthographicCamera?this.camera.getWorldDirection(this.eye).negate():this.eye.copy(this.cameraPosition).sub(this.worldPosition).normalize(),super.updateMatrixWorld(this)}pointerHover(t){if(this.object===void 0||this.dragging===!0)return;Qt.setFromCamera(t,this.camera);const e=ti(this._gizmo.picker[this.mode],Qt);e?this.axis=e.object.name:this.axis=null}pointerDown(t){if(!(this.object===void 0||this.dragging===!0||t.button!==0)&&this.axis!==null){Qt.setFromCamera(t,this.camera);const e=ti(this._plane,Qt,!0);e&&(this.object.updateMatrixWorld(),this.object.parent.updateMatrixWorld(),this._positionStart.copy(this.object.position),this._quaternionStart.copy(this.object.quaternion),this._scaleStart.copy(this.object.scale),this.object.matrixWorld.decompose(this.worldPositionStart,this.worldQuaternionStart,this._worldScaleStart),this.pointStart.copy(e.point).sub(this.worldPositionStart)),this.dragging=!0,_n.mode=this.mode,this.dispatchEvent(_n)}}pointerMove(t){const e=this.axis,s=this.mode,i=this.object;let o=this.space;if(s==="scale"?o="local":(e==="E"||e==="XYZE"||e==="XYZ")&&(o="world"),i===void 0||e===null||this.dragging===!1||t.button!==-1)return;Qt.setFromCamera(t,this.camera);const n=ti(this._plane,Qt,!0);if(n){if(this.pointEnd.copy(n.point).sub(this.worldPositionStart),s==="translate")this._offset.copy(this.pointEnd).sub(this.pointStart),o==="local"&&e!=="XYZ"&&this._offset.applyQuaternion(this._worldQuaternionInv),e.indexOf("X")===-1&&(this._offset.x=0),e.indexOf("Y")===-1&&(this._offset.y=0),e.indexOf("Z")===-1&&(this._offset.z=0),o==="local"&&e!=="XYZ"?this._offset.applyQuaternion(this._quaternionStart).divide(this._parentScale):this._offset.applyQuaternion(this._parentQuaternionInv).divide(this._parentScale),i.position.copy(this._offset).add(this._positionStart),this.translationSnap&&(o==="local"&&(i.position.applyQuaternion(Q.copy(this._quaternionStart).invert()),e.search("X")!==-1&&(i.position.x=Math.round(i.position.x/this.translationSnap)*this.translationSnap),e.search("Y")!==-1&&(i.position.y=Math.round(i.position.y/this.translationSnap)*this.translationSnap),e.search("Z")!==-1&&(i.position.z=Math.round(i.position.z/this.translationSnap)*this.translationSnap),i.position.applyQuaternion(this._quaternionStart)),o==="world"&&(i.parent&&i.position.add(ot.setFromMatrixPosition(i.parent.matrixWorld)),e.search("X")!==-1&&(i.position.x=Math.round(i.position.x/this.translationSnap)*this.translationSnap),e.search("Y")!==-1&&(i.position.y=Math.round(i.position.y/this.translationSnap)*this.translationSnap),e.search("Z")!==-1&&(i.position.z=Math.round(i.position.z/this.translationSnap)*this.translationSnap),i.parent&&i.position.sub(ot.setFromMatrixPosition(i.parent.matrixWorld))));else if(s==="scale"){if(e.search("XYZ")!==-1){let r=this.pointEnd.length()/this.pointStart.length();this.pointEnd.dot(this.pointStart)<0&&(r*=-1),xt.set(r,r,r)}else ot.copy(this.pointStart),xt.copy(this.pointEnd),ot.applyQuaternion(this._worldQuaternionInv),xt.applyQuaternion(this._worldQuaternionInv),xt.divide(ot),e.search("X")===-1&&(xt.x=1),e.search("Y")===-1&&(xt.y=1),e.search("Z")===-1&&(xt.z=1);i.scale.copy(this._scaleStart).multiply(xt),this.scaleSnap&&(e.search("X")!==-1&&(i.scale.x=Math.round(i.scale.x/this.scaleSnap)*this.scaleSnap||this.scaleSnap),e.search("Y")!==-1&&(i.scale.y=Math.round(i.scale.y/this.scaleSnap)*this.scaleSnap||this.scaleSnap),e.search("Z")!==-1&&(i.scale.z=Math.round(i.scale.z/this.scaleSnap)*this.scaleSnap||this.scaleSnap))}else if(s==="rotate"){this._offset.copy(this.pointEnd).sub(this.pointStart);const r=20/this.worldPosition.distanceTo(ot.setFromMatrixPosition(this.camera.matrixWorld));let a=!1;e==="XYZE"?(this.rotationAxis.copy(this._offset).cross(this.eye).normalize(),this.rotationAngle=this._offset.dot(ot.copy(this.rotationAxis).cross(this.eye))*r):(e==="X"||e==="Y"||e==="Z")&&(this.rotationAxis.copy(Fn[e]),ot.copy(Fn[e]),o==="local"&&ot.applyQuaternion(this.worldQuaternion),ot.cross(this.eye),ot.length()===0?a=!0:this.rotationAngle=this._offset.dot(ot.normalize())*r),(e==="E"||a)&&(this.rotationAxis.copy(this.eye),this.rotationAngle=this.pointEnd.angleTo(this.pointStart),this._startNorm.copy(this.pointStart).normalize(),this._endNorm.copy(this.pointEnd).normalize(),this.rotationAngle*=this._endNorm.cross(this._startNorm).dot(this.eye)<0?1:-1),this.rotationSnap&&(this.rotationAngle=Math.round(this.rotationAngle/this.rotationSnap)*this.rotationSnap),o==="local"&&e!=="E"&&e!=="XYZE"?(i.quaternion.copy(this._quaternionStart),i.quaternion.multiply(Q.setFromAxisAngle(this.rotationAxis,this.rotationAngle)).normalize()):(this.rotationAxis.applyQuaternion(this._parentQuaternionInv),i.quaternion.copy(Q.setFromAxisAngle(this.rotationAxis,this.rotationAngle)),i.quaternion.multiply(this._quaternionStart).normalize())}this.dispatchEvent(Js),this.dispatchEvent(Sn)}}pointerUp(t){t.button===0&&(this.dragging&&this.axis!==null&&(On.mode=this.mode,this.dispatchEvent(On)),this.dragging=!1,this.axis=null)}dispose(){this.domElement.removeEventListener("pointerdown",this._onPointerDown),this.domElement.removeEventListener("pointermove",this._onPointerHover),this.domElement.removeEventListener("pointermove",this._onPointerMove),this.domElement.removeEventListener("pointerup",this._onPointerUp),this.traverse(function(t){t.geometry&&t.geometry.dispose(),t.material&&t.material.dispose()})}attach(t){return this.object=t,this.visible=!0,this}detach(){return this.object=void 0,this.visible=!1,this.axis=null,this}reset(){this.enabled&&this.dragging&&(this.object.position.copy(this._positionStart),this.object.quaternion.copy(this._quaternionStart),this.object.scale.copy(this._scaleStart),this.dispatchEvent(Js),this.dispatchEvent(Sn),this.pointStart.copy(this.pointEnd))}getRaycaster(){return Qt}getMode(){return this.mode}setMode(t){this.mode=t}setTranslationSnap(t){this.translationSnap=t}setRotationSnap(t){this.rotationSnap=t}setScaleSnap(t){this.scaleSnap=t}setSize(t){this.size=t}setSpace(t){this.space=t}}function Na(c){if(this.domElement.ownerDocument.pointerLockElement)return{x:0,y:0,button:c.button};{const t=this.domElement.getBoundingClientRect();return{x:(c.clientX-t.left)/t.width*2-1,y:-(c.clientY-t.top)/t.height*2+1,button:c.button}}}function wa(c){if(this.enabled)switch(c.pointerType){case"mouse":case"pen":this.pointerHover(this._getPointer(c));break}}function La(c){this.enabled&&(document.pointerLockElement||this.domElement.setPointerCapture(c.pointerId),this.domElement.addEventListener("pointermove",this._onPointerMove),this.pointerHover(this._getPointer(c)),this.pointerDown(this._getPointer(c)))}function Ma(c){this.enabled&&this.pointerMove(this._getPointer(c))}function Da(c){this.enabled&&(this.domElement.releasePointerCapture(c.pointerId),this.domElement.removeEventListener("pointermove",this._onPointerMove),this.pointerUp(this._getPointer(c)))}function ti(c,t,e){const s=t.intersectObject(c,!0);for(let i=0;i<s.length;i++)if(s[i].object.visible||e)return s[i];return!1}const ps=new So,H=new O(0,1,0),yn=new O(0,0,0),Pn=new W,Cs=new Rt,As=new Rt,St=new O,Nn=new W,Be=new O(1,0,0),jt=new O(0,1,0),Ye=new O(0,0,1),Ts=new O,be=new O,ve=new O;class Ua extends Fs{constructor(){super(),this.isTransformControlsGizmo=!0,this.type="TransformControlsGizmo";const t=new Te({depthTest:!1,depthWrite:!1,fog:!1,toneMapped:!1,transparent:!0}),e=new xn({depthTest:!1,depthWrite:!1,fog:!1,toneMapped:!1,transparent:!0}),s=t.clone();s.opacity=.15;const i=e.clone();i.opacity=.5;const o=t.clone();o.color.setHex(16711680);const n=t.clone();n.color.setHex(65280);const r=t.clone();r.color.setHex(255);const a=t.clone();a.color.setHex(16711680),a.opacity=.5;const l=t.clone();l.color.setHex(65280),l.opacity=.5;const d=t.clone();d.color.setHex(255),d.opacity=.5;const u=t.clone();u.opacity=.25;const h=t.clone();h.color.setHex(16776960),h.opacity=.25,t.clone().color.setHex(16776960);const p=t.clone();p.color.setHex(7895160);const T=new at(0,.04,.1,12);T.translate(0,.05,0);const m=new nt(.08,.08,.08);m.translate(0,.04,0);const C=new Ge;C.setAttribute("position",new Wi([0,0,0,1,0,0],3));const R=new at(.0075,.0075,.5,3);R.translate(0,.25,0);function g(b,G){const j=new _e(b,.0075,3,64,G*Math.PI*2);return j.rotateY(Math.PI/2),j.rotateX(Math.PI/2),j}function I(){const b=new Ge;return b.setAttribute("position",new Wi([0,0,0,1,1,1],3)),b}const A={X:[[new x(T,o),[.5,0,0],[0,0,-Math.PI/2]],[new x(T,o),[-.5,0,0],[0,0,Math.PI/2]],[new x(R,o),[0,0,0],[0,0,-Math.PI/2]]],Y:[[new x(T,n),[0,.5,0]],[new x(T,n),[0,-.5,0],[Math.PI,0,0]],[new x(R,n)]],Z:[[new x(T,r),[0,0,.5],[Math.PI/2,0,0]],[new x(T,r),[0,0,-.5],[-Math.PI/2,0,0]],[new x(R,r),null,[Math.PI/2,0,0]]],XYZ:[[new x(new je(.1,0),u.clone()),[0,0,0]]],XY:[[new x(new nt(.15,.15,.01),d.clone()),[.15,.15,0]]],YZ:[[new x(new nt(.15,.15,.01),a.clone()),[0,.15,.15],[0,Math.PI/2,0]]],XZ:[[new x(new nt(.15,.15,.01),l.clone()),[.15,0,.15],[-Math.PI/2,0,0]]]},F={X:[[new x(new at(.2,0,.6,4),s),[.3,0,0],[0,0,-Math.PI/2]],[new x(new at(.2,0,.6,4),s),[-.3,0,0],[0,0,Math.PI/2]]],Y:[[new x(new at(.2,0,.6,4),s),[0,.3,0]],[new x(new at(.2,0,.6,4),s),[0,-.3,0],[0,0,Math.PI]]],Z:[[new x(new at(.2,0,.6,4),s),[0,0,.3],[Math.PI/2,0,0]],[new x(new at(.2,0,.6,4),s),[0,0,-.3],[-Math.PI/2,0,0]]],XYZ:[[new x(new je(.2,0),s)]],XY:[[new x(new nt(.2,.2,.01),s),[.15,.15,0]]],YZ:[[new x(new nt(.2,.2,.01),s),[0,.15,.15],[0,Math.PI/2,0]]],XZ:[[new x(new nt(.2,.2,.01),s),[.15,0,.15],[-Math.PI/2,0,0]]]},_={START:[[new x(new je(.01,2),i),null,null,null,"helper"]],END:[[new x(new je(.01,2),i),null,null,null,"helper"]],DELTA:[[new Dt(I(),i),null,null,null,"helper"]],X:[[new Dt(C,i.clone()),[-1e3,0,0],null,[1e6,1,1],"helper"]],Y:[[new Dt(C,i.clone()),[0,-1e3,0],[0,0,Math.PI/2],[1e6,1,1],"helper"]],Z:[[new Dt(C,i.clone()),[0,0,-1e3],[0,-Math.PI/2,0],[1e6,1,1],"helper"]]},S={XYZE:[[new x(g(.5,1),p),null,[0,Math.PI/2,0]]],X:[[new x(g(.5,.5),o)]],Y:[[new x(g(.5,.5),n),null,[0,0,-Math.PI/2]]],Z:[[new x(g(.5,.5),r),null,[0,Math.PI/2,0]]],E:[[new x(g(.75,1),h),null,[0,Math.PI/2,0]]]},y={AXIS:[[new Dt(C,i.clone()),[-1e3,0,0],null,[1e6,1,1],"helper"]]},N={XYZE:[[new x(new Qo(.25,10,8),s)]],X:[[new x(new _e(.5,.1,4,24),s),[0,0,0],[0,-Math.PI/2,-Math.PI/2]]],Y:[[new x(new _e(.5,.1,4,24),s),[0,0,0],[Math.PI/2,0,0]]],Z:[[new x(new _e(.5,.1,4,24),s),[0,0,0],[0,0,-Math.PI/2]]],E:[[new x(new _e(.75,.1,2,24),s)]]},L={X:[[new x(m,o),[.5,0,0],[0,0,-Math.PI/2]],[new x(R,o),[0,0,0],[0,0,-Math.PI/2]],[new x(m,o),[-.5,0,0],[0,0,Math.PI/2]]],Y:[[new x(m,n),[0,.5,0]],[new x(R,n)],[new x(m,n),[0,-.5,0],[0,0,Math.PI]]],Z:[[new x(m,r),[0,0,.5],[Math.PI/2,0,0]],[new x(R,r),[0,0,0],[Math.PI/2,0,0]],[new x(m,r),[0,0,-.5],[-Math.PI/2,0,0]]],XY:[[new x(new nt(.15,.15,.01),d),[.15,.15,0]]],YZ:[[new x(new nt(.15,.15,.01),a),[0,.15,.15],[0,Math.PI/2,0]]],XZ:[[new x(new nt(.15,.15,.01),l),[.15,0,.15],[-Math.PI/2,0,0]]],XYZ:[[new x(new nt(.1,.1,.1),u.clone())]]},w={X:[[new x(new at(.2,0,.6,4),s),[.3,0,0],[0,0,-Math.PI/2]],[new x(new at(.2,0,.6,4),s),[-.3,0,0],[0,0,Math.PI/2]]],Y:[[new x(new at(.2,0,.6,4),s),[0,.3,0]],[new x(new at(.2,0,.6,4),s),[0,-.3,0],[0,0,Math.PI]]],Z:[[new x(new at(.2,0,.6,4),s),[0,0,.3],[Math.PI/2,0,0]],[new x(new at(.2,0,.6,4),s),[0,0,-.3],[-Math.PI/2,0,0]]],XY:[[new x(new nt(.2,.2,.01),s),[.15,.15,0]]],YZ:[[new x(new nt(.2,.2,.01),s),[0,.15,.15],[0,Math.PI/2,0]]],XZ:[[new x(new nt(.2,.2,.01),s),[.15,0,.15],[-Math.PI/2,0,0]]],XYZ:[[new x(new nt(.2,.2,.2),s),[0,0,0]]]},D={X:[[new Dt(C,i.clone()),[-1e3,0,0],null,[1e6,1,1],"helper"]],Y:[[new Dt(C,i.clone()),[0,-1e3,0],[0,0,Math.PI/2],[1e6,1,1],"helper"]],Z:[[new Dt(C,i.clone()),[0,0,-1e3],[0,-Math.PI/2,0],[1e6,1,1],"helper"]]};function U(b){const G=new Fs;for(const j in b)for(let tt=b[j].length;tt--;){const Z=b[j][tt][0].clone(),Vt=b[j][tt][1],Ht=b[j][tt][2],kt=b[j][tt][3],Xe=b[j][tt][4];Z.name=j,Z.tag=Xe,Vt&&Z.position.set(Vt[0],Vt[1],Vt[2]),Ht&&Z.rotation.set(Ht[0],Ht[1],Ht[2]),kt&&Z.scale.set(kt[0],kt[1],kt[2]),Z.updateMatrix();const ge=Z.geometry.clone();ge.applyMatrix4(Z.matrix),Z.geometry=ge,Z.renderOrder=1/0,Z.position.set(0,0,0),Z.rotation.set(0,0,0),Z.scale.set(1,1,1),G.add(Z)}return G}this.gizmo={},this.picker={},this.helper={},this.add(this.gizmo.translate=U(A)),this.add(this.gizmo.rotate=U(S)),this.add(this.gizmo.scale=U(L)),this.add(this.picker.translate=U(F)),this.add(this.picker.rotate=U(N)),this.add(this.picker.scale=U(w)),this.add(this.helper.translate=U(_)),this.add(this.helper.rotate=U(y)),this.add(this.helper.scale=U(D)),this.picker.translate.visible=!1,this.picker.rotate.visible=!1,this.picker.scale.visible=!1}updateMatrixWorld(t){const s=(this.mode==="scale"?"local":this.space)==="local"?this.worldQuaternion:As;this.gizmo.translate.visible=this.mode==="translate",this.gizmo.rotate.visible=this.mode==="rotate",this.gizmo.scale.visible=this.mode==="scale",this.helper.translate.visible=this.mode==="translate",this.helper.rotate.visible=this.mode==="rotate",this.helper.scale.visible=this.mode==="scale";let i=[];i=i.concat(this.picker[this.mode].children),i=i.concat(this.gizmo[this.mode].children),i=i.concat(this.helper[this.mode].children);for(let o=0;o<i.length;o++){const n=i[o];n.visible=!0,n.rotation.set(0,0,0),n.position.copy(this.worldPosition);let r;if(this.camera.isOrthographicCamera?r=(this.camera.top-this.camera.bottom)/this.camera.zoom:r=this.worldPosition.distanceTo(this.cameraPosition)*Math.min(1.9*Math.tan(Math.PI*this.camera.fov/360)/this.camera.zoom,7),n.scale.set(1,1,1).multiplyScalar(r*this.size/4),n.tag==="helper"){n.visible=!1,n.name==="AXIS"?(n.visible=!!this.axis,this.axis==="X"&&(Q.setFromEuler(ps.set(0,0,0)),n.quaternion.copy(s).multiply(Q),Math.abs(H.copy(Be).applyQuaternion(s).dot(this.eye))>.9&&(n.visible=!1)),this.axis==="Y"&&(Q.setFromEuler(ps.set(0,0,Math.PI/2)),n.quaternion.copy(s).multiply(Q),Math.abs(H.copy(jt).applyQuaternion(s).dot(this.eye))>.9&&(n.visible=!1)),this.axis==="Z"&&(Q.setFromEuler(ps.set(0,Math.PI/2,0)),n.quaternion.copy(s).multiply(Q),Math.abs(H.copy(Ye).applyQuaternion(s).dot(this.eye))>.9&&(n.visible=!1)),this.axis==="XYZE"&&(Q.setFromEuler(ps.set(0,Math.PI/2,0)),H.copy(this.rotationAxis),n.quaternion.setFromRotationMatrix(Pn.lookAt(yn,H,jt)),n.quaternion.multiply(Q),n.visible=this.dragging),this.axis==="E"&&(n.visible=!1)):n.name==="START"?(n.position.copy(this.worldPositionStart),n.visible=this.dragging):n.name==="END"?(n.position.copy(this.worldPosition),n.visible=this.dragging):n.name==="DELTA"?(n.position.copy(this.worldPositionStart),n.quaternion.copy(this.worldQuaternionStart),ot.set(1e-10,1e-10,1e-10).add(this.worldPositionStart).sub(this.worldPosition).multiplyScalar(-1),ot.applyQuaternion(this.worldQuaternionStart.clone().invert()),n.scale.copy(ot),n.visible=this.dragging):(n.quaternion.copy(s),this.dragging?n.position.copy(this.worldPositionStart):n.position.copy(this.worldPosition),this.axis&&(n.visible=this.axis.search(n.name)!==-1));continue}n.quaternion.copy(s),this.mode==="translate"||this.mode==="scale"?(n.name==="X"&&Math.abs(H.copy(Be).applyQuaternion(s).dot(this.eye))>.99&&(n.scale.set(1e-10,1e-10,1e-10),n.visible=!1),n.name==="Y"&&Math.abs(H.copy(jt).applyQuaternion(s).dot(this.eye))>.99&&(n.scale.set(1e-10,1e-10,1e-10),n.visible=!1),n.name==="Z"&&Math.abs(H.copy(Ye).applyQuaternion(s).dot(this.eye))>.99&&(n.scale.set(1e-10,1e-10,1e-10),n.visible=!1),n.name==="XY"&&Math.abs(H.copy(Ye).applyQuaternion(s).dot(this.eye))<.2&&(n.scale.set(1e-10,1e-10,1e-10),n.visible=!1),n.name==="YZ"&&Math.abs(H.copy(Be).applyQuaternion(s).dot(this.eye))<.2&&(n.scale.set(1e-10,1e-10,1e-10),n.visible=!1),n.name==="XZ"&&Math.abs(H.copy(jt).applyQuaternion(s).dot(this.eye))<.2&&(n.scale.set(1e-10,1e-10,1e-10),n.visible=!1)):this.mode==="rotate"&&(Cs.copy(s),H.copy(this.eye).applyQuaternion(Q.copy(s).invert()),n.name.search("E")!==-1&&n.quaternion.setFromRotationMatrix(Pn.lookAt(this.eye,yn,jt)),n.name==="X"&&(Q.setFromAxisAngle(Be,Math.atan2(-H.y,H.z)),Q.multiplyQuaternions(Cs,Q),n.quaternion.copy(Q)),n.name==="Y"&&(Q.setFromAxisAngle(jt,Math.atan2(H.x,H.z)),Q.multiplyQuaternions(Cs,Q),n.quaternion.copy(Q)),n.name==="Z"&&(Q.setFromAxisAngle(Ye,Math.atan2(H.y,H.x)),Q.multiplyQuaternions(Cs,Q),n.quaternion.copy(Q))),n.visible=n.visible&&(n.name.indexOf("X")===-1||this.showX),n.visible=n.visible&&(n.name.indexOf("Y")===-1||this.showY),n.visible=n.visible&&(n.name.indexOf("Z")===-1||this.showZ),n.visible=n.visible&&(n.name.indexOf("E")===-1||this.showX&&this.showY&&this.showZ),n.material._color=n.material._color||n.material.color.clone(),n.material._opacity=n.material._opacity||n.material.opacity,n.material.color.copy(n.material._color),n.material.opacity=n.material._opacity,this.enabled&&this.axis&&(n.name===this.axis||this.axis.split("").some(function(a){return n.name===a}))&&(n.material.color.setHex(16776960),n.material.opacity=1)}super.updateMatrixWorld(t)}}class xa extends x{constructor(){super(new Ni(1e5,1e5,2,2),new Te({visible:!1,wireframe:!0,side:We,transparent:!0,opacity:.1,toneMapped:!1})),this.isTransformControlsPlane=!0,this.type="TransformControlsPlane"}updateMatrixWorld(t){let e=this.space;switch(this.position.copy(this.worldPosition),this.mode==="scale"&&(e="local"),Ts.copy(Be).applyQuaternion(e==="local"?this.worldQuaternion:As),be.copy(jt).applyQuaternion(e==="local"?this.worldQuaternion:As),ve.copy(Ye).applyQuaternion(e==="local"?this.worldQuaternion:As),H.copy(be),this.mode){case"translate":case"scale":switch(this.axis){case"X":H.copy(this.eye).cross(Ts),St.copy(Ts).cross(H);break;case"Y":H.copy(this.eye).cross(be),St.copy(be).cross(H);break;case"Z":H.copy(this.eye).cross(ve),St.copy(ve).cross(H);break;case"XY":St.copy(ve);break;case"YZ":St.copy(Ts);break;case"XZ":H.copy(ve),St.copy(be);break;case"XYZ":case"E":St.set(0,0,0);break}break;case"rotate":default:St.set(0,0,0)}St.length()===0?this.quaternion.copy(this.cameraQuaternion):(Nn.lookAt(ot.set(0,0,0),St,H),this.quaternion.setFromRotationMatrix(Nn)),super.updateMatrixWorld(t)}}class vi{constructor(t,e,s,i,o,n=5,r=!0){if(E(this,"onDraggingStarted",new M),E(this,"onDraggingEnded",new M),E(this,"onDisposed",new M),E(this,"normal"),E(this,"origin"),E(this,"three",new Re),E(this,"_helper"),E(this,"_visible",!0),E(this,"_enabled",!0),E(this,"components"),E(this,"world"),E(this,"_controlsActive",!1),E(this,"_arrowBoundBox",new x),E(this,"_planeMesh"),E(this,"_controls"),E(this,"_hiddenMaterial",new Te({visible:!1})),E(this,"update",()=>{this._enabled&&this.three.setFromNormalAndCoplanarPoint(this.normal,this._helper.position)}),E(this,"changeDrag",a=>{this._visible=!a.value,this.preventCameraMovement(),this.notifyDraggingChanged(a)}),this.components=t,this.world=e,!e.renderer)throw new Error("The given world must have a renderer!");this.normal=i,this.origin=s,e.renderer.setPlane(!0,this.three),this._planeMesh=vi.newPlaneMesh(n,o),this._helper=this.newHelper(),this._controls=this.newTransformControls(),this.three.setFromNormalAndCoplanarPoint(i,s),r&&this.toggleControls(!0)}get enabled(){return this._enabled}set enabled(t){if(!this.world.renderer)throw new Error("No renderer found for clipping plane!");this._enabled=t,this.world.renderer.setPlane(t,this.three)}get visible(){return this._visible}set visible(t){this._visible=t,this._controls.visible=t,this._helper.visible=t,this.toggleControls(t)}get meshes(){return[this._planeMesh,this._arrowBoundBox]}get planeMaterial(){return this._planeMesh.material}set planeMaterial(t){this._planeMesh.material=t}get size(){return this._planeMesh.scale.x}set size(t){this._planeMesh.scale.set(t,t,t)}get helper(){return this._helper}setFromNormalAndCoplanarPoint(t,e){this.reset(),this.normal.equals(t)||(this.normal.copy(t),this._helper.lookAt(t)),this.origin.copy(e),this._helper.position.copy(e),this._helper.updateMatrix(),this.update()}dispose(){this._enabled=!1,this.onDraggingStarted.reset(),this.onDraggingEnded.reset(),this._helper.removeFromParent(),this.world.renderer&&this.world.renderer.setPlane(!1,this.three),this._arrowBoundBox.removeFromParent(),this._arrowBoundBox.geometry.dispose(),this._planeMesh.geometry.dispose(),this._controls.removeFromParent(),this._controls.dispose(),this.onDisposed.trigger(),this.onDisposed.reset()}reset(){const t=new O(1,0,0),e=new O;this.normal.equals(t)||(this.normal.copy(t),this._helper.lookAt(t)),this.origin.copy(e),this._helper.position.copy(e),this._helper.updateMatrix()}toggleControls(t){if(t){if(this._controlsActive)return;this._controls.addEventListener("change",this.update),this._controls.addEventListener("dragging-changed",this.changeDrag)}else this._controls.removeEventListener("change",this.update),this._controls.removeEventListener("dragging-changed",this.changeDrag);this._controlsActive=t}newTransformControls(){if(!this.world.renderer)throw new Error("No renderer found for clipping plane!");const t=this.world.camera.three,e=this.world.renderer.three.domElement,s=new Pa(t,e);return this.initializeControls(s),this.world.scene.three.add(s),s}initializeControls(t){t.attach(this._helper),t.showX=!1,t.showY=!1,t.setSpace("local"),this.createArrowBoundingBox(),t.children[0].children[0].add(this._arrowBoundBox)}createArrowBoundingBox(){this._arrowBoundBox.geometry=new at(.18,.18,1.2),this._arrowBoundBox.material=this._hiddenMaterial,this._arrowBoundBox.rotateX(Math.PI/2),this._arrowBoundBox.updateMatrix(),this._arrowBoundBox.geometry.applyMatrix4(this._arrowBoundBox.matrix)}notifyDraggingChanged(t){t.value?this.onDraggingStarted.trigger():this.onDraggingEnded.trigger()}preventCameraMovement(){this.world.camera.enabled=this._visible}newHelper(){const t=new Fs;return t.lookAt(this.normal),t.position.copy(this.origin),this._planeMesh.position.z+=.01,t.add(this._planeMesh),this.world.scene.three.add(t),t}static newPlaneMesh(t,e){const s=new Ni(1),i=new x(s,e);return i.scale.set(t,t,t),i}}const $n=class Ei extends ${constructor(t){super(t),E(this,"onAfterCreate",new M),E(this,"onAfterDelete",new M),E(this,"onBeforeDrag",new M),E(this,"onAfterDrag",new M),E(this,"onBeforeCreate",new M),E(this,"onBeforeCancel",new M),E(this,"onAfterCancel",new M),E(this,"onBeforeDelete",new M),E(this,"onDisposed",new M),E(this,"orthogonalY",!1),E(this,"toleranceOrthogonalY",.7),E(this,"Type",vi),E(this,"list",[]),E(this,"_material",new Te({color:12255487,side:We,transparent:!0,opacity:.2})),E(this,"_size",5),E(this,"_enabled",!1),E(this,"_visible",!0),E(this,"_onStartDragging",()=>{this.onBeforeDrag.trigger()}),E(this,"_onEndDragging",()=>{this.onAfterDrag.trigger()}),this.components.add(Ei.uuid,this)}get enabled(){return this._enabled}set enabled(t){this._enabled=t;for(const e of this.list)e.enabled=t;this.updateMaterialsAndPlanes()}get visible(){return this._visible}set visible(t){this._visible=t;for(const e of this.list)e.visible=t}get material(){return this._material}set material(t){this._material=t;for(const e of this.list)e.planeMaterial=t}get size(){return this._size}set size(t){this._size=t;for(const e of this.list)e.size=t}dispose(){this._enabled=!1;for(const t of this.list)t.dispose();this.list.length=0,this._material.dispose(),this.onBeforeCreate.reset(),this.onBeforeCancel.reset(),this.onBeforeDelete.reset(),this.onBeforeDrag.reset(),this.onAfterCreate.reset(),this.onAfterCancel.reset(),this.onAfterDelete.reset(),this.onAfterDrag.reset(),this.onDisposed.trigger(Ei.uuid),this.onDisposed.reset()}create(t){if(!this.enabled)return;const i=this.components.get(ui).get(t).castRay();i&&this.createPlaneFromIntersection(t,i)}createFromNormalAndCoplanarPoint(t,e,s){const i=this.newPlane(t,s,e);return this.updateMaterialsAndPlanes(),i}delete(t,e){this.enabled&&(e||(e=this.pickPlane(t)),e&&this.deletePlane(e))}deleteAll(){for(;this.list.length>0;){const t=this.list[0];this.delete(t.world,t)}}deletePlane(t){const e=this.list.indexOf(t);if(e!==-1){if(this.list.splice(e,1),!t.world.renderer)throw new Error("Renderer not found for this plane's world!");t.world.renderer.setPlane(!1,t.three),t.dispose(),this.updateMaterialsAndPlanes(),this.onAfterDelete.trigger(t)}}pickPlane(t){const s=this.components.get(ui).get(t),i=this.getAllPlaneMeshes(),o=s.castRay(i);if(o){const n=o.object;return this.list.find(r=>r.meshes.includes(n))}}getAllPlaneMeshes(){const t=[];for(const e of this.list)t.push(...e.meshes);return t}createPlaneFromIntersection(t,e){var s;if(!t.renderer)throw new Error("The given world must have a renderer!");const i=e.point.distanceTo(new O(0,0,0)),o=(s=e.face)==null?void 0:s.normal;if(!i||!o)return;const n=this.getWorldNormal(e,o),r=this.newPlane(t,e.point,n.negate());r.visible=this._visible,r.size=this._size,t.renderer.setPlane(!0,r.three),this.updateMaterialsAndPlanes()}getWorldNormal(t,e){const s=t.object;let i=t.object.matrixWorld.clone();if(s instanceof He&&t.instanceId!==void 0){const a=new W;s.getMatrixAt(t.instanceId,a),i=a.multiply(i)}const n=new qt().getNormalMatrix(i),r=e.clone().applyMatrix3(n).normalize();return this.normalizePlaneDirectionY(r),r}normalizePlaneDirectionY(t){this.orthogonalY&&(t.y>this.toleranceOrthogonalY&&(t.x=0,t.y=1,t.z=0),t.y<-this.toleranceOrthogonalY&&(t.x=0,t.y=-1,t.z=0))}newPlane(t,e,s){const i=new this.Type(this.components,t,e,s,this._material);return i.onDraggingStarted.add(this._onStartDragging),i.onDraggingEnded.add(this._onEndDragging),this.list.push(i),this.onAfterCreate.trigger(i),i}updateMaterialsAndPlanes(){const t=this.components.get(Sa);for(const[e,s]of t.list){if(!s.renderer)continue;s.renderer.updateClippingPlanes();const{clippingPlanes:i}=s.renderer;for(const o of s.meshes)if(Array.isArray(o.material))for(const n of o.material)n.clippingPlanes=i;else o.material.clippingPlanes=i}}};E($n,"uuid","66290bc5-18c4-4cd1-9379-2e17a0617611");let ac=$n;function ba(c,t,e,s){return new Promise((i,o)=>{function n(){const r=c.clientWaitSync(t,e,0);if(r===c.WAIT_FAILED){o();return}if(r===c.TIMEOUT_EXPIRED){setTimeout(n,s);return}i()}n()})}async function va(c,t,e,s,i,o,n){const r=c.fenceSync(c.SYNC_GPU_COMMANDS_COMPLETE,0);c.flush(),await ba(c,r,0,10),c.deleteSync(r),c.bindBuffer(t,e),c.getBufferSubData(t,s,i,o,n),c.bindBuffer(t,null)}async function Ba(c,t,e,s,i,o,n,r){const a=c.createBuffer();return c.bindBuffer(c.PIXEL_PACK_BUFFER,a),c.bufferData(c.PIXEL_PACK_BUFFER,r.byteLength,c.STREAM_READ),c.readPixels(t,e,s,i,o,n,0),c.bindBuffer(c.PIXEL_PACK_BUFFER,null),await va(c,c.PIXEL_PACK_BUFFER,a,0,r),c.deleteBuffer(a),r}class Ya{constructor(t,e,s){if(E(this,"onDisposed",new M),E(this,"onViewUpdated",new Kt),E(this,"enabled",!0),E(this,"needsUpdate",!1),E(this,"renderDebugFrame",!1),E(this,"components"),E(this,"world"),E(this,"renderer"),E(this,"autoUpdate",!0),E(this,"updateInterval",1e3),E(this,"worker"),E(this,"scene",new Ti),E(this,"_width",512),E(this,"_height",512),E(this,"_availableColor",1),E(this,"renderTarget"),E(this,"bufferSize"),E(this,"_buffer"),E(this,"_isWorkerBusy",!1),E(this,"updateVisibility",async n=>{if(!this.enabled||!this.needsUpdate&&!n||this._isWorkerBusy)return;this._isWorkerBusy=!0;const r=this.world.camera.three;r.updateMatrix(),this.renderer.setSize(this._width,this._height),this.renderer.setRenderTarget(this.renderTarget),this.renderer.render(this.scene,r);const a=this.renderer.getContext();await Ba(a,0,0,this._width,this._height,a.RGBA,a.UNSIGNED_BYTE,this._buffer),this.renderer.setRenderTarget(null),this.renderDebugFrame&&this.renderer.render(this.scene,r),this.worker.postMessage({buffer:this._buffer}),this.needsUpdate=!1}),!e.renderer)throw new Error("The given world must have a renderer!");this.components=t,this.applySettings(s),this.world=e,this.renderer=new gs,this.renderTarget=new jo(this._width,this._height),this.bufferSize=this._width*this._height*4,this._buffer=new Uint8Array(this.bufferSize),this.renderer.clippingPlanes=e.renderer.clippingPlanes;const i=`
      addEventListener("message", (event) => {
        const { buffer } = event.data;
        const colors = new Map();
        for (let i = 0; i < buffer.length; i += 4) {
          const r = buffer[i];
          const g = buffer[i + 1];
          const b = buffer[i + 2];
          const code = "" + r + "-" + g + "-" + b;
          if(colors.has(code)) {
            colors.set(code, colors.get(code) + 1);
          } else {
            colors.set(code, 1);
          }
        }
        postMessage({ colors });
      });
    `,o=new Blob([i],{type:"application/javascript"});this.worker=new Worker(URL.createObjectURL(o))}dispose(){this.enabled=!1;for(const t of this.scene.children)t.removeFromParent();this.onViewUpdated.reset(),this.worker.terminate(),this.renderer.dispose(),this.renderTarget.dispose(),this._buffer=null,this.onDisposed.reset()}getAvailableColor(){let t=BigInt(this._availableColor.toString());const e=[];do e.unshift(Number(t%256n)),t/=256n;while(t);for(;e.length!==3;)e.unshift(0);const[s,i,o]=e,n=`${s}-${i}-${o}`;return{r:s,g:i,b:o,code:n}}increaseColor(){if(this._availableColor===256*256*256){console.warn("Color can't be increased over 256 x 256 x 256!");return}this._availableColor++}decreaseColor(){if(this._availableColor===1){console.warn("Color can't be decreased under 0!");return}this._availableColor--}applySettings(t){t&&(t.updateInterval!==void 0&&(this.updateInterval=t.updateInterval),t.height!==void 0&&(this._height=t.height),t.width!==void 0&&(this._width=t.width),t.autoUpdate!==void 0&&(this.autoUpdate=t.autoUpdate))}}class za extends Ya{constructor(t,e,s){super(t,e,s),E(this,"threshold",100),E(this,"onViewUpdated",new M),E(this,"colorMeshes",new Map),E(this,"isProcessing",!1),E(this,"_colorCodeMeshMap",new Map),E(this,"_meshIDColorCodeMap",new Map),E(this,"_currentVisibleMeshes",new Set),E(this,"_recentlyHiddenMeshes",new Set),E(this,"_intervalID",null),E(this,"_transparentMat",new Te({transparent:!0,opacity:0})),E(this,"handleWorkerMessage",async i=>{if(this.isProcessing)return;const o=i.data.colors;this._recentlyHiddenMeshes=new Set(this._currentVisibleMeshes),this._currentVisibleMeshes.clear();for(const[n,r]of o){if(r<this.threshold)continue;const a=this._colorCodeMeshMap.get(n);a&&(this._currentVisibleMeshes.add(a),this._recentlyHiddenMeshes.delete(a))}this.onViewUpdated.trigger({seen:this._currentVisibleMeshes,unseen:this._recentlyHiddenMeshes}),this._isWorkerBusy=!1}),this.worker.addEventListener("message",this.handleWorkerMessage),this.autoUpdate&&window.setInterval(async()=>{this.isProcessing||await this.updateVisibility()},this.updateInterval),this.onViewUpdated.add(({seen:i,unseen:o})=>{for(const n of i)n.visible=!0;for(const n of o)n.visible=!1})}dispose(){super.dispose(),this._intervalID!==null&&(window.clearInterval(this._intervalID),this._intervalID=null),this._currentVisibleMeshes.clear(),this._recentlyHiddenMeshes.clear(),this._meshIDColorCodeMap.clear(),this._transparentMat.dispose(),this._colorCodeMeshMap.clear();const t=this.components.get(me);for(const e in this.colorMeshes){const s=this.colorMeshes.get(e);s&&t.destroy(s,!0)}this.colorMeshes.clear()}add(t){if(!this.enabled)return;if(this.isProcessing){console.log("Culler processing not finished yet.");return}this.isProcessing=!0;const e=t instanceof He,{geometry:s,material:i}=t,{colorMaterial:o,code:n}=this.getAvailableMaterial();let r;if(Array.isArray(i)){let d=!0;const u=[];for(const h of i)fn.isTransparent(h)?u.push(this._transparentMat):(d=!1,u.push(o));if(d){o.dispose(),this.isProcessing=!1;return}r=u}else if(fn.isTransparent(i)){o.dispose(),this.isProcessing=!1;return}else r=o;this._colorCodeMeshMap.set(n,t),this._meshIDColorCodeMap.set(t.uuid,n);const a=e?t.count:1,l=new He(s,r,a);e?l.instanceMatrix=t.instanceMatrix:l.setMatrixAt(0,new W),t.visible=!1,l.applyMatrix4(t.matrix),l.updateMatrix(),this.scene.add(l),this.colorMeshes.set(t.uuid,l),this.increaseColor(),this.isProcessing=!1}remove(t){if(this.isProcessing){console.log("Culler processing not finished yet.");return}this.isProcessing=!0;const e=this.components.get(me);this._currentVisibleMeshes.delete(t),this._recentlyHiddenMeshes.delete(t);const s=this.colorMeshes.get(t.uuid),i=this._meshIDColorCodeMap.get(t.uuid);if(!s||!i){this.isProcessing=!1,console.log(t.visible);return}this._colorCodeMeshMap.delete(i),this._meshIDColorCodeMap.delete(t.uuid),this.colorMeshes.delete(t.uuid),s.geometry=void 0,s.material=[],e.destroy(s,!0),this._recentlyHiddenMeshes.delete(t),this._currentVisibleMeshes.delete(t),this.isProcessing=!1}getAvailableMaterial(){const{r:t,g:e,b:s,code:i}=this.getAvailableColor(),o=Ds.enabled;Ds.enabled=!1;const n=new $t(`rgb(${t}, ${e}, ${s})`);if(!this.world.renderer)throw new Error("Renderer not found in the world!");const r=this.world.renderer.clippingPlanes,a=new Te({color:n,clippingPlanes:r,side:We});return Ds.enabled=o,{colorMaterial:a,code:i}}}const Kn=class fi extends ${constructor(t){super(t),E(this,"_enabled",!0),E(this,"list",new Map),E(this,"onDisposed",new M),t.add(fi.uuid,this)}get enabled(){return this._enabled}set enabled(t){this._enabled=t;for(const[e,s]of this.list)s.enabled=t}create(t,e){if(this.list.has(t.uuid))return this.list.get(t.uuid);const s=new za(this.components,t,e);return this.list.set(t.uuid,s),s}delete(t){const e=this.list.get(t.uuid);e&&e.dispose(),this.list.delete(t.uuid)}dispose(){this.enabled=!1,this.onDisposed.trigger(fi.uuid),this.onDisposed.reset();for(const[t,e]of this.list)e.dispose();this.list.clear()}};E(Kn,"uuid","69f2a50d-c266-44fc-b1bd-fa4d34be89e6");let Ga=Kn;class Va{constructor(t){if(E(this,"onDisposed",new M),E(this,"onAfterUpdate",new M),E(this,"onBeforeUpdate",new M),E(this,"onResize",new M),E(this,"frontOffset",0),E(this,"overrideMaterial",new zo),E(this,"backgroundColor",new $t(395274)),E(this,"renderer"),E(this,"enabled",!0),E(this,"world"),E(this,"_lockRotation",!0),E(this,"_camera"),E(this,"_plane"),E(this,"_size",new gt(320,160)),E(this,"_tempVector1",new O),E(this,"_tempVector2",new O),E(this,"_tempTarget",new O),E(this,"down",new O(0,-1,0)),E(this,"updatePlanes",()=>{if(!this.world.renderer)throw new Error("The given world must have a renderer!");const i=[],o=this.world.renderer.three;for(const n of o.clippingPlanes)i.push(n);i.push(this._plane),this.renderer.clippingPlanes=i}),this.world=t,!this.world.renderer)throw new Error("The given world must have a renderer!");this.renderer=new gs,this.renderer.setSize(this._size.x,this._size.y);const e=1,s=this._size.x/this._size.y;this._camera=new mi(e*s/-2,e*s/2,e/2,e/-2),this.world.renderer.onClippingPlanesUpdated.add(this.updatePlanes),this._camera.position.set(0,200,0),this._camera.zoom=.1,this._camera.rotation.x=-Math.PI/2,this._plane=new Re(this.down,200),this.updatePlanes()}get lockRotation(){return this._lockRotation}set lockRotation(t){this._lockRotation=t,t&&(this._camera.rotation.z=0)}get zoom(){return this._camera.zoom}set zoom(t){this._camera.zoom=t,this._camera.updateProjectionMatrix()}dispose(){this.enabled=!1,this.onBeforeUpdate.reset(),this.onAfterUpdate.reset(),this.onResize.reset(),this.overrideMaterial.dispose(),this.renderer.dispose(),this.onDisposed.trigger(),this.onDisposed.reset()}get(){return this._camera}update(){if(!this.enabled)return;this.onBeforeUpdate.trigger();const t=this.world.scene.three,e=this.world.camera;if(!e.hasCameraControls())throw new Error("The given world must use camera controls!");if(!(t instanceof Ti))throw new Error("The given world must have a THREE.Scene as a root!");const s=e.controls;if(s.getPosition(this._tempVector1),this._camera.position.x=this._tempVector1.x,this._camera.position.z=this._tempVector1.z,this.frontOffset!==0&&(s.getTarget(this._tempVector2),this._tempVector2.sub(this._tempVector1),this._tempVector2.normalize().multiplyScalar(this.frontOffset),this._camera.position.x+=this._tempVector2.x,this._camera.position.z+=this._tempVector2.z),!this._lockRotation){s.getTarget(this._tempTarget);const o=Math.atan2(this._tempTarget.x-this._tempVector1.x,this._tempTarget.z-this._tempVector1.z);this._camera.rotation.z=o+Math.PI}this._plane.set(this.down,this._tempVector1.y);const i=t.background;t.background=this.backgroundColor,this.renderer.render(t,this._camera),t.background=i,this.onAfterUpdate.trigger()}getSize(){return this._size}resize(t=this._size){this._size.copy(t),this.renderer.setSize(t.x,t.y);const e=t.x/t.y,s=1;this._camera.left=s*e/-2,this._camera.right=s*e/2,this._camera.top=s/2,this._camera.bottom=-s/2,this._camera.updateProjectionMatrix(),this.onResize.trigger(t)}}const Jn=class to extends ${constructor(t){super(t),E(this,"onAfterUpdate",new M),E(this,"onBeforeUpdate",new M),E(this,"onDisposed",new M),E(this,"enabled",!0),E(this,"list",new Map),this.components.add(to.uuid,this)}create(t){if(this.list.has(t.uuid))throw new Error("This world already has a minimap!");const e=new Va(t);return this.list.set(t.uuid,e),e}delete(t){const e=this.list.get(t);e&&e.dispose(),this.list.delete(t)}dispose(){for(const[t,e]of this.list)e.dispose();this.list.clear(),this.onDisposed.trigger()}update(){for(const[t,e]of this.list)e.update()}};E(Jn,"uuid","39ad6aad-84c8-4adf-a1e0-7f25313a9e7f");let cc=Jn;class Ha{constructor(t){E(this,"enabled",!1),E(this,"id","FirstPerson"),this.camera=t}set(t){if(this.enabled=t,t){if(this.camera.projection.current!=="Perspective"){this.camera.set("Orbit");return}this.setupFirstPersonCamera()}}setupFirstPersonCamera(){const t=this.camera.controls,e=new O;t.distance--,t.getPosition(e),t.minDistance=1,t.maxDistance=1,t.distance=1,t.moveTo(e.x,e.y,e.z),t.truckSpeed=50,t.mouseButtons.wheel=rt.ACTION.DOLLY,t.touches.two=rt.ACTION.TOUCH_ZOOM_TRUCK}}class ka{constructor(t){E(this,"enabled",!0),E(this,"id","Orbit"),this.camera=t,this.activateOrbitControls()}set(t){this.enabled=t,t&&this.activateOrbitControls()}activateOrbitControls(){const t=this.camera.controls;t.minDistance=1,t.maxDistance=300;const e=new O;t.getPosition(e);const s=e.length();t.distance=s,t.truckSpeed=2;const{rotation:i}=this.camera.three,o=new O(0,0,-1).applyEuler(i),n=e.addScaledVector(o,s);t.moveTo(n.x,n.y,n.z)}}class Wa{constructor(t){E(this,"enabled",!1),E(this,"id","Plan"),E(this,"mouseAction1"),E(this,"mouseAction2"),E(this,"mouseInitialized",!1),E(this,"defaultAzimuthSpeed"),E(this,"defaultPolarSpeed"),this.camera=t,this.defaultAzimuthSpeed=t.controls.azimuthRotateSpeed,this.defaultPolarSpeed=t.controls.polarRotateSpeed}set(t){this.enabled=t;const e=this.camera.controls;e.azimuthRotateSpeed=t?0:this.defaultAzimuthSpeed,e.polarRotateSpeed=t?0:this.defaultPolarSpeed,this.mouseInitialized||(this.mouseAction1=e.touches.one,this.mouseAction2=e.touches.two,this.mouseInitialized=!0),t?(e.mouseButtons.left=rt.ACTION.TRUCK,e.touches.one=rt.ACTION.TOUCH_TRUCK,e.touches.two=rt.ACTION.TOUCH_ZOOM):(e.mouseButtons.left=rt.ACTION.ROTATE,e.touches.one=this.mouseAction1,e.touches.two=this.mouseAction2)}}class Xa{constructor(t){E(this,"onChanged",new M),E(this,"current","Perspective"),E(this,"camera"),E(this,"_component"),E(this,"_previousDistance",-1),E(this,"matchOrthoDistanceEnabled",!1),this._component=t,this.camera=t.three}async set(t){this.current!==t&&(t==="Orthographic"?this.setOrthoCamera():await this.setPerspectiveCamera(),this.onChanged.trigger(this.camera))}async toggle(){const e=this.current==="Perspective"?"Orthographic":"Perspective";await this.set(e)}setOrthoCamera(){if(this._component.mode===null||this._component.mode.id==="FirstPerson")return;this._previousDistance=this._component.controls.distance,this._component.controls.distance=200;const t=this.getPerspectiveDims();if(!t)return;const{width:e,height:s}=t;this.setupOrthoCamera(s,e),this.camera=this._component.threeOrtho,this.current="Orthographic"}getPerspectiveDims(){const t=this._component.currentWorld;if(!t||!t.renderer)return null;const e=new O;this._component.threePersp.getWorldDirection(e);const s=new O;this._component.controls.getTarget(s);const o=s.clone().sub(this._component.threePersp.position).dot(e),n=t.renderer.getSize(),r=n.x/n.y,a=this._component.threePersp,l=o*2*Math.atan(a.fov*(Math.PI/180)/2);return{width:l*r,height:l}}setupOrthoCamera(t,e){this._component.controls.mouseButtons.wheel=rt.ACTION.ZOOM,this._component.controls.mouseButtons.middle=rt.ACTION.ZOOM;const s=this._component.threePersp,i=this._component.threeOrtho;i.zoom=1,i.left=e/-2,i.right=e/2,i.top=t/2,i.bottom=t/-2,i.updateProjectionMatrix(),i.position.copy(s.position),i.quaternion.copy(s.quaternion),this._component.controls.camera=i}getDistance(){const t=this._component.threePersp,e=this._component.threeOrtho;return(e.top-e.bottom)/e.zoom/(2*Math.atan(t.fov*(Math.PI/180)/2))}async setPerspectiveCamera(){this._component.controls.mouseButtons.wheel=rt.ACTION.DOLLY,this._component.controls.mouseButtons.middle=rt.ACTION.DOLLY;const t=this._component.threePersp,e=this._component.threeOrtho;t.position.copy(e.position),t.quaternion.copy(e.quaternion),this._component.controls.mouseButtons.wheel=rt.ACTION.DOLLY,this.matchOrthoDistanceEnabled?this._component.controls.distance=this.getDistance():this._component.controls.distance=this._previousDistance,await this._component.controls.zoomTo(1),t.updateProjectionMatrix(),this._component.controls.camera=t,this.camera=t,this.current="Perspective"}}class lc extends ke{constructor(t){super(t),E(this,"_mode",null),E(this,"projection"),E(this,"threeOrtho"),E(this,"threePersp"),E(this,"_userInputButtons",{}),E(this,"_frustumSize",50),E(this,"_navigationModes",new Map),E(this,"previousSize",null),this.threePersp=this.three,this.threeOrtho=this.newOrthoCamera(),this.projection=new Xa(this),this.onAspectUpdated.add(()=>{this.setOrthoPerspCameraAspect()}),this.projection.onChanged.add(e=>{this.three=e,this.updateAspect()}),this.onWorldChanged.add(({action:e})=>{e==="added"&&(this._navigationModes.clear(),this._navigationModes.set("Orbit",new ka(this)),this._navigationModes.set("FirstPerson",new Ha(this)),this._navigationModes.set("Plan",new Wa(this)),this._mode=this._navigationModes.get("Orbit"),this.mode.set(!0,{preventTargetAdjustment:!0}),this.currentWorld&&this.currentWorld.renderer&&(this.previousSize=this.currentWorld.renderer.getSize().clone()))})}get mode(){if(!this._mode)throw new Error("Mode not found, camera not initialized");return this._mode}dispose(){super.dispose(),this.threeOrtho.removeFromParent()}set(t){if(this.mode!==null&&this.mode.id!==t){if(this.mode.set(!1),!this._navigationModes.has(t))throw new Error("The specified mode does not exist!");this._mode=this._navigationModes.get(t),this.mode.set(!0)}}async fit(t,e=1.5){if(!this.enabled)return;const s=Number.MAX_VALUE,i=Number.MIN_VALUE,o=new O(s,s,s),n=new O(i,i,i);for(const h of t){const f=new it().setFromObject(h);f.min.x<o.x&&(o.x=f.min.x),f.min.y<o.y&&(o.y=f.min.y),f.min.z<o.z&&(o.z=f.min.z),f.max.x>n.x&&(n.x=f.max.x),f.max.y>n.y&&(n.y=f.max.y),f.max.z>n.z&&(n.z=f.max.z)}const r=new it(o,n),a=new O;r.getSize(a);const l=new O;r.getCenter(l);const d=Math.max(a.x,a.y,a.z)*e,u=new Os(l,d);await this.controls.fitToSphere(u,!0)}setUserInput(t){t?this.enableUserInput():this.disableUserInput()}disableUserInput(){this._userInputButtons.left=this.controls.mouseButtons.left,this._userInputButtons.right=this.controls.mouseButtons.right,this._userInputButtons.middle=this.controls.mouseButtons.middle,this._userInputButtons.wheel=this.controls.mouseButtons.wheel,this.controls.mouseButtons.left=0,this.controls.mouseButtons.right=0,this.controls.mouseButtons.middle=0,this.controls.mouseButtons.wheel=0}enableUserInput(){Object.keys(this._userInputButtons).length!==0&&(this.controls.mouseButtons.left=this._userInputButtons.left,this.controls.mouseButtons.right=this._userInputButtons.right,this.controls.mouseButtons.middle=this._userInputButtons.middle,this.controls.mouseButtons.wheel=this._userInputButtons.wheel)}newOrthoCamera(){const t=window.innerWidth/window.innerHeight;return new mi(this._frustumSize*t/-2,this._frustumSize*t/2,this._frustumSize/2,this._frustumSize/-2,.1,1e3)}setOrthoPerspCameraAspect(){if(!this.currentWorld||!this.currentWorld.renderer||!this.previousSize)return;const t=this.currentWorld.renderer.getSize(),e=this.threeOrtho.top,s=this.threeOrtho.right,i=t.y/this.previousSize.y,o=t.x/this.previousSize.x,n=e*i,r=s*o;this.threeOrtho.left=-r,this.threeOrtho.right=r,this.threeOrtho.top=n,this.threeOrtho.bottom=-n,this.threeOrtho.updateProjectionMatrix(),this.previousSize.copy(t)}}const eo=class Lt extends ${constructor(t){super(t),E(this,"enabled",!0),E(this,"onDisposed",new M),E(this,"_absoluteMin"),E(this,"_absoluteMax"),E(this,"_meshes",[]),this.components.add(Lt.uuid,this),this._absoluteMin=Lt.newBound(!0),this._absoluteMax=Lt.newBound(!1)}static getDimensions(t){const{min:e,max:s}=t,i=Math.abs(s.x-e.x),o=Math.abs(s.y-e.y),n=Math.abs(s.z-e.z),r=new O;return r.subVectors(s,e).divideScalar(2).add(e),{width:i,height:o,depth:n,center:r}}static newBound(t){const e=t?1:-1;return new O(e*Number.MAX_VALUE,e*Number.MAX_VALUE,e*Number.MAX_VALUE)}static getBounds(t,e,s){const i=s||this.newBound(!1),o=e||this.newBound(!0);for(const n of t)n.x<o.x&&(o.x=n.x),n.y<o.y&&(o.y=n.y),n.z<o.z&&(o.z=n.z),n.x>i.x&&(i.x=n.x),n.y>i.y&&(i.y=n.y),n.z>i.z&&(i.z=n.z);return new it(e,s)}dispose(){const t=this.components.get(me);for(const e of this._meshes)t.destroy(e);this._meshes=[],this.onDisposed.trigger(Lt.uuid),this.onDisposed.reset()}get(){const t=this._absoluteMin.clone(),e=this._absoluteMax.clone();return new it(t,e)}getSphere(){const t=this._absoluteMin.clone(),e=this._absoluteMax.clone(),s=Math.abs((e.x-t.x)/2),i=Math.abs((e.y-t.y)/2),o=Math.abs((e.z-t.z)/2),n=new O(t.x+s,t.y+i,t.z+o),r=n.distanceTo(t);return new Os(n,r)}getMesh(){const t=new it(this._absoluteMin,this._absoluteMax),e=Lt.getDimensions(t),{width:s,height:i,depth:o,center:n}=e,r=new nt(s,i,o),a=new x(r);return this._meshes.push(a),a.position.copy(n),a}reset(){this._absoluteMin=Lt.newBound(!0),this._absoluteMax=Lt.newBound(!1)}add(t){for(const e of t.items)this.addMesh(e.mesh)}addMesh(t,e){if(!t.geometry.index)return;const s=Lt.getFragmentBounds(t);t.updateMatrixWorld();const i=t.matrixWorld,o=new W,n=t instanceof He,r=new Set;if(e&&t instanceof xo)for(const a of e){const l=t.fragment.getInstancesIDs(a);if(l)for(const d of l)r.add(d)}else r.add(0);for(const a of r){const l=s.min.clone(),d=s.max.clone();n&&(t.getMatrixAt(a,o),l.applyMatrix4(o),d.applyMatrix4(o)),l.applyMatrix4(i),d.applyMatrix4(i),l.x<this._absoluteMin.x&&(this._absoluteMin.x=l.x),l.y<this._absoluteMin.y&&(this._absoluteMin.y=l.y),l.z<this._absoluteMin.z&&(this._absoluteMin.z=l.z),l.x>this._absoluteMax.x&&(this._absoluteMax.x=l.x),l.y>this._absoluteMax.y&&(this._absoluteMax.y=l.y),l.z>this._absoluteMax.z&&(this._absoluteMax.z=l.z),d.x>this._absoluteMax.x&&(this._absoluteMax.x=d.x),d.y>this._absoluteMax.y&&(this._absoluteMax.y=d.y),d.z>this._absoluteMax.z&&(this._absoluteMax.z=d.z),d.x<this._absoluteMin.x&&(this._absoluteMin.x=d.x),d.y<this._absoluteMin.y&&(this._absoluteMin.y=d.y),d.z<this._absoluteMin.z&&(this._absoluteMin.z=d.z)}}static getFragmentBounds(t){const e=t.geometry.attributes.position,s=Number.MAX_VALUE,i=-s,o=new O(s,s,s),n=new O(i,i,i);if(!t.geometry.index)throw new Error("Geometry must be indexed!");const r=Array.from(t.geometry.index.array);for(let a=0;a<r.length;a++){if(a%3===0&&r[a]===0&&r[a+1]===0&&r[a+2]===0){a+=2;continue}const l=r[a],d=e.getX(l),u=e.getY(l),h=e.getZ(l);d<o.x&&(o.x=d),u<o.y&&(o.y=u),h<o.z&&(o.z=h),d>n.x&&(n.x=d),u>n.y&&(n.y=u),h>n.z&&(n.z=h)}return new it(o,n)}};E(eo,"uuid","d1444724-dba6-4cdd-a0c7-68ee1450d166");let hc=eo;const Bi=new Set([1123145078,574549367,1675464909,2059837836,3798115385,32440307,3125803723,3207858831,2740243338,2624227202,4240577450,3615266464,3724593414,220341763,477187591,1878645084,1300840506,3303107099,1607154358,1878645084,846575682,1351298697,2417041796,3049322572,3331915920,1416205885,776857604,3285139300,3958052878,2827736869,2732653382,673634403,3448662350,4142052618,2924175390,803316827,2556980723,1809719519,2205249479,807026263,3737207727,1660063152,2347385850,3940055652,2705031697,3732776249,2485617015,2611217952,1704287377,2937912522,2770003689,1281925730,1484403080,3448662350,4142052618,3800577675,4006246654,3590301190,1383045692,2775532180,2047409740,370225590,3593883385,2665983363,4124623270,812098782,3649129432,987898635,1105321065,3510044353,1635779807,2603310189,3406155212,1310608509,4261334040,2736907675,3649129432,1136057603,1260505505,4182860854,2713105998,2898889636,59481748,3749851601,3486308946,3150382593,1062206242,3264961684,15328376,1485152156,370225590,1981873012,2859738748,45288368,2614616156,2732653382,775493141,2147822146,2601014836,2629017746,1186437898,2367409068,1213902940,3632507154,3900360178,476780140,1472233963,2804161546,3008276851,738692330,374418227,315944413,3905492369,3570813810,2571569899,178912537,2294589976,1437953363,2133299955,572779678,3092502836,388784114,2624227202,1425443689,3057273783,2347385850,1682466193,2519244187,2839578677,3958567839,2513912981,2830218821,427810014]),so=class io extends ${constructor(t){super(t),E(this,"enabled",!0),t.add(io.uuid,this)}async export(t,e,s=!1,i=!0){const o={},n=new Set(t.GetIfcEntityList(e)),r=new Set([Oi,Si,yi,Pi,Jt]);for(const a of r)n.add(a);for(const a of n){if(Bi.has(a))continue;const l=r.has(a)&&i,d=t.GetLineIDsWithType(e,a);for(const u of d){const h=t.GetLine(0,u,l,s);o[h.expressID]=h}}return o}};E(so,"uuid","b32c4332-cd67-436e-ba7f-196646c7a635");let Za=so;const no=class oo extends ${constructor(t){super(t),E(this,"onDisposed",new M),E(this,"onFragmentsLoaded",new M),E(this,"onFragmentsDisposed",new M),E(this,"list",new Map),E(this,"groups",new Map),E(this,"enabled",!0),E(this,"baseCoordinationModel",""),E(this,"_loader",new Ln),this.components.add(oo.uuid,this)}get meshes(){const t=[];for(const[e,s]of this.list)t.push(s.mesh);return t}dispose(){for(const[t,e]of this.groups)e.dispose(!0);this.baseCoordinationModel="",this.groups.clear(),this.list.clear(),this.onFragmentsLoaded.reset(),this.onFragmentsDisposed.reset(),this.onDisposed.trigger(),this.onDisposed.reset()}disposeGroup(t){const{uuid:e}=t,s=[];for(const i of t.items)s.push(i.id),this.list.delete(i.id);t.dispose(!0),this.groups.delete(t.uuid),this.onFragmentsDisposed.trigger({groupID:e,fragmentIDs:s})}load(t,e){const i={...{coordinate:!0},...e},{coordinate:o,name:n,properties:r,relationsMap:a}=i,l=this._loader.import(t);n&&(l.name=n);for(const d of l.items)d.group=l,this.list.set(d.id,d);return o&&this.coordinate([l]),this.groups.set(l.uuid,l),r&&l.setLocalProperties(r),a&&this.components.get(Yi).setRelationMap(l,a),this.onFragmentsLoaded.trigger(l),l}export(t){return this._loader.export(t)}coordinate(t=Array.from(this.groups.values())){if(this.baseCoordinationModel.length===0){const i=t.pop();if(!i)return;this.baseCoordinationModel=i.uuid}if(!t.length)return;const s=this.groups.get(this.baseCoordinationModel);if(!s){console.log("No base model found for coordination!");return}for(const i of t)i!==s&&(i.position.set(0,0,0),i.rotation.set(0,0,0),i.scale.set(1,1,1),i.updateMatrix(),i.applyMatrix4(i.coordinationMatrix.clone().invert()),i.applyMatrix4(s.coordinationMatrix))}};E(no,"uuid","fef46874-46a3-461b-8c44-2922ab77c806");let Pt=no;const ro={950732822:"IFCURIREFERENCE",4075327185:"IFCTIME",1209108979:"IFCTEMPERATURERATEOFCHANGEMEASURE",3457685358:"IFCSOUNDPRESSURELEVELMEASURE",4157543285:"IFCSOUNDPOWERLEVELMEASURE",2798247006:"IFCPROPERTYSETDEFINITIONSET",1790229001:"IFCPOSITIVEINTEGER",525895558:"IFCNONNEGATIVELENGTHMEASURE",1774176899:"IFCLINEINDEX",1275358634:"IFCLANGUAGEID",2541165894:"IFCDURATION",3701338814:"IFCDAYINWEEKNUMBER",2195413836:"IFCDATETIME",937566702:"IFCDATE",1683019596:"IFCCARDINALPOINTREFERENCE",2314439260:"IFCBINARY",1500781891:"IFCAREADENSITYMEASURE",3683503648:"IFCARCINDEX",4065007721:"IFCYEARNUMBER",1718600412:"IFCWARPINGMOMENTMEASURE",51269191:"IFCWARPINGCONSTANTMEASURE",2593997549:"IFCVOLUMETRICFLOWRATEMEASURE",3458127941:"IFCVOLUMEMEASURE",3345633955:"IFCVAPORPERMEABILITYMEASURE",1278329552:"IFCTORQUEMEASURE",2591213694:"IFCTIMESTAMP",2726807636:"IFCTIMEMEASURE",743184107:"IFCTHERMODYNAMICTEMPERATUREMEASURE",2016195849:"IFCTHERMALTRANSMITTANCEMEASURE",857959152:"IFCTHERMALRESISTANCEMEASURE",2281867870:"IFCTHERMALEXPANSIONCOEFFICIENTMEASURE",2645777649:"IFCTHERMALCONDUCTIVITYMEASURE",232962298:"IFCTHERMALADMITTANCEMEASURE",296282323:"IFCTEXTTRANSFORMATION",603696268:"IFCTEXTFONTNAME",3490877962:"IFCTEXTDECORATION",1460886941:"IFCTEXTALIGNMENT",2801250643:"IFCTEXT",58845555:"IFCTEMPERATUREGRADIENTMEASURE",361837227:"IFCSPECULARROUGHNESS",2757832317:"IFCSPECULAREXPONENT",3477203348:"IFCSPECIFICHEATCAPACITYMEASURE",993287707:"IFCSOUNDPRESSUREMEASURE",846465480:"IFCSOUNDPOWERMEASURE",3471399674:"IFCSOLIDANGLEMEASURE",408310005:"IFCSHEARMODULUSMEASURE",2190458107:"IFCSECTIONALAREAINTEGRALMEASURE",3467162246:"IFCSECTIONMODULUSMEASURE",2766185779:"IFCSECONDINMINUTE",3211557302:"IFCROTATIONALSTIFFNESSMEASURE",1755127002:"IFCROTATIONALMASSMEASURE",2133746277:"IFCROTATIONALFREQUENCYMEASURE",200335297:"IFCREAL",96294661:"IFCRATIOMEASURE",3972513137:"IFCRADIOACTIVITYMEASURE",3665567075:"IFCPRESSUREMEASURE",2169031380:"IFCPRESENTABLETEXT",1364037233:"IFCPOWERMEASURE",1245737093:"IFCPOSITIVERATIOMEASURE",3054510233:"IFCPOSITIVEPLANEANGLEMEASURE",2815919920:"IFCPOSITIVELENGTHMEASURE",4042175685:"IFCPLANEANGLEMEASURE",2642773653:"IFCPLANARFORCEMEASURE",2260317790:"IFCPARAMETERVALUE",929793134:"IFCPHMEASURE",2395907400:"IFCNUMERICMEASURE",2095195183:"IFCNORMALISEDRATIOMEASURE",765770214:"IFCMONTHINYEARNUMBER",2615040989:"IFCMONETARYMEASURE",3114022597:"IFCMOMENTOFINERTIAMEASURE",1648970520:"IFCMOLECULARWEIGHTMEASURE",3177669450:"IFCMOISTUREDIFFUSIVITYMEASURE",1753493141:"IFCMODULUSOFSUBGRADEREACTIONMEASURE",1052454078:"IFCMODULUSOFROTATIONALSUBGRADEREACTIONMEASURE",2173214787:"IFCMODULUSOFLINEARSUBGRADEREACTIONMEASURE",3341486342:"IFCMODULUSOFELASTICITYMEASURE",102610177:"IFCMINUTEINHOUR",3531705166:"IFCMASSPERLENGTHMEASURE",3124614049:"IFCMASSMEASURE",4017473158:"IFCMASSFLOWRATEMEASURE",1477762836:"IFCMASSDENSITYMEASURE",2486716878:"IFCMAGNETICFLUXMEASURE",286949696:"IFCMAGNETICFLUXDENSITYMEASURE",151039812:"IFCLUMINOUSINTENSITYMEASURE",2755797622:"IFCLUMINOUSINTENSITYDISTRIBUTIONMEASURE",2095003142:"IFCLUMINOUSFLUXMEASURE",503418787:"IFCLOGICAL",3086160713:"IFCLINEARVELOCITYMEASURE",1307019551:"IFCLINEARSTIFFNESSMEASURE",2128979029:"IFCLINEARMOMENTMEASURE",191860431:"IFCLINEARFORCEMEASURE",1243674935:"IFCLENGTHMEASURE",3258342251:"IFCLABEL",2054016361:"IFCKINEMATICVISCOSITYMEASURE",3192672207:"IFCISOTHERMALMOISTURECAPACITYMEASURE",3686016028:"IFCIONCONCENTRATIONMEASURE",3809634241:"IFCINTEGERCOUNTRATEMEASURE",1939436016:"IFCINTEGER",2679005408:"IFCINDUCTANCEMEASURE",3358199106:"IFCILLUMINANCEMEASURE",983778844:"IFCIDENTIFIER",2589826445:"IFCHOURINDAY",1158859006:"IFCHEATINGVALUEMEASURE",3113092358:"IFCHEATFLUXDENSITYMEASURE",3064340077:"IFCGLOBALLYUNIQUEID",3044325142:"IFCFREQUENCYMEASURE",1361398929:"IFCFORCEMEASURE",2590844177:"IFCFONTWEIGHT",2715512545:"IFCFONTVARIANT",1102727119:"IFCFONTSTYLE",2078135608:"IFCENERGYMEASURE",2506197118:"IFCELECTRICVOLTAGEMEASURE",2951915441:"IFCELECTRICRESISTANCEMEASURE",3790457270:"IFCELECTRICCURRENTMEASURE",2093906313:"IFCELECTRICCONDUCTANCEMEASURE",3818826038:"IFCELECTRICCHARGEMEASURE",1827137117:"IFCELECTRICCAPACITANCEMEASURE",69416015:"IFCDYNAMICVISCOSITYMEASURE",524656162:"IFCDOSEEQUIVALENTMEASURE",4134073009:"IFCDIMENSIONCOUNT",1514641115:"IFCDESCRIPTIVEMEASURE",300323983:"IFCDAYLIGHTSAVINGHOUR",86635668:"IFCDAYINMONTHNUMBER",94842927:"IFCCURVATUREMEASURE",1778710042:"IFCCOUNTMEASURE",3238673880:"IFCCONTEXTDEPENDENTMEASURE",3812528620:"IFCCOMPOUNDPLANEANGLEMEASURE",2991860651:"IFCCOMPLEXNUMBER",1867003952:"IFCBOXALIGNMENT",2735952531:"IFCBOOLEAN",2650437152:"IFCAREAMEASURE",632304761:"IFCANGULARVELOCITYMEASURE",360377573:"IFCAMOUNTOFSUBSTANCEMEASURE",4182062534:"IFCACCELERATIONMEASURE",3699917729:"IFCABSORBEDDOSEMEASURE",1971632696:"IFCGEOSLICE",2680139844:"IFCGEOMODEL",24726584:"IFCELECTRICFLOWTREATMENTDEVICE",3693000487:"IFCDISTRIBUTIONBOARD",3460952963:"IFCCONVEYORSEGMENT",3999819293:"IFCCAISSONFOUNDATION",3314249567:"IFCBOREHOLE",4196446775:"IFCBEARING",325726236:"IFCALIGNMENT",3425753595:"IFCTRACKELEMENT",991950508:"IFCSIGNAL",3798194928:"IFCREINFORCEDSOIL",3290496277:"IFCRAIL",1383356374:"IFCPAVEMENT",2182337498:"IFCNAVIGATIONELEMENT",234836483:"IFCMOORINGDEVICE",2078563270:"IFCMOBILETELECOMMUNICATIONSAPPLIANCE",1638804497:"IFCLIQUIDTERMINAL",1154579445:"IFCLINEARPOSITIONINGELEMENT",2696325953:"IFCKERB",2713699986:"IFCGEOTECHNICALASSEMBLY",2142170206:"IFCELECTRICFLOWTREATMENTDEVICETYPE",3376911765:"IFCEARTHWORKSFILL",1077100507:"IFCEARTHWORKSELEMENT",3071239417:"IFCEARTHWORKSCUT",479945903:"IFCDISTRIBUTIONBOARDTYPE",3426335179:"IFCDEEPFOUNDATION",1502416096:"IFCCOURSE",2940368186:"IFCCONVEYORSEGMENTTYPE",3203706013:"IFCCAISSONFOUNDATIONTYPE",3862327254:"IFCBUILTSYSTEM",1876633798:"IFCBUILTELEMENT",963979645:"IFCBRIDGEPART",644574406:"IFCBRIDGE",3649138523:"IFCBEARINGTYPE",1662888072:"IFCALIGNMENTVERTICAL",317615605:"IFCALIGNMENTSEGMENT",1545765605:"IFCALIGNMENTHORIZONTAL",4266260250:"IFCALIGNMENTCANT",3956297820:"IFCVIBRATIONDAMPERTYPE",1530820697:"IFCVIBRATIONDAMPER",840318589:"IFCVEHICLE",1953115116:"IFCTRANSPORTATIONDEVICE",618700268:"IFCTRACKELEMENTTYPE",2281632017:"IFCTENDONCONDUITTYPE",3663046924:"IFCTENDONCONDUIT",42703149:"IFCSINESPIRAL",1894708472:"IFCSIGNALTYPE",3599934289:"IFCSIGNTYPE",33720170:"IFCSIGN",1027922057:"IFCSEVENTHORDERPOLYNOMIALSPIRAL",544395925:"IFCSEGMENTEDREFERENCECURVE",3649235739:"IFCSECONDORDERPOLYNOMIALSPIRAL",550521510:"IFCROADPART",146592293:"IFCROAD",3818125796:"IFCRELADHERESTOELEMENT",4021432810:"IFCREFERENT",1891881377:"IFCRAILWAYPART",3992365140:"IFCRAILWAY",1763565496:"IFCRAILTYPE",1946335990:"IFCPOSITIONINGELEMENT",514975943:"IFCPAVEMENTTYPE",506776471:"IFCNAVIGATIONELEMENTTYPE",710110818:"IFCMOORINGDEVICETYPE",1950438474:"IFCMOBILETELECOMMUNICATIONSAPPLIANCETYPE",976884017:"IFCMARINEPART",525669439:"IFCMARINEFACILITY",1770583370:"IFCLIQUIDTERMINALTYPE",2176059722:"IFCLINEARELEMENT",679976338:"IFCKERBTYPE",3948183225:"IFCIMPACTPROTECTIONDEVICETYPE",2568555532:"IFCIMPACTPROTECTIONDEVICE",2898700619:"IFCGRADIENTCURVE",1594536857:"IFCGEOTECHNICALSTRATUM",4230923436:"IFCGEOTECHNICALELEMENT",4228831410:"IFCFACILITYPARTCOMMON",1310830890:"IFCFACILITYPART",24185140:"IFCFACILITY",4234616927:"IFCDIRECTRIXDERIVEDREFERENCESWEPTAREASOLID",1306400036:"IFCDEEPFOUNDATIONTYPE",4189326743:"IFCCOURSETYPE",2000195564:"IFCCOSINESPIRAL",3497074424:"IFCCLOTHOID",1626504194:"IFCBUILTELEMENTTYPE",3651464721:"IFCVEHICLETYPE",1229763772:"IFCTRIANGULATEDIRREGULARNETWORK",3665877780:"IFCTRANSPORTATIONDEVICETYPE",782932809:"IFCTHIRDORDERPOLYNOMIALSPIRAL",2735484536:"IFCSPIRAL",1356537516:"IFCSECTIONEDSURFACE",1290935644:"IFCSECTIONEDSOLIDHORIZONTAL",1862484736:"IFCSECTIONEDSOLID",1441486842:"IFCRELPOSITIONS",1033248425:"IFCRELASSOCIATESPROFILEDEF",3381221214:"IFCPOLYNOMIALCURVE",2485787929:"IFCOFFSETCURVEBYDISTANCES",590820931:"IFCOFFSETCURVE",3465909080:"IFCINDEXEDPOLYGONALTEXTUREMAP",593015953:"IFCDIRECTRIXCURVESWEPTAREASOLID",4212018352:"IFCCURVESEGMENT",3425423356:"IFCAXIS2PLACEMENTLINEAR",823603102:"IFCSEGMENT",2165702409:"IFCPOINTBYDISTANCEEXPRESSION",182550632:"IFCOPENCROSSPROFILEDEF",388784114:"IFCLINEARPLACEMENT",536804194:"IFCALIGNMENTHORIZONTALSEGMENT",3752311538:"IFCALIGNMENTCANTSEGMENT",1010789467:"IFCTEXTURECOORDINATEINDICESWITHVOIDS",222769930:"IFCTEXTURECOORDINATEINDICES",2691318326:"IFCQUANTITYNUMBER",3633395639:"IFCALIGNMENTVERTICALSEGMENT",2879124712:"IFCALIGNMENTPARAMETERSEGMENT",25142252:"IFCCONTROLLER",3087945054:"IFCALARM",4288193352:"IFCACTUATOR",630975310:"IFCUNITARYCONTROLELEMENT",4086658281:"IFCSENSOR",2295281155:"IFCPROTECTIVEDEVICETRIPPINGUNIT",182646315:"IFCFLOWINSTRUMENT",1426591983:"IFCFIRESUPPRESSIONTERMINAL",819412036:"IFCFILTER",3415622556:"IFCFAN",1003880860:"IFCELECTRICTIMECONTROL",402227799:"IFCELECTRICMOTOR",264262732:"IFCELECTRICGENERATOR",3310460725:"IFCELECTRICFLOWSTORAGEDEVICE",862014818:"IFCELECTRICDISTRIBUTIONBOARD",1904799276:"IFCELECTRICAPPLIANCE",1360408905:"IFCDUCTSILENCER",3518393246:"IFCDUCTSEGMENT",342316401:"IFCDUCTFITTING",562808652:"IFCDISTRIBUTIONCIRCUIT",4074379575:"IFCDAMPER",3640358203:"IFCCOOLINGTOWER",4136498852:"IFCCOOLEDBEAM",2272882330:"IFCCONDENSER",3571504051:"IFCCOMPRESSOR",3221913625:"IFCCOMMUNICATIONSAPPLIANCE",639361253:"IFCCOIL",3902619387:"IFCCHILLER",4217484030:"IFCCABLESEGMENT",1051757585:"IFCCABLEFITTING",3758799889:"IFCCABLECARRIERSEGMENT",635142910:"IFCCABLECARRIERFITTING",2938176219:"IFCBURNER",32344328:"IFCBOILER",2906023776:"IFCBEAMSTANDARDCASE",277319702:"IFCAUDIOVISUALAPPLIANCE",2056796094:"IFCAIRTOAIRHEATRECOVERY",177149247:"IFCAIRTERMINALBOX",1634111441:"IFCAIRTERMINAL",486154966:"IFCWINDOWSTANDARDCASE",4237592921:"IFCWASTETERMINAL",4156078855:"IFCWALLELEMENTEDCASE",4207607924:"IFCVALVE",4292641817:"IFCUNITARYEQUIPMENT",3179687236:"IFCUNITARYCONTROLELEMENTTYPE",3026737570:"IFCTUBEBUNDLE",3825984169:"IFCTRANSFORMER",812556717:"IFCTANK",1162798199:"IFCSWITCHINGDEVICE",385403989:"IFCSTRUCTURALLOADCASE",1404847402:"IFCSTACKTERMINAL",1999602285:"IFCSPACEHEATER",3420628829:"IFCSOLARDEVICE",3027962421:"IFCSLABSTANDARDCASE",3127900445:"IFCSLABELEMENTEDCASE",1329646415:"IFCSHADINGDEVICE",3053780830:"IFCSANITARYTERMINAL",2572171363:"IFCREINFORCINGBARTYPE",1232101972:"IFCRATIONALBSPLINECURVEWITHKNOTS",90941305:"IFCPUMP",655969474:"IFCPROTECTIVEDEVICETRIPPINGUNITTYPE",738039164:"IFCPROTECTIVEDEVICE",1156407060:"IFCPLATESTANDARDCASE",3612865200:"IFCPIPESEGMENT",310824031:"IFCPIPEFITTING",3694346114:"IFCOUTLET",144952367:"IFCOUTERBOUNDARYCURVE",2474470126:"IFCMOTORCONNECTION",1911478936:"IFCMEMBERSTANDARDCASE",1437502449:"IFCMEDICALDEVICE",629592764:"IFCLIGHTFIXTURE",76236018:"IFCLAMP",2176052936:"IFCJUNCTIONBOX",4175244083:"IFCINTERCEPTOR",2068733104:"IFCHUMIDIFIER",3319311131:"IFCHEATEXCHANGER",2188021234:"IFCFLOWMETER",1209101575:"IFCEXTERNALSPATIALELEMENT",484807127:"IFCEVAPORATOR",3747195512:"IFCEVAPORATIVECOOLER",2814081492:"IFCENGINE",2417008758:"IFCELECTRICDISTRIBUTIONBOARDTYPE",3242481149:"IFCDOORSTANDARDCASE",3205830791:"IFCDISTRIBUTIONSYSTEM",400855858:"IFCCOMMUNICATIONSAPPLIANCETYPE",905975707:"IFCCOLUMNSTANDARDCASE",1677625105:"IFCCIVILELEMENT",3296154744:"IFCCHIMNEY",2674252688:"IFCCABLEFITTINGTYPE",2188180465:"IFCBURNERTYPE",1177604601:"IFCBUILDINGSYSTEM",39481116:"IFCBUILDINGELEMENTPARTTYPE",1136057603:"IFCBOUNDARYCURVE",2461110595:"IFCBSPLINECURVEWITHKNOTS",1532957894:"IFCAUDIOVISUALAPPLIANCETYPE",4088093105:"IFCWORKCALENDAR",4009809668:"IFCWINDOWTYPE",926996030:"IFCVOIDINGFEATURE",2391383451:"IFCVIBRATIONISOLATOR",2415094496:"IFCTENDONTYPE",3081323446:"IFCTENDONANCHORTYPE",413509423:"IFCSYSTEMFURNITUREELEMENT",3101698114:"IFCSURFACEFEATURE",3657597509:"IFCSTRUCTURALSURFACEACTION",2757150158:"IFCSTRUCTURALCURVEREACTION",1004757350:"IFCSTRUCTURALCURVEACTION",338393293:"IFCSTAIRTYPE",1072016465:"IFCSOLARDEVICETYPE",4074543187:"IFCSHADINGDEVICETYPE",2157484638:"IFCSEAMCURVE",2781568857:"IFCROOFTYPE",2310774935:"IFCREINFORCINGMESHTYPE",964333572:"IFCREINFORCINGELEMENTTYPE",683857671:"IFCRATIONALBSPLINESURFACEWITHKNOTS",1469900589:"IFCRAMPTYPE",2839578677:"IFCPOLYGONALFACESET",1158309216:"IFCPILETYPE",3079942009:"IFCOPENINGSTANDARDCASE",1114901282:"IFCMEDICALDEVICETYPE",3113134337:"IFCINTERSECTIONCURVE",3946677679:"IFCINTERCEPTORTYPE",2571569899:"IFCINDEXEDPOLYCURVE",3493046030:"IFCGEOGRAPHICELEMENT",1509553395:"IFCFURNITURE",1893162501:"IFCFOOTINGTYPE",2853485674:"IFCEXTERNALSPATIALSTRUCTUREELEMENT",4148101412:"IFCEVENT",132023988:"IFCENGINETYPE",2397081782:"IFCELEMENTASSEMBLYTYPE",2323601079:"IFCDOORTYPE",1213902940:"IFCCYLINDRICALSURFACE",1525564444:"IFCCONSTRUCTIONPRODUCTRESOURCETYPE",4105962743:"IFCCONSTRUCTIONMATERIALRESOURCETYPE",2185764099:"IFCCONSTRUCTIONEQUIPMENTRESOURCETYPE",15328376:"IFCCOMPOSITECURVEONSURFACE",3875453745:"IFCCOMPLEXPROPERTYTEMPLATE",3893394355:"IFCCIVILELEMENTTYPE",2197970202:"IFCCHIMNEYTYPE",167062518:"IFCBSPLINESURFACEWITHKNOTS",2887950389:"IFCBSPLINESURFACE",2603310189:"IFCADVANCEDBREPWITHVOIDS",1635779807:"IFCADVANCEDBREP",2916149573:"IFCTRIANGULATEDFACESET",1935646853:"IFCTOROIDALSURFACE",2387106220:"IFCTESSELLATEDFACESET",3206491090:"IFCTASKTYPE",699246055:"IFCSURFACECURVE",4095615324:"IFCSUBCONTRACTRESOURCETYPE",603775116:"IFCSTRUCTURALSURFACEREACTION",4015995234:"IFCSPHERICALSURFACE",2481509218:"IFCSPATIALZONETYPE",463610769:"IFCSPATIALZONE",710998568:"IFCSPATIALELEMENTTYPE",1412071761:"IFCSPATIALELEMENT",3663146110:"IFCSIMPLEPROPERTYTEMPLATE",3243963512:"IFCREVOLVEDAREASOLIDTAPERED",816062949:"IFCREPARAMETRISEDCOMPOSITECURVESEGMENT",1521410863:"IFCRELSPACEBOUNDARY2NDLEVEL",3523091289:"IFCRELSPACEBOUNDARY1STLEVEL",427948657:"IFCRELINTERFERESELEMENTS",307848117:"IFCRELDEFINESBYTEMPLATE",1462361463:"IFCRELDEFINESBYOBJECT",2565941209:"IFCRELDECLARES",1027710054:"IFCRELASSIGNSTOGROUPBYFACTOR",3521284610:"IFCPROPERTYTEMPLATE",492091185:"IFCPROPERTYSETTEMPLATE",653396225:"IFCPROJECTLIBRARY",569719735:"IFCPROCEDURETYPE",3967405729:"IFCPREDEFINEDPROPERTYSET",1682466193:"IFCPCURVE",428585644:"IFCLABORRESOURCETYPE",2294589976:"IFCINDEXEDPOLYGONALFACEWITHVOIDS",178912537:"IFCINDEXEDPOLYGONALFACE",4095422895:"IFCGEOGRAPHICELEMENTTYPE",2652556860:"IFCFIXEDREFERENCESWEPTAREASOLID",2804161546:"IFCEXTRUDEDAREASOLIDTAPERED",4024345920:"IFCEVENTTYPE",2629017746:"IFCCURVEBOUNDEDSURFACE",1815067380:"IFCCREWRESOURCETYPE",3419103109:"IFCCONTEXT",2574617495:"IFCCONSTRUCTIONRESOURCETYPE",2059837836:"IFCCARTESIANPOINTLIST3D",1675464909:"IFCCARTESIANPOINTLIST2D",574549367:"IFCCARTESIANPOINTLIST",3406155212:"IFCADVANCEDFACE",3698973494:"IFCTYPERESOURCE",3736923433:"IFCTYPEPROCESS",901063453:"IFCTESSELLATEDITEM",1096409881:"IFCSWEPTDISKSOLIDPOLYGONAL",1042787934:"IFCRESOURCETIME",1608871552:"IFCRESOURCECONSTRAINTRELATIONSHIP",2943643501:"IFCRESOURCEAPPROVALRELATIONSHIP",2090586900:"IFCQUANTITYSET",1482703590:"IFCPROPERTYTEMPLATEDEFINITION",3778827333:"IFCPREDEFINEDPROPERTIES",2998442950:"IFCMIRROREDPROFILEDEF",853536259:"IFCMATERIALRELATIONSHIP",3404854881:"IFCMATERIALPROFILESETUSAGETAPERING",3079605661:"IFCMATERIALPROFILESETUSAGE",2852063980:"IFCMATERIALCONSTITUENTSET",3708119e3:"IFCMATERIALCONSTITUENT",1585845231:"IFCLAGTIME",2133299955:"IFCINDEXEDTRIANGLETEXTUREMAP",1437953363:"IFCINDEXEDTEXTUREMAP",3570813810:"IFCINDEXEDCOLOURMAP",1437805879:"IFCEXTERNALREFERENCERELATIONSHIP",297599258:"IFCEXTENDEDPROPERTIES",211053100:"IFCEVENTTIME",2713554722:"IFCCONVERSIONBASEDUNITWITHOFFSET",3285139300:"IFCCOLOURRGBLIST",1236880293:"IFCWORKTIME",1199560280:"IFCTIMEPERIOD",3611470254:"IFCTEXTUREVERTEXLIST",2771591690:"IFCTASKTIMERECURRING",1549132990:"IFCTASKTIME",2043862942:"IFCTABLECOLUMN",2934153892:"IFCSURFACEREINFORCEMENTAREA",609421318:"IFCSTRUCTURALLOADORRESULT",3478079324:"IFCSTRUCTURALLOADCONFIGURATION",1054537805:"IFCSCHEDULINGTIME",2439245199:"IFCRESOURCELEVELRELATIONSHIP",2433181523:"IFCREFERENCE",3915482550:"IFCRECURRENCEPATTERN",986844984:"IFCPROPERTYABSTRACTION",3843373140:"IFCPROJECTEDCRS",677532197:"IFCPRESENTATIONITEM",1507914824:"IFCMATERIALUSAGEDEFINITION",552965576:"IFCMATERIALPROFILEWITHOFFSETS",164193824:"IFCMATERIALPROFILESET",2235152071:"IFCMATERIALPROFILE",1847252529:"IFCMATERIALLAYERWITHOFFSETS",760658860:"IFCMATERIALDEFINITION",3057273783:"IFCMAPCONVERSION",4294318154:"IFCEXTERNALINFORMATION",1466758467:"IFCCOORDINATEREFERENCESYSTEM",1785450214:"IFCCOORDINATEOPERATION",775493141:"IFCCONNECTIONVOLUMEGEOMETRY",979691226:"IFCREINFORCINGBAR",3700593921:"IFCELECTRICDISTRIBUTIONPOINT",1062813311:"IFCDISTRIBUTIONCONTROLELEMENT",1052013943:"IFCDISTRIBUTIONCHAMBERELEMENT",578613899:"IFCCONTROLLERTYPE",2454782716:"IFCCHAMFEREDGEFEATURE",753842376:"IFCBEAM",3001207471:"IFCALARMTYPE",2874132201:"IFCACTUATORTYPE",3304561284:"IFCWINDOW",3512223829:"IFCWALLSTANDARDCASE",2391406946:"IFCWALL",3313531582:"IFCVIBRATIONISOLATORTYPE",2347447852:"IFCTENDONANCHOR",3824725483:"IFCTENDON",2515109513:"IFCSTRUCTURALANALYSISMODEL",4252922144:"IFCSTAIRFLIGHT",331165859:"IFCSTAIR",1529196076:"IFCSLAB",1783015770:"IFCSENSORTYPE",1376911519:"IFCROUNDEDEDGEFEATURE",2016517767:"IFCROOF",2320036040:"IFCREINFORCINGMESH",3027567501:"IFCREINFORCINGELEMENT",3055160366:"IFCRATIONALBEZIERCURVE",3283111854:"IFCRAMPFLIGHT",3024970846:"IFCRAMP",2262370178:"IFCRAILING",3171933400:"IFCPLATE",1687234759:"IFCPILE",1073191201:"IFCMEMBER",900683007:"IFCFOOTING",3508470533:"IFCFLOWTREATMENTDEVICE",2223149337:"IFCFLOWTERMINAL",707683696:"IFCFLOWSTORAGEDEVICE",987401354:"IFCFLOWSEGMENT",3132237377:"IFCFLOWMOVINGDEVICE",4037862832:"IFCFLOWINSTRUMENTTYPE",4278956645:"IFCFLOWFITTING",2058353004:"IFCFLOWCONTROLLER",4222183408:"IFCFIRESUPPRESSIONTERMINALTYPE",1810631287:"IFCFILTERTYPE",346874300:"IFCFANTYPE",1658829314:"IFCENERGYCONVERSIONDEVICE",857184966:"IFCELECTRICALELEMENT",1634875225:"IFCELECTRICALCIRCUIT",712377611:"IFCELECTRICTIMECONTROLTYPE",1217240411:"IFCELECTRICMOTORTYPE",1365060375:"IFCELECTRICHEATERTYPE",1534661035:"IFCELECTRICGENERATORTYPE",3277789161:"IFCELECTRICFLOWSTORAGEDEVICETYPE",663422040:"IFCELECTRICAPPLIANCETYPE",855621170:"IFCEDGEFEATURE",2030761528:"IFCDUCTSILENCERTYPE",3760055223:"IFCDUCTSEGMENTTYPE",869906466:"IFCDUCTFITTINGTYPE",395920057:"IFCDOOR",3041715199:"IFCDISTRIBUTIONPORT",3040386961:"IFCDISTRIBUTIONFLOWELEMENT",1945004755:"IFCDISTRIBUTIONELEMENT",2063403501:"IFCDISTRIBUTIONCONTROLELEMENTTYPE",1599208980:"IFCDISTRIBUTIONCHAMBERELEMENTTYPE",2635815018:"IFCDISCRETEACCESSORYTYPE",1335981549:"IFCDISCRETEACCESSORY",4147604152:"IFCDIAMETERDIMENSION",3961806047:"IFCDAMPERTYPE",3495092785:"IFCCURTAINWALL",1973544240:"IFCCOVERING",2954562838:"IFCCOOLINGTOWERTYPE",335055490:"IFCCOOLEDBEAMTYPE",488727124:"IFCCONSTRUCTIONPRODUCTRESOURCE",1060000209:"IFCCONSTRUCTIONMATERIALRESOURCE",3898045240:"IFCCONSTRUCTIONEQUIPMENTRESOURCE",1163958913:"IFCCONDITIONCRITERION",2188551683:"IFCCONDITION",2816379211:"IFCCONDENSERTYPE",3850581409:"IFCCOMPRESSORTYPE",843113511:"IFCCOLUMN",2301859152:"IFCCOILTYPE",2611217952:"IFCCIRCLE",2951183804:"IFCCHILLERTYPE",1285652485:"IFCCABLESEGMENTTYPE",3293546465:"IFCCABLECARRIERSEGMENTTYPE",395041908:"IFCCABLECARRIERFITTINGTYPE",1909888760:"IFCBUILDINGELEMENTPROXYTYPE",1095909175:"IFCBUILDINGELEMENTPROXY",2979338954:"IFCBUILDINGELEMENTPART",52481810:"IFCBUILDINGELEMENTCOMPONENT",3299480353:"IFCBUILDINGELEMENT",231477066:"IFCBOILERTYPE",1916977116:"IFCBEZIERCURVE",819618141:"IFCBEAMTYPE",1967976161:"IFCBSPLINECURVE",3460190687:"IFCASSET",2470393545:"IFCANGULARDIMENSION",1871374353:"IFCAIRTOAIRHEATRECOVERYTYPE",3352864051:"IFCAIRTERMINALTYPE",1411407467:"IFCAIRTERMINALBOXTYPE",3821786052:"IFCACTIONREQUEST",1213861670:"IFC2DCOMPOSITECURVE",1033361043:"IFCZONE",3342526732:"IFCWORKSCHEDULE",4218914973:"IFCWORKPLAN",1028945134:"IFCWORKCONTROL",1133259667:"IFCWASTETERMINALTYPE",1898987631:"IFCWALLTYPE",2769231204:"IFCVIRTUALELEMENT",728799441:"IFCVALVETYPE",1911125066:"IFCUNITARYEQUIPMENTTYPE",1600972822:"IFCTUBEBUNDLETYPE",3593883385:"IFCTRIMMEDCURVE",1620046519:"IFCTRANSPORTELEMENT",1692211062:"IFCTRANSFORMERTYPE",1637806684:"IFCTIMESERIESSCHEDULE",5716631:"IFCTANKTYPE",2254336722:"IFCSYSTEM",2315554128:"IFCSWITCHINGDEVICETYPE",148013059:"IFCSUBCONTRACTRESOURCE",1975003073:"IFCSTRUCTURALSURFACECONNECTION",2986769608:"IFCSTRUCTURALRESULTGROUP",1235345126:"IFCSTRUCTURALPOINTREACTION",734778138:"IFCSTRUCTURALPOINTCONNECTION",2082059205:"IFCSTRUCTURALPOINTACTION",3987759626:"IFCSTRUCTURALPLANARACTIONVARYING",1621171031:"IFCSTRUCTURALPLANARACTION",1252848954:"IFCSTRUCTURALLOADGROUP",1721250024:"IFCSTRUCTURALLINEARACTIONVARYING",1807405624:"IFCSTRUCTURALLINEARACTION",2445595289:"IFCSTRUCTURALCURVEMEMBERVARYING",214636428:"IFCSTRUCTURALCURVEMEMBER",4243806635:"IFCSTRUCTURALCURVECONNECTION",1179482911:"IFCSTRUCTURALCONNECTION",682877961:"IFCSTRUCTURALACTION",1039846685:"IFCSTAIRFLIGHTTYPE",3112655638:"IFCSTACKTERMINALTYPE",3812236995:"IFCSPACETYPE",652456506:"IFCSPACEPROGRAM",1305183839:"IFCSPACEHEATERTYPE",3856911033:"IFCSPACE",2533589738:"IFCSLABTYPE",4097777520:"IFCSITE",4105383287:"IFCSERVICELIFE",3517283431:"IFCSCHEDULETIMECONTROL",1768891740:"IFCSANITARYTERMINALTYPE",2863920197:"IFCRELASSIGNSTASKS",160246688:"IFCRELAGGREGATES",2324767716:"IFCRAMPFLIGHTTYPE",2893384427:"IFCRAILINGTYPE",3248260540:"IFCRADIUSDIMENSION",2250791053:"IFCPUMPTYPE",1842657554:"IFCPROTECTIVEDEVICETYPE",3651124850:"IFCPROJECTIONELEMENT",3642467123:"IFCPROJECTORDERRECORD",2904328755:"IFCPROJECTORDER",2744685151:"IFCPROCEDURE",3740093272:"IFCPORT",3724593414:"IFCPOLYLINE",4017108033:"IFCPLATETYPE",4231323485:"IFCPIPESEGMENTTYPE",804291784:"IFCPIPEFITTINGTYPE",3327091369:"IFCPERMIT",2382730787:"IFCPERFORMANCEHISTORY",2837617999:"IFCOUTLETTYPE",3425660407:"IFCORDERACTION",3588315303:"IFCOPENINGELEMENT",4143007308:"IFCOCCUPANT",1916936684:"IFCMOVE",977012517:"IFCMOTORCONNECTIONTYPE",3181161470:"IFCMEMBERTYPE",2108223431:"IFCMECHANICALFASTENERTYPE",377706215:"IFCMECHANICALFASTENER",2506943328:"IFCLINEARDIMENSION",1161773419:"IFCLIGHTFIXTURETYPE",1051575348:"IFCLAMPTYPE",3827777499:"IFCLABORRESOURCE",4288270099:"IFCJUNCTIONBOXTYPE",2391368822:"IFCINVENTORY",1806887404:"IFCHUMIDIFIERTYPE",1251058090:"IFCHEATEXCHANGERTYPE",2706460486:"IFCGROUP",3009204131:"IFCGRID",200128114:"IFCGASTERMINALTYPE",814719939:"IFCFURNITURESTANDARD",263784265:"IFCFURNISHINGELEMENT",3009222698:"IFCFLOWTREATMENTDEVICETYPE",2297155007:"IFCFLOWTERMINALTYPE",1339347760:"IFCFLOWSTORAGEDEVICETYPE",1834744321:"IFCFLOWSEGMENTTYPE",1482959167:"IFCFLOWMOVINGDEVICETYPE",3815607619:"IFCFLOWMETERTYPE",3198132628:"IFCFLOWFITTINGTYPE",3907093117:"IFCFLOWCONTROLLERTYPE",1287392070:"IFCFEATUREELEMENTSUBTRACTION",2143335405:"IFCFEATUREELEMENTADDITION",2827207264:"IFCFEATUREELEMENT",2489546625:"IFCFASTENERTYPE",647756555:"IFCFASTENER",3737207727:"IFCFACETEDBREPWITHVOIDS",807026263:"IFCFACETEDBREP",3390157468:"IFCEVAPORATORTYPE",3174744832:"IFCEVAPORATIVECOOLERTYPE",3272907226:"IFCEQUIPMENTSTANDARD",1962604670:"IFCEQUIPMENTELEMENT",2107101300:"IFCENERGYCONVERSIONDEVICETYPE",1704287377:"IFCELLIPSE",2590856083:"IFCELEMENTCOMPONENTTYPE",1623761950:"IFCELEMENTCOMPONENT",4123344466:"IFCELEMENTASSEMBLY",1758889154:"IFCELEMENT",360485395:"IFCELECTRICALBASEPROPERTIES",3849074793:"IFCDISTRIBUTIONFLOWELEMENTTYPE",3256556792:"IFCDISTRIBUTIONELEMENTTYPE",681481545:"IFCDIMENSIONCURVEDIRECTEDCALLOUT",1457835157:"IFCCURTAINWALLTYPE",3295246426:"IFCCREWRESOURCE",1916426348:"IFCCOVERINGTYPE",1419761937:"IFCCOSTSCHEDULE",3895139033:"IFCCOSTITEM",3293443760:"IFCCONTROL",2559216714:"IFCCONSTRUCTIONRESOURCE",2510884976:"IFCCONIC",3732776249:"IFCCOMPOSITECURVE",300633059:"IFCCOLUMNTYPE",2937912522:"IFCCIRCLEHOLLOWPROFILEDEF",3124254112:"IFCBUILDINGSTOREY",1950629157:"IFCBUILDINGELEMENTTYPE",4031249490:"IFCBUILDING",1260505505:"IFCBOUNDEDCURVE",3649129432:"IFCBOOLEANCLIPPINGRESULT",1334484129:"IFCBLOCK",3207858831:"IFCASYMMETRICISHAPEPROFILEDEF",1674181508:"IFCANNOTATION",2296667514:"IFCACTOR",2097647324:"IFCTRANSPORTELEMENTTYPE",3473067441:"IFCTASK",1580310250:"IFCSYSTEMFURNITUREELEMENTTYPE",4124788165:"IFCSURFACEOFREVOLUTION",2809605785:"IFCSURFACEOFLINEAREXTRUSION",2028607225:"IFCSURFACECURVESWEPTAREASOLID",4070609034:"IFCSTRUCTUREDDIMENSIONCALLOUT",2218152070:"IFCSTRUCTURALSURFACEMEMBERVARYING",3979015343:"IFCSTRUCTURALSURFACEMEMBER",3689010777:"IFCSTRUCTURALREACTION",530289379:"IFCSTRUCTURALMEMBER",3136571912:"IFCSTRUCTURALITEM",3544373492:"IFCSTRUCTURALACTIVITY",451544542:"IFCSPHERE",3893378262:"IFCSPATIALSTRUCTUREELEMENTTYPE",2706606064:"IFCSPATIALSTRUCTUREELEMENT",3626867408:"IFCRIGHTCIRCULARCYLINDER",4158566097:"IFCRIGHTCIRCULARCONE",1856042241:"IFCREVOLVEDAREASOLID",2914609552:"IFCRESOURCE",1401173127:"IFCRELVOIDSELEMENT",3451746338:"IFCRELSPACEBOUNDARY",366585022:"IFCRELSERVICESBUILDINGS",4122056220:"IFCRELSEQUENCE",1058617721:"IFCRELSCHEDULESCOSTITEMS",1245217292:"IFCRELREFERENCEDINSPATIALSTRUCTURE",750771296:"IFCRELPROJECTSELEMENT",202636808:"IFCRELOVERRIDESPROPERTIES",2051452291:"IFCRELOCCUPIESSPACES",3268803585:"IFCRELNESTS",4189434867:"IFCRELINTERACTIONREQUIREMENTS",279856033:"IFCRELFLOWCONTROLELEMENTS",3940055652:"IFCRELFILLSELEMENT",781010003:"IFCRELDEFINESBYTYPE",4186316022:"IFCRELDEFINESBYPROPERTIES",693640335:"IFCRELDEFINES",2551354335:"IFCRELDECOMPOSES",2802773753:"IFCRELCOVERSSPACES",886880790:"IFCRELCOVERSBLDGELEMENTS",3242617779:"IFCRELCONTAINEDINSPATIALSTRUCTURE",3678494232:"IFCRELCONNECTSWITHREALIZINGELEMENTS",504942748:"IFCRELCONNECTSWITHECCENTRICITY",1638771189:"IFCRELCONNECTSSTRUCTURALMEMBER",3912681535:"IFCRELCONNECTSSTRUCTURALELEMENT",2127690289:"IFCRELCONNECTSSTRUCTURALACTIVITY",3190031847:"IFCRELCONNECTSPORTS",4201705270:"IFCRELCONNECTSPORTTOELEMENT",3945020480:"IFCRELCONNECTSPATHELEMENTS",1204542856:"IFCRELCONNECTSELEMENTS",826625072:"IFCRELCONNECTS",2851387026:"IFCRELASSOCIATESPROFILEPROPERTIES",2655215786:"IFCRELASSOCIATESMATERIAL",3840914261:"IFCRELASSOCIATESLIBRARY",982818633:"IFCRELASSOCIATESDOCUMENT",2728634034:"IFCRELASSOCIATESCONSTRAINT",919958153:"IFCRELASSOCIATESCLASSIFICATION",4095574036:"IFCRELASSOCIATESAPPROVAL",1327628568:"IFCRELASSOCIATESAPPLIEDVALUE",1865459582:"IFCRELASSOCIATES",205026976:"IFCRELASSIGNSTORESOURCE",3372526763:"IFCRELASSIGNSTOPROJECTORDER",2857406711:"IFCRELASSIGNSTOPRODUCT",4278684876:"IFCRELASSIGNSTOPROCESS",1307041759:"IFCRELASSIGNSTOGROUP",2495723537:"IFCRELASSIGNSTOCONTROL",1683148259:"IFCRELASSIGNSTOACTOR",3939117080:"IFCRELASSIGNS",3454111270:"IFCRECTANGULARTRIMMEDSURFACE",2798486643:"IFCRECTANGULARPYRAMID",2770003689:"IFCRECTANGLEHOLLOWPROFILEDEF",3219374653:"IFCPROXY",1451395588:"IFCPROPERTYSET",4194566429:"IFCPROJECTIONCURVE",103090709:"IFCPROJECT",4208778838:"IFCPRODUCT",2945172077:"IFCPROCESS",220341763:"IFCPLANE",603570806:"IFCPLANARBOX",3566463478:"IFCPERMEABLECOVERINGPROPERTIES",3505215534:"IFCOFFSETCURVE3D",3388369263:"IFCOFFSETCURVE2D",3888040117:"IFCOBJECT",1425443689:"IFCMANIFOLDSOLIDBREP",1281925730:"IFCLINE",572779678:"IFCLSHAPEPROFILEDEF",1484403080:"IFCISHAPEPROFILEDEF",987898635:"IFCGEOMETRICCURVESET",1268542332:"IFCFURNITURETYPE",4238390223:"IFCFURNISHINGELEMENTTYPE",3455213021:"IFCFLUIDFLOWPROPERTIES",315944413:"IFCFILLAREASTYLETILES",4203026998:"IFCFILLAREASTYLETILESYMBOLWITHSTYLE",374418227:"IFCFILLAREASTYLEHATCHING",2047409740:"IFCFACEBASEDSURFACEMODEL",477187591:"IFCEXTRUDEDAREASOLID",80994333:"IFCENERGYPROPERTIES",2835456948:"IFCELLIPSEPROFILEDEF",2777663545:"IFCELEMENTARYSURFACE",339256511:"IFCELEMENTTYPE",1883228015:"IFCELEMENTQUANTITY",1472233963:"IFCEDGELOOP",4006246654:"IFCDRAUGHTINGPREDEFINEDCURVEFONT",445594917:"IFCDRAUGHTINGPREDEFINEDCOLOUR",3073041342:"IFCDRAUGHTINGCALLOUT",526551008:"IFCDOORSTYLE",1714330368:"IFCDOORPANELPROPERTIES",2963535650:"IFCDOORLININGPROPERTIES",32440307:"IFCDIRECTION",4054601972:"IFCDIMENSIONCURVETERMINATOR",606661476:"IFCDIMENSIONCURVE",693772133:"IFCDEFINEDSYMBOL",2827736869:"IFCCURVEBOUNDEDPLANE",2601014836:"IFCCURVE",2147822146:"IFCCSGSOLID",2506170314:"IFCCSGPRIMITIVE3D",194851669:"IFCCRANERAILFSHAPEPROFILEDEF",4133800736:"IFCCRANERAILASHAPEPROFILEDEF",2485617015:"IFCCOMPOSITECURVESEGMENT",2205249479:"IFCCLOSEDSHELL",1383045692:"IFCCIRCLEPROFILEDEF",1416205885:"IFCCARTESIANTRANSFORMATIONOPERATOR3DNONUNIFORM",3331915920:"IFCCARTESIANTRANSFORMATIONOPERATOR3D",3486308946:"IFCCARTESIANTRANSFORMATIONOPERATOR2DNONUNIFORM",3749851601:"IFCCARTESIANTRANSFORMATIONOPERATOR2D",59481748:"IFCCARTESIANTRANSFORMATIONOPERATOR",1123145078:"IFCCARTESIANPOINT",2898889636:"IFCCSHAPEPROFILEDEF",2713105998:"IFCBOXEDHALFSPACE",2581212453:"IFCBOUNDINGBOX",4182860854:"IFCBOUNDEDSURFACE",2736907675:"IFCBOOLEANRESULT",2740243338:"IFCAXIS2PLACEMENT3D",3125803723:"IFCAXIS2PLACEMENT2D",4261334040:"IFCAXIS1PLACEMENT",1302238472:"IFCANNOTATIONSURFACE",2265737646:"IFCANNOTATIONFILLAREAOCCURRENCE",669184980:"IFCANNOTATIONFILLAREA",3288037868:"IFCANNOTATIONCURVEOCCURRENCE",2543172580:"IFCZSHAPEPROFILEDEF",1299126871:"IFCWINDOWSTYLE",512836454:"IFCWINDOWPANELPROPERTIES",336235671:"IFCWINDOWLININGPROPERTIES",2759199220:"IFCVERTEXLOOP",1417489154:"IFCVECTOR",427810014:"IFCUSHAPEPROFILEDEF",2347495698:"IFCTYPEPRODUCT",1628702193:"IFCTYPEOBJECT",1345879162:"IFCTWODIRECTIONREPEATFACTOR",2715220739:"IFCTRAPEZIUMPROFILEDEF",3124975700:"IFCTEXTLITERALWITHEXTENT",4282788508:"IFCTEXTLITERAL",3028897424:"IFCTERMINATORSYMBOL",3071757647:"IFCTSHAPEPROFILEDEF",230924584:"IFCSWEPTSURFACE",1260650574:"IFCSWEPTDISKSOLID",2247615214:"IFCSWEPTAREASOLID",1878645084:"IFCSURFACESTYLERENDERING",2513912981:"IFCSURFACE",2233826070:"IFCSUBEDGE",3653947884:"IFCSTRUCTURALSTEELPROFILEPROPERTIES",3843319758:"IFCSTRUCTURALPROFILEPROPERTIES",1190533807:"IFCSTRUCTURALLOADSINGLEFORCEWARPING",1597423693:"IFCSTRUCTURALLOADSINGLEFORCE",1973038258:"IFCSTRUCTURALLOADSINGLEDISPLACEMENTDISTORTION",2473145415:"IFCSTRUCTURALLOADSINGLEDISPLACEMENT",2668620305:"IFCSTRUCTURALLOADPLANARFORCE",1595516126:"IFCSTRUCTURALLOADLINEARFORCE",390701378:"IFCSPACETHERMALLOADPROPERTIES",1202362311:"IFCSOUNDVALUE",2485662743:"IFCSOUNDPROPERTIES",723233188:"IFCSOLIDMODEL",2609359061:"IFCSLIPPAGECONNECTIONCONDITION",4124623270:"IFCSHELLBASEDSURFACEMODEL",2411513650:"IFCSERVICELIFEFACTOR",1509187699:"IFCSECTIONEDSPINE",2778083089:"IFCROUNDEDRECTANGLEPROFILEDEF",478536968:"IFCRELATIONSHIP",3765753017:"IFCREINFORCEMENTDEFINITIONPROPERTIES",3413951693:"IFCREGULARTIMESERIES",3615266464:"IFCRECTANGLEPROFILEDEF",110355661:"IFCPROPERTYTABLEVALUE",3650150729:"IFCPROPERTYSINGLEVALUE",3357820518:"IFCPROPERTYSETDEFINITION",941946838:"IFCPROPERTYREFERENCEVALUE",2752243245:"IFCPROPERTYLISTVALUE",4166981789:"IFCPROPERTYENUMERATEDVALUE",1680319473:"IFCPROPERTYDEFINITION",871118103:"IFCPROPERTYBOUNDEDVALUE",673634403:"IFCPRODUCTDEFINITIONSHAPE",179317114:"IFCPREDEFINEDPOINTMARKERSYMBOL",433424934:"IFCPREDEFINEDDIMENSIONSYMBOL",2559016684:"IFCPREDEFINEDCURVEFONT",759155922:"IFCPREDEFINEDCOLOUR",2775532180:"IFCPOLYGONALBOUNDEDHALFSPACE",2924175390:"IFCPOLYLOOP",1423911732:"IFCPOINTONSURFACE",4022376103:"IFCPOINTONCURVE",2067069095:"IFCPOINT",1663979128:"IFCPLANAREXTENT",2004835150:"IFCPLACEMENT",597895409:"IFCPIXELTEXTURE",3021840470:"IFCPHYSICALCOMPLEXQUANTITY",2519244187:"IFCPATH",2529465313:"IFCPARAMETERIZEDPROFILEDEF",1029017970:"IFCORIENTEDEDGE",2665983363:"IFCOPENSHELL",2833995503:"IFCONEDIRECTIONREPEATFACTOR",219451334:"IFCOBJECTDEFINITION",1430189142:"IFCMECHANICALCONCRETEMATERIALPROPERTIES",2022407955:"IFCMATERIALDEFINITIONREPRESENTATION",2347385850:"IFCMAPPEDITEM",1008929658:"IFCLOOP",2624227202:"IFCLOCALPLACEMENT",3422422726:"IFCLIGHTSOURCESPOT",1520743889:"IFCLIGHTSOURCEPOSITIONAL",4266656042:"IFCLIGHTSOURCEGONIOMETRIC",2604431987:"IFCLIGHTSOURCEDIRECTIONAL",125510826:"IFCLIGHTSOURCEAMBIENT",1402838566:"IFCLIGHTSOURCE",3741457305:"IFCIRREGULARTIMESERIES",3905492369:"IFCIMAGETEXTURE",2445078500:"IFCHYGROSCOPICMATERIALPROPERTIES",812098782:"IFCHALFSPACESOLID",178086475:"IFCGRIDPLACEMENT",3590301190:"IFCGEOMETRICSET",4142052618:"IFCGEOMETRICREPRESENTATIONSUBCONTEXT",2453401579:"IFCGEOMETRICREPRESENTATIONITEM",3448662350:"IFCGEOMETRICREPRESENTATIONCONTEXT",1446786286:"IFCGENERALPROFILEPROPERTIES",803998398:"IFCGENERALMATERIALPROPERTIES",3857492461:"IFCFUELPROPERTIES",738692330:"IFCFILLAREASTYLE",4219587988:"IFCFAILURECONNECTIONCONDITION",3008276851:"IFCFACESURFACE",803316827:"IFCFACEOUTERBOUND",1809719519:"IFCFACEBOUND",2556980723:"IFCFACE",1860660968:"IFCEXTENDEDMATERIALPROPERTIES",476780140:"IFCEDGECURVE",3900360178:"IFCEDGE",4170525392:"IFCDRAUGHTINGPREDEFINEDTEXTFONT",3732053477:"IFCDOCUMENTREFERENCE",1694125774:"IFCDIMENSIONPAIR",2273265877:"IFCDIMENSIONCALLOUTRELATIONSHIP",3632507154:"IFCDERIVEDPROFILEDEF",3800577675:"IFCCURVESTYLE",2889183280:"IFCCONVERSIONBASEDUNIT",3050246964:"IFCCONTEXTDEPENDENTUNIT",45288368:"IFCCONNECTIONPOINTECCENTRICITY",1981873012:"IFCCONNECTIONCURVEGEOMETRY",370225590:"IFCCONNECTEDFACESET",1485152156:"IFCCOMPOSITEPROFILEDEF",2542286263:"IFCCOMPLEXPROPERTY",776857604:"IFCCOLOURRGB",647927063:"IFCCLASSIFICATIONREFERENCE",3150382593:"IFCCENTERLINEPROFILEDEF",616511568:"IFCBLOBTEXTURE",2705031697:"IFCARBITRARYPROFILEDEFWITHVOIDS",1310608509:"IFCARBITRARYOPENPROFILEDEF",3798115385:"IFCARBITRARYCLOSEDPROFILEDEF",2297822566:"IFCANNOTATIONTEXTOCCURRENCE",3612888222:"IFCANNOTATIONSYMBOLOCCURRENCE",962685235:"IFCANNOTATIONSURFACEOCCURRENCE",2442683028:"IFCANNOTATIONOCCURRENCE",1065908215:"IFCWATERPROPERTIES",891718957:"IFCVIRTUALGRIDINTERSECTION",1907098498:"IFCVERTEXPOINT",3304826586:"IFCVERTEXBASEDTEXTUREMAP",2799835756:"IFCVERTEX",180925521:"IFCUNITASSIGNMENT",1735638870:"IFCTOPOLOGYREPRESENTATION",1377556343:"IFCTOPOLOGICALREPRESENTATIONITEM",581633288:"IFCTIMESERIESVALUE",1718945513:"IFCTIMESERIESREFERENCERELATIONSHIP",3101149627:"IFCTIMESERIES",3317419933:"IFCTHERMALMATERIALPROPERTIES",1210645708:"IFCTEXTUREVERTEX",2552916305:"IFCTEXTUREMAP",1742049831:"IFCTEXTURECOORDINATEGENERATOR",280115917:"IFCTEXTURECOORDINATE",1484833681:"IFCTEXTSTYLEWITHBOXCHARACTERISTICS",1640371178:"IFCTEXTSTYLETEXTMODEL",2636378356:"IFCTEXTSTYLEFORDEFINEDFONT",1983826977:"IFCTEXTSTYLEFONTMODEL",1447204868:"IFCTEXTSTYLE",912023232:"IFCTELECOMADDRESS",531007025:"IFCTABLEROW",985171141:"IFCTABLE",1290481447:"IFCSYMBOLSTYLE",626085974:"IFCSURFACETEXTURE",1351298697:"IFCSURFACESTYLEWITHTEXTURES",846575682:"IFCSURFACESTYLESHADING",1607154358:"IFCSURFACESTYLEREFRACTION",3303107099:"IFCSURFACESTYLELIGHTING",1300840506:"IFCSURFACESTYLE",3049322572:"IFCSTYLEDREPRESENTATION",3958052878:"IFCSTYLEDITEM",2830218821:"IFCSTYLEMODEL",3408363356:"IFCSTRUCTURALLOADTEMPERATURE",2525727697:"IFCSTRUCTURALLOADSTATIC",2162789131:"IFCSTRUCTURALLOAD",2273995522:"IFCSTRUCTURALCONNECTIONCONDITION",3692461612:"IFCSIMPLEPROPERTY",4240577450:"IFCSHAPEREPRESENTATION",3982875396:"IFCSHAPEMODEL",867548509:"IFCSHAPEASPECT",4165799628:"IFCSECTIONREINFORCEMENTPROPERTIES",2042790032:"IFCSECTIONPROPERTIES",448429030:"IFCSIUNIT",2341007311:"IFCROOT",3679540991:"IFCRIBPLATEPROFILEPROPERTIES",1660063152:"IFCREPRESENTATIONMAP",3008791417:"IFCREPRESENTATIONITEM",3377609919:"IFCREPRESENTATIONCONTEXT",1076942058:"IFCREPRESENTATION",1222501353:"IFCRELAXATION",1580146022:"IFCREINFORCEMENTBARPROPERTIES",2692823254:"IFCREFERENCESVALUEDOCUMENT",825690147:"IFCQUANTITYWEIGHT",2405470396:"IFCQUANTITYVOLUME",3252649465:"IFCQUANTITYTIME",931644368:"IFCQUANTITYLENGTH",2093928680:"IFCQUANTITYCOUNT",2044713172:"IFCQUANTITYAREA",3710013099:"IFCPROPERTYENUMERATION",148025276:"IFCPROPERTYDEPENDENCYRELATIONSHIP",3896028662:"IFCPROPERTYCONSTRAINTRELATIONSHIP",2598011224:"IFCPROPERTY",2802850158:"IFCPROFILEPROPERTIES",3958567839:"IFCPROFILEDEF",2267347899:"IFCPRODUCTSOFCOMBUSTIONPROPERTIES",2095639259:"IFCPRODUCTREPRESENTATION",2417041796:"IFCPRESENTATIONSTYLEASSIGNMENT",3119450353:"IFCPRESENTATIONSTYLE",1304840413:"IFCPRESENTATIONLAYERWITHSTYLE",2022622350:"IFCPRESENTATIONLAYERASSIGNMENT",1775413392:"IFCPREDEFINEDTEXTFONT",3213052703:"IFCPREDEFINEDTERMINATORSYMBOL",990879717:"IFCPREDEFINEDSYMBOL",3727388367:"IFCPREDEFINEDITEM",3355820592:"IFCPOSTALADDRESS",2226359599:"IFCPHYSICALSIMPLEQUANTITY",2483315170:"IFCPHYSICALQUANTITY",101040310:"IFCPERSONANDORGANIZATION",2077209135:"IFCPERSON",1207048766:"IFCOWNERHISTORY",1411181986:"IFCORGANIZATIONRELATIONSHIP",4251960020:"IFCORGANIZATION",1227763645:"IFCOPTICALMATERIALPROPERTIES",2251480897:"IFCOBJECTIVE",3701648758:"IFCOBJECTPLACEMENT",1918398963:"IFCNAMEDUNIT",2706619895:"IFCMONETARYUNIT",3368373690:"IFCMETRIC",677618848:"IFCMECHANICALSTEELMATERIALPROPERTIES",4256014907:"IFCMECHANICALMATERIALPROPERTIES",2597039031:"IFCMEASUREWITHUNIT",3265635763:"IFCMATERIALPROPERTIES",2199411900:"IFCMATERIALLIST",1303795690:"IFCMATERIALLAYERSETUSAGE",3303938423:"IFCMATERIALLAYERSET",248100487:"IFCMATERIALLAYER",1847130766:"IFCMATERIALCLASSIFICATIONRELATIONSHIP",1838606355:"IFCMATERIAL",30780891:"IFCLOCALTIME",1566485204:"IFCLIGHTINTENSITYDISTRIBUTION",4162380809:"IFCLIGHTDISTRIBUTIONDATA",3452421091:"IFCLIBRARYREFERENCE",2655187982:"IFCLIBRARYINFORMATION",3020489413:"IFCIRREGULARTIMESERIESVALUE",852622518:"IFCGRIDAXIS",3548104201:"IFCEXTERNALLYDEFINEDTEXTFONT",3207319532:"IFCEXTERNALLYDEFINEDSYMBOL",1040185647:"IFCEXTERNALLYDEFINEDSURFACESTYLE",2242383968:"IFCEXTERNALLYDEFINEDHATCHSTYLE",3200245327:"IFCEXTERNALREFERENCE",1648886627:"IFCENVIRONMENTALIMPACTVALUE",3796139169:"IFCDRAUGHTINGCALLOUTRELATIONSHIP",770865208:"IFCDOCUMENTINFORMATIONRELATIONSHIP",1154170062:"IFCDOCUMENTINFORMATION",1376555844:"IFCDOCUMENTELECTRONICFORMAT",2949456006:"IFCDIMENSIONALEXPONENTS",1045800335:"IFCDERIVEDUNITELEMENT",1765591967:"IFCDERIVEDUNIT",1072939445:"IFCDATEANDTIME",3510044353:"IFCCURVESTYLEFONTPATTERN",2367409068:"IFCCURVESTYLEFONTANDSCALING",1105321065:"IFCCURVESTYLEFONT",539742890:"IFCCURRENCYRELATIONSHIP",602808272:"IFCCOSTVALUE",1065062679:"IFCCOORDINATEDUNIVERSALTIMEOFFSET",347226245:"IFCCONSTRAINTRELATIONSHIP",613356794:"IFCCONSTRAINTCLASSIFICATIONRELATIONSHIP",1658513725:"IFCCONSTRAINTAGGREGATIONRELATIONSHIP",1959218052:"IFCCONSTRAINT",2732653382:"IFCCONNECTIONSURFACEGEOMETRY",4257277454:"IFCCONNECTIONPORTGEOMETRY",2614616156:"IFCCONNECTIONPOINTGEOMETRY",2859738748:"IFCCONNECTIONGEOMETRY",3264961684:"IFCCOLOURSPECIFICATION",3639012971:"IFCCLASSIFICATIONNOTATIONFACET",938368621:"IFCCLASSIFICATIONNOTATION",1098599126:"IFCCLASSIFICATIONITEMRELATIONSHIP",1767535486:"IFCCLASSIFICATIONITEM",747523909:"IFCCLASSIFICATION",622194075:"IFCCALENDARDATE",2069777674:"IFCBOUNDARYNODECONDITIONWARPING",1387855156:"IFCBOUNDARYNODECONDITION",3367102660:"IFCBOUNDARYFACECONDITION",1560379544:"IFCBOUNDARYEDGECONDITION",4037036970:"IFCBOUNDARYCONDITION",3869604511:"IFCAPPROVALRELATIONSHIP",390851274:"IFCAPPROVALPROPERTYRELATIONSHIP",2080292479:"IFCAPPROVALACTORRELATIONSHIP",130549933:"IFCAPPROVAL",1110488051:"IFCAPPLIEDVALUERELATIONSHIP",411424972:"IFCAPPLIEDVALUE",639542469:"IFCAPPLICATION",618182010:"IFCADDRESS",3630933823:"IFCACTORROLE",599546466:"FILE_DESCRIPTION",1390159747:"FILE_NAME",1109904537:"FILE_SCHEMA"};class Yt{static async getUnits(t){var e;const{IFCUNITASSIGNMENT:s}=Nt,i=await t.getAllPropertiesOfType(s);if(!i)return 1;const o=Object.keys(i),n=i[parseInt(o[0],10)];for(const r of n.Units){if(r.value===void 0||r.value===null)continue;const a=await t.getProperties(r.value);if(!a||!a.UnitType||!a.UnitType.value||a.UnitType.value!=="LENGTHUNIT")continue;let d=1,u=1;return a.Name.value==="METRE"&&(u=1),a.Name.value==="FOOT"&&(u=.3048),((e=a.Prefix)==null?void 0:e.value)==="MILLI"&&(d=.001),u*d}return 1}static async findItemByGuid(t,e){var s;const i=t.getAllPropertiesIDs();for(const o of i){const n=await t.getProperties(o);if(n&&((s=n.GlobalId)==null?void 0:s.value)===e)return n}return null}static async getRelationMap(t,e,s){var i;const n=s??(async()=>{}),r={},a=t.getAllPropertiesIDs();for(const l of a){const d=await t.getProperties(l);if(!d)continue;const u=d.type===e,h=Object.keys(d).find(C=>C.startsWith("Relating")),f=Object.keys(d).find(C=>C.startsWith("Related"));if(!(u&&h&&f))continue;const p=await t.getProperties((i=d[h])==null?void 0:i.value),T=d[f];if(!p||!T||!(T&&Array.isArray(T)))continue;const m=T.map(C=>C.value);await n(p.expressID,m),r[p.expressID]=m}return r}static async getQsetQuantities(t,e,s){const o=s??(()=>{}),n=await t.getProperties(e);return!n||n.type!==Do?null:(n.Quantities??[{}]).map(l=>(l.value&&o(l.value),l.value)).filter(l=>l!==null)}static async getPsetProps(t,e,s){const o=s??(()=>{}),n=await t.getProperties(e);return!n||n.type!==ei?null:(n.HasProperties??[{}]).map(l=>(l.value&&o(l.value),l.value)).filter(l=>l!==null)}static async getPsetRel(t,e){var s;if(!await t.getProperties(e))return null;const o=await t.getAllPropertiesOfType(Ss);if(!o)return null;const n=Object.values(o);let r=null;for(const a of n)((s=a.RelatingPropertyDefinition)==null?void 0:s.value)===e&&(r=a.expressID);return r}static async getQsetRel(t,e){return Yt.getPsetRel(t,e)}static async getEntityName(t,e){var s;const i=await t.getProperties(e);if(!i)return{key:null,name:null};const o=Object.keys(i).find(r=>r.endsWith("Name"))??null,n=o?(s=i[o])==null?void 0:s.value:null;return{key:o,name:n}}static async getQuantityValue(t,e){const s=await t.getProperties(e);if(!s)return{key:null,value:null};const i=Object.keys(s).find(n=>n.endsWith("Value"))??null;let o;return i===null||s[i]===void 0||s[i]===null?o=null:o=s[i].value,{key:i,value:o}}static isRel(t){return ro[t].startsWith("IFCREL")}static async attributeExists(t,e,s){const i=await t.getProperties(e);return i?Object.keys(i).includes(s):!1}static async groupEntitiesByType(t,e){var s;const i=new Map;for(const o of e){const n=await t.getProperties(o);if(!n)continue;const r=n.type;i.get(r)||i.set(r,new Set),(s=i.get(r))==null||s.add(o)}return i}}const Qa=new Map([[Ri,{forRelating:"IsDecomposedBy",forRelated:"Decomposes"}],[Ai,{forRelating:"AssociatedTo",forRelated:"HasAssociations"}],[gi,{forRelating:"ClassificationForObjects",forRelated:"HasAssociations"}],[Fi,{forRelating:"IsGroupedBy",forRelated:"HasAssignments"}],[Ss,{forRelated:"IsDefinedBy",forRelating:"DefinesOcurrence"}],[_i,{forRelated:"IsTypedBy",forRelating:"Types"}],[Mn,{forRelated:"IsDefinedBy",forRelating:"Defines"}],[ys,{forRelated:"ContainedInStructure",forRelating:"ContainsElements"}]]),ao=class Ii extends ${constructor(t){super(t),E(this,"onDisposed",new M),E(this,"enabled",!0),E(this,"onRelationsIndexed",new M),E(this,"_relToAttributesMap",Qa),E(this,"_inverseAttributes",["IsDecomposedBy","Decomposes","AssociatedTo","HasAssociations","ClassificationForObjects","IsGroupedBy","HasAssignments","IsDefinedBy","DefinesOcurrence","IsTypedBy","Types","Defines","ContainedInStructure","ContainsElements"]),E(this,"_ifcRels",[Ri,Ai,gi,Fi,Ss,_i,Mn,ys]),E(this,"relationMaps",{}),E(this,"onFragmentsDisposed",s=>{delete this.relationMaps[s.groupID]}),this.components.add(Ii.uuid,this),t.get(Pt).onFragmentsDisposed.add(this.onFragmentsDisposed)}setRelationMap(t,e){this.relationMaps[t.uuid]=e,this.onRelationsIndexed.trigger({modelID:t.uuid,relationsMap:e})}async process(t){if(!t.hasProperties)throw new Error("FragmentsGroup properties not found");let e=this.relationMaps[t.uuid];if(e)return e;e=new Map;for(const s of this._ifcRels)await Yt.getRelationMap(t,s,async(i,o)=>{const n=this._relToAttributesMap.get(s);if(!n)return;const{forRelated:r,forRelating:a}=n,l=e.get(i)??new Map,d=this._inverseAttributes.indexOf(a);l.set(d,o),e.set(i,l);for(const u of o){const h=e.get(u)??new Map,f=this._inverseAttributes.indexOf(r),p=h.get(f)??[];p.push(i),h.set(f,p),e.set(u,h)}});return this.setRelationMap(t,e),e}async processFromWebIfc(t,e){const s=new Map;for(const i of this._ifcRels){const o=this._relToAttributesMap.get(i);if(!o)continue;const{forRelated:n,forRelating:r}=o,a=t.GetLineIDsWithType(e,i);for(let l=0;l<a.size();l++){const d=await t.properties.getItemProperties(e,a.get(l)),u=Object.keys(d).find(C=>C.startsWith("Relating")),h=Object.keys(d).find(C=>C.startsWith("Related"));if(!(u&&h))continue;const f=d[u].value,p=d[h].map(C=>C.value),T=s.get(f)??new Map,m=this._inverseAttributes.indexOf(r);T.set(m,p),s.set(f,T);for(const C of p){const R=s.get(C)??new Map,g=this._inverseAttributes.indexOf(n),I=R.get(g)??[];I.push(f),R.set(g,I),s.set(C,R)}}}return this.onRelationsIndexed.trigger({modelID:e.toString(),relationsMap:s}),s}getEntityRelations(t,e,s){const i=this.relationMaps[t.uuid];if(!i)return null;const o=i.get(e),n=this._inverseAttributes.indexOf(s);if(!o||n===-1)return null;const r=o.get(n);return r||null}serializeRelations(t){const e={};for(const[s,i]of t.entries()){e[s]||(e[s]={});for(const[o,n]of i.entries())e[s][o]=n}return JSON.stringify(e)}serializeModelRelations(t){const e=this.relationMaps[t.uuid];return e?this.serializeRelations(e):null}serializeAllRelations(){const t={};for(const e in this.relationMaps){const s=this.relationMaps[e],i={};for(const[o,n]of s.entries()){i[o]||(i[o]={});for(const[r,a]of n.entries())i[o][r]=a}t[e]=i}return JSON.stringify(t)}getRelationsMapFromJSON(t){const e=JSON.parse(t),s=new Map;for(const i in e){const o=e[i],n=new Map;for(const r in o)n.set(Number(r),o[r]);s.set(Number(i),n)}return s}dispose(){this.relationMaps={},this.components.get(Pt).onFragmentsDisposed.remove(this.onFragmentsDisposed),this.onDisposed.trigger(Ii.uuid),this.onDisposed.reset()}};E(ao,"uuid","23a889ab-83b3-44a4-8bee-ead83438370b");let Yi=ao;class ja{constructor(){E(this,"factor",1),E(this,"complement",1)}apply(t){const s=this.getScaleMatrix().multiply(t);t.copy(s)}setUp(t){var e;this.factor=1;const s=this.getLengthUnits(t);if(!s)return;const i=s==null,o=s.Name===void 0||s.Name===null;i||o||(s.Name.value==="FOOT"?this.factor=.3048:((e=s.Prefix)==null?void 0:e.value)==="MILLI"&&(this.complement=.001))}getLengthUnits(t){try{const s=t.GetLineIDsWithType(0,qo).get(0),i=t.GetLine(0,s);for(const o of i.Units){if(!o||o.value===null||o.value===void 0)continue;const n=t.GetLine(0,o.value);if(n.UnitType&&n.UnitType.value==="LENGTHUNIT")return n}return null}catch{return console.log("Could not get units"),null}}getScaleMatrix(){const t=this.factor;return new W().fromArray([t,0,0,0,0,t,0,0,0,0,t,0,0,0,0,1])}}class co{constructor(){E(this,"itemsByFloor",{}),E(this,"_units",new ja)}setUp(t){this._units.setUp(t),this.cleanUp();try{const e=t.GetLineIDsWithType(0,ys),s=new Set,i=t.GetLineIDsWithType(0,Jt);for(let l=0;l<i.size();l++)s.add(i.get(l));const o=t.GetLineIDsWithType(0,Ri),n=o.size();for(let l=0;l<n;l++){const d=o.get(l),u=t.GetLine(0,d);if(!u||!u.RelatingObject||!u.RelatedObjects)continue;const h=u.RelatingObject.value,f=u.RelatedObjects;for(const p of f){const T=p.value;s.has(T)&&(this.itemsByFloor[T]=h)}}const r={},a=e.size();for(let l=0;l<a;l++){const d=e.get(l),u=t.GetLine(0,d);if(!u||!u.RelatingStructure||!u.RelatedElements)continue;const h=u.RelatingStructure.value,f=u.RelatedElements;if(s.has(h))for(const p of f){r[h]||(r[h]=[]);const T=p.value;r[h].push(T)}else for(const p of f){const T=p.value;this.itemsByFloor[T]=h}}for(const l in r){const d=this.itemsByFloor[l];if(d!==void 0){const u=r[l];for(const h of u)this.itemsByFloor[h]=d}}for(let l=0;l<n;l++){const d=o.get(l),u=t.GetLine(0,d);if(!u||!u.RelatingObject||!u.RelatedObjects)continue;const h=u.RelatingObject.value,f=u.RelatedObjects;for(const p of f){const T=p.value,m=this.itemsByFloor[h];m!==void 0&&(this.itemsByFloor[T]=m)}}}catch{console.log("Could not get floors.")}}cleanUp(){this.itemsByFloor={}}}class zi{constructor(){E(this,"includeProperties",!0),E(this,"optionalCategories",[Jt]),E(this,"coordinate",!0),E(this,"wasm",{path:"",absolute:!1,logLevel:Go.LOG_LEVEL_OFF}),E(this,"excludedCategories",new Set),E(this,"saveLocations",!1),E(this,"webIfc",{COORDINATE_TO_ORIGIN:!0,OPTIMIZE_PROFILES:!0}),E(this,"autoSetWasm",!0),E(this,"customLocateFileHandler",null)}}class lo{constructor(){E(this,"defLineMat",new xn({color:16777215}))}read(t){const e=t.GetAllAlignments(0),s=t.GetAllCrossSections2D(0),i=t.GetAllCrossSections3D(0),o={IfcAlignment:e,IfcCrossSection2D:s,IfcCrossSection3D:i};return this.get(o)}get(t){if(t.IfcAlignment){const e=new Map;for(const s of t.IfcAlignment){const i=new Vo;i.absolute=this.getCurves(s.curve3D,i),i.horizontal=this.getCurves(s.horizontal,i),i.vertical=this.getCurves(s.vertical,i),e.set(e.size,i)}return{alignments:e,coordinationMatrix:new W}}}getCurves(t,e){const s=[];let i=0;for(const o of t){const n={};if(o.data)for(const h of o.data){const[f,p]=h.split(": "),T=parseFloat(p);n[f]=T||p}const{points:r}=o,a=new Float32Array(r.length*3);for(let h=0;h<r.length;h++){const{x:f,y:p,z:T}=r[h];a[h*3]=f,a[h*3+1]=p,a[h*3+2]=T||0}const l=new Ve(a,3),d=new Ho;d.setAttribute("position",l);const u=new ko(i,n,e,d,this.defLineMat);s.push(u.curve),i++}return s}}class ho{getNameInfo(t){var e;const s={},{arguments:i}=t.GetHeaderLine(0,Wo)||{};if(!i)return s;const[o,n,r,a,l,d,u]=i;if(o!=null&&o.value&&(s.name=o.value),n!=null&&n.value&&(s.creationDate=new Date(n.value)),r){s.author={};const[h,f]=r;h!=null&&h.value&&(s.author.name=h.value),f!=null&&f.value&&(s.author.email=f.value)}return(e=a[0])!=null&&e.value&&(s.organization=a[0].value),l!=null&&l.value&&(s.preprocessorVersion=l==null?void 0:l.value),d!=null&&d.value&&(s.originatingSystem=d==null?void 0:d.value),u!=null&&u.value&&(s.authorization=u==null?void 0:u.value),s}getDescriptionInfo(t){var e;const s={},{arguments:i}=t.GetHeaderLine(0,Xo)||{};if(!i)return s;const[o,n]=i;if((e=o[0])!=null&&e.value){const r=o[0].value.match(/\[([^\]]+)\]/);r[1]&&(s.viewDefinition=r[1])}return n!=null&&n.value&&(s.implementationLevel=n.value),s}}const uo=class pi extends ${constructor(t){super(t),E(this,"onIfcStartedLoading",new M),E(this,"onSetup",new M),E(this,"onDisposed",new M),E(this,"settings",new zi),E(this,"enabled",!0),E(this,"webIfc",new zt),E(this,"_material",new Hi),E(this,"_spatialTree",new co),E(this,"_metaData",new ho),E(this,"_fragmentInstances",new Map),E(this,"_civil",new lo),E(this,"_visitedFragments",new Map),E(this,"_materialT",new Hi({transparent:!0,opacity:.5})),this.components.add(pi.uuid,this),this.settings.excludedCategories.add(Dn)}dispose(){this.webIfc=null,this.onDisposed.trigger(pi.uuid),this.onDisposed.reset()}async setup(t){this.settings={...this.settings,...t},this.settings.autoSetWasm&&await this.autoSetWasm(),this.onSetup.trigger()}async load(t,e=!0){const s=performance.now();this.onIfcStartedLoading.trigger(),await this.readIfcFile(t);const i=await this.getAllGeometries(),n=await this.components.get(Za).export(this.webIfc,0);i.setLocalProperties(n),this.cleanUp();const r=this.components.get(Pt);r.groups.set(i.uuid,i);for(const a of i.items)r.list.set(a.id,a),a.mesh.uuid=a.id,a.group=i;return r.onFragmentsLoaded.trigger(i),e&&r.coordinate([i]),console.log(`Streaming the IFC took ${performance.now()-s} ms!`),i}async readIfcFile(t){const{path:e,absolute:s,logLevel:i}=this.settings.wasm;return this.webIfc.SetWasmPath(e,s),await this.webIfc.Init(),i&&this.webIfc.SetLogLevel(i),this.webIfc.OpenModel(t,this.settings.webIfc)}async getAllGeometries(){this._spatialTree.setUp(this.webIfc);const t=this.webIfc.GetIfcEntityList(0),e=new Un;e.ifcMetadata={name:"",description:"",...this._metaData.getNameInfo(this.webIfc),...this._metaData.getDescriptionInfo(this.webIfc),schema:this.webIfc.GetModelSchema(0)||"IFC2X3",maxExpressID:this.webIfc.GetMaxExpressID(0)};const s=[];for(const o of t){if(!this.webIfc.IsIfcElement(o)&&o!==Jt||this.settings.excludedCategories.has(o))continue;const n=this.webIfc.GetLineIDsWithType(0,o),r=n.size();for(let a=0;a<r;a++){const l=n.get(a);s.push(l);const d=this._spatialTree.itemsByFloor[l]||0;e.data.set(l,[[],[d,o]])}}this._spatialTree.cleanUp(),this.webIfc.StreamMeshes(0,s,o=>{this.getMesh(o,e)});for(const o of this._visitedFragments){const{index:n,fragment:r}=o[1];e.keyFragments.set(n,r.id)}for(const o of e.items){const n=this._fragmentInstances.get(o.id);if(!n)throw new Error("Fragment not found!");const r=[];for(const[a,l]of n)r.push(l);o.add(r)}const i=this.webIfc.GetCoordinationMatrix(0);return e.coordinationMatrix.fromArray(i),e.civilData=this._civil.read(this.webIfc),e}cleanUp(){this.webIfc=null,this.webIfc=new zt,this._visitedFragments.clear(),this._fragmentInstances.clear()}getMesh(t,e){const s=t.geometries.size(),i=t.expressID;for(let o=0;o<s;o++){const n=t.geometries.get(o),{x:r,y:a,z:l,w:d}=n.color,u=d!==1,{geometryExpressID:h}=n,f=`${h}-${u}`;if(!this._visitedFragments.has(f)){const I=this.getGeometry(this.webIfc,h),A=u?this._materialT:this._material,F=new bo(I,A,1);e.add(F.mesh),e.items.push(F);const _=this._visitedFragments.size;this._visitedFragments.set(f,{index:_,fragment:F})}const p=new $t().setRGB(r,a,l,"srgb"),T=new W;T.fromArray(n.flatTransformation);const m=this._visitedFragments.get(f);if(m===void 0)throw new Error("Error getting geometry data for streaming!");const C=e.data.get(i);if(!C)throw new Error("Data not found!");C[0].push(m.index);const{fragment:R}=m;this._fragmentInstances.has(R.id)||this._fragmentInstances.set(R.id,new Map);const g=this._fragmentInstances.get(R.id);if(!g)throw new Error("Instances not found!");if(g.has(i)){const I=g.get(i);if(!I)throw new Error("Instance not found!");I.transforms.push(T),I.colors&&I.colors.push(p)}else g.set(i,{id:i,transforms:[T],colors:[p]})}}getGeometry(t,e){const s=t.GetGeometry(0,e),i=t.GetIndexArray(s.GetIndexData(),s.GetIndexDataSize()),o=t.GetVertexArray(s.GetVertexData(),s.GetVertexDataSize()),n=new Float32Array(o.length/2),r=new Float32Array(o.length/2);for(let u=0;u<o.length;u+=6)n[u/2]=o[u],n[u/2+1]=o[u+1],n[u/2+2]=o[u+2],r[u/2]=o[u+3],r[u/2+1]=o[u+4],r[u/2+2]=o[u+5];const a=new Ge,l=new Ve(n,3),d=new Ve(r,3);return a.setAttribute("position",l),a.setAttribute("normal",d),a.setIndex(Array.from(i)),s.delete(),a}async autoSetWasm(){const t=await fetch(`https://unpkg.com/openbim-components@${Ta.release}/package.json`);if(!t.ok){console.warn("Couldn't get openbim-components package.json. Set wasm settings manually.");return}const e=await t.json();if(!("web-ifc"in e.peerDependencies))console.warn("Couldn't get web-ifc from peer dependencies in openbim-components. Set wasm settings manually.");else{const s=e.peerDependencies["web-ifc"];this.settings.wasm.path=`https://unpkg.com/web-ifc@${s}/`,this.settings.wasm.absolute=!0}}};E(uo,"uuid","a659add7-1418-4771-a0d6-7d4d438e4624");let qa=uo;const $a=class Ie extends ${constructor(t){super(t),E(this,"onDisposed",new M),E(this,"onRequestFile",new M),E(this,"ifcToExport",null),E(this,"onElementToPset",new M),E(this,"onPropToPset",new M),E(this,"onPsetRemoved",new M),E(this,"onDataChanged",new M),E(this,"wasm",{path:"/",absolute:!1}),E(this,"enabled",!0),E(this,"attributeListeners",{}),E(this,"selectedModel"),E(this,"changeMap",{}),this.components.add(Ie.uuid,this)}dispose(){this.selectedModel=void 0,this.attributeListeners={},this.changeMap={},this.onElementToPset.reset(),this.onPropToPset.reset(),this.onPsetRemoved.reset(),this.onDataChanged.reset(),this.onDisposed.trigger(Ie.uuid),this.onDisposed.reset()}increaseMaxID(t){return t.ifcMetadata.maxExpressID++,t.ifcMetadata.maxExpressID}static getIFCSchema(t){const e=t.ifcMetadata.schema;if(!e)throw new Error("IFC Schema not found");return e}newGUID(t){const e=Ie.getIFCSchema(t);return new Nt[e].IfcGloballyUniqueId(bi.create())}async getOwnerHistory(t){const e=await t.getAllPropertiesOfType(vo);if(!e)throw new Error("No OwnerHistory was found.");const s=Object.keys(e).map(n=>parseInt(n,10)),i=e[s[0]],o=new Qe(i.expressID);return{ownerHistory:i,ownerHistoryHandle:o}}registerChange(t,...e){this.changeMap[t.uuid]||(this.changeMap[t.uuid]=new Set);for(const s of e)this.changeMap[t.uuid].add(s),this.onDataChanged.trigger({model:t,expressID:s})}async setData(t,...e){for(const s of e){const i=s.expressID;i&&(await t.setProperties(i,s),this.registerChange(t,i))}}async newPset(t,e,s){const i=Ie.getIFCSchema(t),{ownerHistoryHandle:o}=await this.getOwnerHistory(t),n=this.newGUID(t),r=new Nt[i].IfcLabel(e),a=s?new Nt[i].IfcText(s):null,l=new Nt[i].IfcPropertySet(n,o,r,a,[]);l.expressID=this.increaseMaxID(t);const d=this.newGUID(t),u=new Nt[i].IfcRelDefinesByProperties(d,o,null,null,[],new Qe(l.expressID));return u.expressID=this.increaseMaxID(t),await this.setData(t,l,u),{pset:l,rel:u}}async removePset(t,...e){for(const s of e){const i=await t.getProperties(s);if((i==null?void 0:i.type)!==ei)continue;const o=await Yt.getPsetRel(t,s);if(o&&(await t.setProperties(o,null),this.registerChange(t,o)),i){for(const n of i.HasProperties)await t.setProperties(n.value,null);await t.setProperties(s,null),this.onPsetRemoved.trigger({model:t,psetID:s}),this.registerChange(t,s)}}}async newSingleProperty(t,e,s,i){const o=Ie.getIFCSchema(t),n=new Nt[o].IfcIdentifier(s),r=new Nt[o][e](i),a=new Nt[o].IfcPropertySingleValue(n,null,r,null);return a.expressID=this.increaseMaxID(t),await this.setData(t,a),a}newSingleStringProperty(t,e,s,i){return this.newSingleProperty(t,e,s,i)}newSingleNumericProperty(t,e,s,i){return this.newSingleProperty(t,e,s,i)}newSingleBooleanProperty(t,e,s,i){return this.newSingleProperty(t,e,s,i)}async removePsetProp(t,e,s){const i=await t.getProperties(e),o=await t.getProperties(s);!i||!o||i.type===ei&&o&&(i.HasProperties=i.HasProperties.filter(n=>n.value!==s),await t.setProperties(s,null),this.registerChange(t,e,s))}async addElementToPset(t,e,...s){const i=await Yt.getPsetRel(t,e);if(!i)return;const o=await t.getProperties(i);if(o){for(const n of s){const r=new Qe(n);o.RelatedObjects.push(r),this.onElementToPset.trigger({model:t,psetID:e,elementID:n})}this.registerChange(t,e)}}async addPropToPset(t,e,...s){const i=await t.getProperties(e);if(i){for(const o of s){if(i.HasProperties.includes(o))continue;const n=new Qe(o);i.HasProperties.push(n),this.onPropToPset.trigger({model:t,psetID:e,propID:o})}this.registerChange(t,e)}}async saveToIfc(t,e){const s=this.components.get(qa),i=s.webIfc,o=await s.readIfcFile(e),n=this.changeMap[t.uuid]??[];for(const a of n){const l=await t.getProperties(a);if(l)try{i.WriteLine(o,l)}catch{}else try{i.DeleteLine(o,a)}catch{}}const r=i.SaveModel(o);return s.webIfc.CloseModel(o),s.cleanUp(),r}async setAttributeListener(t,e,s){this.attributeListeners[t.uuid]||(this.attributeListeners[t.uuid]={});const i=this.attributeListeners[t.uuid][e]?this.attributeListeners[t.uuid][e][s]:null;if(i)return i;const o=await t.getProperties(e);if(!o)throw new Error(`Entity with expressID ${e} doesn't exists.`);const n=o[s];if(Array.isArray(n)||!n)throw new Error(`Attribute ${s} is array or null, and it can't have a listener.`);const r=n.value;if(r===void 0||r==null)throw new Error(`Attribute ${s} has a badly defined handle.`);const a=new M;return Object.defineProperty(o[s],"value",{get(){return this._value},async set(l){this._value=l,a.trigger(l)}}),o[s].value=r,this.attributeListeners[t.uuid][e]||(this.attributeListeners[t.uuid][e]={}),this.attributeListeners[t.uuid][e][s]=a,a}};E($a,"uuid","58c2d9f0-183c-48d6-a402-dfcf5b9a34df");const Eo=class fo extends ${constructor(t){super(t),E(this,"enabled",!0),E(this,"list",{}),E(this,"onDisposed",new M),E(this,"onFragmentsDisposed",s=>{const{groupID:i,fragmentIDs:o}=s;for(const n in this.list){const r=this.list[n],a=Object.keys(r);if(a.includes(i))delete r[i],Object.values(r).length===0&&delete this.list[n];else for(const l of a){const d=r[l];for(const u of o)delete d[u];Object.values(d).length===0&&delete r[l]}}}),t.add(fo.uuid,this),t.get(Pt).onFragmentsDisposed.add(this.onFragmentsDisposed)}dispose(){this.list={},this.components.get(Pt).onFragmentsDisposed.remove(this.onFragmentsDisposed),this.onDisposed.trigger(),this.onDisposed.reset()}remove(t){for(const e in this.list){const s=this.list[e];for(const i in s){const o=s[i];delete o[t]}}}find(t){const e=this.components.get(Pt);if(!t){const n={};for(const[r,a]of e.list)n[r]=new Set(a.ids);return n}const s=Object.keys(t).length,i={};for(const n in t){const r=t[n];if(!this.list[n]){console.warn(`Classification ${n} does not exist.`);continue}for(const a of r){const l=this.list[n][a];if(l)for(const d in l){i[d]||(i[d]=new Map);for(const u of l[d]){const h=i[d].get(u);h===void 0?i[d].set(u,1):i[d].set(u,h+1)}}}}const o={};for(const n in i){const r=i[n];for(const[a,l]of r){if(l===void 0)throw new Error("Malformed fragments map!");l===s&&(o[n]||(o[n]=new Set),o[n].add(a))}}return o}byModel(t,e){this.list.models||(this.list.models={});const s=this.list.models;s[t]||(s[t]={});const i=s[t];for(const[o,n]of e.data){const r=n[0];for(const a of r){const l=e.keyFragments.get(a);l&&(i[l]||(i[l]=new Set),i[l].add(o))}}}async byPredefinedType(t){var e;this.list.predefinedTypes||(this.list.predefinedTypes={});const s=this.list.predefinedTypes,i=t.getAllPropertiesIDs();for(const o of i){const n=await t.getProperties(o);if(!n)continue;const r=String((e=n.PredefinedType)==null?void 0:e.value).toUpperCase();s[r]||(s[r]={});const a=s[r];for(const[l,d]of t.data){const u=d[0];for(const h of u){const f=t.keyFragments.get(h);if(!f)throw new Error("Fragment ID not found!");a[f]||(a[f]=new Set),a[f].add(n.expressID)}}}}byEntity(t){this.list.entities||(this.list.entities={});for(const[e,s]of t.data){const o=s[1][1],n=ro[o];this.saveItem(t,"entities",n,e)}}async byIfcRel(t,e,s){Yt.isRel(e)&&await Yt.getRelationMap(t,e,async(i,o)=>{const{name:n}=await Yt.getEntityName(t,i);for(const r of o)this.saveItem(t,s,n??"NO REL NAME",r)})}async bySpatialStructure(t){var e;const s=this.components.get(Yi),i=s.relationMaps[t.uuid];if(!i)throw new Error(`Classifier: model relations of ${t.name||t.uuid} have to exists to group by spatial structure.`);const o="spatialStructures";for(const[n]of i){const r=s.getEntityRelations(t,n,"ContainsElements"),a=await t.getProperties(n);if(!(r&&a))continue;const l=(e=a.Name)==null?void 0:e.value;for(const d of r){this.saveItem(t,o,l,d);const u=s.getEntityRelations(t,Number(d),"IsDecomposedBy");if(u)for(const h of u)this.saveItem(t,o,l,h)}}}setColor(t,e,s=!1){const i=this.components.get(Pt);for(const o in t){const n=i.list.get(o);if(!n)continue;const r=t[o];n.setColor(e,r,s)}}resetColor(t){const e=this.components.get(Pt);for(const s in t){const i=e.list.get(s);if(!i)continue;const o=t[s];i.resetColor(o)}}saveItem(t,e,s,i){this.list[e]||(this.list[e]={});const o=t.data.get(i);if(o)for(const n of o[0]){const r=t.keyFragments.get(n);if(r){const a=this.list[e];a[s]||(a[s]={}),a[s][r]||(a[s][r]=new Set),a[s][r].add(i)}}}};E(Eo,"uuid","e25a7f3c-46c4-4a14-9d3d-5115f24ebeb7");let Ka=Eo;const Io=class po extends ${constructor(t){super(t),E(this,"enabled",!0),E(this,"height",10),E(this,"groupName","storeys"),E(this,"onDisposed",new M),E(this,"list",new Set),t.add(po.uuid,this)}dispose(){this.list.clear(),this.onDisposed.trigger(),this.onDisposed.reset()}set(t){if(!this.enabled)return;const e=this.components.get(Ka),s=this.components.get(Pt),i=t?1:-1;let o=0;const n=e.list[this.groupName],r=new W;for(const a in n){r.elements[13]=o*i*this.height;for(const l in n[a]){const d=s.list.get(l),u=a+l,h=this.list.has(u);if(!d||t&&h||!t&&!h)continue;t?this.list.add(u):this.list.delete(u);const f=n[a][l];d.applyTransform(f,r)}o++}}};E(Io,"uuid","d260618b-ce88-4c7d-826c-6debb91de3e2");let dc=Io;const Co=class To extends ${constructor(t){super(t),E(this,"enabled",!0),this.components.add(To.uuid,this)}set(t,e){const s=this.components.get(Pt);if(!e){for(const i in s.list){const o=s.list.get(i);o&&(o.setVisibility(t),this.updateCulledVisibility(o))}return}for(const i in e){const o=e[i],n=s.list.get(i);n&&(n.setVisibility(t,o),this.updateCulledVisibility(n))}}isolate(t){this.set(!1),this.set(!0,t)}updateCulledVisibility(t){const e=this.components.get(Ga);for(const[s,i]of e.list){const o=i.colorMeshes.get(t.id);o&&(o.count=t.mesh.count)}}};E(Co,"uuid","dd9ccf2d-8a21-4821-b7f6-2949add16a29");let uc=Co;class Ja extends zi{constructor(){super(...arguments),E(this,"minGeometrySize",10),E(this,"minAssetsSize",1e3)}}class mo extends zi{constructor(){super(...arguments),E(this,"propertiesSize",100)}}class tc extends ${constructor(){super(...arguments),E(this,"onPropertiesStreamed",new Kt),E(this,"onProgress",new Kt),E(this,"onIndicesStreamed",new Kt),E(this,"onDisposed",new M),E(this,"enabled",!0),E(this,"settings",new mo),E(this,"webIfc",new zt)}async dispose(){this.onIndicesStreamed.reset(),this.onPropertiesStreamed.reset(),this.webIfc=null,this.onDisposed.reset()}async streamFromBuffer(t){const e=performance.now();await this.readIfcFile(t),await this.streamAllProperties(),this.cleanUp(),console.log(`Streaming the IFC took ${performance.now()-e} ms!`)}async streamFromCallBack(t){const e=performance.now();await this.streamIfcFile(t),await this.streamAllProperties(),this.cleanUp(),console.log(`Streaming the IFC took ${performance.now()-e} ms!`)}async readIfcFile(t){const{path:e,absolute:s,logLevel:i}=this.settings.wasm;this.webIfc.SetWasmPath(e,s),await this.webIfc.Init(),i&&this.webIfc.SetLogLevel(i),this.webIfc.OpenModel(t,this.settings.webIfc)}async streamIfcFile(t){const{path:e,absolute:s,logLevel:i}=this.settings.wasm;this.webIfc.SetWasmPath(e,s),await this.webIfc.Init(),i&&this.webIfc.SetLogLevel(i),this.webIfc.OpenModelFromCallback(t,this.settings.webIfc)}async streamAllProperties(){const{propertiesSize:t}=this.settings,e=new Set(this.webIfc.GetIfcEntityList(0)),s=[Ss,_i,Ai,ys,gi,Fi],i=new Map,o=new Set([Oi,Si,yi,Pi,Jt]);for(const l of o)e.add(l);let n=.01,r=0;for(const l of e){if(r++,Bi.has(l))continue;const d=o.has(l),u=this.webIfc.GetLineIDsWithType(0,l),h=u.size();let f=0;for(let T=0;T<h-t;T+=t){const m={};for(let C=0;C<t;C++){f++;const R=u.get(T+C);try{const g=this.webIfc.GetLine(0,R,d);s.includes(l)&&this.getIndices(g,R,i),m[g.expressID]=g}catch{console.log(`Could not get property: ${R}`)}}await this.onPropertiesStreamed.trigger({type:l,data:m})}if(f!==h){const T={};for(let m=f;m<h;m++){const C=u.get(m);try{const R=this.webIfc.GetLine(0,C,d);s.includes(l)&&this.getIndices(R,C,i),T[R.expressID]=R}catch{console.log(`Could not get property: ${C}`)}}await this.onPropertiesStreamed.trigger({type:l,data:T})}const p=r/e.size;p>n&&(n+=.01,n=Math.max(n,p),await this.onProgress.trigger(Math.round(n*100)/100))}const a=[];for(const[l,d]of i)a.push([l,...d]);await this.onIndicesStreamed.trigger(a)}getIndices(t,e,s){const i=t.RelatedObjects||t.RelatedElements;if(!i){console.log(`Related objects not found: ${e}`);return}const o=t.RelatingType||t.RelatingMaterial||t.RelatingStructure||t.RelatingPropertyDefinition||t.RelatingGroup||t.RelatingClassification;if(!o){console.log(`Relating object not found: ${e}`);return}if(!Array.isArray(i)||o.value===void 0)return;const n=o.value;for(const r of i){if(r.value===void 0||r.value===null)continue;const a=r.value;s.has(a)||s.set(a,new Set),s.get(a).add(n)}}cleanUp(){this.webIfc=null,this.webIfc=new zt}}E(tc,"uuid","88d2c89c-ce32-47d7-8cb6-d51e4b311a0b");const Ro=class Ao extends ${constructor(t){super(t),E(this,"onGeometryStreamed",new M),E(this,"onAssetStreamed",new M),E(this,"onProgress",new M),E(this,"onIfcLoaded",new M),E(this,"onDisposed",new M),E(this,"settings",new Ja),E(this,"enabled",!0),E(this,"webIfc",new zt),E(this,"_spatialTree",new co),E(this,"_metaData",new ho),E(this,"_visitedGeometries",new Map),E(this,"_streamSerializer",new Bo),E(this,"_geometries",new Map),E(this,"_geometryCount",0),E(this,"_civil",new lo),E(this,"_groupSerializer",new Ln),E(this,"_assets",[]),E(this,"_meshesWithHoles",new Set),this.components.add(Ao.uuid,this),this.settings.excludedCategories.add(Dn)}dispose(){this.onIfcLoaded.reset(),this.onGeometryStreamed.reset(),this.onAssetStreamed.reset(),this.webIfc=null,this.onDisposed.trigger(),this.onDisposed.reset()}async streamFromBuffer(t){const e=performance.now();await this.readIfcFile(t),await this.streamAllGeometries(),this.cleanUp(),console.log(`Streaming the IFC took ${performance.now()-e} ms!`)}async streamFromCallBack(t){const e=performance.now();await this.streamIfcFile(t),await this.streamAllGeometries(),this.cleanUp(),console.log(`Streaming the IFC took ${performance.now()-e} ms!`)}async readIfcFile(t){const{path:e,absolute:s,logLevel:i}=this.settings.wasm;this.webIfc.SetWasmPath(e,s),await this.webIfc.Init(),i&&this.webIfc.SetLogLevel(i),this.webIfc.OpenModel(t,this.settings.webIfc)}async streamIfcFile(t){const{path:e,absolute:s,logLevel:i}=this.settings.wasm;this.webIfc.SetWasmPath(e,s),await this.webIfc.Init(),i&&this.webIfc.SetLogLevel(i),this.webIfc.OpenModelFromCallback(t,this.settings.webIfc)}async streamAllGeometries(){const{minGeometrySize:t,minAssetsSize:e}=this.settings;this._spatialTree.setUp(this.webIfc);const s=this.webIfc.GetIfcEntityList(0),i=[[]],o=new Un;o.ifcMetadata={name:"",description:"",...this._metaData.getNameInfo(this.webIfc),...this._metaData.getDescriptionInfo(this.webIfc),schema:this.webIfc.GetModelSchema(0)||"IFC2X3",maxExpressID:this.webIfc.GetMaxExpressID(0)};let n=0,r=0;for(const T of s){if(!this.webIfc.IsIfcElement(T)&&T!==Jt||this.settings.excludedCategories.has(T))continue;const m=this.webIfc.GetLineIDsWithType(0,T),C=m.size();for(let R=0;R<C;R++){n>t&&(n=0,r++,i.push([]));const g=m.get(R);i[r].push(g);const I=this._spatialTree.itemsByFloor[g]||0;o.data.set(g,[[],[I,T]]),n++}}this._spatialTree.cleanUp();let a=.01,l=0;for(const T of i){l++,this.webIfc.StreamMeshes(0,T,C=>{this.getMesh(this.webIfc,C,o)}),this._geometryCount>t&&await this.streamGeometries(),this._assets.length>e&&await this.streamAssets();const m=l/i.length;m>a&&(a+=.01,a=Math.max(a,m),this.onProgress.trigger(Math.round(a*100)/100))}this._geometryCount&&await this.streamGeometries(),this._assets.length&&await this.streamAssets();const{opaque:d,transparent:u}=o.geometryIDs;for(const[T,{index:m,uuid:C}]of this._visitedGeometries)o.keyFragments.set(m,C),(T>1?d:u).set(T,m);const h=o.data.keys();for(const T of h){const[m]=o.data.get(T);m.length||o.data.delete(T)}const f=this.webIfc.GetCoordinationMatrix(0);o.coordinationMatrix.fromArray(f),o.civilData=this._civil.read(this.webIfc);const p=this._groupSerializer.export(o);this.onIfcLoaded.trigger(p),o.dispose(!0)}cleanUp(){this.webIfc=null,this.webIfc=new zt,this._visitedGeometries.clear(),this._geometries.clear(),this._assets=[],this._meshesWithHoles.clear()}getMesh(t,e,s){const i=e.geometries.size(),o=e.expressID,n={id:o,geometries:[]};for(let r=0;r<i;r++){const a=e.geometries.get(r),l=a.geometryExpressID,d=a.color.w===1?1:-1,u=l*d;if(!this._visitedGeometries.has(u)){this._visitedGeometries.has(l)||this.getGeometry(t,l);const I=this._visitedGeometries.size,A=wn.generateUUID();this._visitedGeometries.set(u,{uuid:A,index:I})}const h=this._visitedGeometries.get(u);if(h===void 0)throw new Error("Error getting geometry data for streaming!");const f=s.data.get(o);if(!f)throw new Error("Data not found!");f[0].push(h.index);const{x:p,y:T,z:m,w:C}=a.color,R=[p,T,m,C],g=a.flatTransformation;n.geometries.push({color:R,geometryID:l,transformation:g})}this._assets.push(n)}getGeometry(t,e){const s=t.GetGeometry(0,e),i=t.GetIndexArray(s.GetIndexData(),s.GetIndexDataSize()),o=t.GetVertexArray(s.GetVertexData(),s.GetVertexDataSize()),n=new Float32Array(o.length/2),r=new Float32Array(o.length/2);for(let h=0;h<o.length;h+=6)n[h/2]=o[h],n[h/2+1]=o[h+1],n[h/2+2]=o[h+2],r[h/2]=o[h+3],r[h/2+1]=o[h+4],r[h/2+2]=o[h+5];const a=pa(n),l=new Float32Array(a.transformation.elements),d=[a.center.x,a.center.y,a.center.z];let u=!1;for(let h=0;h<n.length-2;h+=3){const f=n[h],p=n[h+1],T=n[h+2],m=r[h],C=r[h+1],R=r[h+2];if(Ca(d,[f,p,T],[m,C,R])){u=!0;break}}this._geometries.set(e,{position:n,normal:r,index:i,boundingBox:l,hasHoles:u}),s.delete(),this._geometryCount++}async streamAssets(){await this.onAssetStreamed.trigger(this._assets),this._assets=null,this._assets=[]}async streamGeometries(){let t=this._streamSerializer.export(this._geometries),e={};for(const[s,{boundingBox:i,hasHoles:o}]of this._geometries)e[s]={boundingBox:i,hasHoles:o};this.onGeometryStreamed.trigger({data:e,buffer:t}),e=null,t=null,this._geometries.clear(),this._geometryCount=0}};E(Ro,"uuid","d9999a00-e1f5-4d3f-8cfe-c56e08609764");let Ec=Ro;class ec extends ${constructor(){super(...arguments),E(this,"onPropertiesStreamed",new Kt),E(this,"onProgress",new Kt),E(this,"onIndicesStreamed",new Kt),E(this,"onDisposed",new M),E(this,"enabled",!0),E(this,"settings",new mo),E(this,"webIfc",new zt)}async dispose(){this.onIndicesStreamed.reset(),this.onPropertiesStreamed.reset(),this.webIfc=null,this.onDisposed.reset()}async streamFromBuffer(t){const e=performance.now();await this.readIfcFile(t),await this.streamAllProperties(),this.cleanUp(),console.log(`Streaming the IFC took ${performance.now()-e} ms!`)}async streamFromCallBack(t){const e=performance.now();await this.streamIfcFile(t),await this.streamAllProperties(),this.cleanUp(),console.log(`Streaming the IFC took ${performance.now()-e} ms!`)}async readIfcFile(t){const{path:e,absolute:s,logLevel:i}=this.settings.wasm;this.webIfc.SetWasmPath(e,s),await this.webIfc.Init(),i&&this.webIfc.SetLogLevel(i),this.webIfc.OpenModel(t,this.settings.webIfc)}async streamIfcFile(t){const{path:e,absolute:s,logLevel:i}=this.settings.wasm;this.webIfc.SetWasmPath(e,s),await this.webIfc.Init(),i&&this.webIfc.SetLogLevel(i),this.webIfc.OpenModelFromCallback(t,this.settings.webIfc)}async streamAllProperties(){const{propertiesSize:t}=this.settings,e=new Set(this.webIfc.GetIfcEntityList(0)),s=new Set([Oi,Si,yi,Pi,Jt]);for(const a of s)e.add(a);let i=.01,o=0;for(const a of e){if(o++,Bi.has(a))continue;const l=s.has(a),d=this.webIfc.GetLineIDsWithType(0,a),u=d.size();let h=0;for(let p=0;p<u-t;p+=t){const T={};for(let m=0;m<t;m++){h++;const C=d.get(p+m);try{const R=this.webIfc.GetLine(0,C,l);T[R.expressID]=R}catch{console.log(`Could not get property: ${C}`)}}await this.onPropertiesStreamed.trigger({type:a,data:T})}if(h!==u){const p={};for(let T=h;T<u;T++){const m=d.get(T);try{const C=this.webIfc.GetLine(0,m,l);p[C.expressID]=C}catch{console.log(`Could not get property: ${m}`)}}await this.onPropertiesStreamed.trigger({type:a,data:p})}const f=o/e.size;f>i&&(i+=.01,i=Math.max(i,f),await this.onProgress.trigger(Math.round(i*100)/100))}const r=await this.components.get(Yi).processFromWebIfc(this.webIfc,0);await this.onIndicesStreamed.trigger(r)}cleanUp(){this.webIfc=null,this.webIfc=new zt}}E(ec,"uuid","88d2c89c-ce32-47d7-8cb6-d51e4b311a0b");const go=class Fo extends ${constructor(t){super(t),E(this,"enabled",!0),t.add(Fo.uuid,this)}getFace(t,e,s){if(!t.geometry.index)throw new Error("Geometry must be indexed!");const i=new Map,o=t.geometry.index.array,{plane:n}=this.getFaceData(e,s,t),r=[];for(let u=0;u<o.length/3;u++){const{plane:h,edges:f}=this.getFaceData(u,s,t);if(h.equals(n)){r.push({index:u,edges:f});for(const{id:p,points:T,distance:m}of f)i.set(p,{points:T,distance:m})}}let a=0;const l=new Map,d=new Map;for(const{index:u,edges:h}of r){const f=new Map;for(const{id:I}of h)if(l.has(I)){const A=l.get(I);f.set(I,A)}const p=h.map(I=>I.id);if(!f.size){const I=a++;for(const{id:A}of h)l.set(A,I);d.set(I,{edges:new Set(p),indices:new Set([u])});continue}let T=null;const m=new Set,C=new Set(p);for(const[I,A]of f){T===null?T=A:A!==T&&m.add(A),l.delete(I);const{edges:F}=d.get(A);F.delete(I),C.delete(I)}if(T===null)throw new Error("Error computing face!");const R=d.get(T),{indices:g}=R;g.add(u);for(const I of C){l.set(I,T);const{edges:A}=R;A.add(I)}for(const I of m){const A=d.get(I),{edges:F,indices:_}=A,S=d.get(T),{edges:y,indices:N}=S;for(const L of F)y.add(L),l.set(L,T);for(const L of _)N.add(L);d.delete(I)}}for(const[u,{indices:h,edges:f}]of d)if(h.has(e)){const p=[];for(const T of f){const m=i.get(T);p.push(m)}return{edges:p,indices:h}}return null}static distanceFromPointToLine(t,e,s,i=!1){const o=new At,n=new O;return o.set(e,s),o.closestPointToPoint(t,i,n),n.distanceTo(t)}getFaceData(t,e,s){const i=this.getVerticesAndNormal(s,t,e),{p1:o,p2:n,p3:r,faceNormal:a}=i;this.round(o),this.round(n),this.round(r),this.round(a);const l=[{id:`${o.x}|${o.y}|${o.z}`,value:o},{id:`${n.x}|${n.y}|${n.z}`,value:n},{id:`${r.x}|${r.y}|${r.z}`,value:r}];l.sort((R,g)=>R.id<g.id?-1:R.id>g.id?1:0);const[{id:d,value:u},{id:h,value:f},{id:p,value:T}]=l,m=[{id:`${d}|${h}`,distance:u.distanceTo(f),points:[u,f]},{id:`${h}|${p}`,distance:f.distanceTo(T),points:[f,T]},{id:`${d}|${p}`,distance:u.distanceTo(T),points:[u,T]}],C=new Re;return C.setFromNormalAndCoplanarPoint(a,o),C.constant=Math.round(C.constant*10)/10,{plane:C,edges:m}}getVerticesAndNormal(t,e,s){if(!t.geometry.index)throw new Error("Geometry must be indexed!");const i=t.geometry.index.array,o=t.geometry.attributes.position.array,n=t.geometry.attributes.normal.array,r=i[e*3]*3,a=i[e*3+1]*3,l=i[e*3+2]*3,d=new O(o[r],o[r+1],o[r+2]),u=new O(o[a],o[a+1],o[a+2]),h=new O(o[l],o[l+1],o[l+2]),f=new O(n[r],n[r+1],n[r+2]),p=new O(n[a],n[a+1],n[a+2]),T=new O(n[l],n[l+1],n[l+2]),m=(f.x+p.x+T.x)/3,C=(f.y+p.y+T.y)/3,R=(f.z+p.z+T.z)/3,g=new O(m,C,R);if(s!==void 0&&t instanceof He){const I=new W;t.getMatrixAt(s,I);const A=new W;A.extractRotation(I),g.applyMatrix4(A),d.applyMatrix4(I),u.applyMatrix4(I),h.applyMatrix4(I)}return{p1:d,p2:u,p3:h,faceNormal:g}}round(t){t.x=Math.trunc(t.x*1e3)/1e3,t.y=Math.trunc(t.y*1e3)/1e3,t.z=Math.trunc(t.z*1e3)/1e3}};E(go,"uuid","267ca032-672f-4cb0-afa9-d24e904f39d6");let fc=go;export{hc as B,$ as C,me as D,M as E,Pt as F,rc as G,uc as H,Yi as I,fc as M,lc as O,ui as R,nc as S,ic as V,Sa as W,Ta as a,ke as b,oc as c,Ga as d,Ka as e,ac as f,qa as g,Aa as h,ro as i,Yt as j,Za as k,ec as l,Ec as m,dc as n,cc as o};
