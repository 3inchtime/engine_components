var j=Object.defineProperty;var W=(E,d,e)=>d in E?j(E,d,{enumerable:!0,configurable:!0,writable:!0,value:e}):E[d]=e;var P=(E,d,e)=>(W(E,typeof d!="symbol"?d+"":d,e),e);import{r as k,V as v,P as q,I as H,a as T,M as C,ap as J,L as K,s as O}from"./web-ifc-api-BiYij3qq.js";import{S as Q}from"./stats.min-GTpOrGrX.js";import{C as X,a as Y,W as Z,S as _,b as ee,c as te}from"./index-DsPLPeA6.js";import{R as ne}from"./index-D_3pJs_2.js";import{G as se}from"./index-GK9dObYT.js";import{C as oe}from"./index-BuSG1Eje.js";import{F as ae}from"./index-Ba8czaZS.js";import"./_commonjsHelpers-Cpj98o6Y.js";import"./async-event-D8tC9awa.js";const z=class z extends X{constructor(e){super(e);P(this,"enabled",!0);e.add(z.uuid,this)}getFace(e,g,w){if(!e.geometry.index)throw new Error("Geometry must be indexed!");const h=new Map,n=e.geometry.index.array,{plane:o}=this.getFaceData(g,w,e),i=[];for(let c=0;c<n.length/3;c++){const{plane:p,edges:a}=this.getFaceData(c,w,e);if(p.equals(o)){i.push({index:c,edges:a});for(const{id:u,points:s,distance:x}of a)h.set(u,{points:s,distance:x})}}let y=0;const r=new Map,m=new Map;for(const{index:c,edges:p}of i){const a=new Map;for(const{id:t}of p)if(r.has(t)){const f=r.get(t);a.set(t,f)}const u=p.map(t=>t.id);if(!a.size){const t=y++;for(const{id:f}of p)r.set(f,t);m.set(t,{edges:new Set(u),indices:new Set([c])});continue}let s=null;const x=new Set,I=new Set(u);for(const[t,f]of a){s===null?s=f:f!==s&&x.add(f),r.delete(t);const{edges:D}=m.get(f);D.delete(t),I.delete(t)}if(s===null)throw new Error("Error computing face!");const $=m.get(s),{indices:F}=$;F.add(c);for(const t of I){r.set(t,s);const{edges:f}=$;f.add(t)}for(const t of x){const f=m.get(t),{edges:D,indices:R}=f,B=m.get(s),{edges:V,indices:U}=B;for(const b of D)V.add(b),r.set(b,s);for(const b of R)U.add(b);m.delete(t)}}for(const[c,{indices:p,edges:a}]of m)if(p.has(g)){const u=[];for(const s of a){const x=h.get(s);u.push(x)}return{edges:u,indices:p}}return null}static distanceFromPointToLine(e,g,w,h=!1){const n=new k,o=new v;return n.set(g,w),n.closestPointToPoint(e,h,o),o.distanceTo(e)}getFaceData(e,g,w){const h=this.getVerticesAndNormal(w,e,g),{p1:n,p2:o,p3:i,faceNormal:y}=h;this.round(n),this.round(o),this.round(i),this.round(y);const r=[{id:`${n.x}|${n.y}|${n.z}`,value:n},{id:`${o.x}|${o.y}|${o.z}`,value:o},{id:`${i.x}|${i.y}|${i.z}`,value:i}];r.sort(($,F)=>$.id<F.id?-1:$.id>F.id?1:0);const[{id:m,value:c},{id:p,value:a},{id:u,value:s}]=r,x=[{id:`${m}|${p}`,distance:c.distanceTo(a),points:[c,a]},{id:`${p}|${u}`,distance:a.distanceTo(s),points:[a,s]},{id:`${m}|${u}`,distance:c.distanceTo(s),points:[c,s]}],I=new q;return I.setFromNormalAndCoplanarPoint(y,n),I.constant=Math.round(I.constant*10)/10,{plane:I,edges:x}}getVerticesAndNormal(e,g,w){if(!e.geometry.index)throw new Error("Geometry must be indexed!");const h=e.geometry.index.array,n=e.geometry.attributes.position.array,o=e.geometry.attributes.normal.array,i=h[g*3]*3,y=h[g*3+1]*3,r=h[g*3+2]*3,m=new v(n[i],n[i+1],n[i+2]),c=new v(n[y],n[y+1],n[y+2]),p=new v(n[r],n[r+1],n[r+2]),a=new v(o[i],o[i+1],o[i+2]),u=new v(o[y],o[y+1],o[y+2]),s=new v(o[r],o[r+1],o[r+2]),x=(a.x+u.x+s.x)/3,I=(a.y+u.y+s.y)/3,$=(a.z+u.z+s.z)/3,F=new v(x,I,$);if(!F.x&&!F.y&&!F.z&&console.log("hey"),w!==void 0&&e instanceof H){const t=new T;e.getMatrixAt(w,t);const f=new T;f.extractRotation(t),F.applyMatrix4(f),m.applyMatrix4(t),c.applyMatrix4(t),p.applyMatrix4(t)}return{p1:m,p2:c,p3:p,faceNormal:F}}round(e){e.x=Math.trunc(e.x*1e3)/1e3,e.y=Math.trunc(e.y*1e3)/1e3,e.z=Math.trunc(e.z*1e3)/1e3}};P(z,"uuid","267ca032-672f-4cb0-afa9-d24e904f39d6");let L=z;const re=document.getElementById("container"),M=new Y,ce=M.get(Z),l=ce.create();l.scene=new _(M);l.renderer=new ee(M,re);l.camera=new te(M);M.init();l.camera.controls.setLookAt(12,6,8,0,0,-10);l.scene.setup();const de=M.get(se);de.create(l);const ie=new ae(M),fe=await fetch("../../../../../resources/small.frag"),le=await fe.arrayBuffer(),ge=new Uint8Array(le),A=ie.load(ge);l.scene.three.add(A);const pe=M.get(oe),N=pe.create(l);for(const E of A.children)E instanceof C&&N.add(E);N.needsUpdate=!0;l.camera.controls.addEventListener("sleep",()=>{N.needsUpdate=!0});const ue=M.get(L),me=M.get(ne),we=me.get(l),G=new J,ye=new K({color:16711680,depthTest:!1}),he=new O(G,ye);l.scene.three.add(he);l.renderer&&l.renderer.three.domElement.addEventListener("mousemove",()=>{const d=we.castRay([A]);if(!d||!(d.object instanceof C)||d.faceIndex===void 0)return;const e=ue.getFace(d.object,d.faceIndex,d.instanceId);if(e){const g=[];for(const w of e.edges)g.push(...w.points);G.setFromPoints(g)}});const S=new Q;S.showPanel(2);document.body.append(S.dom);S.dom.style.left="0px";S.dom.style.right="auto";l.renderer.onBeforeUpdate.add(()=>S.begin());l.renderer.onAfterUpdate.add(()=>S.end());
