var W=Object.defineProperty;var q=(v,t,e)=>t in v?W(v,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):v[t]=e;var c=(v,t,e)=>(q(v,typeof t!="symbol"?t+"":t,e),e);import{f as O,z as j,r as H,V as D,P as J,I as K,a as R,M as V,ap as Q,L as Z,s as ee}from"./web-ifc-api-BC8YMRiS.js";import{S as te}from"./stats.min-GTpOrGrX.js";import{E as T,C as B,a as se,W as ne,S as oe,b as re,c as ie}from"./index-BY1If8xF.js";import{G as ae}from"./index-DE4WfR4J.js";import{C as ce}from"./index-Buo71ORv.js";import{F as de}from"./index-CqfCnTh7.js";import"./_commonjsHelpers-Cpj98o6Y.js";import"./async-event-D8tC9awa.js";class fe{constructor(t){c(this,"_event");c(this,"_position",new O);c(this,"onDisposed",new T);c(this,"updateMouseInfo",t=>{this._event=t});this.dom=t,this.setupEvents(!0)}get position(){if(this._event){const t=this.dom.getBoundingClientRect();this._position.x=this.getPositionX(t,this._event),this._position.y=this.getPositionY(t,this._event)}return this._position}dispose(){this.setupEvents(!1),this.onDisposed.trigger(),this.onDisposed.reset()}getPositionY(t,e){return-((e.clientY-t.top)/(t.bottom-t.top))*2+1}getPositionX(t,e){return(e.clientX-t.left)/(t.right-t.left)*2-1}setupEvents(t){t?this.dom.addEventListener("mousemove",this.updateMouseInfo):this.dom.removeEventListener("mousemove",this.updateMouseInfo)}}class le{constructor(t,e){c(this,"enabled",!0);c(this,"components");c(this,"onDisposed",new T);c(this,"mouse");c(this,"three",new j);c(this,"world");const s=e.renderer;if(!s)throw new Error("A renderer is needed for the raycaster to work!");this.world=e,this.mouse=new fe(s.three.domElement),this.components=t}dispose(){this.mouse.dispose(),this.onDisposed.trigger(),this.onDisposed.reset()}castRay(t=Array.from(this.world.meshes)){if(!this.world)throw new Error("A world is needed to cast rays!");const e=this.world.camera.three;return this.three.setFromCamera(this.mouse.position,e),this.intersect(t)}castRayFromVector(t,e,s=Array.from(this.world.meshes)){return this.three.set(t,e),this.intersect(s)}intersect(t=Array.from(this.world.meshes)){const e=this.three.intersectObjects(t),s=this.filterClippingPlanes(e);return s.length>0?s[0]:null}filterClippingPlanes(t){if(!this.world.renderer)throw new Error("Renderer not found!");const e=this.world.renderer.three;if(!e.clippingPlanes)return t;const s=e.clippingPlanes;return t.length<=0||!s||(s==null?void 0:s.length)<=0?t:t.filter(m=>s.every(y=>y.distanceToPoint(m.point)>0))}}const A=class A extends B{constructor(e){super(e);c(this,"enabled",!0);c(this,"list",new Map);c(this,"onDisposed",new T);e.add(A.uuid,this)}get(e){if(this.list.has(e.uuid))return this.list.get(e.uuid);const s=new le(this.components,e);return this.list.set(e.uuid,s),e.onDisposed.add(()=>{this.delete(e)}),s}delete(e){const s=this.list.get(e.uuid);s&&s.dispose(),this.list.delete(e.uuid)}dispose(){for(const[e,s]of this.list)s.dispose();this.list.clear(),this.onDisposed.trigger()}};c(A,"uuid","d5d8bdf0-db25-4952-b951-b643af207ace");let C=A;const S=class S extends B{constructor(e){super(e);c(this,"enabled",!0);e.add(S.uuid,this)}getFace(e,s,m){if(!e.geometry.index)throw new Error("Geometry must be indexed!");const y=new Map,o=e.geometry.index.array,{plane:i}=this.getFaceData(s,m,e),l=[];for(let f=0;f<o.length/3;f++){const{plane:h,edges:a}=this.getFaceData(f,m,e);if(h.equals(i)){l.push({index:f,edges:a});for(const{id:g,points:r,distance:E}of a)y.set(g,{points:r,distance:E})}}let x=0;const d=new Map,w=new Map;for(const{index:f,edges:h}of l){const a=new Map;for(const{id:n}of h)if(d.has(n)){const u=d.get(n);a.set(n,u)}const g=h.map(n=>n.id);if(!a.size){const n=x++;for(const{id:u}of h)d.set(u,n);w.set(n,{edges:new Set(g),indices:new Set([f])});continue}let r=null;const E=new Set,M=new Set(g);for(const[n,u]of a){r===null?r=u:u!==r&&E.add(u),d.delete(n);const{edges:z}=w.get(u);z.delete(n),M.delete(n)}if(r===null)throw new Error("Error computing face!");const I=w.get(r),{indices:P}=I;P.add(f);for(const n of M){d.set(n,r);const{edges:u}=I;u.add(n)}for(const n of E){const u=w.get(n),{edges:z,indices:U}=u,X=w.get(r),{edges:Y,indices:k}=X;for(const b of z)Y.add(b),d.set(b,r);for(const b of U)k.add(b);w.delete(n)}}for(const[f,{indices:h,edges:a}]of w)if(h.has(s)){const g=[];for(const r of a){const E=y.get(r);g.push(E)}return{edges:g,indices:h}}return null}static distanceFromPointToLine(e,s,m,y=!1){const o=new H,i=new D;return o.set(s,m),o.closestPointToPoint(e,y,i),i.distanceTo(e)}getFaceData(e,s,m){const y=this.getVerticesAndNormal(m,e,s),{p1:o,p2:i,p3:l,faceNormal:x}=y;this.round(o),this.round(i),this.round(l),this.round(x);const d=[{id:`${o.x}|${o.y}|${o.z}`,value:o},{id:`${i.x}|${i.y}|${i.z}`,value:i},{id:`${l.x}|${l.y}|${l.z}`,value:l}];d.sort((I,P)=>I.id<P.id?-1:I.id>P.id?1:0);const[{id:w,value:f},{id:h,value:a},{id:g,value:r}]=d,E=[{id:`${w}|${h}`,distance:f.distanceTo(a),points:[f,a]},{id:`${h}|${g}`,distance:a.distanceTo(r),points:[a,r]},{id:`${w}|${g}`,distance:f.distanceTo(r),points:[f,r]}],M=new J;return M.setFromNormalAndCoplanarPoint(x,o),M.constant=Math.round(M.constant*10)/10,{plane:M,edges:E}}getVerticesAndNormal(e,s,m){if(!e.geometry.index)throw new Error("Geometry must be indexed!");const y=e.geometry.index.array,o=e.geometry.attributes.position.array,i=e.geometry.attributes.normal.array,l=y[s*3]*3,x=y[s*3+1]*3,d=y[s*3+2]*3,w=new D(o[l],o[l+1],o[l+2]),f=new D(o[x],o[x+1],o[x+2]),h=new D(o[d],o[d+1],o[d+2]),a=new D(i[l],i[l+1],i[l+2]),g=new D(i[x],i[x+1],i[x+2]),r=new D(i[d],i[d+1],i[d+2]),E=(a.x+g.x+r.x)/3,M=(a.y+g.y+r.y)/3,I=(a.z+g.z+r.z)/3,P=new D(E,M,I);if(m!==void 0&&e instanceof K){const n=new R;e.getMatrixAt(m,n);const u=new R;u.extractRotation(n),P.applyMatrix4(u),w.applyMatrix4(n),f.applyMatrix4(n),h.applyMatrix4(n)}return{p1:w,p2:f,p3:h,faceNormal:P}}round(e){e.x=Math.trunc(e.x*1e3)/1e3,e.y=Math.trunc(e.y*1e3)/1e3,e.z=Math.trunc(e.z*1e3)/1e3}};c(S,"uuid","267ca032-672f-4cb0-afa9-d24e904f39d6");let L=S;const ue=document.getElementById("container"),F=new se,pe=F.get(ne),p=pe.create();p.scene=new oe(F);p.renderer=new re(F,ue);p.camera=new ie(F);F.init();p.camera.controls.setLookAt(12,6,8,0,0,-10);p.scene.setup();const he=F.get(ae);he.create(p);const ge=new de(F),me=await fetch("https://thatopen.github.io/engine_components/resources/small.frag"),we=await me.arrayBuffer(),ye=new Uint8Array(we),N=ge.load(ye);p.scene.three.add(N);const ve=F.get(ce),_=ve.create(p);for(const v of N.children)v instanceof V&&_.add(v);_.needsUpdate=!0;p.camera.controls.addEventListener("sleep",()=>{_.needsUpdate=!0});const xe=F.get(L),Ee=F.get(C),Fe=Ee.get(p),G=new Q,Me=new Z({color:16711680,depthTest:!1}),De=new ee(G,Me);p.scene.three.add(De);p.renderer&&p.renderer.three.domElement.addEventListener("mousemove",()=>{const t=Fe.castRay([N]);if(!t||!(t.object instanceof V)||t.faceIndex===void 0)return;const e=xe.getFace(t.object,t.faceIndex,t.instanceId);if(e){const s=[];for(const m of e.edges)s.push(...m.points);G.setFromPoints(s)}});const $=new te;$.showPanel(2);document.body.append($.dom);$.dom.style.left="0px";$.dom.style.right="auto";p.renderer.onBeforeUpdate.add(()=>$.begin());p.renderer.onAfterUpdate.add(()=>$.end());
