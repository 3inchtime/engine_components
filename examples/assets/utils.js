var V=Object.defineProperty;var j=($,d,e)=>d in $?V($,d,{enumerable:!0,configurable:!0,writable:!0,value:e}):$[d]=e;var P=($,d,e)=>(j($,typeof d!="symbol"?d+"":d,e),e);import{t as W,V as I,P as k,I as q,a as L,aB as U,L as H,v as J,M as K}from"./web-ifc-api-eJ7dR4yy.js";import{S as O}from"./stats.min-GTpOrGrX.js";import{C as Q,a as X,W as Y,S as Z,b as _,c as ee}from"./index-BRIP3dnE.js";import{R as te}from"./index-BhUtnAQ6.js";import{G as ne}from"./index-aZ7tPJp1.js";import{F as se}from"./index-DUv5fNdI.js";import"./_commonjsHelpers-Cpj98o6Y.js";const z=class z extends Q{constructor(e){super(e);P(this,"enabled",!0);e.add(z.uuid,this)}getFace(e,g,w){if(!e.geometry.index)throw new Error("Geometry must be indexed!");const x=new Map,n=e.geometry.index.array,{plane:o}=this.getFaceData(g,w,e),i=[];for(let c=0;c<n.length/3;c++){const{plane:l,edges:a}=this.getFaceData(c,w,e);if(l.equals(o)){i.push({index:c,edges:a});for(const{id:p,points:s,distance:h}of a)x.set(p,{points:s,distance:h})}}let y=0;const r=new Map,u=new Map;for(const{index:c,edges:l}of i){const a=new Map;for(const{id:t}of l)if(r.has(t)){const f=r.get(t);a.set(t,f)}const p=l.map(t=>t.id);if(!a.size){const t=y++;for(const{id:f}of l)r.set(f,t);u.set(t,{edges:new Set(p),indices:new Set([c])});continue}let s=null;const h=new Set,M=new Set(p);for(const[t,f]of a){s===null?s=f:f!==s&&h.add(f),r.delete(t);const{edges:D}=u.get(f);D.delete(t),M.delete(t)}if(s===null)throw new Error("Error computing face!");const v=u.get(s),{indices:F}=v;F.add(c);for(const t of M){r.set(t,s);const{edges:f}=v;f.add(t)}for(const t of h){const f=u.get(t),{edges:D,indices:B}=f,C=u.get(s),{edges:G,indices:R}=C;for(const b of D)G.add(b),r.set(b,s);for(const b of B)R.add(b);u.delete(t)}}for(const[c,{indices:l,edges:a}]of u)if(l.has(g)){const p=[];for(const s of a){const h=x.get(s);p.push(h)}return{edges:p,indices:l}}return null}static distanceFromPointToLine(e,g,w,x=!1){const n=new W,o=new I;return n.set(g,w),n.closestPointToPoint(e,x,o),o.distanceTo(e)}getFaceData(e,g,w){const x=this.getVerticesAndNormal(w,e,g),{p1:n,p2:o,p3:i,faceNormal:y}=x;this.round(n),this.round(o),this.round(i),this.round(y);const r=[{id:`${n.x}|${n.y}|${n.z}`,value:n},{id:`${o.x}|${o.y}|${o.z}`,value:o},{id:`${i.x}|${i.y}|${i.z}`,value:i}];r.sort((v,F)=>v.id<F.id?-1:v.id>F.id?1:0);const[{id:u,value:c},{id:l,value:a},{id:p,value:s}]=r,h=[{id:`${u}|${l}`,distance:c.distanceTo(a),points:[c,a]},{id:`${l}|${p}`,distance:a.distanceTo(s),points:[a,s]},{id:`${u}|${p}`,distance:c.distanceTo(s),points:[c,s]}],M=new k;return M.setFromNormalAndCoplanarPoint(y,n),M.constant=Math.round(M.constant*10)/10,{plane:M,edges:h}}getVerticesAndNormal(e,g,w){if(!e.geometry.index)throw new Error("Geometry must be indexed!");const x=e.geometry.index.array,n=e.geometry.attributes.position.array,o=e.geometry.attributes.normal.array,i=x[g*3]*3,y=x[g*3+1]*3,r=x[g*3+2]*3,u=new I(n[i],n[i+1],n[i+2]),c=new I(n[y],n[y+1],n[y+2]),l=new I(n[r],n[r+1],n[r+2]),a=new I(o[i],o[i+1],o[i+2]),p=new I(o[y],o[y+1],o[y+2]),s=new I(o[r],o[r+1],o[r+2]),h=(a.x+p.x+s.x)/3,M=(a.y+p.y+s.y)/3,v=(a.z+p.z+s.z)/3,F=new I(h,M,v);if(!F.x&&!F.y&&!F.z&&console.log("hey"),w!==void 0&&e instanceof q){const t=new L;e.getMatrixAt(w,t);const f=new L;f.extractRotation(t),F.applyMatrix4(f),u.applyMatrix4(t),c.applyMatrix4(t),l.applyMatrix4(t)}return{p1:u,p2:c,p3:l,faceNormal:F}}round(e){e.x=Math.trunc(e.x*1e3)/1e3,e.y=Math.trunc(e.y*1e3)/1e3,e.z=Math.trunc(e.z*1e3)/1e3}};P(z,"uuid","267ca032-672f-4cb0-afa9-d24e904f39d6");let A=z;const oe=document.getElementById("container"),E=new X,ae=E.get(Y),m=ae.create();m.scene=new Z(E);m.renderer=new _(E,oe);m.camera=new ee(E);E.init();m.camera.controls.setLookAt(12,6,8,0,0,-10);m.scene.setup();const re=E.get(ne);re.create(m);const ce=new se(E),de=await fetch("../../../../../resources/small.frag"),ie=await de.arrayBuffer(),fe=new Uint8Array(ie),N=ce.load(fe);m.scene.three.add(N);const ge=E.get(A),le=E.get(te),pe=le.get(m),T=new U,ue=new H({color:16711680,depthTest:!1}),me=new J(T,ue);m.scene.three.add(me);m.renderer&&m.renderer.three.domElement.addEventListener("mousemove",()=>{const d=pe.castRay([N]);if(!d||!(d.object instanceof K)||d.faceIndex===void 0)return;const e=ge.getFace(d.object,d.faceIndex,d.instanceId);if(e){const g=[];for(const w of e.edges)g.push(...w.points);T.setFromPoints(g)}});const S=new O;S.showPanel(2);document.body.append(S.dom);S.dom.style.left="0px";S.dom.style.right="auto";m.renderer.onBeforeUpdate.add(()=>S.begin());m.renderer.onAfterUpdate.add(()=>S.end());
