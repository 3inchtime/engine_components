import{I as Ft,C as P,aK as _t,f as V,g as yt,aL as T,aM as pt,aN as Z,aO as ut,aP as Ct,G as Ot,B as Lt,aQ as Mt,V as mt,K as St,ac as Dt,L as Pt,h as ct,al as Ut}from"./unzipit.module-RGQJWpcx.js";class gt extends Ft{constructor(t,s,e,i){if(super(t,s,e),Array.isArray(s)||(s=[s]),this.material=s,!t.index)throw new Error("The geometry for fragments must be indexed!");this.geometry=t,this.fragment=i;const r=t.index.count;t.groups.length||t.groups.push({start:0,count:r,materialIndex:0})}exportData(){const t=this.geometry.attributes.position.array,s=this.geometry.attributes.normal.array,e=Array.from(this.geometry.index.array),i=[];for(const a of this.geometry.groups){const c=a.materialIndex||0,{start:h,count:b}=a;i.push(h,b,c)}const r=[];if(Array.isArray(this.material))for(const a of this.material){const c=a.opacity,h=a.transparent?1:0,b=new P(a.color).toArray();r.push(c,h,...b)}const n=Array.from(this.instanceMatrix.array);let o;return this.instanceColor!==null?o=Array.from(this.instanceColor.array):o=[],{position:t,normal:s,index:e,groups:i,materials:r,matrices:n,colors:o}}}let Bt=class It{constructor(t,s,e){this.ids=new Set,this.itemToInstances=new Map,this.instanceToItem=new Map,this.hiddenItems=new Set,this.capacity=0,this.capacityOffset=10,this.fragments={},this._settingVisibility=!1,this.mesh=new gt(t,s,e,this),this.id=this.mesh.uuid,this.capacity=e,this.mesh.count=0,this.mesh.geometry.index.count&&_t.apply(this.mesh.geometry)}dispose(t=!0){if(this.clear(),this.group=void 0,this.mesh){if(t){for(const s of this.mesh.material)s.dispose();this.mesh.material=[],_t.dispose(this.mesh.geometry),this.mesh.geometry.dispose(),this.mesh.geometry=null}this.mesh.removeFromParent(),this.mesh.dispose(),this.mesh.fragment=null,this.mesh=null}for(const s in this.fragments)this.fragments[s].dispose(t);this.fragments={}}get(t){const s=this.getInstancesIDs(t);if(!s)throw new Error("Item not found!");const e=[],i=[];for(const n of s){const o=new V;if(this.mesh.getMatrixAt(n,o),e.push(o),this.mesh.instanceColor){const a=new P;this.mesh.getColorAt(n,a),i.push(a)}}const r=i.length?i:void 0;return{id:t,transforms:e,colors:r}}getItemID(t){return this.instanceToItem.get(t)||null}getInstancesIDs(t){return this.itemToInstances.get(t)||null}update(){this.mesh.instanceColor&&(this.mesh.instanceColor.needsUpdate=!0),this.mesh.instanceMatrix.needsUpdate=!0}add(t){var s;let e=0;for(const r of t)e+=r.transforms.length;const i=this.mesh.count+e;if(i>this.capacity){const r=i+this.capacityOffset,n=new gt(this.mesh.geometry,this.mesh.material,r,this);n.count=this.mesh.count,this.capacity=r;const o=this.mesh;(s=o.parent)===null||s===void 0||s.add(n),o.removeFromParent(),this.mesh=n;const a=new V;for(let c=0;c<o.instanceMatrix.count;c++)o.getMatrixAt(c,a),n.setMatrixAt(c,a);if(o.instanceColor){const c=new P;for(let h=0;h<o.instanceColor.count;h++)o.getColorAt(h,c),n.setColorAt(h,c)}o.dispose()}for(let r=0;r<t.length;r++){const{transforms:n,colors:o,id:a}=t[r];this.itemToInstances.has(a)||this.itemToInstances.set(a,new Set);const c=this.itemToInstances.get(a);this.ids.add(a);for(let h=0;h<n.length;h++){const b=n[h],d=this.mesh.count;if(this.mesh.setMatrixAt(d,b),o){const p=o[h];this.mesh.setColorAt(d,p)}c.add(d),this.instanceToItem.set(d,a),this.mesh.count++}}this.update()}remove(t){if(this.mesh.count!==0){for(const s of t){const e=this.itemToInstances.get(s);if(e===void 0)throw new Error("Instances not found!");for(const i of e){if(this.mesh.count===0)throw new Error("Errow with mesh count!");this.putLast(i),this.instanceToItem.delete(i),this.mesh.count--}this.itemToInstances.delete(s),this.ids.delete(s)}this.update()}}clear(){this.hiddenItems.clear(),this.ids.clear(),this.instanceToItem.clear(),this.itemToInstances.clear(),this.mesh.count=0}addFragment(t,s=this.mesh.material){const e=new yt,i=this.mesh.geometry.attributes;e.setAttribute("position",i.position),e.setAttribute("normal",i.normal),e.setIndex(Array.from(this.mesh.geometry.index.array));const r=new It(e,s,this.capacity),n=[];for(const o of this.ids){const a=this.get(o);n.push(a)}return r.add(n),r.mesh.applyMatrix4(this.mesh.matrix),r.mesh.updateMatrix(),this.fragments[t]=r,this.fragments[t]}removeFragment(t){const s=this.fragments[t];s&&(s.dispose(!1),delete this.fragments[t])}setVisibility(t,s=this.ids){if(!this._settingVisibility){if(this._settingVisibility=!0,t)for(const e of s){if(!this.ids.has(e))throw new Error(`This item doesn't exist here: ${e}`);if(!this.hiddenItems.has(e))continue;const i=this.itemToInstances.get(e);if(!i)throw new Error("Instances not found!");for(const r of new Set(i))this.mesh.count++,this.putLast(r);this.hiddenItems.delete(e)}else for(const e of s){if(!this.ids.has(e))throw new Error(`This item doesn't exist here: ${e}`);if(this.hiddenItems.has(e))continue;const i=this.itemToInstances.get(e);if(!i)throw new Error("Instances not found!");for(const r of new Set(i))this.putLast(r),this.mesh.count--;this.hiddenItems.add(e)}this.update(),this._settingVisibility=!1}}applyTransform(t,s){const e=new V;for(const i of t){const r=this.getInstancesIDs(i);if(r!==null)for(const n of r)this.mesh.getMatrixAt(n,e),e.premultiply(s),this.mesh.setMatrixAt(n,e)}this.update()}exportData(){const t=this.mesh.exportData(),s=Array.from(this.ids),e=this.id;return{...t,ids:s,id:e}}putLast(t){if(this.mesh.count===0)return;const s=this.instanceToItem.get(t),e=this.mesh.count-1;if(e===t)return;const i=this.instanceToItem.get(e);if(s===void 0||i===void 0)throw new Error("Keys not found");if(s!==i){const o=this.itemToInstances.get(s),a=this.itemToInstances.get(i);if(!o||!a)throw new Error("Instances not found");if(!o.has(t)||!a.has(e))throw new Error("Malformed fragment structure");o.delete(t),a.delete(e),o.add(e),a.add(t),this.instanceToItem.set(t,i),this.instanceToItem.set(e,s)}const r=new V,n=new V;if(this.mesh.getMatrixAt(t,r),this.mesh.getMatrixAt(e,n),this.mesh.setMatrixAt(t,n),this.mesh.setMatrixAt(e,r),this.mesh.instanceColor!==null){const o=new P,a=new P;this.mesh.getColorAt(t,o),this.mesh.getColorAt(e,a),this.mesh.setColorAt(t,a),this.mesh.setColorAt(e,o)}}};const ht=2,A=4,C=4,E=4;class ${constructor(t){this.bytes_=t,this.position_=0,this.text_decoder_=new TextDecoder}static allocate(t){return new $(new Uint8Array(t))}clear(){this.position_=0}bytes(){return this.bytes_}position(){return this.position_}setPosition(t){this.position_=t}capacity(){return this.bytes_.length}readInt8(t){return this.readUint8(t)<<24>>24}readUint8(t){return this.bytes_[t]}readInt16(t){return this.readUint16(t)<<16>>16}readUint16(t){return this.bytes_[t]|this.bytes_[t+1]<<8}readInt32(t){return this.bytes_[t]|this.bytes_[t+1]<<8|this.bytes_[t+2]<<16|this.bytes_[t+3]<<24}readUint32(t){return this.readInt32(t)>>>0}readInt64(t){return BigInt.asIntN(64,BigInt(this.readUint32(t))+(BigInt(this.readUint32(t+4))<<BigInt(32)))}readUint64(t){return BigInt.asUintN(64,BigInt(this.readUint32(t))+(BigInt(this.readUint32(t+4))<<BigInt(32)))}readFloat32(t){return T[0]=this.readInt32(t),pt[0]}readFloat64(t){return T[Z?0:1]=this.readInt32(t),T[Z?1:0]=this.readInt32(t+4),ut[0]}writeInt8(t,s){this.bytes_[t]=s}writeUint8(t,s){this.bytes_[t]=s}writeInt16(t,s){this.bytes_[t]=s,this.bytes_[t+1]=s>>8}writeUint16(t,s){this.bytes_[t]=s,this.bytes_[t+1]=s>>8}writeInt32(t,s){this.bytes_[t]=s,this.bytes_[t+1]=s>>8,this.bytes_[t+2]=s>>16,this.bytes_[t+3]=s>>24}writeUint32(t,s){this.bytes_[t]=s,this.bytes_[t+1]=s>>8,this.bytes_[t+2]=s>>16,this.bytes_[t+3]=s>>24}writeInt64(t,s){this.writeInt32(t,Number(BigInt.asIntN(32,s))),this.writeInt32(t+4,Number(BigInt.asIntN(32,s>>BigInt(32))))}writeUint64(t,s){this.writeUint32(t,Number(BigInt.asUintN(32,s))),this.writeUint32(t+4,Number(BigInt.asUintN(32,s>>BigInt(32))))}writeFloat32(t,s){pt[0]=s,this.writeInt32(t,T[0])}writeFloat64(t,s){ut[0]=s,this.writeInt32(t,T[Z?0:1]),this.writeInt32(t+4,T[Z?1:0])}getBufferIdentifier(){if(this.bytes_.length<this.position_+A+C)throw new Error("FlatBuffers: ByteBuffer is too short to contain an identifier.");let t="";for(let s=0;s<C;s++)t+=String.fromCharCode(this.readInt8(this.position_+A+s));return t}__offset(t,s){const e=t-this.readInt32(t);return s<this.readInt16(e)?this.readInt16(e+s):0}__union(t,s){return t.bb_pos=s+this.readInt32(s),t.bb=this,t}__string(t,s){t+=this.readInt32(t);const e=this.readInt32(t);t+=A;const i=this.bytes_.subarray(t,t+e);return s===Ct.UTF8_BYTES?i:this.text_decoder_.decode(i)}__union_with_string(t,s){return typeof t=="string"?this.__string(s):this.__union(t,s)}__indirect(t){return t+this.readInt32(t)}__vector(t){return t+this.readInt32(t)+A}__vector_len(t){return this.readInt32(t+this.readInt32(t))}__has_identifier(t){if(t.length!=C)throw new Error("FlatBuffers: file identifier must be length "+C);for(let s=0;s<C;s++)if(t.charCodeAt(s)!=this.readInt8(this.position()+A+s))return!1;return!0}createScalarList(t,s){const e=[];for(let i=0;i<s;++i){const r=t(i);r!==null&&e.push(r)}return e}createObjList(t,s){const e=[];for(let i=0;i<s;++i){const r=t(i);r!==null&&e.push(r.unpack())}return e}}class dt{constructor(t){this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1,this.string_maps=null,this.text_encoder=new TextEncoder;let s;t?s=t:s=1024,this.bb=$.allocate(s),this.space=s}clear(){this.bb.clear(),this.space=this.bb.capacity(),this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1,this.string_maps=null}forceDefaults(t){this.force_defaults=t}dataBuffer(){return this.bb}asUint8Array(){return this.bb.bytes().subarray(this.bb.position(),this.bb.position()+this.offset())}prep(t,s){t>this.minalign&&(this.minalign=t);const e=~(this.bb.capacity()-this.space+s)+1&t-1;for(;this.space<e+t+s;){const i=this.bb.capacity();this.bb=dt.growByteBuffer(this.bb),this.space+=this.bb.capacity()-i}this.pad(e)}pad(t){for(let s=0;s<t;s++)this.bb.writeInt8(--this.space,0)}writeInt8(t){this.bb.writeInt8(this.space-=1,t)}writeInt16(t){this.bb.writeInt16(this.space-=2,t)}writeInt32(t){this.bb.writeInt32(this.space-=4,t)}writeInt64(t){this.bb.writeInt64(this.space-=8,t)}writeFloat32(t){this.bb.writeFloat32(this.space-=4,t)}writeFloat64(t){this.bb.writeFloat64(this.space-=8,t)}addInt8(t){this.prep(1,0),this.writeInt8(t)}addInt16(t){this.prep(2,0),this.writeInt16(t)}addInt32(t){this.prep(4,0),this.writeInt32(t)}addInt64(t){this.prep(8,0),this.writeInt64(t)}addFloat32(t){this.prep(4,0),this.writeFloat32(t)}addFloat64(t){this.prep(8,0),this.writeFloat64(t)}addFieldInt8(t,s,e){(this.force_defaults||s!=e)&&(this.addInt8(s),this.slot(t))}addFieldInt16(t,s,e){(this.force_defaults||s!=e)&&(this.addInt16(s),this.slot(t))}addFieldInt32(t,s,e){(this.force_defaults||s!=e)&&(this.addInt32(s),this.slot(t))}addFieldInt64(t,s,e){(this.force_defaults||s!==e)&&(this.addInt64(s),this.slot(t))}addFieldFloat32(t,s,e){(this.force_defaults||s!=e)&&(this.addFloat32(s),this.slot(t))}addFieldFloat64(t,s,e){(this.force_defaults||s!=e)&&(this.addFloat64(s),this.slot(t))}addFieldOffset(t,s,e){(this.force_defaults||s!=e)&&(this.addOffset(s),this.slot(t))}addFieldStruct(t,s,e){s!=e&&(this.nested(s),this.slot(t))}nested(t){if(t!=this.offset())throw new TypeError("FlatBuffers: struct must be serialized inline.")}notNested(){if(this.isNested)throw new TypeError("FlatBuffers: object serialization must not be nested.")}slot(t){this.vtable!==null&&(this.vtable[t]=this.offset())}offset(){return this.bb.capacity()-this.space}static growByteBuffer(t){const s=t.capacity();if(s&3221225472)throw new Error("FlatBuffers: cannot grow buffer beyond 2 gigabytes.");const e=s<<1,i=$.allocate(e);return i.setPosition(e-s),i.bytes().set(t.bytes(),e-s),i}addOffset(t){this.prep(A,0),this.writeInt32(this.offset()-t+A)}startObject(t){this.notNested(),this.vtable==null&&(this.vtable=[]),this.vtable_in_use=t;for(let s=0;s<t;s++)this.vtable[s]=0;this.isNested=!0,this.object_start=this.offset()}endObject(){if(this.vtable==null||!this.isNested)throw new Error("FlatBuffers: endObject called without startObject");this.addInt32(0);const t=this.offset();let s=this.vtable_in_use-1;for(;s>=0&&this.vtable[s]==0;s--);const e=s+1;for(;s>=0;s--)this.addInt16(this.vtable[s]!=0?t-this.vtable[s]:0);const i=2;this.addInt16(t-this.object_start);const r=(e+i)*ht;this.addInt16(r);let n=0;const o=this.space;t:for(s=0;s<this.vtables.length;s++){const a=this.bb.capacity()-this.vtables[s];if(r==this.bb.readInt16(a)){for(let c=ht;c<r;c+=ht)if(this.bb.readInt16(o+c)!=this.bb.readInt16(a+c))continue t;n=this.vtables[s];break}}return n?(this.space=this.bb.capacity()-t,this.bb.writeInt32(this.space,n-t)):(this.vtables.push(this.offset()),this.bb.writeInt32(this.bb.capacity()-t,this.offset()-t)),this.isNested=!1,t}finish(t,s,e){const i=e?E:0;if(s){const r=s;if(this.prep(this.minalign,A+C+i),r.length!=C)throw new TypeError("FlatBuffers: file identifier must be length "+C);for(let n=C-1;n>=0;n--)this.writeInt8(r.charCodeAt(n))}this.prep(this.minalign,A+i),this.addOffset(t),i&&this.addInt32(this.bb.capacity()-this.space),this.bb.setPosition(this.space)}finishSizePrefixed(t,s){this.finish(t,s,!0)}requiredField(t,s){const e=this.bb.capacity()-t,i=e-this.bb.readInt32(e);if(!(s<this.bb.readInt16(i)&&this.bb.readInt16(i+s)!=0))throw new TypeError("FlatBuffers: field "+s+" must be set")}startVector(t,s,e){this.notNested(),this.vector_num_elems=s,this.prep(A,t*s),this.prep(e,t*s)}endVector(){return this.writeInt32(this.vector_num_elems),this.offset()}createSharedString(t){if(!t)return 0;if(this.string_maps||(this.string_maps=new Map),this.string_maps.has(t))return this.string_maps.get(t);const s=this.createString(t);return this.string_maps.set(t,s),s}createString(t){if(t==null)return 0;let s;t instanceof Uint8Array?s=t:s=this.text_encoder.encode(t),this.addInt8(0),this.startVector(1,s.length,1),this.bb.setPosition(this.space-=s.length);for(let e=0,i=this.space,r=this.bb.bytes();e<s.length;e++)r[i++]=s[e];return this.endVector()}createObjectOffset(t){return t===null?0:typeof t=="string"?this.createString(t):t.pack(this)}createObjectOffsetList(t){const s=[];for(let e=0;e<t.length;++e){const i=t[e];if(i!==null)s.push(this.createObjectOffset(i));else throw new TypeError("FlatBuffers: Argument for createObjectOffsetList cannot contain null.")}return s}createStructOffsetList(t,s){return s(this,t.length),this.createObjectOffsetList(t.slice().reverse()),this.endVector()}}let Y=class D{constructor(){this.bb=null,this.bb_pos=0}__init(t,s){return this.bb_pos=t,this.bb=s,this}static getRootAsCivilCurve(t,s){return(s||new D).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsCivilCurve(t,s){return t.setPosition(t.position()+E),(s||new D).__init(t.readInt32(t.position())+t.position(),t)}points(t){const s=this.bb.__offset(this.bb_pos,4);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+t*4):0}pointsLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}pointsArray(){const t=this.bb.__offset(this.bb_pos,4);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}data(t){const s=this.bb.__offset(this.bb_pos,6);return s?this.bb.__string(this.bb_pos+s,t):null}static startCivilCurve(t){t.startObject(2)}static addPoints(t,s){t.addFieldOffset(0,s,0)}static createPointsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addFloat32(s[e]);return t.endVector()}static startPointsVector(t,s){t.startVector(4,s,4)}static addData(t,s){t.addFieldOffset(1,s,0)}static endCivilCurve(t){return t.endObject()}static createCivilCurve(t,s,e){return D.startCivilCurve(t),D.addPoints(t,s),D.addData(t,e),D.endCivilCurve(t)}},wt=class x{constructor(){this.bb=null,this.bb_pos=0}__init(t,s){return this.bb_pos=t,this.bb=s,this}static getRootAsAlignment(t,s){return(s||new x).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsAlignment(t,s){return t.setPosition(t.position()+E),(s||new x).__init(t.readInt32(t.position())+t.position(),t)}vertical(t,s){const e=this.bb.__offset(this.bb_pos,4);return e?(s||new Y).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+e)+t*4),this.bb):null}verticalLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}horizontal(t,s){const e=this.bb.__offset(this.bb_pos,6);return e?(s||new Y).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+e)+t*4),this.bb):null}horizontalLength(){const t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}absolute(t,s){const e=this.bb.__offset(this.bb_pos,8);return e?(s||new Y).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+e)+t*4),this.bb):null}absoluteLength(){const t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}initialPk(){const t=this.bb.__offset(this.bb_pos,10);return t?this.bb.readFloat32(this.bb_pos+t):0}static startAlignment(t){t.startObject(4)}static addVertical(t,s){t.addFieldOffset(0,s,0)}static createVerticalVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addOffset(s[e]);return t.endVector()}static startVerticalVector(t,s){t.startVector(4,s,4)}static addHorizontal(t,s){t.addFieldOffset(1,s,0)}static createHorizontalVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addOffset(s[e]);return t.endVector()}static startHorizontalVector(t,s){t.startVector(4,s,4)}static addAbsolute(t,s){t.addFieldOffset(2,s,0)}static createAbsoluteVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addOffset(s[e]);return t.endVector()}static startAbsoluteVector(t,s){t.startVector(4,s,4)}static addInitialPk(t,s){t.addFieldFloat32(3,s,0)}static endAlignment(t){return t.endObject()}static createAlignment(t,s,e,i,r){return x.startAlignment(t),x.addVertical(t,s),x.addHorizontal(t,e),x.addAbsolute(t,i),x.addInitialPk(t,r),x.endAlignment(t)}};class F{constructor(){this.bb=null,this.bb_pos=0}__init(t,s){return this.bb_pos=t,this.bb=s,this}static getRootAsCivilData(t,s){return(s||new F).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsCivilData(t,s){return t.setPosition(t.position()+E),(s||new F).__init(t.readInt32(t.position())+t.position(),t)}alignments(t,s){const e=this.bb.__offset(this.bb_pos,4);return e?(s||new wt).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+e)+t*4),this.bb):null}alignmentsLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}coordinationMatrix(t){const s=this.bb.__offset(this.bb_pos,6);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+t*4):0}coordinationMatrixLength(){const t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}coordinationMatrixArray(){const t=this.bb.__offset(this.bb_pos,6);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}static startCivilData(t){t.startObject(2)}static addAlignments(t,s){t.addFieldOffset(0,s,0)}static createAlignmentsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addOffset(s[e]);return t.endVector()}static startAlignmentsVector(t,s){t.startVector(4,s,4)}static addCoordinationMatrix(t,s){t.addFieldOffset(1,s,0)}static createCoordinationMatrixVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addFloat32(s[e]);return t.endVector()}static startCoordinationMatrixVector(t,s){t.startVector(4,s,4)}static endCivilData(t){return t.endObject()}static createCivilData(t,s,e){return F.startCivilData(t),F.addAlignments(t,s),F.addCoordinationMatrix(t,e),F.endCivilData(t)}}class l{constructor(){this.bb=null,this.bb_pos=0}__init(t,s){return this.bb_pos=t,this.bb=s,this}static getRootAsFragment(t,s){return(s||new l).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsFragment(t,s){return t.setPosition(t.position()+E),(s||new l).__init(t.readInt32(t.position())+t.position(),t)}position(t){const s=this.bb.__offset(this.bb_pos,4);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+t*4):0}positionLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}positionArray(){const t=this.bb.__offset(this.bb_pos,4);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}normal(t){const s=this.bb.__offset(this.bb_pos,6);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+t*4):0}normalLength(){const t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}normalArray(){const t=this.bb.__offset(this.bb_pos,6);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}index(t){const s=this.bb.__offset(this.bb_pos,8);return s?this.bb.readUint32(this.bb.__vector(this.bb_pos+s)+t*4):0}indexLength(){const t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}indexArray(){const t=this.bb.__offset(this.bb_pos,8);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}groups(t){const s=this.bb.__offset(this.bb_pos,10);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+t*4):0}groupsLength(){const t=this.bb.__offset(this.bb_pos,10);return t?this.bb.__vector_len(this.bb_pos+t):0}groupsArray(){const t=this.bb.__offset(this.bb_pos,10);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}materials(t){const s=this.bb.__offset(this.bb_pos,12);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+t*4):0}materialsLength(){const t=this.bb.__offset(this.bb_pos,12);return t?this.bb.__vector_len(this.bb_pos+t):0}materialsArray(){const t=this.bb.__offset(this.bb_pos,12);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}matrices(t){const s=this.bb.__offset(this.bb_pos,14);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+t*4):0}matricesLength(){const t=this.bb.__offset(this.bb_pos,14);return t?this.bb.__vector_len(this.bb_pos+t):0}matricesArray(){const t=this.bb.__offset(this.bb_pos,14);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}colors(t){const s=this.bb.__offset(this.bb_pos,16);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+t*4):0}colorsLength(){const t=this.bb.__offset(this.bb_pos,16);return t?this.bb.__vector_len(this.bb_pos+t):0}colorsArray(){const t=this.bb.__offset(this.bb_pos,16);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}itemsSize(t){const s=this.bb.__offset(this.bb_pos,18);return s?this.bb.readUint32(this.bb.__vector(this.bb_pos+s)+t*4):0}itemsSizeLength(){const t=this.bb.__offset(this.bb_pos,18);return t?this.bb.__vector_len(this.bb_pos+t):0}itemsSizeArray(){const t=this.bb.__offset(this.bb_pos,18);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}ids(t){const s=this.bb.__offset(this.bb_pos,20);return s?this.bb.readUint32(this.bb.__vector(this.bb_pos+s)+t*4):0}idsLength(){const t=this.bb.__offset(this.bb_pos,20);return t?this.bb.__vector_len(this.bb_pos+t):0}idsArray(){const t=this.bb.__offset(this.bb_pos,20);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}id(t){const s=this.bb.__offset(this.bb_pos,22);return s?this.bb.__string(this.bb_pos+s,t):null}capacity(){const t=this.bb.__offset(this.bb_pos,24);return t?this.bb.readUint32(this.bb_pos+t):0}capacityOffset(){const t=this.bb.__offset(this.bb_pos,26);return t?this.bb.readUint32(this.bb_pos+t):0}static startFragment(t){t.startObject(12)}static addPosition(t,s){t.addFieldOffset(0,s,0)}static createPositionVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addFloat32(s[e]);return t.endVector()}static startPositionVector(t,s){t.startVector(4,s,4)}static addNormal(t,s){t.addFieldOffset(1,s,0)}static createNormalVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addFloat32(s[e]);return t.endVector()}static startNormalVector(t,s){t.startVector(4,s,4)}static addIndex(t,s){t.addFieldOffset(2,s,0)}static createIndexVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addInt32(s[e]);return t.endVector()}static startIndexVector(t,s){t.startVector(4,s,4)}static addGroups(t,s){t.addFieldOffset(3,s,0)}static createGroupsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addFloat32(s[e]);return t.endVector()}static startGroupsVector(t,s){t.startVector(4,s,4)}static addMaterials(t,s){t.addFieldOffset(4,s,0)}static createMaterialsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addFloat32(s[e]);return t.endVector()}static startMaterialsVector(t,s){t.startVector(4,s,4)}static addMatrices(t,s){t.addFieldOffset(5,s,0)}static createMatricesVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addFloat32(s[e]);return t.endVector()}static startMatricesVector(t,s){t.startVector(4,s,4)}static addColors(t,s){t.addFieldOffset(6,s,0)}static createColorsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addFloat32(s[e]);return t.endVector()}static startColorsVector(t,s){t.startVector(4,s,4)}static addItemsSize(t,s){t.addFieldOffset(7,s,0)}static createItemsSizeVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addInt32(s[e]);return t.endVector()}static startItemsSizeVector(t,s){t.startVector(4,s,4)}static addIds(t,s){t.addFieldOffset(8,s,0)}static createIdsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addInt32(s[e]);return t.endVector()}static startIdsVector(t,s){t.startVector(4,s,4)}static addId(t,s){t.addFieldOffset(9,s,0)}static addCapacity(t,s){t.addFieldInt32(10,s,0)}static addCapacityOffset(t,s){t.addFieldInt32(11,s,0)}static endFragment(t){return t.endObject()}static createFragment(t,s,e,i,r,n,o,a,c,h,b,d,p){return l.startFragment(t),l.addPosition(t,s),l.addNormal(t,e),l.addIndex(t,i),l.addGroups(t,r),l.addMaterials(t,n),l.addMatrices(t,o),l.addColors(t,a),l.addItemsSize(t,c),l.addIds(t,h),l.addId(t,b),l.addCapacity(t,d),l.addCapacityOffset(t,p),l.endFragment(t)}}let bt=class ft{constructor(){this.bb=null,this.bb_pos=0}__init(t,s){return this.bb_pos=t,this.bb=s,this}static getRootAsFragmentsGroup(t,s){return(s||new ft).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsFragmentsGroup(t,s){return t.setPosition(t.position()+E),(s||new ft).__init(t.readInt32(t.position())+t.position(),t)}items(t,s){const e=this.bb.__offset(this.bb_pos,4);return e?(s||new l).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+e)+t*4),this.bb):null}itemsLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}civil(t){const s=this.bb.__offset(this.bb_pos,6);return s?(t||new F).__init(this.bb.__indirect(this.bb_pos+s),this.bb):null}coordinationMatrix(t){const s=this.bb.__offset(this.bb_pos,8);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+t*4):0}coordinationMatrixLength(){const t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}coordinationMatrixArray(){const t=this.bb.__offset(this.bb_pos,8);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}ids(t){const s=this.bb.__offset(this.bb_pos,10);return s?this.bb.readUint32(this.bb.__vector(this.bb_pos+s)+t*4):0}idsLength(){const t=this.bb.__offset(this.bb_pos,10);return t?this.bb.__vector_len(this.bb_pos+t):0}idsArray(){const t=this.bb.__offset(this.bb_pos,10);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}itemsKeys(t){const s=this.bb.__offset(this.bb_pos,12);return s?this.bb.readUint32(this.bb.__vector(this.bb_pos+s)+t*4):0}itemsKeysLength(){const t=this.bb.__offset(this.bb_pos,12);return t?this.bb.__vector_len(this.bb_pos+t):0}itemsKeysArray(){const t=this.bb.__offset(this.bb_pos,12);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}itemsKeysIndices(t){const s=this.bb.__offset(this.bb_pos,14);return s?this.bb.readUint32(this.bb.__vector(this.bb_pos+s)+t*4):0}itemsKeysIndicesLength(){const t=this.bb.__offset(this.bb_pos,14);return t?this.bb.__vector_len(this.bb_pos+t):0}itemsKeysIndicesArray(){const t=this.bb.__offset(this.bb_pos,14);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}itemsRels(t){const s=this.bb.__offset(this.bb_pos,16);return s?this.bb.readUint32(this.bb.__vector(this.bb_pos+s)+t*4):0}itemsRelsLength(){const t=this.bb.__offset(this.bb_pos,16);return t?this.bb.__vector_len(this.bb_pos+t):0}itemsRelsArray(){const t=this.bb.__offset(this.bb_pos,16);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}itemsRelsIndices(t){const s=this.bb.__offset(this.bb_pos,18);return s?this.bb.readUint32(this.bb.__vector(this.bb_pos+s)+t*4):0}itemsRelsIndicesLength(){const t=this.bb.__offset(this.bb_pos,18);return t?this.bb.__vector_len(this.bb_pos+t):0}itemsRelsIndicesArray(){const t=this.bb.__offset(this.bb_pos,18);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}fragmentKeys(t){const s=this.bb.__offset(this.bb_pos,20);return s?this.bb.__string(this.bb_pos+s,t):null}id(t){const s=this.bb.__offset(this.bb_pos,22);return s?this.bb.__string(this.bb_pos+s,t):null}name(t){const s=this.bb.__offset(this.bb_pos,24);return s?this.bb.__string(this.bb_pos+s,t):null}ifcName(t){const s=this.bb.__offset(this.bb_pos,26);return s?this.bb.__string(this.bb_pos+s,t):null}ifcDescription(t){const s=this.bb.__offset(this.bb_pos,28);return s?this.bb.__string(this.bb_pos+s,t):null}ifcSchema(t){const s=this.bb.__offset(this.bb_pos,30);return s?this.bb.__string(this.bb_pos+s,t):null}maxExpressId(){const t=this.bb.__offset(this.bb_pos,32);return t?this.bb.readUint32(this.bb_pos+t):0}boundingBox(t){const s=this.bb.__offset(this.bb_pos,34);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+t*4):0}boundingBoxLength(){const t=this.bb.__offset(this.bb_pos,34);return t?this.bb.__vector_len(this.bb_pos+t):0}boundingBoxArray(){const t=this.bb.__offset(this.bb_pos,34);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}opaqueGeometriesIds(t){const s=this.bb.__offset(this.bb_pos,36);return s?this.bb.readInt32(this.bb.__vector(this.bb_pos+s)+t*4):0}opaqueGeometriesIdsLength(){const t=this.bb.__offset(this.bb_pos,36);return t?this.bb.__vector_len(this.bb_pos+t):0}opaqueGeometriesIdsArray(){const t=this.bb.__offset(this.bb_pos,36);return t?new Int32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}transparentGeometriesIds(t){const s=this.bb.__offset(this.bb_pos,38);return s?this.bb.readInt32(this.bb.__vector(this.bb_pos+s)+t*4):0}transparentGeometriesIdsLength(){const t=this.bb.__offset(this.bb_pos,38);return t?this.bb.__vector_len(this.bb_pos+t):0}transparentGeometriesIdsArray(){const t=this.bb.__offset(this.bb_pos,38);return t?new Int32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}static startFragmentsGroup(t){t.startObject(18)}static addItems(t,s){t.addFieldOffset(0,s,0)}static createItemsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addOffset(s[e]);return t.endVector()}static startItemsVector(t,s){t.startVector(4,s,4)}static addCivil(t,s){t.addFieldOffset(1,s,0)}static addCoordinationMatrix(t,s){t.addFieldOffset(2,s,0)}static createCoordinationMatrixVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addFloat32(s[e]);return t.endVector()}static startCoordinationMatrixVector(t,s){t.startVector(4,s,4)}static addIds(t,s){t.addFieldOffset(3,s,0)}static createIdsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addInt32(s[e]);return t.endVector()}static startIdsVector(t,s){t.startVector(4,s,4)}static addItemsKeys(t,s){t.addFieldOffset(4,s,0)}static createItemsKeysVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addInt32(s[e]);return t.endVector()}static startItemsKeysVector(t,s){t.startVector(4,s,4)}static addItemsKeysIndices(t,s){t.addFieldOffset(5,s,0)}static createItemsKeysIndicesVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addInt32(s[e]);return t.endVector()}static startItemsKeysIndicesVector(t,s){t.startVector(4,s,4)}static addItemsRels(t,s){t.addFieldOffset(6,s,0)}static createItemsRelsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addInt32(s[e]);return t.endVector()}static startItemsRelsVector(t,s){t.startVector(4,s,4)}static addItemsRelsIndices(t,s){t.addFieldOffset(7,s,0)}static createItemsRelsIndicesVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addInt32(s[e]);return t.endVector()}static startItemsRelsIndicesVector(t,s){t.startVector(4,s,4)}static addFragmentKeys(t,s){t.addFieldOffset(8,s,0)}static addId(t,s){t.addFieldOffset(9,s,0)}static addName(t,s){t.addFieldOffset(10,s,0)}static addIfcName(t,s){t.addFieldOffset(11,s,0)}static addIfcDescription(t,s){t.addFieldOffset(12,s,0)}static addIfcSchema(t,s){t.addFieldOffset(13,s,0)}static addMaxExpressId(t,s){t.addFieldInt32(14,s,0)}static addBoundingBox(t,s){t.addFieldOffset(15,s,0)}static createBoundingBoxVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addFloat32(s[e]);return t.endVector()}static startBoundingBoxVector(t,s){t.startVector(4,s,4)}static addOpaqueGeometriesIds(t,s){t.addFieldOffset(16,s,0)}static createOpaqueGeometriesIdsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addInt32(s[e]);return t.endVector()}static startOpaqueGeometriesIdsVector(t,s){t.startVector(4,s,4)}static addTransparentGeometriesIds(t,s){t.addFieldOffset(17,s,0)}static createTransparentGeometriesIdsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addInt32(s[e]);return t.endVector()}static startTransparentGeometriesIdsVector(t,s){t.startVector(4,s,4)}static endFragmentsGroup(t){return t.endObject()}static finishFragmentsGroupBuffer(t,s){t.finish(s)}static finishSizePrefixedFragmentsGroupBuffer(t,s){t.finish(s,void 0,!0)}};class Gt extends Ot{constructor(){super(...arguments),this.items=[],this.boundingBox=new Lt,this.coordinationMatrix=new V,this.keyFragments=new Map,this.data=new Map,this.geometryIDs={opaque:new Map,transparent:new Map},this.ifcMetadata={name:"",description:"",schema:"IFC2X3",maxExpressID:0},this.streamSettings={baseUrl:"",baseFileName:"",ids:new Map,types:new Map}}get hasProperties(){const t=this._properties!==void 0,s=this.streamSettings.ids.size!==0;return t||s}getFragmentMap(t){const s={};for(const e of t){const i=this.data.get(e);if(i)for(const r of i[0]){const n=this.keyFragments.get(r);n!==void 0&&(s[n]||(s[n]=new Set),s[n].add(e))}}return s}dispose(t=!0){for(const s of this.items)s.dispose(t);if(this.coordinationMatrix=new V,this.keyFragments.clear(),this.data.clear(),this._properties={},this.removeFromParent(),this.items=[],this.civilData){const{alignments:s}=this.civilData;for(const[e,i]of s)this.disposeAlignment(i.vertical),this.disposeAlignment(i.horizontal),this.disposeAlignment(i.absolute)}this.civilData=void 0}setLocalProperties(t){this._properties=t}getLocalProperties(){return this._properties}getAllPropertiesIDs(){return this._properties?Object.keys(this._properties).map(t=>parseInt(t,10)):Array.from(this.streamSettings.ids.keys())}getAllPropertiesTypes(){if(this._properties){const t=new Set;for(const s in this._properties){const e=this._properties[s];e.type!==void 0&&t.add(e.type)}return Array.from(t)}return Array.from(this.streamSettings.types.keys())}async getProperties(t){if(this._properties)return this._properties[t]||null;const s=this.getPropsURL(t),e=await this.getPropertiesData(s);return e?e[t]:null}async setProperties(t,s){if(this._properties){s!==null?this._properties[t]=s:delete this._properties[t];return}const e=this.getPropsURL(t),i=await this.getPropertiesData(e);s!==null?i[t]=s:delete i[t];const r=new FormData;r.append("file",JSON.stringify(i)),await fetch("api/KJAKDSJFAKÑSDFJAÑSFJDAÑJFÑA",{body:r,method:"post"})}async getAllPropertiesOfType(t){if(this._properties){const r={};let n=!1;for(const o in this._properties){const a=this._properties[o];a.type===t&&(r[a.expressID]=a,n=!0)}return n?r:null}const{types:s}=this.streamSettings,e=s.get(t);if(e===void 0)return null;const i={};for(const r of e){const n=this.constructFileName(r),o=this.constructURL(n),a=await this.getPropertiesData(o);for(const c in a)i[parseInt(c,10)]=a[c]}return i}getPropsURL(t){const{ids:s}=this.streamSettings,e=s.get(t);if(e===void 0)throw new Error("ID not found");const i=this.constructFileName(e);return this.constructURL(i)}async getPropertiesData(t){const e=await(await fetch(t)).arrayBuffer(),i=new File([new Blob([e])],"temp"),r=URL.createObjectURL(i),{entries:n}=await Mt(r),o=Object.keys(n)[0];return n[o].json()}constructFileName(t){const{baseFileName:s}=this.streamSettings;return`${s}-${t}`}constructURL(t){const{baseUrl:s}=this.streamSettings;return`${s}${t}`}disposeAlignment(t){for(const s of t)if(s.mesh.geometry.dispose(),Array.isArray(s.mesh.material))for(const e of s.mesh.material)e.dispose();else s.mesh.material.dispose();t.length=0}}class Tt{constructor(){this.vertical=[],this.horizontal=[],this.absolute=[],this.initialKP=0}getLength(t){let s=0;for(const e of this[t])s+=e.getLength();return s}getPointAt(t,s){const e=this.getCurveAt(t,s);return e.curve.getPointAt(e.percentage)}getPercentageAt(t,s,e=.01){const i=this[s];let r=0;for(const n of i){const o=n.getPercentageAt(t,e),a=n.getLength();if(o!==null){const c=r+o*a,h=this.getLength(s);return c/h}r+=a}return null}getCurveAt(t,s){t<0?t=0:t>1&&(t=1);const e=this[s],r=this.getLength(s)*t;let n=0;for(const o of e){const a=o.getLength();if(n+a>=r){const h=(r-n)/a;return{curve:o,percentage:h}}n+=a}throw new Error("Could not compute point!")}}class Et{get _index(){return this.mesh.geometry.index}get _pos(){return this.mesh.geometry.attributes.position.array}constructor(t,s,e,i){this.index=t,this.mesh=s,this.data=e,this.alignment=i}getLength(){let t=0;for(let s=0;s<this._index.array.length-1;s+=2){const{startPoint:e,endPoint:i}=this.getSegment(s);t+=e.distanceTo(i)}return t}getPointAt(t){const{startPoint:s,endPoint:e,distanceToStart:i}=this.getSegmentAt(t),r=e.clone();return r.sub(s),r.normalize(),r.multiplyScalar(i),r.add(s),r}getSegmentAt(t){t<0?t=0:t>1&&(t=1);const e=this.getLength()*t;let i=0;for(let r=0;r<this._index.array.length-1;r+=2){const{startPoint:n,endPoint:o}=this.getSegment(r),a=n.distanceTo(o);if(i+a>=e)return{distanceToStart:e-i,index:r,startPoint:n,endPoint:o};i+=a}throw new Error("Could not compute point")}getPercentageAt(t,s=.01){let e=0;for(let i=0;i<this._index.array.length-1;i+=2){const{startPoint:r,endPoint:n}=this.getSegment(i),o=r.distanceTo(n),a=t.distanceTo(r),c=t.distanceTo(n);if(a+c-o<=s){const d=e+a,p=this.getLength();return d/p}e+=o}return null}getSegment(t){const s=this._index.array[t]*3,e=this._index.array[t+1]*3,i=new mt(this._pos[s],this._pos[s+1],this._pos[s+2]),r=new mt(this._pos[e],this._pos[e+1],this._pos[e+2]);return{startPoint:i,endPoint:r}}}class zt extends St{constructor(t,s,e,i,r){super(i,r),this.curve=new Et(t,this,s,e)}}class Rt{constructor(){this.fragmentIDSeparator="|"}import(t){const s=new $(t),e=bt.getRootAsFragmentsGroup(s),i=this.constructFragmentGroup(e),r=e.itemsLength();for(let n=0;n<r;n++){const o=e.items(n);if(!o)continue;const a=this.constructGeometry(o),c=this.constructMaterials(o),h=o.capacity(),b=new Bt(a,c,h);b.capacityOffset=o.capacityOffset(),this.setInstances(o,b),this.setID(o,b),i.items.push(b),i.add(b.mesh)}return i}export(t){const s=new dt(1024),e=[],i=bt,r=l;let n=null;if(t.civilData){const u=[],f=wt,g=F;for(const[lt,J]of t.civilData.alignments){const{absolute:tt,horizontal:st,vertical:et}=J,it=this.saveCivilCurves(st,s),rt=this.saveCivilCurves(et,s),nt=this.saveCivilCurves(tt,s),ot=f.createHorizontalVector(s,it),at=f.createVerticalVector(s,rt),X=f.createAbsoluteVector(s,nt);f.startAlignment(s),f.addHorizontal(s,ot),f.addVertical(s,at),f.addAbsolute(s,X),f.addInitialPk(s,J.initialKP);const xt=f.endAlignment(s);u.push(xt)}const S=g.createAlignmentsVector(s,u),W=g.createCoordinationMatrixVector(s,t.coordinationMatrix.elements);g.startCivilData(s),g.addAlignments(s,S),g.addCoordinationMatrix(s,W),n=g.endCivilData(s)}for(const u of t.items){const f=u.exportData(),g=[];for(const at of u.ids){const X=u.getInstancesIDs(at);if(!X)throw new Error("Instances not found!");g.push(X.size)}const S=r.createPositionVector(s,f.position),W=r.createNormalVector(s,f.normal),lt=r.createIndexVector(s,f.index),J=r.createGroupsVector(s,f.groups),tt=r.createMaterialsVector(s,f.materials),st=r.createMatricesVector(s,f.matrices),et=r.createColorsVector(s,f.colors),it=r.createIdsVector(s,f.ids),rt=r.createItemsSizeVector(s,g),nt=s.createString(f.id);r.startFragment(s),r.addPosition(s,S),r.addNormal(s,W),r.addIndex(s,lt),r.addGroups(s,J),r.addMaterials(s,tt),r.addMatrices(s,st),r.addColors(s,et),r.addIds(s,it),r.addItemsSize(s,rt),r.addId(s,nt),r.addCapacity(s,u.capacity),r.addCapacityOffset(s,u.capacityOffset);const ot=l.endFragment(s);e.push(ot)}const o=i.createItemsVector(s,e),a=i.createCoordinationMatrixVector(s,t.coordinationMatrix.elements);let c="";for(const u of t.keyFragments.values())c.length&&(c+=this.fragmentIDSeparator),c+=u;const h=s.createString(c),b=[],d=[],p=[],y=[],I=[];let m=0,U=0;for(const[u,[f,g]]of t.data){b.push(m),p.push(U),I.push(u);for(const S of f)d.push(S);for(const S of g)y.push(S);m+=f.length,U+=g.length}const B=[],L=[];for(const[u,f]of t.geometryIDs.opaque)B.push(u,f);for(const[u,f]of t.geometryIDs.transparent)L.push(u,f);const N=s.createString(t.uuid),R=s.createString(t.name),k=s.createString(t.ifcMetadata.name),K=s.createString(t.ifcMetadata.description),_=s.createString(t.ifcMetadata.schema),O=i.createItemsKeysIndicesVector(s,b),M=i.createItemsKeysVector(s,d),G=i.createItemsRelsIndicesVector(s,p),j=i.createItemsRelsVector(s,y),w=i.createIdsVector(s,I),v=i.createOpaqueGeometriesIdsVector(s,B),Q=i.createTransparentGeometriesIdsVector(s,L),{min:q,max:H}=t.boundingBox,vt=[q.x,q.y,q.z,H.x,H.y,H.z],Vt=i.createBoundingBoxVector(s,vt);i.startFragmentsGroup(s),i.addId(s,N),i.addName(s,R),i.addIfcName(s,k),i.addIfcDescription(s,K),i.addIfcSchema(s,_),i.addMaxExpressId(s,t.ifcMetadata.maxExpressID),i.addItems(s,o),i.addFragmentKeys(s,h),i.addIds(s,w),i.addItemsKeysIndices(s,O),i.addItemsKeys(s,M),i.addItemsRelsIndices(s,G),i.addItemsRels(s,j),i.addCoordinationMatrix(s,a),i.addBoundingBox(s,Vt),i.addOpaqueGeometriesIds(s,v),i.addTransparentGeometriesIds(s,Q),n!==null&&i.addCivil(s,n);const At=bt.endFragmentsGroup(s);return s.finish(At),s.asUint8Array()}setID(t,s){const e=t.id();e&&(s.id=e,s.mesh.uuid=e)}setInstances(t,s){const e=t.matricesArray(),i=t.colorsArray(),r=t.idsArray(),n=t.itemsSizeArray();if(!e||!r||!n)throw new Error("Error: Can't load empty fragment!");const o=[];let a=0;for(let c=0;c<n.length;c++){const h=r[c],b=n[c],d=[],p=[];for(let I=0;I<b;I++){const m=a*16,U=e.subarray(m,m+17),B=new V().fromArray(U);if(d.push(B),i){const L=a*3,[N,R,k]=i.subarray(L,L+4),K=new P(N,R,k);p.push(K)}a++}const y=p.length?p:void 0;o.push({id:h,transforms:d,colors:y})}s.add(o)}constructMaterials(t){const s=t.materialsArray(),e=[];if(!s)return e;for(let i=0;i<s.length;i+=5){const r=s[i],n=!!s[i+1],o=s[i+2],a=s[i+3],c=s[i+4],h=new P(o,a,c),b=new Dt({color:h,opacity:r,transparent:n});e.push(b)}return e}constructFragmentGroup(t){const s=new Gt,e=t.civil();if(e){const _=e.coordinationMatrixArray(),O=new V;_&&O.fromArray(_),s.civilData={alignments:new Map,coordinationMatrix:O};const M=e.alignmentsLength();for(let G=0;G<M;G++){const j=new Pt({color:16777215}),w=new Tt,v=e.alignments(G);if(!v)throw new Error("Alignment not found!");const Q=v.horizontalLength();w.horizontal=this.constructCivilCurves(v,w,"horizontal",Q,j);const q=v.verticalLength();w.vertical=this.constructCivilCurves(v,w,"vertical",q,j);const H=v.horizontalLength();w.absolute=this.constructCivilCurves(v,w,"absolute",H,j),w.initialKP=v.initialPk(),s.civilData.alignments.set(G,w)}}s.uuid=t.id()||s.uuid,s.name=t.name()||"",s.ifcMetadata={name:t.ifcName()||"",description:t.ifcDescription()||"",schema:t.ifcSchema()||"IFC2X3",maxExpressID:t.maxExpressId()||0};const i=new V().elements,r=t.coordinationMatrixArray()||i,n=t.idsArray()||new Uint32Array,o=t.itemsKeysIndicesArray()||new Uint32Array,a=t.itemsKeysArray()||new Uint32Array,c=t.itemsRelsArray()||new Uint32Array,h=t.itemsRelsIndicesArray()||new Uint32Array,d=(t.fragmentKeys()||"").split(this.fragmentIDSeparator);this.setGroupData(s,n,o,a,0),this.setGroupData(s,n,h,c,1);const p=t.opaqueGeometriesIdsArray()||new Uint32Array,y=t.transparentGeometriesIdsArray()||new Uint32Array,I=new Map;for(let _=0;_<p.length-1;_+=2){const O=p[_],M=p[_+1];I.set(O,M)}const m=new Map;for(let _=0;_<y.length-1;_+=2){const O=y[_],M=y[_+1];m.set(O,M)}s.geometryIDs={opaque:I,transparent:m};const U=t.boundingBoxArray()||[0,0,0,0,0,0],[B,L,N,R,k,K]=U;s.boundingBox.min.set(B,L,N),s.boundingBox.max.set(R,k,K);for(let _=0;_<d.length;_++)s.keyFragments.set(_,d[_]);return r.length===16&&s.coordinationMatrix.fromArray(r),s}setGroupData(t,s,e,i,r){for(let n=0;n<e.length;n++){const o=s[n],a=e[n],c=e[n+1]||i.length,h=[];for(let d=a;d<c;d++)h.push(i[d]);t.data.has(o)||t.data.set(o,[[],[]]);const b=t.data.get(o);b&&(b[r]=h)}}constructGeometry(t){const s=t.positionArray()||new Float32Array,e=t.normalArray()||new Float32Array,i=t.indexArray(),r=t.groupsArray();if(!i)throw new Error("Index not found!");const n=new yt;if(n.setIndex(Array.from(i)),n.setAttribute("position",new ct(s,3)),n.setAttribute("normal",new ct(e,3)),r)for(let o=0;o<r.length;o+=3){const a=r[o],c=r[o+1],h=r[o+2];n.addGroup(a,c,h)}return n}constructCivilCurves(t,s,e,i,r){const n=[];for(let o=0;o<i;o++){const a=t[e](o);if(!a)throw new Error("Curve not found!");const c=a.pointsArray();if(c===null)throw new Error("Curve points not found!");let h={};const b=a.data();b&&(h=JSON.parse(b));const d=new Ut,p=new ct(c,3);d.setAttribute("position",p);const y=[];for(let m=0;m<c.length/3-1;m++)y.push(m,m+1);d.setIndex(y);const I=new zt(o,h,s,d,r);n.push(I.curve)}return n}saveCivilCurves(t,s){const e=Y,i=[];for(const r of t){const o=r.mesh.geometry.attributes.position.array,a=e.createPointsVector(s,o),c=s.createString(JSON.stringify(r.data));e.startCivilCurve(s),e.addPoints(s,a),e.addData(s,c);const h=e.endCivilCurve(s);i.push(h)}return i}}export{Tt as A,$ as B,zt as C,Gt as F,Rt as S,gt as a,Bt as b,E as c,dt as d};
