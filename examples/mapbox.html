<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport"
        content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <link rel="stylesheet" href="resources/styles.css">
  <link rel="icon" type="image/x-icon" href="../favicon.ico">
  <title>Components | Hello world</title>
</head>
<body>
<div class="full-screen" id="map"></div>

<link href="https://api.mapbox.com/mapbox-gl-js/v2.10.0/mapbox-gl.css" rel="stylesheet">
<script src="https://api.mapbox.com/mapbox-gl-js/v2.10.0/mapbox-gl.js"></script>

<script type="module">
	import * as THREE from "./resources/three.module.js";
	import { unzip } from "./resources/unzipit.module.js";
	import * as OBC from './resources/openbim-components.js';

	const modelOrigin = [-5.995612418051309, 37.388643156297796];

	mapboxgl.accessToken = 'pk.eyJ1IjoiYWd2aWVnYXMiLCJhIjoiY2wyZjE4emwwMDYzbTNlb2dyODFyZHd2ciJ9.4939d5SFkJYnw9BpMxlPnA';

	const map = new mapboxgl.Map({
		container: 'map',
		style: 'mapbox://styles/mapbox/light-v10',
		zoom: 18,
		center: modelOrigin,
		pitch: 60,
		antialias: true
	});

	// parameters to ensure the model is georeferenced correctly on the map
	const modelAltitude = 0;
	const modelRotate = [Math.PI / 2, 0, 0];

	const modelAsMercatorCoordinate = mapboxgl.MercatorCoordinate.fromLngLat(
		modelOrigin,
		modelAltitude
	);

	// transformation parameters to position, rotate and scale the 3D model onto the map
	const modelTransform = {
		translateX: modelAsMercatorCoordinate.x,
		translateY: modelAsMercatorCoordinate.y,
		translateZ: modelAsMercatorCoordinate.z,
		rotateX: modelRotate[0],
		rotateY: modelRotate[1],
		rotateZ: modelRotate[2],
		/* Since the 3D model is in real world meters, a scale transform needs to be
    * applied since the CustomLayerInterface expects units in MercatorCoordinates.
    */
		scale: modelAsMercatorCoordinate.meterInMercatorCoordinateUnits()
	};

	// 3D model load
	const customLayer = {
		id: '3d-model',
		type: 'custom',
		renderingMode: '3d',
		onAdd: function (map, gl) {

			this.map = map;

			const canvas = map.getCanvas();
			const components = new OBC.Components();

			components.scene = new OBC.SimpleScene(components);
			components.camera = new OBC.MapboxCamera();
			components.renderer = new OBC.MapboxRenderer(canvas, gl);

			this._renderer = components.renderer.get();
			this.camera = components.camera.get();
			this.scene = components.scene.get();
			this.scene.background = null;

			// create two three.js lights to illuminate the model
			const directionalLight = new THREE.DirectionalLight(0xffffff);
			directionalLight.position.set(0, -70, 100).normalize();
			this.scene.add(directionalLight);

			const directionalLight2 = new THREE.DirectionalLight(0xffffff);
			directionalLight2.position.set(0, 70, 100).normalize();
			this.scene.add(directionalLight2);

			const fragments = new OBC.Fragments(components, { culling: false });
			loadFragments();

			async function loadFragments() {
				const { entries } = await unzip('./resources/medium.zip');

				const fileNames = Object.keys(entries);

				const allTypes = await entries['all-types.json'].json();
				const modelTypes = await entries['model-types.json'].json();
				const levelsProperties = await entries['levels-properties.json'].json();
				const levelsRelationship = await entries['levels-relationship.json'].json();

				const floorNames = {};
				for (const levelProps of levelsProperties) {
					floorNames[levelProps.expressID] = levelProps.Name.value;
				}

				for (let i = 0; i < fileNames.length; i++) {

					const name = fileNames[i];
					if (!name.includes('.glb')) continue;

					// Load data
					const geometryName = fileNames[i];
					const geometry = await entries[geometryName].blob();
					const geometryURL = URL.createObjectURL(geometry);

					const dataName = geometryName.substring(0, geometryName.indexOf('.glb')) + '.json';
					const dataBlob = await entries[dataName].blob();
					const data = await entries[dataName].json();
					const dataURL = URL.createObjectURL(dataBlob);

					const fragment = await fragments.load(geometryURL, dataURL);

					// TODO: string conversion temporary until we update the fragment files (ids are now strings)
					fragment.items = fragment.items.map(item => item.toString());

					// Group items for visibility

					const groups = { category: {}, floor: {} };

					// TODO: string conversion temporary until we update the fragment files (ids are now strings)
					const ids = data.ids.map(id => id.toString());

					for (const id of ids) {
						const categoryID = modelTypes[id];
						const category = allTypes[categoryID];
						if (!groups.category[category]) {
							groups.category[category] = [];
						}
						groups.category[category].push(id);

						const floorID = levelsRelationship[id];
						const floor = floorNames[floorID];
						if (!groups.floor[floor]) {
							groups.floor[floor] = [];
						}
						groups.floor[floor].push(id);
					}

					fragments.groups.add(fragment.id, groups);

				}
			}

		},
		render: function (gl, matrix) {
			const rotationX = new THREE.Matrix4().makeRotationAxis(
				new THREE.Vector3(1, 0, 0),
				modelTransform.rotateX
			);
			const rotationY = new THREE.Matrix4().makeRotationAxis(
				new THREE.Vector3(0, 1, 0),
				modelTransform.rotateY
			);
			const rotationZ = new THREE.Matrix4().makeRotationAxis(
				new THREE.Vector3(0, 0, 1),
				modelTransform.rotateZ
			);

			const m = new THREE.Matrix4().fromArray(matrix);
			const l = new THREE.Matrix4()
				.makeTranslation(
					modelTransform.translateX,
					modelTransform.translateY,
					modelTransform.translateZ
				)
				.scale(
					new THREE.Vector3(
						modelTransform.scale,
						-modelTransform.scale,
						modelTransform.scale
					)
				)
				.multiply(rotationX)
				.multiply(rotationY)
				.multiply(rotationZ);

			this.camera.projectionMatrix = m.multiply(l);
			this.renderer.resetState();
			this.renderer.render(this.scene, this.camera);

			this.map.triggerRepaint();
		}
	};

	// 3D Buildings
	map.on('load', () => {
		// Insert the layer beneath any symbol layer.
		const layers = map.getStyle().layers;
		const labelLayerId = layers.find(
			(layer) => layer.type === 'symbol' && layer.layout['text-field']
		).id;

		// The 'building' layer in the Mapbox Streets
		// vector tileset contains building height data
		// from OpenStreetMap.
		map.addLayer(
			{
				'id': 'add-3d-buildings',
				'source': 'composite',
				'source-layer': 'building',
				'filter': ['==', 'extrude', 'true'],
				'type': 'fill-extrusion',
				'minzoom': 15,
				'paint': {
					'fill-extrusion-color': '#aaa',

					// Use an 'interpolate' expression to
					// add a smooth transition effect to
					// the buildings as the user zooms in.
					'fill-extrusion-height': [
						'interpolate',
						['linear'],
						['zoom'],
						15,
						0,
						15.05,
						['get', 'height']
					],
					'fill-extrusion-base': [
						'interpolate',
						['linear'],
						['zoom'],
						15,
						0,
						15.05,
						['get', 'min_height']
					],
					'fill-extrusion-opacity': 0.6
				}
			},
			labelLayerId
		);
	});


	map.on('style.load', () => {
		map.addLayer(customLayer, 'waterway-label');
	});
</script>
</body>
</html>