// Generated by CodiumAI

/*
Code Analysis

Main functionalities:
The Disposer class is designed to safely remove meshes, geometries, and materials
from memory to prevent memory leaks. It provides a dispose method that removes a mesh,
its geometry, and its materials from memory, as well as a disposeGeometry method that
disposes of a geometry from memory. The class also includes several private helper
methods to dispose of materials and children of a mesh.

Methods:
- dispose(mesh: Item3D, materials = true, recursive = true): removes a mesh, its geometry, and its materials from memory. It takes in a mesh, a boolean indicating whether to dispose of the materials of the mesh, and a boolean indicating whether to recursively dispose of the children of the mesh.
- disposeGeometry(geometry: THREE.BufferGeometry): disposes of a geometry from memory.
- disposeGeometryAndMaterials(mesh: Item3D, materials: boolean): a private helper method that disposes of a mesh's geometry and materials. It takes in a mesh and a boolean indicating whether to dispose of the materials of the mesh.
- disposeChildren(mesh: Item3D): a private helper method that recursively disposes of a mesh's children. It takes in a mesh.
- disposeMaterial(mesh: Item3D): a private static helper method that disposes of a mesh's material. It takes in a mesh.

Fields:
- None.
*/

import * as THREE from "three";
import { Disposer } from "./index";

describe("Disposer_class", () => {
  // Tests that dispose method removes a mesh with geometry and materials.
  it("test_dispose_removes_mesh_with_geometry_and_materials", () => {
    const disposer = new Disposer();
    const geometry = new THREE.BufferGeometry();
    const material = new THREE.MeshBasicMaterial();
    const mesh = new THREE.Mesh(geometry, material);

    disposer.dispose(mesh);

    expect(mesh.parent).toBeNull();
    expect(mesh.material).toEqual([]);
  });

  // Tests that dispose method removes a mesh with only geometry.
  it("test_dispose_removes_mesh_with_only_geometry", () => {
    const disposer = new Disposer();
    const geometry = new THREE.BufferGeometry();
    const mesh = new THREE.Mesh(geometry);

    disposer.dispose(mesh);

    expect(mesh.parent).toBeNull();
    expect(mesh.material).toEqual([]);
  });

  // Tests that dispose method does not throw an error when removing a mesh with no geometry or materials.
  it("test_dispose_does_not_throw_error_when_removing_mesh_with_no_geometry_or_materials", () => {
    const disposer = new Disposer();
    const mesh = new THREE.Mesh();

    expect(() => {
      disposer.dispose(mesh);
    }).not.toThrow();
  });

  // Tests that dispose method recursively disposes children of a mesh.
  it("test_dispose_recursively_disposes_children_of_a_mesh", () => {
    const disposer = new Disposer();
    const geometry = new THREE.BufferGeometry();
    const material = new THREE.MeshBasicMaterial();
    const childGeometry = new THREE.BufferGeometry();
    const childMaterial = new THREE.MeshBasicMaterial();
    const childMesh = new THREE.Mesh(childGeometry, childMaterial);
    const mesh = new THREE.Mesh(geometry, material);

    mesh.add(childMesh);
    disposer.dispose(mesh, true, true);

    expect(mesh.parent).toBeNull();
    expect(mesh.material).toEqual([]);
    expect(childMesh.parent).toBeNull();
    expect(childMesh.material).toEqual([]);
  });

  // Tests that dispose method removes a mesh with only materials.
  it("test_dispose_removes_mesh_with_only_materials", () => {
    const disposer = new Disposer();
    const material = new THREE.MeshBasicMaterial();
    const mesh = new THREE.Mesh(undefined, material);

    disposer.dispose(mesh);

    expect(mesh.parent).toBeNull();
    expect(mesh.material).toEqual([]);
  });

  // Tests that dispose method removes a mesh with no children.
  it("test_dispose_removes_mesh_with_no_children", () => {
    const disposer = new Disposer();
    const geometry = new THREE.BufferGeometry();
    const material = new THREE.MeshBasicMaterial();
    const mesh = new THREE.Mesh(geometry, material);

    disposer.dispose(mesh, true, false);

    expect(mesh.parent).toBeNull();
    expect(mesh.material).toEqual([]);
  });
});
