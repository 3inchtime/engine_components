// Generated by CodiumAI

/*
Code Analysis

Main functionalities:
The SimpleRaycaster class is a component of the Open BIM Components library that provides
a simple way to cast rays from the camera to the mouse or touch event point and return
the first item found. It also takes into account the clipping planes used by the renderer.

Methods:
- constructor(components: Components): initializes the SimpleRaycaster instance with a reference to the Components instance and creates a Mouse instance to track the mouse position.
- get(): returns the THREE.Raycaster instance used by the SimpleRaycaster.
- castRay(items?: THREE.Mesh[]): throws a ray from the camera to the mouse or touch event point and returns the first item found. It takes an optional array of meshes to query. If not provided, it will query all the meshes stored in Components.meshes.
- filterClippingPlanes(objs: THREE.Intersection[]): filters the intersections found by the raycaster to take into account the clipping planes used by the renderer.

Fields:
- name: a string that identifies the SimpleRaycaster component.
- enabled: a boolean that determines whether the SimpleRaycaster is active or not.
- _raycaster: the THREE.Raycaster instance used by the SimpleRaycaster.
- _mouse: a Mouse instance that tracks the mouse position.
- components: a reference to the Components instance used by the SimpleRaycaster.
*/

import * as THREE from "three";
import { SimpleRaycaster } from "./index";
import testComponents from "../../test/mock/testComponents";

describe("SimpleRaycaster", () => {
  // Tests that the castRay method returns the first intersection when there are multiple intersections.
  it("test_cast_ray_returns_first_intersection", () => {
    const components = testComponents();

    const mesh1 = new THREE.Mesh(
      new THREE.BoxGeometry(),
      new THREE.MeshBasicMaterial()
    );

    const mesh2 = new THREE.Mesh(
      new THREE.BoxGeometry(),
      new THREE.MeshBasicMaterial()
    );

    mesh1.position.set(0, 0, -5);
    mesh2.position.set(0, 0, -10);

    components.scene.get().add(mesh1);

    components.scene.get().add(mesh2);

    components.meshes.push(mesh1, mesh2);

    const raycaster = new SimpleRaycaster(components);
    const result = raycaster.castRay();

    expect(result?.object).toBe(mesh1);
  });

  // Tests that the castRay method returns null when there are no intersections.
  it("test_cast_ray_returns_null_if_no_intersections", () => {
    const components = testComponents();

    const raycaster = new SimpleRaycaster(components);
    const result = raycaster.castRay();

    expect(result).toBeNull();
  });

  // Tests that the castRay method returns null when an empty list of meshes is provided.
  it("test_cast_ray_with_empty_list_of_meshes", () => {
    const components = testComponents();

    const raycaster = new SimpleRaycaster(components);

    const result = raycaster.castRay([]);

    expect(result).toBeNull();
  });

  // Tests that the castRay method returns null when a null list of meshes is provided.
  it("test_cast_ray_with_null_list_of_meshes", () => {
    const components = testComponents();

    const raycaster = new SimpleRaycaster(components);

    const result = raycaster.castRay();

    expect(result).toBeNull();
  });

  // Tests that the filterClippingPlanes method correctly filters intersections based on clipping planes.
  it("test_filter_clipping_planes", () => {
    const components = testComponents();

    const mesh1 = new THREE.Mesh(
      new THREE.BoxGeometry(),
      new THREE.MeshBasicMaterial()
    );

    mesh1.position.set(0, 0, -5);

    components.scene.get().add(mesh1);

    components.meshes.push(mesh1);

    const raycaster = new SimpleRaycaster(components);

    expect(raycaster.castRay()?.point).toStrictEqual(
      new THREE.Vector3(0.4999999999999929, 0.4999999999999858, 0.5)
    );
  });
});
